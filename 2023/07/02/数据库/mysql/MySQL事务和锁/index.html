

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Francis">
  <meta name="keywords" content="">
  
    <meta name="description" content="1. 数据库事务1.1 事务的典型场景​    在项目中，什么地方使用事务？是根据业务类型来使用的还是根据数据操作类型来使用的？无论你是在方法上加@Transactional注解，还是在xml文件中配置切面，还是直接用JDBC的方法。很多时候我们需要事务是因为我们希望涉及数据库的多个操作都成功，比如客户下单，会操作订单表，资金表，物流表等等，就需要放在一个事务中执行。 ​    一个非常典型的案例">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL事务和锁">
<meta property="og:url" content="http://www.zivjie.cn/2023/07/02/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/index.html">
<meta property="og:site_name" content="Francis-Blog">
<meta property="og:description" content="1. 数据库事务1.1 事务的典型场景​    在项目中，什么地方使用事务？是根据业务类型来使用的还是根据数据操作类型来使用的？无论你是在方法上加@Transactional注解，还是在xml文件中配置切面，还是直接用JDBC的方法。很多时候我们需要事务是因为我们希望涉及数据库的多个操作都成功，比如客户下单，会操作订单表，资金表，物流表等等，就需要放在一个事务中执行。 ​    一个非常典型的案例">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.zivjie.cn/img/aftershock.png">
<meta property="article:published_time" content="2023-07-02T07:58:21.000Z">
<meta property="article:modified_time" content="2024-01-02T01:39:44.735Z">
<meta property="article:author" content="Francis">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://www.zivjie.cn/img/aftershock.png">
  
  
  
  <title>MySQL事务和锁 - Francis-Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.zivjie.cn","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Francis</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="MySQL事务和锁"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-07-02 15:58" pubdate>
          2023年7月2日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          121 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">MySQL事务和锁</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="1-数据库事务"><a href="#1-数据库事务" class="headerlink" title="1. 数据库事务"></a>1. 数据库事务</h2><h3 id="1-1-事务的典型场景"><a href="#1-1-事务的典型场景" class="headerlink" title="1.1 事务的典型场景"></a>1.1 事务的典型场景</h3><p>​    在项目中，什么地方使用事务？是根据业务类型来使用的还是根据数据操作类型来使用的？无论你是在方法上加@Transactional注解，还是在xml文件中配置切面，还是直接用JDBC的方法。很多时候我们需要事务是因为我们希望涉及数据库的多个操作都成功，比如客户下单，会操作订单表，资金表，物流表等等，就需要放在一个事务中执行。</p>
<p>​    一个非常典型的案例就是银行转账。如果我们把行内转账简化为一个账户余额减少，另一个账户余额增加的情况，那么这两个动作一定是同时成功或同时失败的，否则会造成会计科目不平衡。另一个例子：12306的连续换乘功能，两张票必须同时购买成功，只买到前半程或者只买到后半程是没有意义的。</p>
<h3 id="1-2事务的定义"><a href="#1-2事务的定义" class="headerlink" title="1.2事务的定义"></a>1.2事务的定义</h3><p>​    事务是数据库管理系统（DBMS）执行过程中的一个逻辑单位，有一个有限的数据库操作序列构成。这里有两个关键点，1.所谓的逻辑单位，意味着它是数据库最小的工作单位，是不可再分的。2.它可能包含了一个或者多个DML语句，包括insert delete update。（单条DDL（create drop）和DCL（grant revoke）也会有事务）。</p>
<h3 id="1-3-哪些存储引擎支持事务"><a href="#1-3-哪些存储引擎支持事务" class="headerlink" title="1.3 哪些存储引擎支持事务"></a>1.3 哪些存储引擎支持事务</h3><p>​    并不是所有的数据库或者所有的存储引擎都支持事务，它是作为一种特性出现的。在MySQL中除了做集群的NDB之外，只有InnoDB支持事务，这个也是它成为默认的存储引擎的一个重要原因。</p>
<h3 id="1-4-事务的四大特性-ACID"><a href="#1-4-事务的四大特性-ACID" class="headerlink" title="1.4 事务的四大特性(ACID)"></a>1.4 事务的四大特性(ACID)</h3><p>​    1.原子性，Atomicity，也就是不可再分，因为原子是化学上（参加化学反应）最小单位。也就意味着我们对数据库的一系列操作，要么都成功，要么都失败，不可能出现部分成功的情况。问题是如果前面一个成功了，后面的操作失败了，怎么让它全部失败？这个时候我们必须要回滚。原子性在InnoDB中是通过undo log来实现的，他记录了数据修改之前的值（逻辑日志），一旦发生异常，就可以用undo log来实现回滚操作。</p>
<p>​    2.隔离性，Isolation，我们有了事务的定义后，在数据库中会有很多的事务同时去操作我们的同一张表或者同一行数据，必然会产生一些并发或者干扰的操作。我们对隔离性的定义，就是这些很多个的事务，对表或者行的并发操作，应该是透明的，互相不干扰的。比如两个人给青山转账100，开启两个事务，都拿到了青山账户的余额1000，然后各自基于1000加100，最后结果是1100，就出现了数据混乱的问题。</p>
<p>​    3.持久性，Durability，事务的持久性是什么意思？我们对数据库的任意的操作，增删改，是要事务提交成功，那么结果就是永久性的，不可能因为数据库掉电，宕机，意外重启，又能变成原来的状态。这个就是事务的持久性。持久性是通过redo log和double write buffer（双写缓冲）来实现的，我们操作数据的时候，会先写到内存的buffer pool中，同时记录redo log，如果在刷盘之前出现异常，在重启后就可以读取到redo log的内容，写入到磁盘，保证数据的持久性。当然，恢复成功的前提是数据页本身没有损坏，是完整的，这个通过双写缓冲保证。需要注意的是，原子性，隔离性，持久性，最后都是为了实现一致性。</p>
<p>​    4.一致性，consistent，指的是数据库的完整性约束没有被破坏，事务执行前后都是合法的数据状态。数据库自身提供了一些约束：比如主键必须是唯一的，字段长度符合要求。另外还有用户自定义的完整性，用户自定义的完整性通常要在代码中控制，例如金额不能小于0等。</p>
<h3 id="1-5数据库什么时候出现事务"><a href="#1-5数据库什么时候出现事务" class="headerlink" title="1.5数据库什么时候出现事务"></a>1.5数据库什么时候出现事务</h3><p>​    当执行一条更新语句，实际上，它不仅自动开启了事务，而且还自动提交了，所以最终写入了磁盘。这个是开启事务的第一种方式，增删改的语句会自动开启事务，当然是一条SQL一个事务。注意每个事务都是有编号的，这个编号是一个整数，有递增的特性。如果把多条SQL放在一个事务中，就要手动开启事务。手动开启事务有两种方式：一种是用begin；一种是用start transaction。结束事务也有两种方式：一种是回滚事务rollback，事务结束；另一种是提交事务commit，事务结束。</p>
<p>​    InnoDB中有一个autocommit的参数（分为两个级别，session和global级别）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;autocommit&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>​    它的默认值是ON。这个参数的意义是是否自动提交。如果它的值是true/ON的话，会自动提交事务。如果设置为false/OFF的话，那么数据库的事务就需要我们手动结束，用rollback或commit。</p>
<p>​    还有一种情况，客户端的连接断开的时候，事务也会结束。</p>
<h3 id="1-6事务并发会带来哪些问题？"><a href="#1-6事务并发会带来哪些问题？" class="headerlink" title="1.6事务并发会带来哪些问题？"></a>1.6事务并发会带来哪些问题？</h3><p>​    有两个事务，一个编号2573，另一个是2674。在第一个事务中，它首先通过where id=1的条件查询一条数据，返回name=Ada，age=16的这条数据，然后第二个事务，它通过一个update的语句，把id=1的数据的age改成了18，但是没有提交。</p>
<p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/1.png" srcset="/img/loading.gif" lazyload></p>
<p>​    这时，在第一个事务中，它再次执行相同的查询操作，发现数据发生了变化，获取到的数据age变成了18.那么，这种在一个事务中，由于其他的时候修改了数据并且没有提交，而导致了前后两次读取数据不一致的情况，这种事务并发的问题，我们把它定义为<strong>脏读。</strong>如果在转账的案例中，我们第一个事务基于读取到的第二个事务未提交的余额进行了操作，但是第二个事务进行了回滚，这个时候就会导致数据不一致。</p>
<p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/2.png" srcset="/img/loading.gif" lazyload></p>
<p>​    同样是两个事务，第一个事务通过id=1查询到了一条数据。然后第二个事务中执行了一个update操作，执行了update以后它通过一个commit提交了修改。然后第一个事务读取到了其他事务已提交的数据导致前后两次读取数据不一致的情况，就像这里，age到底是16还是18，那么这种事务并发带来的问题，把它叫做<strong>不可重复读。</strong></p>
<p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/3.png" srcset="/img/loading.gif" lazyload></p>
<p>​    在第一个事务中我们执行了一个范围查询，这时满足条件的数据只有一条。在第二个事务中，插入了一行数据，并且提交了。重点：插入了一条数据。在第一个事务再去查询时，它发现多了一行数据。一个事务前后两次读取数据不一致，是由于其他事务插入数据造成的，这种情况叫做<strong>幻读</strong>。</p>
<p>不可重复读和幻读的区别在哪里？修改或删除造成的读不一致叫做不可重复读，插入造成的读叫做幻读。</p>
<p>这里有两点需要说明：</p>
<ol>
<li><p>一个事务读取到其他事务最新提交的数据，这不是正常的吗？当然是正常的，所以这里讨论的是读一致性。读一致性的意义就是一个事务的select操作跟其他事务没有瓜葛，你不需要修改数据，所以不需要获取最新的数据，这样能够提高并发性能。</p>
</li>
<li><p>如果在第一个事务中，select以后，再执行一个update，就能获取到第二个事务的最新数据，这个怎么解释？同样的，这个页脱离了读一致性的讨论范畴。如果要修改数据。必然会读取到最新的数据，也会影响其他的事务。</p>
</li>
</ol>
<p>所以这里要不要修改，要不要读取到最新的数据，是一个区别点。目前我们讨论的都是一个事务中多次重复读取。</p>
<p>​    小结：无论是脏读，不可重复读，幻读，他们都是数据库的读一致性问题，都是在一个事务中前后两次读取出现了不一致的情况。读一致性的前提，必须要由数据库提供一定的事务隔离机制来解决。就像我们去饭店吃饭，基本的设施和卫生保证都是饭店提供的。那么我们使用的数据库，隔离性的问题页必须由数据库帮助我们解决。</p>
<h3 id="1-7SQL92标准事务隔离级别定义"><a href="#1-7SQL92标准事务隔离级别定义" class="headerlink" title="1.7SQL92标准事务隔离级别定义"></a>1.7SQL92标准事务隔离级别定义</h3><p>​    美国国家标准协会（ANSI）制定了一个SQL标准，也就是说建议数据库厂商都按照这个标准，提供一定的事务隔离级别，来解决事务并发的问题。这个SQL标准有很多版本，大家最熟悉的是SQL92标准。</p>
<p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/4.png" srcset="/img/loading.gif" lazyload></p>
<p>​    这个表格里面定义了四个隔离级别，右边P1 P2 P3计师代表事务并发的3个问题，脏读，不可重复读，幻读。Possible代表在这个隔离级别下，这个问题有可能发生，换句话说就是没有解决这个问题。Not Possiable就是解决了这个问题。</p>
<p>我们详细的分析这4个隔离级别是怎么定义的。</p>
<ol>
<li><p>Read Uncommitted（未提交读），一个事务可以读取到其他事务为提交的数据，会出现脏读，所以叫做RU，没有解决任何问题。</p>
</li>
<li><p>Read Commited（已提交读），就是一个事务只能读取到其他事务已提交的数据，不能读取其他事务未提交的数据，解决了脏读的问题，但是会出现不可重复读的问题。</p>
</li>
<li><p>Repeatable Read（可重复读），它解决了不可重复读的问题，也就是在同一事务中多次读取的数据结果是一样的，但是没有解决幻读的问题</p>
</li>
<li><p>Serializable（串行化），这个隔离级别下，所有的事务都是串行执行的，也就是对数据的操作需要排队，已经不存在事务的并发操作了，所以它解决了所有问题。</p>
</li>
</ol>
<p>事务的隔离级别是可以修改的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level read uncommitted;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level read committed;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level repeatable read;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level serializable;<br></code></pre></td></tr></table></figure>

<p>​    这个是SQL92的标准，但是不同的数据库厂商或者存储引擎的实现有一定的差异，比如Oracle中就只有两种RC（已提交读）和Serializable（串行化）。</p>
<h3 id="1-8-InnoDB事务隔离级别的实现"><a href="#1-8-InnoDB事务隔离级别的实现" class="headerlink" title="1.8 InnoDB事务隔离级别的实现"></a>1.8 InnoDB事务隔离级别的实现</h3><table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>未提交读(Read Uncommitted)</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>已提交读(Read Committed)</td>
<td><em>不可能</em></td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>可重复读(Repeatable Read)</td>
<td><em>不可能</em></td>
<td><em>不可能</em></td>
<td><em><strong>对InnoDB不可能</strong></em></td>
</tr>
<tr>
<td>串行化(Serializable)</td>
<td><em>不可能</em></td>
<td><em>不可能</em></td>
<td><em>不可能</em></td>
</tr>
</tbody></table>
<p>​    InnoDB支持的4个隔离级别和SQL92定义的完全一致，隔离级别越高，事务的并发度越低。唯一的区别是InnoDB在RR级别就解决了幻读的问题。也就是说不需要使用串行话去解决所有问你题，既保证了数据的一致性，又支持较高的并发度，这个就是InnoDB默认使用RR作为事务隔离级别的原因。</p>
<h3 id="1-9-读一致性解决方案"><a href="#1-9-读一致性解决方案" class="headerlink" title="1.9 读一致性解决方案"></a>1.9 读一致性解决方案</h3><p>​    如果要解决读一致性的问题，保证一个事务中前后两次读取数据结果一致，实现事务隔离，总体上有以下两大类方案。</p>
<h4 id="1-9-1-LBCC"><a href="#1-9-1-LBCC" class="headerlink" title="1.9.1 LBCC"></a>1.9.1 LBCC</h4><p>​    既要保证前后两次读取数据一致，那么我读取数据时锁定我要操作的数据，不允许其他的事务修改就行了。这种方案叫做基于锁的并发控制Lock Based Concurrency Control（LBCC）。</p>
<p>​    如果仅仅是基于锁来实现事务隔离，一个事务读取得时候不允许其他事务修改，那就意味着不支持并发得读写操作，而我们得大多数应用都是读多写少得，这样会极大得影响操作数据得效率。</p>
<h4 id="1-9-2-MVCC"><a href="#1-9-2-MVCC" class="headerlink" title="1.9.2 MVCC"></a>1.9.2 MVCC</h4><p>​    第二种，如果要让一个事务前后两次读取得数据保持一致，那么我们可以在修改数据之前给它建立一个备份或者快照，后面再来读取这个快照就行了。这种方案我们叫做多版本的并发控制Multi Version Concurrency Control（MVCC）。MVCC的原则：</p>
<p>一个事务能看到的数据版本：</p>
<ol>
<li><p>第一次查询之前已经提交的事务的修改</p>
</li>
<li><p>本事务的修改</p>
</li>
</ol>
<p>一个事务不能看见的数据版本：</p>
<ol>
<li><p>在本事务第一次查询之后创建的事务（事务ID比本事务ID大）</p>
</li>
<li><p>活跃的（未提交的）事务的修改</p>
</li>
</ol>
<p>​    MVCC的效果：我们可以查到在我这个事务之前已经存在数据，即使它在后面被修改删除了，而在我这个事务之后新增的数据，我是查不到的。所以我们才把这个叫做快照，不管别的事务做任何增删改查的操作，它只能看到第一次查询时看到的数据版本。</p>
<p>​    分析一下MVCC的原理。首先，InnoDB的事务都是由编号的，而且会不断递增。InnoDB为每行记录都实现了两个隐藏字段：</p>
<p>​    1.DB_TRX_ID，6字节：事务id，数据是在哪个事务插入或者修改为新数据的，就记录为当前事务ID。</p>
<p>​    2.DB_ROLL_PTR，7字节：回滚指针，我们把它理解为删除版本号，数据被删除或记录为旧数据时，记录当前事务ID，没有修改或者删除的时候是空。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>DB_TRX_ID</th>
<th>DB_ROLL_PTR</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>aaa</td>
<td>01</td>
<td>NULL</td>
</tr>
</tbody></table>
<p>当第一个事务，初始化数据（检查初始数据）</p>
<table>
<thead>
<tr>
<th>Transaction 1</th>
</tr>
</thead>
<tbody><tr>
<td>begin; <br />insert into mvcctest values(null, ‘qs’);<br />insert into mvcctest values(null, ‘hh’);<br />commit;</td>
</tr>
</tbody></table>
<p>此时的数据，创建版本是当前事务ID（假设事务编号是1），删除版本为空：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>创建版本</th>
<th>删除版本</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>qh</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>2</td>
<td>hh</td>
<td>1</td>
<td>undefined</td>
</tr>
</tbody></table>
<p>第二个事务，执行第一次查询，读取到两条原始数据，这时事务ID是2：</p>
<table>
<thead>
<tr>
<th>Transaction 2</th>
</tr>
</thead>
<tbody><tr>
<td>begin;<br />select * from mvcctest; –(1)第一次查询</td>
</tr>
</tbody></table>
<p>第三个事务，插入数据：</p>
<table>
<thead>
<tr>
<th>Transaction 3</th>
</tr>
</thead>
<tbody><tr>
<td>begin;<br />insert into mvcctest values(NULL, ‘tom’);<br />commit</td>
</tr>
</tbody></table>
<p>此时的数据，多了一条tom，它的创建版本号是当前事务编号，3：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>创建版本</th>
<th>删除版本</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>qs</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>2</td>
<td>hh</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>3</td>
<td>tom</td>
<td>3</td>
<td>undefined</td>
</tr>
</tbody></table>
<p>第二个事务，执行第二次查询：</p>
<table>
<thead>
<tr>
<th>Transaction 2</th>
</tr>
</thead>
<tbody><tr>
<td>select * from mvcctest;  –(2)第二次查询</td>
</tr>
</tbody></table>
<p>​    MVCC的查找原则：只能查找创建时间小于等于当前事务ID的数据，和删除时间大于当前事务ID的行（或未删除）。也就是不能查到在我的事务开始之后插入的数据，tom的创建ID大于2，所以还是只能查到两条数据。</p>
<p>第四个事务，删除数据，删除了id=2 hh这条记录：</p>
<table>
<thead>
<tr>
<th>Transaction 4</th>
</tr>
</thead>
<tbody><tr>
<td>begin;<br />delete from mvcctest where id=2;<br />commit;</td>
</tr>
</tbody></table>
<p>此时的数据，hh的删除版本被记录为当前事务ID，4，其他数据不变：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>创建版本</th>
<th>删除版本</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>qs</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>2</td>
<td>hh</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>tom</td>
<td>3</td>
<td>undefined</td>
</tr>
</tbody></table>
<p>在第二个事务中，执行第三次查询：</p>
<table>
<thead>
<tr>
<th>Transaction 2</th>
</tr>
</thead>
<tbody><tr>
<td>select * from mvcctest; (3)第三次查询</td>
</tr>
</tbody></table>
<p>​    查找规则：只能查找创建时间小于等于当前事务ID的数据，和删除时间大于当前事务ID的行（或未删除）。也就是，在我事务开始之后删除的数据，所以huihui依然可以查出来。所以还是查出两条数据。</p>
<p>​    第五个事务，执行更新操作，这个事务ID是5：</p>
<table>
<thead>
<tr>
<th>Transaction 5</th>
</tr>
</thead>
<tbody><tr>
<td>begin;<br />update mvcctest ser name = ‘盆玉艳’ where id= 1;<br />commit;</td>
</tr>
</tbody></table>
<p>此时的数据，更新数据时，旧数据的删除版本被记录为当前事务ID5（undo），产生了一条新数据，创建ID为当前事务ID5：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>创建版本</th>
<th>删除版本</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>qs</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>hh</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>tom</td>
<td>3</td>
<td>undefined</td>
</tr>
<tr>
<td>1</td>
<td>盆玉艳</td>
<td>5</td>
<td>undefined</td>
</tr>
</tbody></table>
<p>第二个事务，执行第四次查询：</p>
<table>
<thead>
<tr>
<th>Transaction 2</th>
</tr>
</thead>
<tbody><tr>
<td>select * from mvcctest; (4)第四次查询</td>
</tr>
</tbody></table>
<p>​    查找规则：只能查找创建时间小于等于当前事务ID的数据，和删除时间大于当前事务ID的行（或未删除）。因为更新后的数据盆鱼宴创建版本大于2，代表是在事务之后增加的，查不出来。而旧数据qingshan的删除版本大于2，代表是在事务之后删除的，可以查出来。</p>
<p>​    通过以上演示可以看到，通过版本号的控制，无论其他事务是插入，修改，删除，第一个事务查询到的数据都没有变化。这个是MVCC的效果，当然，这里是一个简化的模型。假设一条数据修改了3次，两次提交了一次未提交，每次修改之后都有开启一个事务去查询，那么事务2，4，6查到的数据会有不一样。</p>
<table>
<thead>
<tr>
<th>trx_id</th>
<th>SQL</th>
</tr>
</thead>
<tbody><tr>
<td>trx1</td>
<td>update user_info set name = ‘penyuyan’ where id =1;<br />commit;</td>
</tr>
<tr>
<td>trx2</td>
<td>select name from user_info where id = 1;</td>
</tr>
<tr>
<td>trx3</td>
<td>update user_info set name=’wuyanzu’ where id = 1; <br />commit;</td>
</tr>
<tr>
<td>trx4</td>
<td>select name from user_info where id = 1;</td>
</tr>
<tr>
<td>trx5</td>
<td>update user_info set name=’liudehua’ where id = 1;  <br />未提交</td>
</tr>
<tr>
<td>trx6</td>
<td>select name from user_info where id = 1;</td>
</tr>
<tr>
<td></td>
<td>trx2、4、6再各查一次</td>
</tr>
</tbody></table>
<p>​    InnoDB中，一条数据的旧版本，是存放在undo log中。因为修改了多次，这些undo log回形成一个链条，叫做undo log链，现在undo log中有刘德华，吴彦祖，盆鱼宴。所以前面说的DB_ROLL_PTR，它其实指向undo log链的指针。</p>
<p>​    第二个问题，事务2，4，6最后再查一次，他们去undo log链找数据时。拿到的数据是不一样的。再这个undo log链里面，一个事务怎么判断哪个版本的数据是它应该读取的？</p>
<p>回想一下MVCC的规则：</p>
<p>一个事务能看到的数据版本：1，第一次查询之前已经提交的事务的修改；2，本事务的修改。</p>
<p>一个事务不能看到的数据版本：1，本事务第一次查询之后创建的事务（事务ID比我的事务ID大）；2，活跃的（未提交的）事务的修改。</p>
<p>​    所以，必须要有一个数据结构，把本事务ID，活跃事务ID，当前系统最大事务ID存起来，这样才能实现判断。这个数据结构叫Read View（可见性视图），每个事务都维护一个自己的Read View。</p>
<p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/6.png" srcset="/img/loading.gif" lazyload></p>
<p><em>m_ids</em>：表示在生成ReadView时当前系统活跃的读写事务的事务id列表。</p>
<p><em>min_trx_id</em>：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务ID，也就是m_ids中的最小值。</p>
<p><em>mmax_trx_id</em>：表示生成ReadView时系统中应该分配给下一个事务的id值。</p>
<p><em>creator_trx_id</em>：表示生成该ReadView的事务的事务id。</p>
<p>有了这个数据结构后，事务判断可见性的规则是这样的：</p>
<p>0，从数据的最早版本开始判断（undo log）。</p>
<p>1，数据版本的trx_id = creator_trx_id，本事务修改，可以访问。</p>
<p>2，数据版本的trx_id &lt; min_trx_id（未提交事务的最小ID），说明这个版本是生成ReadView已经提交，可以访问。</p>
<p>3，数据版本的trx_id &gt; max_trx_id（下一个事务ID），这个版本是生成ReadView之后才开启的事务建立的，不能访问。</p>
<p>4，数据版本的trx_id在min_trx_id和max_trx_id之间，看看是否在m_ids中。如果在，不可以。如果不在，可以。</p>
<p>5，如果当前版本不可见，就找undo log链中的下一个版本。</p>
<p>​    注意：RR中ReadView是事务第一次查询时建立的。RC的ReadView是事务每次查询的时候建立的。Oracle，Postgres等等其他数据库都有MVCC实现。需要注意，在InnoDB中，MVCC和锁是协同使用的，这两种方式并不是互斥的。</p>
<h2 id="2-InnoDB锁的基本类型"><a href="#2-InnoDB锁的基本类型" class="headerlink" title="2 InnoDB锁的基本类型"></a>2 InnoDB锁的基本类型</h2><h3 id="2-1-锁的粒度"><a href="#2-1-锁的粒度" class="headerlink" title="2.1 锁的粒度"></a>2.1 锁的粒度</h3><p>​    InnoDB和MyISAM支持的锁的类型是不同的。InnoDB同时支持表锁和行锁，MySIAM只支持表锁，用lock table的语法加锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">lock talbes xxx read;<br>lock tables xxx write;<br>unlock tables;<br></code></pre></td></tr></table></figure>

<h3 id="2-2-锁的类型"><a href="#2-2-锁的类型" class="headerlink" title="2.2 锁的类型"></a>2.2 锁的类型</h3><p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html</a></p>
<p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/7.png" srcset="/img/loading.gif" lazyload></p>
<p>​    官网把锁分成了8类。把前面的两个行级别锁（Shared and Exclusive Locks），和两个表级别的锁（Intention Locks）称为锁的基本模式。后面三个Record Locks，Gap Locks，Next-Key Locks，我们把它们叫做锁的算法。</p>
<p>​    插入意向锁（Insert Intention Locks）：是一个特殊的间隙锁。间隙锁不允许插入数据，但是插入意向锁允许多个事务同时插入数据到同一个范围，比如（4，7），一个事务插入5，一个事务插入6，不会发生锁等待。</p>
<p>​    自增锁（AUTO-INC Locks）：是一种特殊的表锁，用来防止自增字段重复，数据插入以后就会释放，不需要等到事务提交才释放。如果需要选择更快的子增值生成速度或者更加连续的子增值，就要通过修改自增锁的模式改变。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_autoinc_lock_mode&#x27;</span><br></code></pre></td></tr></table></figure>

<p>​    0：traditional（每次都会产生表锁）</p>
<p>​    1：consecutive（会产生一个轻量锁，simple insert会获得批量的锁，保证连续插入，默认值）</p>
<p>​    2：interleaved（不会锁表，来一个处理一个，并发最高）</p>
<p>​    Predicate Locks for Spatial Indexes是5.7版本中新增的一种数据类型的索引的锁。</p>
<h3 id="2-3-共享锁"><a href="#2-3-共享锁" class="headerlink" title="2.3 共享锁"></a>2.3 共享锁</h3><p>​    第一个行级别的锁就是Shared Locks（共享锁），获取了一行数据的读锁以后，可以用来读取数据，所以也叫做读锁，注意不要在加上了读锁以后去写数据，不然的话可能会出现死锁的情况。而且多个事务可以共享一把读锁。共享锁的作用：因为共享锁会阻塞其他事务的修改，所以可以用在不允许其他事务修改数据的情况（共享锁和写锁互斥的例子后面再看）。我们可以用select …… lock in share mode；的方式手工加上一把读锁。释放锁有两种方式，只要事务结束就会自动释放锁，包括提交事务和结束事务</p>
<table>
<thead>
<tr>
<th>Transaction 1</th>
<th>Transaction 2</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>select * from student where id =1 lock in share mode;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>begin;</td>
</tr>
<tr>
<td></td>
<td>select * from student where id = 1 lock in share mode;  <br />//OK</td>
</tr>
</tbody></table>
<h3 id="2-4-排他锁"><a href="#2-4-排他锁" class="headerlink" title="2.4 排他锁"></a>2.4 排他锁</h3><p>​    第二个行级别的锁叫做Exclusive Locks（排他锁），它是用来操作数据的，所以又叫做写锁。只要一个事务获取了一行数据的排他锁，其他事务就不能再获取这一行数据的共享锁和排他锁。加锁的方式有两种，第一种是自动加排他锁，增删改都会默认加上一个排他锁。还有一种是手工加锁，我们用一个FOR UPDATE给一行数据加上一个排他锁，这个无论是在我们的代码中还是操作数据的工具中都比较常用。释放锁和前面是一样的。</p>
<table>
<thead>
<tr>
<th>Transaction 1</th>
<th>Transaction 2</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>update student set sname=’fdasfd’ where id = 1;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>begin;</td>
</tr>
<tr>
<td></td>
<td>select * from student where id=1 lock in share mode;  //blocked <br />select * from student where id=1 for update; //blocked   <br />delete from student where id=1 //blocked</td>
</tr>
</tbody></table>
<h3 id="2-5-意向锁"><a href="#2-5-意向锁" class="headerlink" title="2.5 意向锁"></a>2.5 意向锁</h3><p>​    意向锁是由数据库自己维护的。也就是说，当我们给一行数据加上共享锁之前，数据库会自动在这张表上面加上意向共享锁。当我们给一行数据加上排他锁之前，数据库会自动在这张表上面加上一个意向排他锁。反过来，如果一张表上至少有一个意向共享锁，说明其他事务给其中的某些数据加上了共享锁；如果表上至少有一个意向排他锁，说明其他事务给其中的某些数据行加上了排他锁。</p>
<p>​    意向锁和意向锁是不冲突的，意向锁和行锁也不冲突。那么这两个表级别的锁有什么意义？如果没有意向锁的话，当我们准备给一张表加上表锁时，我们首先需要去判断有没有其他事务锁定了某些行，如果有的话，肯定不能加上表锁。那么这时我们就要去扫描整张表才能确定能不能成功加上一个表锁，如果数据量很大，那么加表锁的效率就非常低。但是我们引入意向锁后就不一样了，我们只要判断这张表上是否有意向锁，如果有直接返回失败。如果没有就可以加锁成功。所以InnoDB中的表锁，我们可以把它理解为一个标志（就像火车上卫生间有没有使用的灯），是用来提高加锁效率的。</p>
<table>
<thead>
<tr>
<th>Transaction 1</th>
<th>Transaction 2</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>select * from student where id=1 for update;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>beginl</td>
</tr>
<tr>
<td></td>
<td>lock tables student write; //blocked <br />unlock tables; //释放表锁的方式</td>
</tr>
</tbody></table>
<p>​    数据库锁跟java中的锁是一样的，是为了解决资源竞争的问题，java中的资源是对象，数据库的资源是数据表或者数据行。所以锁是用来解决事务对数据的并发访问问题的。</p>
<h2 id="3-行锁的原理"><a href="#3-行锁的原理" class="headerlink" title="3 行锁的原理"></a>3 行锁的原理</h2><p>​    有三张表，一张没有索引的t1，一张有主键索引的t2，一张有唯一索引的t3</p>
<p><strong>1.没有索引的表（假设锁住记录）</strong></p>
<p>​    假设InnoDB的行锁是锁住了一行数据或者一条记录。先看一下t1的表结构，它有两个字段，int类型的id和varchar类型的name。里面有4条数据1，2，3，4。</p>
<table>
<thead>
<tr>
<th>Transaction 1</th>
<th>Transaction 2</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>select * from t1 where id = 1 for update;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from t1 where id=3 for update;  //blocked</td>
</tr>
<tr>
<td></td>
<td>insert into ‘t1’(‘id’,’name’) values(5, ‘5’);  //blocked</td>
</tr>
</tbody></table>
<p>​    在两个会话中手工开启两个事务。第一个事务中我们通过where id = 1锁住第一行数据。第二个事务中，我们尝试给id=3的这一行数据加锁，被阻塞。插入一条id=5的数据，被阻塞。结果第二个事务的加锁操作被阻塞了，说明<strong>InnoDB的行锁锁住的不是Record</strong>。那为啥在没有索引或者没有用到索引的情况下，会锁住整张表？这个问题后续解释。</p>
<p><strong>2.有主键索引的表</strong></p>
<p>​    t2的表结构。字段是一样的，不同的地方是id上创建了一个主键索引。里面的数据是1，4，7，10.</p>
<table>
<thead>
<tr>
<th>Transaction 1</th>
<th>Transaction 2</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>select * from t2 where id = 1 for update;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from t2 where id=1 for update;  //blocked</td>
</tr>
<tr>
<td></td>
<td>select * from t2 where id=4 for update  //OK</td>
</tr>
</tbody></table>
<p>第一种情况，使用相同的id值去加锁，冲突；使用不同的id加锁，加锁成功。</p>
<p><strong>3.唯一索引（假设锁住字段）</strong></p>
<p>t3的表结构。字段还是一样的，id上创建了一个主键索引，name上创建了一个唯一索引。里面数据1，4，7，10.</p>
<table>
<thead>
<tr>
<th>Transaction 1</th>
<th>Transaction 2</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>select * from t3 where name=’4’ for update;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from t3 where name=’4’ for update;  //blocked</td>
</tr>
<tr>
<td></td>
<td>select * from t3 where id=4 for update  //blocked</td>
</tr>
</tbody></table>
<p>​    第一个事务中我们通过name字段去锁定值是4的数据。第二个事务中尝试获取一样的排他锁，失败。然后用id=4去给这行数据加锁，被阻塞，说明行锁锁住字段的推测也是错的。</p>
<p>​    既然锁住的不是record，也不是column，InnoDB的行锁到底锁住了什么？在这三个案例中，他们的差异就在于表结构，其实答案就是索引，InnoDB的行锁是**通过锁住索引实现的。还有两个问题没有解决：</p>
<p>​    1.为什么表中没有索引的时候，锁住一行数据会导致锁表？因为查询没有使用索引，会进行全表扫描，然后把每一个隐藏的聚集索引都锁住了。</p>
<p>​    2.为什么通过唯一索引给数据行加锁，主键索引也会被锁住？因为我们通过辅助索引锁定一行数据时，它跟我们检索数据的步骤是一样的，会通过主键值找到主键索引，然后也锁定。本质上是因为锁定的是同一行数据，是相互冲突的。</p>
<h2 id="4-行锁的算法"><a href="#4-行锁的算法" class="headerlink" title="4  行锁的算法"></a>4  行锁的算法</h2><p>​    我们先看一下测试用表t2，其中有个主键，插入4行数据，主键id分别是1，4，7，10.</p>
<p>​    首先，先普及一下三种范围的概念。因为我们用主键索引加锁，我们这里划分标准就是主键索引的值。</p>
<p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/9.png" srcset="/img/loading.gif" lazyload></p>
<p>​    这些数据库中存在的主键值，我们把它叫做Record，记录，那么我们这里就有4个Record。根据主键，这些存在的Record隔开的数据不存在的区间，我们叫做Gap，间隙，它是一个左开右开的区间。假如我们有N个Record，那么我们就有N+1个Gap。最后一个，间隙（Gap）连同它左边的记录（Record），我们把它叫做临键的区间，它是左开右臂=闭得区间。整型的主键索引，它是可以排序的，所以才有这种区间，如果我的主键索引不是整型，是字符怎么办？任何一个字符集，都有相应得排序规则：</p>
<p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/10.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="4-1-记录锁-Record-Locks"><a href="#4-1-记录锁-Record-Locks" class="headerlink" title="4.1 记录锁(Record Locks)"></a>4.1 记录锁(Record Locks)</h3><p>​    当对于唯一性的索引（包括唯一索引和主键索引）使用等值查询，精准匹配到一条记录的时候，这时使用的就是记录锁。</p>
<p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/11.png" srcset="/img/loading.gif" lazyload></p>
<p>​    使用不同的key去加锁，不会冲突，它只锁住这个record。图片上红的字就是使用这种锁的条件。</p>
<h3 id="4-2-间隙锁-Gap-Locks"><a href="#4-2-间隙锁-Gap-Locks" class="headerlink" title="4.2 间隙锁(Gap Locks)"></a>4.2 间隙锁(Gap Locks)</h3><p>​    当查询的记录不存在，没有命中任何一个record，无论是用等值查询还是范围查询时，它使用的都是间隙锁。</p>
<p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/12.png" srcset="/img/loading.gif" lazyload></p>
<p>​    举个例子，where id &gt; 4 and id &lt; 7, where id = 6。</p>
<table>
<thead>
<tr>
<th>Transaction 1</th>
<th>Transaction 2</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>select * from t2 where id=6 for update;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into ‘t2’(‘id’,’name’) values(5,’6’); //blocked<br />insert into ‘t2’(‘id’,’name’) values(6,’6’); //blocked <br />select * from t2 where id=6 for update; //OK</td>
</tr>
<tr>
<td>select * from t2 where id &gt; 20 for update;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into ‘t2’(‘id’,’name’) values(11,’6’); //blocked</td>
</tr>
</tbody></table>
<p>当查询不存在时使用间隙锁。注意，间隙锁主要是阻塞插入insert，相同的间隙锁之间不冲突。</p>
<h3 id="4-3-临键锁-Next-Key-Locks"><a href="#4-3-临键锁-Next-Key-Locks" class="headerlink" title="4.3 临键锁(Next-Key Locks)"></a>4.3 临键锁(Next-Key Locks)</h3><p>​    当我使用了范围查询，不仅仅命中了Record记录，还包含了Gap间隙，在这种情况下我们使用的就是临键锁，它是Mysql中默认的行锁算法，相当于记录锁加上间隙锁。唯一性索引，等值查询匹配到一条记录时退化为记录锁。没有匹配到记录时退化成间隙锁。</p>
<p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/13.png" srcset="/img/loading.gif" lazyload></p>
<p>​    比如使用&gt;5，&lt;9，它包含了记录不存在的区间，也包含了一个Record 7.</p>
<table>
<thead>
<tr>
<th>Transaction 1</th>
<th>Transaction 2</th>
</tr>
</thead>
<tbody><tr>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>select from t2 where id&gt;5 and id&lt;9 for update</td>
<td></td>
</tr>
<tr>
<td></td>
<td>begin;</td>
</tr>
<tr>
<td></td>
<td>select * from t2 where id=4 for update;  //OK<br />insert into ‘t2’(‘id’,’name’) values(6, ‘6’); //blocked <br />insert into ‘t2’(‘id’,’name’) values(8, ‘6’); //blocked <br />select * from t2 where id=10 for update; //blocked</td>
</tr>
</tbody></table>
<p>​    临键锁，锁住最后一个key的下一个左开右闭区间。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t2 <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">7</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>; <span class="hljs-comment">--锁住(4,7] 和(7,10]</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t2 <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">8</span> <span class="hljs-keyword">and</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>; <span class="hljs-comment">--锁住(7,10] 和(10,正无穷)</span><br></code></pre></td></tr></table></figure>

<p>为什么要锁住下一个左开右闭区间？就是为了解决幻读的问题。</p>
<h3 id="4-4-InnoDB事务隔离级别的实现"><a href="#4-4-InnoDB事务隔离级别的实现" class="headerlink" title="4.4 InnoDB事务隔离级别的实现"></a>4.4 InnoDB事务隔离级别的实现</h3><p>​    所以，InnoDB的RR级别能够解决幻读的问题，就是用临键锁实现的。</p>
<p>​    最后总结一下四个事务隔离级别的实现：</p>
<p>​    1.Read Uncommited：RU隔离级别，不加锁</p>
<p>​    2.Serializable：所有的select语句都会被隐式的转化为select ……in share mode，会和update，delete互斥。</p>
<p>​    3.Repeatable Read：RR隔离级别下，普通的select使用快照读（snapshot），底层使用MVCC来实现。加锁的select（select … in share mode/select …for update）以及更新操作update，delete等语句使用当前读（current read），底层使用记录锁，或者间隙锁或者临键锁。</p>
<p>​    4.Read Commited：RC隔离级别下，普通的select都是快照读（MVCC）。加锁的select都使用记录锁，因为没有Gap Lock。除了两种特殊情况——外键约束检查（foreign-key constraint checking）以及重复键检查（duplicate-key checking）时会使用间隙锁封锁区间，所以RC会出现幻读问题。</p>
<h2 id="5-事务隔离级别的选择"><a href="#5-事务隔离级别的选择" class="headerlink" title="5 事务隔离级别的选择"></a>5 事务隔离级别的选择</h2><p>​    RU和Serializable肯定不能使用。为什么有些公司要用RC？</p>
<p>​    RC和RR主要有几个区别：</p>
<p>​    1.RR的间隙锁会导致锁定范围的扩大。</p>
<p>​    2.条件列未使用到索引，RR锁表，RC锁行</p>
<p>​    3.RC的“半一致性”（semi-consistent）读可以增加update操作的并发性。</p>
<p>​    在RC中，一个update语句，如果督导一行已经加锁的记录，此时InnoDB返回记录最近提交的版本，由MySQL上层判断此版本是否满足update的where条件。若满足（需要更新），则MuSQLhi重新发起一次读操作，此时会读取行的最新版本（并加锁）。</p>
<p>​    实际上，如果能够正确的使用锁（避免不使用索引去加锁），只锁定需要的数据，用默认的RR级别就可以了。在我们使用锁的时候，有个问题时需要注意和避免的，我们知道，排他锁由互斥的特性。一个事务或者说一个线程持有锁时，会阻止其他的线程获取锁，这时会造成阻塞等待，如果训话等待，会有可能造成死锁。</p>
<h2 id="6-死锁"><a href="#6-死锁" class="headerlink" title="6 死锁"></a>6 死锁</h2><h3 id="6-1-锁的释放与阻塞"><a href="#6-1-锁的释放与阻塞" class="headerlink" title="6.1 锁的释放与阻塞"></a>6.1 锁的释放与阻塞</h3><p>​    锁是在事务结束（commit，rollback）或者客户端断开连接的时候释放。控制锁的等待时间，默认是50秒</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_lock_wait_timeout&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="6-2-死锁的发生与检测"><a href="#6-2-死锁的发生与检测" class="headerlink" title="6.2 死锁的发生与检测"></a>6.2 死锁的发生与检测</h3><p>​    在发生死锁时，InnoDB一般通过算法（wait-for graph）自动检测到。 死锁产生的条件：</p>
<p>​    （1）同一时刻只能有一个事务持有这把锁</p>
<p>​    （2）其他事务需要在这个事务释放锁之后才能获取锁，而不可以强行剥夺</p>
<p>​    （3）当多个事务形成等待环路的时候，即发生死锁。</p>
<p>​    实际上，发生死锁的原因很多，但是都满足以上3个条件这个也是表锁是不会发生死锁的原因，因为表锁的资源都是一次性获取的。</p>
<h3 id="6-3-查看锁信息（日志）"><a href="#6-3-查看锁信息（日志）" class="headerlink" title="6.3 查看锁信息（日志）"></a>6.3 查看锁信息（日志）</h3><p>首先，SHOW STATUS命令中，包括了一些行锁的信息。</p>
<p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/15.png" srcset="/img/loading.gif" lazyload></p>
<p>Show命令是一个概要信息。InnoDB还提供了三张表来分析事务与锁的情况：</p>
<p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/16.png" srcset="/img/loading.gif" lazyload></p>
<p>更加详细的锁信息，开启标准监控和锁监控：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> innodb_status_output<span class="hljs-operator">=</span><span class="hljs-keyword">ON</span>;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> innodb_status_output_locks<span class="hljs-operator">=</span><span class="hljs-keyword">ON</span>;<br></code></pre></td></tr></table></figure>

<p>​    如果一个事务长时间持有锁不释放，可以kill事务对应的线程ID，也就是INNODB_TRX表中的trx_mysql_thread_id。当然，死锁的问题不能每次都靠kill解决，我们应该尽量在编码的过程中避免。</p>
<h3 id="6-4-死锁的避免"><a href="#6-4-死锁的避免" class="headerlink" title="6.4 死锁的避免"></a>6.4 死锁的避免</h3><p>​    （1）在程序中，操作多张表时，尽量以相同的顺序来访问（避免形成等待环路）</p>
<p>​    （2）批量操作单张表数据时，先对数据进行排序（避免形成等待环路）</p>
<p>​    （3）申请足够级别的锁，如果要操作数据，就申请排他锁</p>
<p>​    （4）尽量使用索引访问数据，避免没有where条件的操作，避免锁表</p>
<p>​    （5）如果可以，大事务化成小事务</p>
<p>​    （6）使用等值查询而不是范围查询查询数据，命中记录，避免间隙锁对并发的影响。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="category-chain-item">数据库</a>
  
  
    <span>></span>
    
  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/" class="category-chain-item">MySQL</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/mysql/">#mysql</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>MySQL事务和锁</div>
      <div>http://www.zivjie.cn/2023/07/02/数据库/mysql/MySQL事务和锁/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Francis</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年7月2日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/07/03/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/" title="信息系统基础">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">信息系统基础</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/07/02/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/" title="网络规划与设计">
                        <span class="hidden-mobile">网络规划与设计</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
