<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Zookeeper源码解析</title>
    <link href="/2023/05/23/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/05/23/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Zookeeper-Server启动流程"><a href="#1-Zookeeper-Server启动流程" class="headerlink" title="1 Zookeeper Server启动流程"></a>1 Zookeeper Server启动流程</h2><p><img src="/image/zookeeper/Zookeeper%E5%8D%95%E6%9C%BA%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8.jpg"></p><h2 id="2-客户端实例化与创建节点"><a href="#2-客户端实例化与创建节点" class="headerlink" title="2 客户端实例化与创建节点"></a>2 客户端实例化与创建节点</h2><p><img src="/image/zookeeper/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%8E%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9.jpg"></p><h2 id="3-Zookeeper源码分析之查询数据与watch"><a href="#3-Zookeeper源码分析之查询数据与watch" class="headerlink" title="3 Zookeeper源码分析之查询数据与watch"></a>3 Zookeeper源码分析之查询数据与watch</h2><p><img src="/image/zookeeper/%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E3%80%81%E6%B7%BB%E5%8A%A0%E7%9B%91%E5%90%AC%E5%92%8C%E5%9B%9E%E8%B0%83.jpg"></p><h2 id="4-集群启动与Leader选举"><a href="#4-集群启动与Leader选举" class="headerlink" title="4 集群启动与Leader选举"></a>4 集群启动与Leader选举</h2><p><img src="/image/zookeeper/ZK%E9%9B%86%E7%BE%A4%E5%90%AF%E5%8A%A8%E4%B8%8Eleader%E9%80%89%E4%B8%BE.jpg"></p><h2 id="5-Learn与Leader数据同步"><a href="#5-Learn与Leader数据同步" class="headerlink" title="5 Learn与Leader数据同步"></a>5 Learn与Leader数据同步</h2><p><img src="/image/zookeeper/Learn%E4%B8%8ELeader%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5.jpg"></p><h2 id="6-ZAB协议处理事务请求"><a href="#6-ZAB协议处理事务请求" class="headerlink" title="6 ZAB协议处理事务请求"></a>6 ZAB协议处理事务请求</h2><p><img src="/image/zookeeper/ZAB%E5%8D%8F%E8%AE%AE%E5%A4%84%E7%90%86%E4%BA%8B%E5%8A%A1%E8%AF%B7%E6%B1%82.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper实现注册中心</title>
    <link href="/2023/05/23/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E9%9B%86%E7%BE%A4/"/>
    <url>/2023/05/23/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="1-初识Zookeeper集群"><a href="#1-初识Zookeeper集群" class="headerlink" title="1 初识Zookeeper集群"></a>1 初识Zookeeper集群</h2><p>官网：<a href="https://zookeeper.apache.org/doc/current/zookeeperOver.html#sc_designGoals">https://zookeeper.apache.org/doc/current/zookeeperOver.html#sc_designGoals</a></p><h3 id="1-1-zk集群中的角色"><a href="#1-1-zk集群中的角色" class="headerlink" title="1.1 zk集群中的角色"></a>1.1 zk集群中的角色</h3><p><img src="/image/zookeeper/6.png"></p><p>客户端是可以连接任意一个Zookeeper Server Cluster中的机器的。</p><p>Leader：只能有一个，可以处理客户端的读写请求。</p><p>Follower：可以有多个，只能处理客户端的读请求，要是收到写请求，则会转发给Leader进行处理。</p><p>Observer：可以有多个，只能处理客户端的读请求，要是收到写请求，则会转发给Leader进行处理，与Follower不同的是，Observer不参与Leader的投票选举以及写请求的提议和提交过程。</p><h3 id="1-2-对zk集群的理解"><a href="#1-2-对zk集群的理解" class="headerlink" title="1.2 对zk集群的理解"></a>1.2 对zk集群的理解</h3><h4 id="1-2-1-leader选举"><a href="#1-2-1-leader选举" class="headerlink" title="1.2.1 leader选举"></a>1.2.1 leader选举</h4><p>Leader+Follower的数量最好是奇数台，因为选举的时候需要进行投票，只有某个节点的票数超过半数，才会成为Leader。</p><p> 如果Leader+Follower是2台，则超过半数就是2。如果Leader+Follower是3台，则超过半数也是 2。</p><h4 id="1-2-2-节点的状态"><a href="#1-2-2-节点的状态" class="headerlink" title="1.2.2 节点的状态"></a>1.2.2 节点的状态</h4><p>Looking：启动节点，但还没有确定当前节点的角色时的状态。 </p><p>Leading：Leader节点所处的状态。 </p><p>Following：Follower节点所处的状态。 </p><p>Observing：Observer节点所处的状态。</p><h4 id="1-2-3-数据同步"><a href="#1-2-3-数据同步" class="headerlink" title="1.2.3 数据同步"></a>1.2.3 数据同步</h4><p>当zk02成为leader之后，zk01、zk03、zk04需要从leader上同步最新的数据。</p><h4 id="1-2-4-崩溃恢复"><a href="#1-2-4-崩溃恢复" class="headerlink" title="1.2.4 崩溃恢复"></a>1.2.4 崩溃恢复</h4><p>如果Leader节点挂了，则集群重新进行leader选举，此时集群对外是不能提供服务的。</p><h2 id="2-搭建Zookeeper集群"><a href="#2-搭建Zookeeper集群" class="headerlink" title="2 搭建Zookeeper集群"></a>2 搭建Zookeeper集群</h2><h3 id="2-1-centos"><a href="#2-1-centos" class="headerlink" title="2.1 centos"></a>2.1 centos</h3><p>（1）准备4台centos机器</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">zk01</span> <span class="hljs-number">192.168.0.111</span><br>zk02 <span class="hljs-number">192.168.0.112</span><br>zk03 <span class="hljs-number">192.168.0.113</span><br>zk04 <span class="hljs-number">192.168.0.114</span> observer<br></code></pre></td></tr></table></figure><p>（2）准备好一些前置环境</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Java、Maven</span><br><span class="hljs-keyword"></span>Zookeeper压缩包并解压<br>Zookeeper的环境变量配置<br></code></pre></td></tr></table></figure><p>（3）配置4台机器的hosts文件</p><blockquote><p>/etc/hosts</p></blockquote><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.0.111</span> zk1<br><span class="hljs-number">192.168.0.112</span> zk2<br><span class="hljs-number">192.168.0.113</span> zk3<br><span class="hljs-number">192.168.0.114</span> zk4<br></code></pre></td></tr></table></figure><p>（4）创建zk持久化目录的文件夹data </p><p>（5）在data目录下创建并配置myid文件 内容分别为：1、2、3、4</p><p>（6）在conf目录下编写zoo.cfg文件</p><blockquote><p>2888用于数据同步或节点间通信</p><p>3888用于leader选举投票</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">tickTime</span>=<span class="hljs-string">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-string">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">dataDir</span>=<span class="hljs-string">/usr/local/zookeeper/apache-zookeeper-3.7.1-bin/data</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-string">2181</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-string">zk1:2888:3888</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-string">zk2:2888:3888</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-string">zk3:2888:3888</span><br><span class="hljs-attr">server.4</span>=<span class="hljs-string">zk4:2888:3888:observer</span><br></code></pre></td></tr></table></figure><p>（7）依次启动zk01、zk02、zk03、zk04，并观察各个节点的状态</p><p>（8）图解</p><p><img src="/image/zookeeper/ZK%E9%9B%86%E7%BE%A4%E5%9B%BE%E8%A7%A3.jpg"></p><h3 id="2-2-基于K8s"><a href="#2-2-基于K8s" class="headerlink" title="2.2 基于K8s"></a>2.2 基于K8s</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f zk-cluster.yaml<br>kubectl get pods -n zookeeper-cluster<br>kubectl get pods -n zookeeper-cluster -o wide<br>kubectl get svc -n zookeeper-cluster<br>kubectl get statefulset -n zookeeper-cluster<br>kubectl describe svc zk-client -n zookeeper-cluster<br>kubectl <span class="hljs-built_in">exec</span> -it zk-1 -n zookeeper-cluster /bin/bash<br>zkServer.sh status<br></code></pre></td></tr></table></figure><h3 id="2-3-基于源码"><a href="#2-3-基于源码" class="headerlink" title="2.3 基于源码"></a>2.3 基于源码</h3><p>（1）下载源码</p><p><a href="https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.7.1/apache-zookeeper-3.7.1.tar.gz">https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.7.1/apache-zookeeper-3.7.1.tar.gz</a></p><p>（2）maven构建 打开源码文件的跟目录，执行如下命令</p><blockquote><p>mvn clean install ‐DskipTests</p></blockquote><p>（3）导入到idea中</p><p>（4）配置日志输出</p><p>a-将conf文件下的log.properties文件复制到zookeeper-server的resources文件夹下 </p><p>b-在zookeeper-server的pom文件中添加slf4j的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>&lt;/dependency<br></code></pre></td></tr></table></figure><p>（5）复制4个zoo文件</p><blockquote><p>zoo-01.cfg</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">tickTime</span>=<span class="hljs-string">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-string">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">dataDir</span>=<span class="hljs-string">D:\\install\\dev\\zookeeper\\zk01\\data</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-string">2191</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-string">127.0.0.1:2881:3881</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-string">127.0.0.1:2882:3882</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-string">127.0.0.1:2883:3883</span><br><span class="hljs-attr">server.4</span>=<span class="hljs-string">127.0.0.1:2884:3884:observer</span><br></code></pre></td></tr></table></figure><blockquote><p>zoo-02.cfg</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">tickTime</span>=<span class="hljs-string">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-string">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">dataDir</span>=<span class="hljs-string">D:\\install\\dev\\zookeeper\\zk02\\data</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-string">2192</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-string">127.0.0.1:2881:3881</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-string">127.0.0.1:2882:3882</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-string">127.0.0.1:2883:3883</span><br><span class="hljs-attr">server.4</span>=<span class="hljs-string">127.0.0.1:2884:3884:observer</span><br></code></pre></td></tr></table></figure><blockquote><p>zoo-03.cfg</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">tickTime</span>=<span class="hljs-string">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-string">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">dataDir</span>=<span class="hljs-string">D:\\install\\dev\\zookeeper\\zk03\\data</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-string">2193</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-string">127.0.0.1:2881:3881</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-string">127.0.0.1:2882:3882</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-string">127.0.0.1:2883:3883</span><br><span class="hljs-attr">server.4</span>=<span class="hljs-string">127.0.0.1:2884:3884:observer</span><br></code></pre></td></tr></table></figure><blockquote><p>zoo-04.cfg</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">tickTime</span>=<span class="hljs-string">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-string">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">dataDir</span>=<span class="hljs-string">D:\\install\\dev\\zookeeper\\zk04\\data</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-string">2194</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-string">127.0.0.1:2881:3881</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-string">127.0.0.1:2882:3882</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-string">127.0.0.1:2883:3883</span><br><span class="hljs-attr">server.4</span>=<span class="hljs-string">127.0.0.1:2884:3884:observer</span><br></code></pre></td></tr></table></figure><p>（7）在各自的data目录创建myid文件，并配置上1、2、3、4 </p><p>（8）寻找启动入口类并配置</p><blockquote><p>bin/zkServer.cmd 或 bin/zkServer.sh</p><p>也就是服务端启动的时候，会通过QuorumPeerMain进行启动</p></blockquote><p>ZOOMAIN=org.apache.zookeeper.server.quorum.QuorumPeerMain</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper实现注册中心</title>
    <link href="/2023/05/17/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <url>/2023/05/17/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Zookeeper实现注册中心"><a href="#1-Zookeeper实现注册中心" class="headerlink" title="1 Zookeeper实现注册中心"></a>1 Zookeeper实现注册中心</h2><h3 id="1-1-项目准备"><a href="#1-1-项目准备" class="headerlink" title="1.1 项目准备"></a>1.1 项目准备</h3><p>创建一个父工程，名称为handwritten-zookeeper-discovery，并在父工程下创建两个Spring Boot项目，分别为order-service和user-service，并在order-service中准备一个OrderController。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/query&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">query</span><span class="hljs-params">()</span>&#123;<br>        System.out.printLn(<span class="hljs-string">&quot;query...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;query...&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-实现服务注册"><a href="#1-2-实现服务注册" class="headerlink" title="1.2 实现服务注册"></a>1.2 实现服务注册</h3><blockquote><p>以order-service项目为例，实现服务注册的功能</p></blockquote><h4 id="1-2-1-事件监听机制扩展Spring-Boot源码"><a href="#1-2-1-事件监听机制扩展Spring-Boot源码" class="headerlink" title="1.2.1 事件监听机制扩展Spring Boot源码"></a>1.2.1 事件监听机制扩展Spring Boot源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JackApplicationListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;事件监听机制的回调...&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Spring SPI: MATA-INF/spring.factories</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span>.ApplicationListener=com<span class="hljs-selector-class">.jack</span><span class="hljs-selector-class">.zkorderservice</span><span class="hljs-selector-class">.initializer</span>.JackApplicationListener<br></code></pre></td></tr></table></figure><h4 id="1-2-2-定义服务注册接口和实现类"><a href="#1-2-2-定义服务注册接口和实现类" class="headerlink" title="1.2.2 定义服务注册接口和实现类"></a>1.2.2 定义服务注册接口和实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ServiceRegistry</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZookeeperServiceRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServiceRegistry</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-3-构造函数初始化curatorFramework"><a href="#1-2-3-构造函数初始化curatorFramework" class="headerlink" title="1.2.3 构造函数初始化curatorFramework"></a>1.2.3 构造函数初始化curatorFramework</h4><p>（1）引入curator依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）构造函数初始化curator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> CuratorFramework curatorFramework;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ZookeeperServiceRegistry</span><span class="hljs-params">(String zkServer)</span>&#123;<br>    <span class="hljs-built_in">this</span>.curatorFramework = CUratorFrameworkFactory<br>        .build()<br>        .connectionTimeoutMs(<span class="hljs-number">20000</span>)<br>        .connectString(zkServer)<br>        .retryPolicy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>        .build();<br>    curatorFramework.start();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-4-配置application-properties"><a href="#1-2-4-配置application-properties" class="headerlink" title="1.2.4  配置application.properties"></a>1.2.4  配置application.properties</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">9091</span><br><span class="hljs-attr">zk.service-name</span>=<span class="hljs-string">order-service</span><br><span class="hljs-attr">zk.server</span>=<span class="hljs-string">192.168.0.8:2181</span><br><span class="hljs-attr">zk.ip</span>=<span class="hljs-string">127.0.0.1</span><br></code></pre></td></tr></table></figure><h4 id="1-2-5-完善监听器回调逻辑"><a href="#1-2-5-完善监听器回调逻辑" class="headerlink" title="1.2.5 完善监听器回调逻辑"></a>1.2.5 完善监听器回调逻辑</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JackApplicationListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span>&#123;<br>System.out.printLn(<span class="hljs-string">&quot;事件监听机制得回调。。。&quot;</span>);<br>        <span class="hljs-comment">// 获取app.properties配置属性</span><br><span class="hljs-type">Environment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> event.getApplicationContext().getEnvironment();<br><span class="hljs-type">String</span> <span class="hljs-variable">serviceName</span> <span class="hljs-operator">=</span> environment.getProperty(<span class="hljs-string">&quot;zk.service-name&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> environment.getProperty(<span class="hljs-string">&quot;zk.ip&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> environment.getProperty(<span class="hljs-string">&quot;server.port&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">zkServer</span> <span class="hljs-operator">=</span> environment.getProperty(<span class="hljs-string">&quot;zk.server&quot;</span>);<br><span class="hljs-comment">// 服务注册</span><br><span class="hljs-type">ServiceRegistry</span> <span class="hljs-variable">zookeeperServiceRegistry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZookeeperServiceRegistry</span>(zkServer);<br>zookeeperServiceRegistry.register()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-6-完善ZookeeperRegistry构造函数"><a href="#1-2-6-完善ZookeeperRegistry构造函数" class="headerlink" title="1.2.6 完善ZookeeperRegistry构造函数"></a>1.2.6 完善ZookeeperRegistry构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 服务注册</span><br><span class="hljs-type">ServiceRegistry</span> <span class="hljs-variable">zookeeperServiceRegistry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZookeeperServiceRegistry</span>(serviceName,ip,port,zkServer);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZookeeperServiceRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServiceRegistry</span>&#123;<br><span class="hljs-keyword">private</span> CuratorFramework curatorFramework;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String ip;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String port;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String serviceName;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String basePath=<span class="hljs-string">&quot;/jack-registry&quot;</span>;<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ZookeeperServiceRegistry</span><span class="hljs-params">(String serviceName, String ip, String port, String zkServer)</span> &#123;<br><span class="hljs-built_in">this</span>.serviceName=serviceName;<br><span class="hljs-built_in">this</span>.ip=ip;<br><span class="hljs-built_in">this</span>.port=port;<br><span class="hljs-built_in">this</span>.curatorFramework = CuratorFrameworkFactory<br>            .builder()<br>.connectionTimeoutMs(<span class="hljs-number">20000</span>)<br>.connectString(zkServer)<br>.retryPolicy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>.build();<br>curatorFramework.start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-7-完善ZookeeperServiceRegistry-register-方法"><a href="#1-2-7-完善ZookeeperServiceRegistry-register-方法" class="headerlink" title="1.2.7 完善ZookeeperServiceRegistry#register()方法"></a>1.2.7 完善ZookeeperServiceRegistry#register()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span> &#123;<br>String serviceNamePath=basePath+<span class="hljs-string">&quot;/&quot;</span>+serviceName;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span>(curatorFramework.checkExists().forPath(serviceNamePath)==<span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.curatorFramework.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(serviceNamePath);<br>&#125;<br><span class="hljs-type">String</span> <span class="hljs-variable">urlNode</span> <span class="hljs-operator">=</span> curatorFramework.create().withMode(CreateMode.EPHEMERAL).forPath(serviceNamePath + <span class="hljs-string">&quot;/&quot;</span> + ip +<span class="hljs-string">&quot;:&quot;</span>+ port);<br>System.out.println(<span class="hljs-string">&quot;服务 &quot;</span>+urlNode+<span class="hljs-string">&quot; 注册成功...&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-注册多个服务实例"><a href="#1-3-注册多个服务实例" class="headerlink" title="1.3 注册多个服务实例"></a>1.3 注册多个服务实例</h3><p>（1）修改application.properties文件 </p><p>（2）允许多个实例的方式进行注册 </p><p>（3）观察order-service节点下的实例</p><h3 id="1-4-手写服务发现"><a href="#1-4-手写服务发现" class="headerlink" title="1.4 手写服务发现"></a>1.4 手写服务发现</h3><h4 id="1-4-1-定义服务发现接口和实现类"><a href="#1-4-1-定义服务发现接口和实现类" class="headerlink" title="1.4.1 定义服务发现接口和实现类"></a>1.4.1 定义服务发现接口和实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ServiceDiscovery</span> &#123;<br>List&lt;String&gt; <span class="hljs-title function_">discovery</span><span class="hljs-params">(String serviceName)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">registerWatch</span><span class="hljs-params">(String serviceNamePath)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceDiscoveryImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServiceDiscovery</span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">discovery</span><span class="hljs-params">(String serviceName)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerWatch</span><span class="hljs-params">(String serviceNamePath)</span> &#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-2-定义配置信息"><a href="#1-4-2-定义配置信息" class="headerlink" title="1.4.2 定义配置信息"></a>1.4.2 定义配置信息</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">6666</span><br><span class="hljs-attr">zk.server</span>=<span class="hljs-string">192.168.0.8:2181</span><br></code></pre></td></tr></table></figure><h4 id="1-4-3-完善ServiceDiscoveryImpl构造函数"><a href="#1-4-3-完善ServiceDiscoveryImpl构造函数" class="headerlink" title="1.4.3 完善ServiceDiscoveryImpl构造函数"></a>1.4.3 完善ServiceDiscoveryImpl构造函数</h4><p>（1）引入curator依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）完善构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CuratorFramework curatorFramework;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String basePath=<span class="hljs-string">&quot;/jack-registry&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ServiceDiscoveryImpl</span><span class="hljs-params">(String zkServer)</span> &#123;<br><span class="hljs-built_in">this</span>.curatorFramework = CuratorFrameworkFactory<br>        .builder()<br>.connectionTimeoutMs(<span class="hljs-number">20000</span>)<br>.connectString(zkServer)<br>.retryPolicy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>.build();<br>curatorFramework.start();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-4-完善ServiceDiscoveryImpl-discovery方法"><a href="#1-4-4-完善ServiceDiscoveryImpl-discovery方法" class="headerlink" title="1.4.4 完善ServiceDiscoveryImpl#discovery方法"></a>1.4.4 完善ServiceDiscoveryImpl#discovery方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">discovery</span><span class="hljs-params">(String serviceName)</span> &#123;<br>String serviceNamePath=basePath + <span class="hljs-string">&quot;/&quot;</span> + serviceName;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.curatorFramework.checkExists().forPath(serviceNamePath)!=<span class="hljs-literal">null</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.curatorFramework.getChildren().forPath(serviceNamePath);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-5-将ServiceDiscoveryImpl交给Spring-IoC容器管理"><a href="#1-4-5-将ServiceDiscoveryImpl交给Spring-IoC容器管理" class="headerlink" title="1.4.5  将ServiceDiscoveryImpl交给Spring IoC容器管理"></a>1.4.5  将ServiceDiscoveryImpl交给Spring IoC容器管理</h4><p>（1）创建ZookeeperDiscoveryAutoConfiguration配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZookeeperDiscoveryAutoConfiguration</span> &#123;<br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> Environment environment;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> ServiceDiscoveryImpl <span class="hljs-title function_">serviceDiscovery</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceDiscoveryImpl</span>(environment.getProperty(<span class="hljs-string">&quot;zk.server&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）通过spring spi机制管理配置类</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">com.jack.zkuserservice.config.ZookeeperDiscoveryAutoConfiguration</span><br></code></pre></td></tr></table></figure><h4 id="1-4-6-负载均衡"><a href="#1-4-6-负载均衡" class="headerlink" title="1.4.6 负载均衡"></a>1.4.6 负载均衡</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LoadBalance</span> &#123;<br>String <span class="hljs-title function_">select</span><span class="hljs-params">(List&lt;String&gt; urls)</span>;<br>&#125;<br><br><span class="hljs-comment">//-----------</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomLoadBalance</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LoadBalance</span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">select</span><span class="hljs-params">(List&lt;String&gt; urls)</span> &#123;<br><span class="hljs-type">int</span> len=urls.size();<br>Random random=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-keyword">return</span> urls.get(random.nextInt(len));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-7-ServiceDiscoveryTest测试"><a href="#1-4-7-ServiceDiscoveryTest测试" class="headerlink" title="1.4.7  ServiceDiscoveryTest测试"></a>1.4.7  ServiceDiscoveryTest测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceDiscoveryTest</span> &#123;<br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> ServiceDiscovery serviceDiscovery;<br>    <br><span class="hljs-keyword">private</span> List&lt;String&gt; urls;<br>    <br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">discovery</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>urls = <span class="hljs-built_in">this</span>.serviceDiscovery.discovery(<span class="hljs-string">&quot;order-service&quot;</span>);<br>LoadBalance loadBalance=<span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomLoadBalance</span>();<br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> loadBalance.select(urls);<br>System.out.println(<span class="hljs-string">&quot;目标url为: &quot;</span>+url);<br><span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>().getForObject(<span class="hljs-string">&quot;http://&quot;</span> + url + <span class="hljs-string">&quot;/order/query&quot;</span>, String.class);<br>System.out.println(<span class="hljs-string">&quot;response: &quot;</span>+response);<br><span class="hljs-comment">// 添加对节点order-service的监听</span><br>    <span class="hljs-built_in">this</span>.serviceDiscovery.registerWatch(<span class="hljs-string">&quot;/jack-registry/order-service&quot;</span>,urls);<br>System.in.read();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-8-添加对节点的监听"><a href="#1-4-8-添加对节点的监听" class="headerlink" title="1.4.8 添加对节点的监听"></a>1.4.8 添加对节点的监听</h4><blockquote><p>监听order-service子节点的变化，完善ServiceDiscoveryImpl#registerWatch方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerWatch</span><span class="hljs-params">(String serviceNamePath)</span> &#123;<br><span class="hljs-comment">// 永久的监听</span><br><span class="hljs-type">CuratorCache</span> <span class="hljs-variable">curatorCache</span> <span class="hljs-operator">=</span> CuratorCache.build(curatorFramework, serviceNamePath);<br><span class="hljs-type">CuratorCacheListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> CuratorCacheListener.builder().forPathChildrenCache(serviceNamePath, curatorFramework, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathChildrenCacheListener</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">childEvent</span><span class="hljs-params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>System.out.println(<span class="hljs-string">&quot;最新的urls为: &quot;</span>+curatorFramework.getChildren().forPath(serviceNamePath));<br>&#125;<br>&#125;).build();<br>curatorCache.listenable().addListener(listener);<br>curatorCache.start();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Spring-Cloud-Zookeeper实现注册中心"><a href="#2-Spring-Cloud-Zookeeper实现注册中心" class="headerlink" title="2 Spring Cloud Zookeeper实现注册中心"></a>2 Spring Cloud Zookeeper实现注册中心</h2><p>（1）创建spring-cloud-zookeeper的spring boot项目，Spring Boot版本为2.7.2</p><p>（2）定义Spring Cloud的版本管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--定义版本的管理--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-comment">&lt;!--定义sc的版本--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（3）引入spring cloud zookeeper注册中心的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- spring cloud zookeeper discovery 注册中心--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（4）写注册中心相关的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">zookeeper:</span><br>      <span class="hljs-attr">connect-string:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.8</span><span class="hljs-string">:2181</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">root:</span> <span class="hljs-string">/services/registries</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">spring-cloud-zookeeper</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9091</span><br></code></pre></td></tr></table></figure><p>（5）启动Spring Boot项目，观察Zookeeper Server上的数据</p><p>（6）服务发现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;<br><span class="hljs-meta">@RequestMapping(&quot;/sc-zk-discovery&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;ServiceInstance&gt; <span class="hljs-title function_">serviceUrl</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> discoveryClient.getInstances(<span class="hljs-string">&quot;spring-cloud-zookeeper&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>（7）服务注册实现核心入口</p><blockquote><p>AbstractAutoServiceRegistration#onApplicationEvent</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper实现配置中心</title>
    <link href="/2023/05/16/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <url>/2023/05/16/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h2 id="1-本地配置原理"><a href="#1-本地配置原理" class="headerlink" title="1 本地配置原理"></a>1 本地配置原理</h2><p><a href="https://docs.spring.io/spring-boot/docs/2.7.2/reference/htmlsingle/#features.external-config">https://docs.spring.io/spring-boot/docs/2.7.2/reference/htmlsingle/#features.external-config</a></p><p>（1）加载application.properties文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">PropertySourceLoader#load()<br>-&gt;PropertiesPropertySourceLoader#load()<br>-&gt;OriginTrackedMapPropertySource<br></code></pre></td></tr></table></figure><p>（2）查看Environment的属性配置源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">SpringApplication#run()<br>-&gt;debug: configureIgnoreBeanInfo(environment)<br></code></pre></td></tr></table></figure><p>（3）比如在Program arguments中配置hello=hi，environment中的 SimpleCommandLinePropertySource</p><p>（4）@Value实现原理</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs livescript">（<span class="hljs-number">1</span>）使用BeanPostProcessor解析类上的@Value字段<br>（<span class="hljs-number">2</span>）获取到字段上的@Value字段<br>（<span class="hljs-number">3</span>）解析@Value字段的value属性值，比如age<br>（<span class="hljs-number">4</span>）从environment中的属性配置源OriginTrackedMapPropertySource中寻找age的key<br>（<span class="hljs-number">5</span>）根据key获取到对应的value值<br>（<span class="hljs-number">6</span>）通过field反射的方式设置value值<br><br>源码：<br>AutowiredAnnotationBeanPostProcessor<span class="hljs-comment">#inject()</span><br>-&gt;resolveFieldValue(field, bean, beanName)   <span class="hljs-comment">#设置条件:</span><br>beanName.equals<span class="hljs-function"><span class="hljs-params">(<span class="hljs-string">&quot;orderController&quot;</span>)</span></span><br><span class="hljs-function">-&gt;</span>AutowiredAnnotationBeanPostProcessor.this.beanFactory.resolveDependency(<br>-&gt;DefaultListableBeanFactory<span class="hljs-comment">#resolveDependency</span><br>-&gt;this.doResolveDependency(descriptor...)<br><span class="hljs-comment"># 获取到@Value属性上的value，比如age</span><br>-&gt;<span class="hljs-built_in">Object</span> value = getAutowireCandidateResolver().getSuggestedValue(descriptor) <br><span class="hljs-comment"># 根据age从env中寻找与之对应的值</span><br>-&gt; <span class="hljs-built_in">String</span> strVal = resolveEmbeddedValue((<span class="hljs-built_in">String</span>) value)<br><span class="hljs-comment">#AutowiredAnnotationBeanPostProcessor#inject最后一段逻辑 通过反射给目标字段赋值</span><br>-&gt; field<span class="hljs-comment">#set(bean,value) </span><br></code></pre></td></tr></table></figure><h2 id="2-spring生态中的扩展机制"><a href="#2-spring生态中的扩展机制" class="headerlink" title="2 spring生态中的扩展机制"></a>2 spring生态中的扩展机制</h2><h3 id="2-1-常见扩展机制"><a href="#2-1-常见扩展机制" class="headerlink" title="2.1  常见扩展机制"></a>2.1  常见扩展机制</h3><blockquote><p>所谓的扩展机制就是不修改Spring生态源码，也能够把一些想要的代码放到启动流程中</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">ApplicationContextInitializer<br>事件监听机制<br><span class="hljs-keyword">BeanPostProcessor</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">BeanFactoryPostProcessor</span><br><span class="hljs-keyword"></span>ApplicationRunner<br>...<br></code></pre></td></tr></table></figure><h3 id="2-2-举例使用ApplicationContextInitializer"><a href="#2-2-举例使用ApplicationContextInitializer" class="headerlink" title="2.2 举例使用ApplicationContextInitializer"></a>2.2 举例使用ApplicationContextInitializer</h3><p>（1）自定义ApplicationContextInitializer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZkConfigApplicationContextInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextInitializer</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> &#123;<br>            <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>resources/META-INF/spring.factories</p><p>SPI:读取所有spring.factories文件中的ApplicationContextInitializer类型，并实例化存放到list集合中</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span>.ApplicationContextInitializer=\com<span class="hljs-selector-class">.jack</span><span class="hljs-selector-class">.handwrittenzookeeperconfig</span><span class="hljs-selector-class">.initializer</span>.ZkConfigApplicationContextInitializer<br></code></pre></td></tr></table></figure><h2 id="3-Zookeeper实现配置中心"><a href="#3-Zookeeper实现配置中心" class="headerlink" title="3 Zookeeper实现配置中心"></a>3 Zookeeper实现配置中心</h2><h3 id="3-1-启动Spring-Boot拉取zk-Server数据"><a href="#3-1-启动Spring-Boot拉取zk-Server数据" class="headerlink" title="3.1 启动Spring Boot拉取zk Server数据"></a>3.1 启动Spring Boot拉取zk Server数据</h3><h4 id="3-1-1-准备数据"><a href="#3-1-1-准备数据" class="headerlink" title="3.1.1 准备数据"></a>3.1.1 准备数据</h4><blockquote><p>/jack-config/product-service</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;product&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mobile&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3000&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="3-1-2-Curator连接ZK并获取指定节点数据"><a href="#3-1-2-Curator连接ZK并获取指定节点数据" class="headerlink" title="3.1.2  Curator连接ZK并获取指定节点数据"></a>3.1.2  Curator连接ZK并获取指定节点数据</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZkConfigApplicationContextInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextInitializer</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;我被调用了...&quot;</span>);<br>    String connectStr=<span class="hljs-string">&quot;192.168.0.8:2181&quot;</span>;<br>        <span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">curatorFramework</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory<br>.builder()<br>.connectionTimeoutMs(<span class="hljs-number">20000</span>)<br>.connectString(connectStr)<br>.retryPolicy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>.build();<br>curatorFramework.start();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">byte</span>[] bytes = curatorFramework.getData().forPath(<span class="hljs-string">&quot;/jackconfig/product-service&quot;</span>);<br><span class="hljs-comment">// String字符串的Json转成Map</span><br>Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>().readValue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes), Map.class);<br>System.out.println(<span class="hljs-string">&quot;从zookeeper server获取到的值为: &quot;</span>+map);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-将map以属性源的形式保存到env中"><a href="#3-2-将map以属性源的形式保存到env中" class="headerlink" title="3.2 将map以属性源的形式保存到env中"></a>3.2 将map以属性源的形式保存到env中</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将map转换成MapPropertySource</span><br><span class="hljs-type">MapPropertySource</span> <span class="hljs-variable">mapPropertySource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapPropertySource</span>(<span class="hljs-string">&quot;product-serviceremote-env&quot;</span>, map);<br><span class="hljs-type">ConfigurableEnvironment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> context.getEnvironment();<br>environment.getPropertySources().addFirst(mapPropertySource);<br>System.out.println(<span class="hljs-string">&quot;env新增MapPropertySource成功.&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="3-3-添加对节点-jack-config-product-service的监听"><a href="#3-3-添加对节点-jack-config-product-service的监听" class="headerlink" title="3.3  添加对节点/jack-config/product-service的监听"></a>3.3  添加对节点/jack-config/product-service的监听</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 永久的监听</span><br><span class="hljs-type">CuratorCache</span> <span class="hljs-variable">curatorCache</span> <span class="hljs-operator">=</span> CuratorCache.build(curatorFramework, <span class="hljs-string">&quot;/jack-config/product-service&quot;</span>, CuratorCache.Options.SINGLE_NODE_CACHE);<br><span class="hljs-type">CuratorCacheListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> CuratorCacheListener.builder().forAll(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CuratorCacheListener</span>() &#123;<br><span class="hljs-comment">// 一旦对应 /jack-config/product-service ZNode发生变化，就会回调这个方法</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">event</span><span class="hljs-params">(Type type, ChildData oldData, ChildData data)</span> &#123;<br><span class="hljs-keyword">if</span>(type.equals(Type.NODE_CHANGED))&#123;<br>System.out.println(<span class="hljs-string">&quot;ZNode数据更新了, 事件类型为: &quot;</span> + type);<br>&#125;<br>&#125;<br>&#125;).build();<br>curatorCache.listenable().addListener(listener);<br>curatorCache.start();<br></code></pre></td></tr></table></figure><h3 id="3-4-获取到更新后的数据并重新赋值给environment"><a href="#3-4-获取到更新后的数据并重新赋值给environment" class="headerlink" title="3.4 获取到更新后的数据并重新赋值给environment"></a>3.4 获取到更新后的数据并重新赋值给environment</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CuratorCacheListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> CuratorCacheListener.builder().forAll(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CuratorCacheListener</span>() &#123;<br><span class="hljs-comment">// 一旦对应 /jack-config/product-service ZNode发生变化，就会回调这个方法</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">event</span><span class="hljs-params">(Type type, ChildData oldData, ChildData data)</span> &#123;<br><span class="hljs-keyword">if</span>(type.equals(Type.NODE_CHANGED))&#123;<br>System.out.println(<span class="hljs-string">&quot;ZNode数据更新了, 事件类型为: &quot;</span> + type);<br><span class="hljs-keyword">try</span> &#123;<br>Map&lt;String, Object&gt; updateMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>().readValue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data.getData()), Map.class);<br>System.out.println(<span class="hljs-string">&quot;更新后的数据map为: &quot;</span>+updateMap);<br>environment.getPropertySources().replace(<span class="hljs-string">&quot;product-service-remote-env&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapPropertySource</span>(<span class="hljs-string">&quot;product-service-remote-enve&quot;</span>, updateMap));<br>&#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br>&#125;).build();<br></code></pre></td></tr></table></figure><h3 id="3-5-更新-Value字段"><a href="#3-5-更新-Value字段" class="headerlink" title="3.5 更新@Value字段"></a>3.5 更新@Value字段</h3><p>（1）FieldDetail</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FieldDetail</span> &#123;<br><span class="hljs-keyword">private</span> Field field; <span class="hljs-comment">// 具体哪个字段</span><br><span class="hljs-keyword">private</span> Object instance; <span class="hljs-comment">// 属于哪个实例</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FieldDetail</span><span class="hljs-params">(Field field, Object instance)</span> &#123;<br><span class="hljs-built_in">this</span>.field = field;<br><span class="hljs-built_in">this</span>.instance = instance;<br>&#125;<br><span class="hljs-keyword">public</span> Field <span class="hljs-title function_">getField</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> field;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setField</span><span class="hljs-params">(Field field)</span> &#123;<br><span class="hljs-built_in">this</span>.field = field;<br>&#125;<br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> instance;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setInstance</span><span class="hljs-params">(Object instance)</span> &#123;<br><span class="hljs-built_in">this</span>.instance = instance;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）定义需要保存下来类的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> JackRefreshScope &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）添加到目标类上，比如ProductController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/product&quot;)</span><br><span class="hljs-meta">@JackRefreshScope</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductController</span> &#123;<br></code></pre></td></tr></table></figure><p>（4）使用后置处理器进行逻辑判断并保存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParseJackRefreshScopeBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><span class="hljs-keyword">private</span> Map&lt;String, FieldDetail&gt; fieldDetailMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> Map&lt;String, FieldDetail&gt; <span class="hljs-title function_">getFieldDetailMap</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> fieldDetailMap;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>Class&lt;?&gt; clazz = bean.getClass();<br><span class="hljs-keyword">if</span>(clazz.isAnnotationPresent(JackRefreshScope.class))&#123;<br>System.out.println(clazz); <span class="hljs-comment">// class com.jack.controller.ProductController</span><br><span class="hljs-keyword">for</span> (Field field : clazz.getDeclaredFields()) &#123;<br><span class="hljs-keyword">if</span>(field.isAnnotationPresent(Value.class))&#123;<br><span class="hljs-type">Value</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> field.getAnnotation(Value.class);<br>String val=value.value(); <span class="hljs-comment">// 获取到了对应的value值 $&#123;id&#125; ---&gt; id</span><br>val=val.substring(<span class="hljs-number">2</span>,val.indexOf(<span class="hljs-string">&quot;&#125;&quot;</span>)); <span class="hljs-comment">// id</span><br>System.out.println(<span class="hljs-string">&quot;val: &quot;</span>+val);<br><span class="hljs-comment">// 保存 val 对应的Field和Field所在的clazz</span><br><span class="hljs-built_in">this</span>.fieldDetailMap.put(val,<span class="hljs-keyword">new</span> <span class="hljs-title class_">FieldDetail</span>(field,bean));<br>&#125;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> BeanPostProcessor.<span class="hljs-built_in">super</span>.postProcessAfterInitialization(bean,beanName);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）完善ZkConfigApplicationContextInitializer最后的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取到有哪些字段可能需要更新</span><br><span class="hljs-type">ParseJackRefreshScopeBeanPostProcessor</span> <span class="hljs-variable">parseJackRefreshScopeBeanPostProcessor</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;parseJackRefreshScopeBeanPostProcessor&quot;</span>, ParseJackRefreshScopeBeanPostProcessor.class);<br>Map&lt;String, FieldDetail&gt; fieldDetailMap = parseJackRefreshScopeBeanPostProcessor.getFieldDetailMap();<br><span class="hljs-keyword">for</span> (String key : fieldDetailMap.keySet()) &#123;<br><span class="hljs-keyword">if</span>(updateMap.containsKey(key))&#123; <span class="hljs-comment">// 判断远端发送过来的map数据中的key</span><br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> environment.getProperty(key);<br><span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> fieldDetailMap.get(key).getField();<br>field.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 反射更新字段的值</span><br>field.set(fieldDetailMap.get(key).getInstance(),value);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper-API</title>
    <link href="/2023/05/16/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper-API/"/>
    <url>/2023/05/16/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper-API/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Zookeeper-API"><a href="#1-Zookeeper-API" class="headerlink" title="1 Zookeeper API"></a>1 Zookeeper API</h2><h3 id="1-1-引入Zookeeper依赖"><a href="#1-1-引入Zookeeper依赖" class="headerlink" title="1.1 引入Zookeeper依赖"></a>1.1 引入Zookeeper依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-2-日志输出"><a href="#1-2-日志输出" class="headerlink" title="1.2 日志输出"></a>1.2 日志输出</h3><p>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）定义log4j.properties文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">###set log levels###</span><br><span class="hljs-attr">log4j.rootLogger</span>=<span class="hljs-string">info, stdout</span><br><span class="hljs-comment">###output to the console###</span><br><span class="hljs-attr">log4j.appender.stdout</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-attr">log4j.appender.stdout.Target</span>=<span class="hljs-string">System.out</span><br><span class="hljs-attr">log4j.appender.stdout.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-attr">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="hljs-string">[%d&#123;dd/MM/yy HH:mm:ss:SSS z&#125;] %t%5p %c&#123;2&#125;: %m%n</span><br></code></pre></td></tr></table></figure><h3 id="1-3-连接服务端"><a href="#1-3-连接服务端" class="headerlink" title="1.3  连接服务端"></a>1.3  连接服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZkConnUtil</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ZooKeeper zookeeper;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 获得zkConn</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ZooKeeper <span class="hljs-title function_">getZkConn</span><span class="hljs-params">(String zkServer)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>zookeeper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(zkServer, <span class="hljs-number">30000</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent event)</span> &#123;<br>Event.<span class="hljs-type">KeeperState</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> event.getState();<br><span class="hljs-keyword">if</span> (Event.KeeperState.SyncConnected == state) &#123;<br>System.out.println(<span class="hljs-string">&quot;连接zkServer成功.&quot;</span>);<br>countDownLatch.countDown();<br>&#125;<br>&#125;<br>&#125;);<br>countDownLatch.await();<br><span class="hljs-keyword">return</span> zookeeper;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">ZooKeeper</span> <span class="hljs-variable">zooKeeper</span> <span class="hljs-operator">=</span> getZkConn(<span class="hljs-string">&quot;192.168.0.8:2181&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-创建ZNode"><a href="#1-4-创建ZNode" class="headerlink" title="1.4 创建ZNode"></a>1.4 创建ZNode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateZNode</span> &#123;<br><span class="hljs-keyword">private</span> ZooKeeper zooKeeper;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CreateZNode</span><span class="hljs-params">(ZooKeeper zooKeeper)</span> &#123;<br><span class="hljs-built_in">this</span>.zooKeeper = zooKeeper;<br>&#125;<br><span class="hljs-comment">// 同步创建节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createZNodeWithSync</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">znode</span> <span class="hljs-operator">=</span> zooKeeper.create(<span class="hljs-string">&quot;/zookeeper-api-sync&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br>System.out.println(<span class="hljs-string">&quot;创建节点成功: &quot;</span>+znode);<br>&#125;<br><span class="hljs-comment">// 异步创建节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createZNodeWithAsync</span><span class="hljs-params">()</span>&#123;<br>zooKeeper.create(<span class="hljs-string">&quot;/zookeeper-api-async&quot;</span>,<span class="hljs-string">&quot;111&quot;</span>.getBytes(),ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncCallback</span>.StringCallback()&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processResult</span><span class="hljs-params">(<span class="hljs-type">int</span> rc, String path, Object ctx, String name)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;rc: &quot;</span>+rc);<br>System.out.println(<span class="hljs-string">&quot;path: &quot;</span>+path);<br>System.out.println(<span class="hljs-string">&quot;ctx: &quot;</span>+ctx);<br>System.out.println(<span class="hljs-string">&quot;name: &quot;</span>+name);<br>&#125;<br>&#125;,<span class="hljs-string">&quot;create-asyn&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">CreateZNode</span> <span class="hljs-variable">createZNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreateZNode</span>(ZkConnUtil.getZkConn(<span class="hljs-string">&quot;192.168.0.8:2181&quot;</span>));<br><span class="hljs-comment">// createZNode.createZNodeWithSync();</span><br>createZNode.createZNodeWithAsync();<br>System.in.read();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-5-查询ZNode数据并设置监听"><a href="#1-5-查询ZNode数据并设置监听" class="headerlink" title="1.5 查询ZNode数据并设置监听"></a>1.5 查询ZNode数据并设置监听</h3><blockquote><p>watch是一次性的，不是永久的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetZNodeData</span> &#123;<br><span class="hljs-keyword">private</span> ZooKeeper zooKeeper;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">GetZNodeData</span><span class="hljs-params">(ZooKeeper zooKeeper)</span> &#123;<br><span class="hljs-built_in">this</span>.zooKeeper = zooKeeper;<br>&#125;<br><span class="hljs-comment">// 同步获取数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDataSync</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">Stat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stat</span>();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">byte</span>[] data = zooKeeper.getData(<span class="hljs-string">&quot;/zookeeper-api-sync&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>()&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent event)</span> &#123;<br><span class="hljs-comment">// 一旦节点发生变化，则会回调该方法</span><br>System.out.println(<span class="hljs-string">&quot;event: &quot;</span>+event);<br>&#125;<br>&#125;, stat);<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data);<br>System.out.println(<span class="hljs-string">&quot;data: &quot;</span>+s);<br>System.out.println(<span class="hljs-string">&quot;stat: &quot;</span>+stat);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><span class="hljs-comment">// 异步获取数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDataAsync</span><span class="hljs-params">()</span>&#123;<br>zooKeeper.getData(<span class="hljs-string">&quot;/zookeeper-api-async&quot;</span>,<span class="hljs-literal">false</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncCallback</span>.DataCallback() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processResult</span><span class="hljs-params">(<span class="hljs-type">int</span> rc, String path, Object ctx, <span class="hljs-type">byte</span>[] data, Stat stat)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;rc: &quot;</span>+rc);<br>System.out.println(<span class="hljs-string">&quot;path: &quot;</span>+path);<br>System.out.println(<span class="hljs-string">&quot;ctx: &quot;</span>+ctx);<br>System.out.println(<span class="hljs-string">&quot;data: &quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data));<br>System.out.println(<span class="hljs-string">&quot;stat: &quot;</span>+stat);<br>&#125;<br>&#125;,<span class="hljs-string">&quot;get-data-async&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">GetZNodeData</span> <span class="hljs-variable">getZNodeData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GetZNodeData</span>(ZkConnUtil.getZkConn(<span class="hljs-string">&quot;192.168.0.8:2181&quot;</span>));<br>getZNodeData.getDataSync();<br>getZNodeData.getDataAsync();<br>System.in.read();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-6-修改ZNode数据"><a href="#1-6-修改ZNode数据" class="headerlink" title="1.6 修改ZNode数据"></a>1.6 修改ZNode数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateZNodeData</span> &#123;<br><span class="hljs-keyword">private</span> ZooKeeper zooKeeper;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">UpdateZNodeData</span><span class="hljs-params">(ZooKeeper zooKeeper)</span> &#123;<br><span class="hljs-built_in">this</span>.zooKeeper = zooKeeper;<br>&#125;<br><span class="hljs-comment">// 同步修改节点数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDataSync</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">// 版本号为-1，表示可以直接修改，不用关心版本号</span><br>zooKeeper.setData(<span class="hljs-string">&quot;/zookeeper-api-sync&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>.getBytes(), -<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// 异步修改节点数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDataAsync</span><span class="hljs-params">()</span>&#123;<br>zooKeeper.setData(<span class="hljs-string">&quot;/zookeeper-api-async&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>.getBytes(), -<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncCallback</span>.StatCallback() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processResult</span><span class="hljs-params">(<span class="hljs-type">int</span> rc, String path, Object ctx, Stat stat)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;rc: &quot;</span>+rc);<br>System.out.println(<span class="hljs-string">&quot;path: &quot;</span>+path);<br>System.out.println(<span class="hljs-string">&quot;ctx: &quot;</span>+ctx);<br>System.out.println(<span class="hljs-string">&quot;stat: &quot;</span>+stat);<br>&#125;<br>&#125;,<span class="hljs-string">&quot;set-data-async&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 根据版本修改同步节点数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDataSyncWithVersion</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">Stat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stat</span>();<br>zooKeeper.getData(<span class="hljs-string">&quot;/zookeeper-api-sync&quot;</span>, <span class="hljs-literal">false</span>, stat);<br>zooKeeper.setData(<span class="hljs-string">&quot;/zookeeper-api-sync&quot;</span>, <span class="hljs-string">&quot;555&quot;</span>.getBytes(),<br>stat.getVersion());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">UpdateZNodeData</span> <span class="hljs-variable">updateZNodeData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateZNodeData</span>(ZkConnUtil.getZkConn(<span class="hljs-string">&quot;192.168.0.8:2181&quot;</span>));<br><span class="hljs-comment">// updateZNodeData.setDataSync();</span><br><span class="hljs-comment">// updateZNodeData.setDataAsync();</span><br>updateZNodeData.setDataSyncWithVersion();<br>System.in.read();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-7-删除ZNode"><a href="#1-7-删除ZNode" class="headerlink" title="1.7 删除ZNode"></a>1.7 删除ZNode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeleteZNode</span> &#123;<br><span class="hljs-keyword">private</span> ZooKeeper zooKeeper;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DeleteZNode</span><span class="hljs-params">(ZooKeeper zooKeeper)</span> &#123;<br><span class="hljs-built_in">this</span>.zooKeeper = zooKeeper;<br>&#125;<br><span class="hljs-comment">// 同步删除节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteZNodeSync</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>zooKeeper.delete(<span class="hljs-string">&quot;/zookeeper-api-sync&quot;</span>,-<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// 异步删除节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteZNodeAsync</span><span class="hljs-params">()</span>&#123;<br>zooKeeper.delete(<span class="hljs-string">&quot;/zookeeper-api-async&quot;</span>, -<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncCallback</span>.VoidCallback() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processResult</span><span class="hljs-params">(<span class="hljs-type">int</span> rc, String path, Object ctx)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;rc: &quot;</span>+rc);<br>System.out.println(<span class="hljs-string">&quot;path: &quot;</span>+path);<br>System.out.println(<span class="hljs-string">&quot;ctx: &quot;</span>+ctx);<br>&#125;<br>&#125;,<span class="hljs-string">&quot;delete-znode-async&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DeleteZNode</span> <span class="hljs-variable">deleteZNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeleteZNode</span>(ZkConnUtil.getZkConn(<span class="hljs-string">&quot;192.168.0.8:2181&quot;</span>));<br>deleteZNode.deleteZNodeAsync();<br>deleteZNode.deleteZNodeSync();<br>System.in.read();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Apache-Curator"><a href="#2-Apache-Curator" class="headerlink" title="2  Apache Curator"></a>2  Apache Curator</h2><p>官网：<a href="https://curator.apache.org/">https://curator.apache.org/</a></p><p>最初是由Netflix团队开发的，后来捐献给了Apache，目前是Apache的顶级项目。Curator是对Zookeeper客户端的封装，主要目的就是简化Zookeeper客户端的使用，不需要自己手动处理ConnectionLossException、NodeExistsException等异常，提供了连接重连以及watch永久注册等解决方案。</p><h3 id="2-1-引入依赖"><a href="#2-1-引入依赖" class="headerlink" title="2.1 引入依赖"></a>2.1 引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-Curator对节点的增删改查"><a href="#2-2-Curator对节点的增删改查" class="headerlink" title="2.2 Curator对节点的增删改查"></a>2.2 Curator对节点的增删改查</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CuratorApi</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">connectStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.0.8:2181&quot;</span>;<br><span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">curatorFramework</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory <span class="hljs-comment">// fluent</span><br>.builder()<br>.connectionTimeoutMs(<span class="hljs-number">20000</span>)<br>.connectString(connectStr)<br>.retryPolicy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">// 设置客户端的重试策略，每隔10秒中重试一次，最多3次</span><br>.build();<br>curatorFramework.start();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 创建节点 curator-api</span><br><span class="hljs-type">String</span> <span class="hljs-variable">znode</span> <span class="hljs-operator">=</span> curatorFramework<br>.create()<br>.withMode(CreateMode.PERSISTENT)<br>.forPath(<span class="hljs-string">&quot;/curator-api&quot;</span>, <span class="hljs-string">&quot;666&quot;</span>.getBytes());<br>System.out.println(<span class="hljs-string">&quot;创建节点成功: &quot;</span> + znode);<br><span class="hljs-comment">// 查询节点 curator-api 数据</span><br><span class="hljs-type">byte</span>[] bytes = curatorFramework.getData().forPath(znode);<br>System.out.println(<span class="hljs-string">&quot;节点curator-api 数据查询成功: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br><span class="hljs-comment">// 修改节点 curator-api 数据</span><br>curatorFramework.setData().forPath(znode, <span class="hljs-string">&quot;888&quot;</span>.getBytes());<br>System.out.println(<span class="hljs-string">&quot;节点curator-api 数据修改成功.&quot;</span>);<br><span class="hljs-comment">// 删除节点 curator-api</span><br>curatorFramework.delete().forPath(znode);<br>System.out.println(<span class="hljs-string">&quot;节点curator-api 已被删除.&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-Curator设置监听"><a href="#2-3-Curator设置监听" class="headerlink" title="2.3 Curator设置监听"></a>2.3 Curator设置监听</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CuratorWatch</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>curatorWatchPersistent();<br>&#125;<br><span class="hljs-comment">// 一次性监听</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">curatorWatchOnce</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">connectStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.0.8:2181&quot;</span>;<br><span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">curatorFramework</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory<br>.builder()<br>.connectionTimeoutMs(<span class="hljs-number">20000</span>)<br>.connectString(connectStr)<br>.retryPolicy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>.build();<br>curatorFramework.start();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 创建节点 curator-watch-once</span><br><span class="hljs-type">String</span> <span class="hljs-variable">znode</span> <span class="hljs-operator">=</span> curatorFramework.create().withMode(CreateMode.PERSISTENT).forPath(<span class="hljs-string">&quot;/curatorwatch-once&quot;</span>, <span class="hljs-string">&quot;&quot;</span>.getBytes());<br>System.out.println(<span class="hljs-string">&quot;节点创建成功: &quot;</span> + znode);<br><span class="hljs-comment">// 给节点 curator-watch-once 添加一次性watch</span><br>curatorFramework.getData().usingWatcher(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CuratorWatcher</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent event)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>System.out.println(<span class="hljs-string">&quot;节点发生变化: &quot;</span> + event);<br>&#125;<br>&#125;).forPath(znode);<br>System.out.println(<span class="hljs-string">&quot;给节点curator-watch-once 添加watch成功.&quot;</span>);<br><span class="hljs-comment">// 让当前进程不结束</span><br>System.in.read();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><span class="hljs-comment">// 永久监听</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">curatorWatchPersistent</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">connectStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.0.8:2181&quot;</span>;<br><span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">curatorFramework</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory<br>.builder()<br>.connectionTimeoutMs(<span class="hljs-number">20000</span>)<br>.connectString(connectStr)<br>.retryPolicy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>.build();<br>curatorFramework.start();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 创建节点 curator-watch-persistent</span><br><span class="hljs-type">String</span> <span class="hljs-variable">znode</span> <span class="hljs-operator">=</span> curatorFramework.create().forPath(<span class="hljs-string">&quot;/curator-watchpersistent&quot;</span>, <span class="hljs-string">&quot;&quot;</span>.getBytes());<br>System.out.println(<span class="hljs-string">&quot;节点创建成功: &quot;</span> + znode);<br><span class="hljs-comment">// 永久的监听</span><br><span class="hljs-type">CuratorCache</span> <span class="hljs-variable">curatorCache</span> <span class="hljs-operator">=</span> CuratorCache.build(curatorFramework,znode, CuratorCache.Options.SINGLE_NODE_CACHE);<br><span class="hljs-type">CuratorCacheListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> CuratorCacheListener.builder().forAll(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CuratorCacheListener</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">event</span><span class="hljs-params">(Type type, ChildData oldData, ChildData data)</span>&#123;<br><span class="hljs-comment">// 等同于Watch#process回调</span><br>System.out.println(<span class="hljs-string">&quot;节点 &quot;</span>+data.getPath()+<span class="hljs-string">&quot; 发生改变, 事件类型为: &quot;</span> + type);<br>&#125;<br>&#125;).build();<br>curatorCache.listenable().addListener(listener);<br>curatorCache.start();<br>System.out.println(<span class="hljs-string">&quot;给节点curator-watch-persistent 添加watch成功.&quot;</span>);<br><span class="hljs-comment">// 让当前进程不结束</span><br>System.in.read();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper高级特性</title>
    <link href="/2023/05/16/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <url>/2023/05/16/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Watch"><a href="#1-Watch" class="headerlink" title="1 Watch"></a>1 Watch</h2><p><a href="https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#ch_zkWatches">https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#ch_zkWatches</a></p><p>图解：</p><p><img src="/image/zookeeper/4.png"></p><p>支持watch的命令</p><blockquote><p>watch的注册基本上都是读事件</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">help</span><br>config [-c] [-w] [-s]<br>get [-s] [-w] path<br><span class="hljs-built_in">ls</span> [-s] [-w] [-R] path<br><span class="hljs-built_in">stat</span> [-w] path<br></code></pre></td></tr></table></figure><h3 id="1-1-watch体验"><a href="#1-1-watch体验" class="headerlink" title="1.1 watch体验"></a>1.1 watch体验</h3><blockquote><p>分类： </p><p>get stat 监听节点数据的变化 </p><p>ls (-R) 针对(子)节点的变化</p></blockquote><h4 id="1-1-1-监听节点数据变化"><a href="#1-1-1-监听节点数据变化" class="headerlink" title="1.1.1 监听节点数据变化"></a>1.1.1 监听节点数据变化</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建节点并添加监听</span><br>create /zk-watch 111<br>get -w /zk-watch<br><span class="hljs-comment"># 来到另外一个客户端</span><br><span class="hljs-built_in">set</span> /zk-watch 222<br><br><span class="hljs-comment"># 观察第一个zkClient的变化，发现收到通知</span><br><span class="hljs-comment">#WATCHER::</span><br><span class="hljs-comment">#WatchedEvent state:SyncConnected type:NodeDataChanged path:/zk-watch</span><br><br><span class="hljs-comment"># 收到watch通知之后，就可以进行对应的业务逻辑处理。但如果再修改/zk-watch的值，发现就不会收到watch通知了，因为该命令下的watch通知是一次性的，要想再收到，得继续添加watch监听</span><br>get -w /zk-watch<br></code></pre></td></tr></table></figure><h4 id="1-1-2-监听-子-节点的创建和删除"><a href="#1-1-2-监听-子-节点的创建和删除" class="headerlink" title="1.1.2 监听(子)节点的创建和删除"></a>1.1.2 监听(子)节点的创建和删除</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建子节点并对父节点添加watch</span><br>create /zk-watch/sub1<br>get -w /zk-watch<br><span class="hljs-comment"># 修改/zk-watch/sub1节点的数据值，发现watch并没有生效，因为get只监听单个节点</span><br><span class="hljs-built_in">set</span> /zk-watch/sub1 111<br><span class="hljs-comment"># 通过ls添加对(子)节点的增加和删除监听</span><br><span class="hljs-built_in">ls</span> -w /zk-watch<br>create /zk-watch/sub2 111<br><span class="hljs-comment"># 继续添加zk-watch节点的子节点，发现并没有收到通知，因为ls也是一次性的</span><br>create /zk-watch/sub3 111<br></code></pre></td></tr></table></figure><h4 id="1-1-3-永久监听"><a href="#1-1-3-永久监听" class="headerlink" title="1.1.3 永久监听"></a>1.1.3 永久监听</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">create /zk-watch-update 666<br>addWatch /zk-watch-update<br><span class="hljs-built_in">set</span> /zk-watch-update 999<br><span class="hljs-built_in">set</span> /zk-watch-update 888<br>create /zk-watch-update/sub1<br>create /zk-watch-update/sub2<br>delete /zk-watch-update/sub1<br><span class="hljs-built_in">set</span> /zk-watch-update/sub2 222<br>create /zk-watch-update/sub2/sub1 111<br>delete /zk-watch-update/sub2/sub1<br>delete /zk-watch-update/sub2<br>delete /zk-watch-update<br></code></pre></td></tr></table></figure><h2 id="2-Monitoring-监控"><a href="#2-Monitoring-监控" class="headerlink" title="2  Monitoring-监控"></a>2  Monitoring-监控</h2><h3 id="2-1-The-Four-Letter-Words"><a href="#2-1-The-Four-Letter-Words" class="headerlink" title="2.1 The Four Letter Words"></a>2.1 The Four Letter Words</h3><p><a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_4lw">https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_4lw</a></p><p>ZooKeeper响应一小组命令。每个命令由四个字母组成。您可以通过客户端端口的 telnet 或 nc 向 ZooKeeper 发出命令。说白了就是由4个字母组成的命令，可以通过telnet或ncat使用客户端向zkServere发出命令。</p><ol><li>修改zoo.cfg文件</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">（1）打开zoo.cfg文件</span><br><span class="hljs-attr">（2）添加一行配置</span>:<span class="hljs-string"></span><br><span class="hljs-attr">4lw.commands.whitelist</span>=<span class="hljs-string">*</span><br><span class="hljs-attr">echo</span> <span class="hljs-string">&quot;4lw.commands.whitelist=*&quot; &gt;&gt; zoo.cfg</span><br><span class="hljs-attr">（3）重启zk服务</span><br><span class="hljs-attr">zkServer.sh</span> <span class="hljs-string">restart</span><br></code></pre></td></tr></table></figure><ol start="2"><li>体验一下</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh">（1）安装ncat: yum install -y nc<br>（2）查看节点是否正常<br><span class="hljs-built_in">echo</span> ruok | ncat localhost 2181<br>（3）查看节点相关配置<br><span class="hljs-built_in">echo</span> conf | ncat localhost 2181<br>（4）查看节点更详细的状态<br><span class="hljs-built_in">echo</span> <span class="hljs-built_in">stat</span> | ncat localhost 2181<br>（5）查看节点更详细的状态<br><span class="hljs-built_in">echo</span> srvr | ncat localhost 2181<br>（6）查看临时节点<br><span class="hljs-built_in">echo</span> dump| ncat localhost 2181<br>（7）查看watch<br>get -w /zk-watch<br><span class="hljs-built_in">echo</span> wchc| ncat localhost 2181<br>（8）查看server的<span class="hljs-built_in">env</span><br><span class="hljs-built_in">echo</span> envi| ncat localhost 2181<br></code></pre></td></tr></table></figure><h3 id="2-2-AdminServer"><a href="#2-2-AdminServer" class="headerlink" title="2.2 AdminServer"></a>2.2 AdminServer</h3><p><a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_adminserver">https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_adminserver</a></p><p><strong>3.5.0 中的新功能：</strong>管理服务器是一个嵌入式 Jetty 服务器，为四个字母的单词命令提供 HTTP 接口。默认情况下，服务器在端口 8080 上启动，并通过转到 URL “/command/[命令名称]”（例如 <a href="http://localhost:8080/commands/stat%EF%BC%89%E5%8F%91%E5%87%BA%E5%91%BD%E4%BB%A4%E3%80%82%E5%91%BD%E4%BB%A4%E5%93%8D%E5%BA%94%E4%BB%A5">http://localhost:8080/commands/stat）发出命令。命令响应以</a> JSON 形式返回。与原始协议不同，命令不限于四个字母的名称，命令可以有多个名称;例如，“STMK”也可以称为“set_trace_mask”。要查看所有可用命令的列表，请将浏览器指向 URL /command（例如，<a href="http://localhost:8080/commands%EF%BC%89">http://localhost:8080/commands）</a></p><h3 id="2-3-JMX-Java-Management-Extensions"><a href="#2-3-JMX-Java-Management-Extensions" class="headerlink" title="2.3 JMX(Java Management Extensions)"></a>2.3 JMX(Java Management Extensions)</h3><p>（1）zkServer.sh中配置JMX</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">ZOOMAIN=<span class="hljs-string">&quot;-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8888</span><br><span class="hljs-string">-Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false</span><br><span class="hljs-string">-Djava.rmi.server.hostname=192.168.0.8</span><br><span class="hljs-string">-Dcom.sun.management.jmxremote.local.only=false</span><br><span class="hljs-string">org.apache.zookeeper.server.quorum.QuorumPeerMain&quot;</span><br></code></pre></td></tr></table></figure><p>（2）重启zkServer</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">zkServer.sh restart<br></code></pre></td></tr></table></figure><p>（3）查看8888端口监听</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">lsof -i:8888 <br></code></pre></td></tr></table></figure><p>（4）打开本地jconsole，连接指定JMX的ip和port：192.168.0.8:8888</p><p><img src="/image/zookeeper/5.png"></p><h2 id="3-ACL-权限"><a href="#3-ACL-权限" class="headerlink" title="3 ACL-权限"></a>3 ACL-权限</h2><p><a href="https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#sc_ZooKeeperAccessControl">https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#sc_ZooKeeperAccessControl</a></p><h3 id="3-1-ACL的组成"><a href="#3-1-ACL的组成" class="headerlink" title="3.1 ACL的组成"></a>3.1 ACL的组成</h3><p>scheme : id : permission </p><ol><li><strong>scheme：表示策略</strong> </li></ol><p>（1）world 该scheme只有一个id，为anyone，表示所有人，格式为 world:anyone:permission </p><p>（2）auth 该scheme表示需要认证登录，也就是对应注册的用户需拥有权限才可以访问，格式为 auth:user:password:permission </p><p>（3）digest 该scheme表示需要密码加密才能访问，格式为 digest:username:BASE64(password):permission</p><p>（4）ip 该scheme表示指定的ip才能访问，格式为 ip:localhost:permission </p><p>（5）super 该scheme表示超管，拥有所有权限</p><ol start="2"><li><p><strong>id：表示允许访问的用户</strong> </p></li><li><p><strong>permission：表示访问的权限</strong></p></li></ol><p>（1）CREATE: you can create a child node </p><p>（2）READ: you can get data from a node and list its children. </p><p>（3）WRITE: you can set data for a node </p><p>（4）DELETE: you can delete a child node </p><p>（5）ADMIN: you can set permissions</p><h3 id="3-2-ACL体验"><a href="#3-2-ACL体验" class="headerlink" title="3.2 ACL体验"></a>3.2 ACL体验</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建节点并查看权限</span><br>create /zk-acl 111<br>getAcl /zk-acl<br><span class="hljs-comment"># 设置某个用户对某个节点的权限</span><br>create /zk-jack 666<br>setAcl /zk-jack auth:jack:123:cdrwa<br><span class="hljs-comment"># 表示该用户还没有在zk中注册，注册一下</span><br>addauth digest jack:123<br>setAcl /zk-jack auth:jack:123:cdrwa<br>getAcl /zk-jack<br><span class="hljs-comment"># 这样一来，对于/zk-jack节点的操作，就需要先登录一下，打开另外一个客户端，执行如下命令，提示:Insufficient permission : /zk-jack</span><br><span class="hljs-built_in">ls</span> /zk-jack<br>get /zk-jack<br><span class="hljs-comment"># 授权</span><br>addauth digest jack:123<br>get /zk-jack<br></code></pre></td></tr></table></figure><h2 id="4-序列化与反序列化"><a href="#4-序列化与反序列化" class="headerlink" title="4 序列化与反序列化"></a>4 序列化与反序列化</h2><p>常见的序列化方式：json、protobuf、thrif、avro等。Zookeeper使用的序列化方式是jute，Java类需要实现Record接口，底层使用的是DataOutput和 DataInput。</p><p>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）定义Java类并测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Record</span>&#123;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(OutputArchive archive, String tag)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        archive.startRecord(<span class="hljs-built_in">this</span>, tag);<br>        archive.writeString(username, <span class="hljs-string">&quot;username&quot;</span>);<br>        archive.writeInt(age, <span class="hljs-string">&quot;age&quot;</span>);<br>        archive.endRecord(<span class="hljs-built_in">this</span>, tag);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(InputArchive archive, String tag)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        archive.startRecord(tag);<br>        username = archive.readString(<span class="hljs-string">&quot;username&quot;</span>);<br>        age = archive.readInt(<span class="hljs-string">&quot;age&quot;</span>);<br>        archive.endRecord(tag);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//序列化</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">BinaryOutputArchive</span> <span class="hljs-variable">binaryOutputArchive</span> <span class="hljs-operator">=</span> BinaryOutputArchive.getArchive(byteArrayOutputStream);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">16</span>).serialize(binaryOutputArchive, <span class="hljs-string">&quot;person&quot;</span>);<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(byteArrayOutputStream.toByteArray());<br>        <span class="hljs-comment">// 反序列化</span><br><span class="hljs-type">ByteBufferInputStream</span> <span class="hljs-variable">byteBufferInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteBufferInputStream</span>(byteBuffer);<br><span class="hljs-type">BinaryInputArchive</span> <span class="hljs-variable">binaryInputArchive</span> <span class="hljs-operator">=</span> BinaryInputArchive.getArchive(byteBufferInputStream);<br><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person.deserialize(binaryInputArchive, <span class="hljs-string">&quot;person&quot;</span>);<br>System.out.println(person.toString());<br><span class="hljs-comment">// 关闭资源</span><br>byteArrayOutputStream.close();<br>byteBufferInputStream.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-快照数据与事务日志"><a href="#5-快照数据与事务日志" class="headerlink" title="5 快照数据与事务日志"></a>5 快照数据与事务日志</h2><p>快照数据：记录所有ZNode节点及数据某一时刻的快照，保存在zoo.cfg文件配置项的dataDir目录的 version-2中，格式为snapshot.zxid 事务日志：记录每一次事务操作的记录，保存在dataLogDir[dataDir]目录的version-2中，格式为 log.zxid</p><p>数据与日志里都是二进制数据，不能直接打开，需要使用以下工具：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">zkSnapShotToolkit.sh snapshot.zxid<br>zkTxnLogToolkit.sh log.zxid<br></code></pre></td></tr></table></figure><h3 id="5-1-zkServer第一次启动"><a href="#5-1-zkServer第一次启动" class="headerlink" title="5.1 zkServer第一次启动"></a>5.1 zkServer第一次启动</h3><p>zkServer第一次启动时，因为此时zxid的值为0，会生成一个snapshot.0的数据快照文件，对应的源码是FileTnxSnapLog#save方法。</p><p>文件的大小不会进行预分配，而是取决于内存DataTree的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">snapLog.serialize(dataTree, sessionsWithTimeouts, snapshotFile, syncSnap);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">SnapshotInfo</span>(Util.getZxidFromName(snapShot.getName(), SNAPSHOT_FILE_PREFIX),snapShot.lastModified() / <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p>查看快照日志文件内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">zkSnapShotToolkit.sh snapshot.0<br></code></pre></td></tr></table></figure><h3 id="5-2-第一次创建事务日志文件"><a href="#5-2-第一次创建事务日志文件" class="headerlink" title="5.2 第一次创建事务日志文件"></a>5.2 第一次创建事务日志文件</h3><p>使用客户端连接zk server时，也是事务事件，会生成了一个log.1的事务日志文件，对应的源码是 FileTxnLog#append方法。</p><p>文件的大小会进行预分配，也就是FilePadding#preAllocaSize = 65536 * 1024 Byte = 64M 也就是说每个事务日志文件的默认大小是64M，可以直接在windows中查看文件。如果事务日志文件的空间剩余不足4KB，则会再次预分配64M的磁盘空间。从这里可以看出，快照文件和日志文件最好不要放在一起，防止文件句柄数的频繁打开。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">zkTxnLogToolkit.sh log.1<br></code></pre></td></tr></table></figure><h3 id="5-3-新建数据快照文件和事务日志文件"><a href="#5-3-新建数据快照文件和事务日志文件" class="headerlink" title="5.3 新建数据快照文件和事务日志文件"></a>5.3 新建数据快照文件和事务日志文件</h3><p>每进行一次事务操作，事务日志中都会增加一条记录，当经过snapCount(默认100000)的过半随机次数(即在5万到10万之间)的事务写入之后，就会触发一次快照数据文件生成，同时也会新生成一个事务日志文件。</p><p>注意：每一次重新启动zk server，如果之前有zxid的变化，则也会创建一个新的快照数据文件，同时在后续的事务操作中，也会新建一个新的事务日志文件。</p><p>具体源码见SyncRequestProcessor#shouldSnapshot()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldSnapshot</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">logCount</span> <span class="hljs-operator">=</span> zks.getZKDatabase().getTxnCount();<br><span class="hljs-type">long</span> <span class="hljs-variable">logSize</span> <span class="hljs-operator">=</span> zks.getZKDatabase().getTxnSize();<br><span class="hljs-keyword">return</span> (logCount &gt; (snapCount / <span class="hljs-number">2</span> + randRoll)) <br>        || (snapSizeInBytes &gt; <span class="hljs-number">0</span> &amp;&amp; logSize &gt; (snapSizeInBytes / <span class="hljs-number">2</span> + randSize));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-数据快照文件和事务日志文件的清理"><a href="#5-4-数据快照文件和事务日志文件的清理" class="headerlink" title="5.4 数据快照文件和事务日志文件的清理"></a>5.4 数据快照文件和事务日志文件的清理</h3><blockquote><p>QuorumPeerConfig</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">purgeInterval</span>=<span class="hljs-string">0   #触发自动清理的时间间隔，单位是小时，默认值为0，表示不开启自动清理的功能</span><br><span class="hljs-attr">snapRetainCount</span>=<span class="hljs-string">3   #自动清理保留3个事务日志和快照数据</span><br></code></pre></td></tr></table></figure><h3 id="5-5-总结"><a href="#5-5-总结" class="headerlink" title="5.5 总结"></a>5.5 总结</h3><p>针对每一次事务操作，都会将其保存到事务日志文件中，同时会将数据的变化应用到内存DataTree中。当经过了一定次数的事务操作后，则会将内存DataTree中的全量数据保存到数据快照文件中。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper初识</title>
    <link href="/2023/05/15/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E5%88%9D%E8%AF%86/"/>
    <url>/2023/05/15/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>官网：<a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a></p><h2 id="1-Zookeeper环境安装"><a href="#1-Zookeeper环境安装" class="headerlink" title="1 Zookeeper环境安装"></a>1 Zookeeper环境安装</h2><h3 id="1-1-服务端安装启动"><a href="#1-1-服务端安装启动" class="headerlink" title="1.1 服务端安装启动"></a>1.1 服务端安装启动</h3><h4 id="1-1-1-centos"><a href="#1-1-1-centos" class="headerlink" title="1.1.1 centos"></a>1.1.1 centos</h4><ol><li>前置环境</li></ol><p>Java8    Maven</p><ol start="2"><li>下载Zookeeper：3.7.1</li></ol><p><a href="https://zookeeper.apache.org/releases.html">https://zookeeper.apache.org/releases.html</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">wget https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.7.1/apache-zookeeper-3.7.1-bin.tar.gz<br></code></pre></td></tr></table></figure><ol start="3"><li>解压</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xvf apache-zookeeper-3.7.1-bin.tar.gz<br></code></pre></td></tr></table></figure><ol start="4"><li>进入conf目录并拷贝zoo_sample.cfg，因为启动的时候会默认使用conf/zoo.cfg文 件，当然也可以指定启动文件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> zoo_sample.cfg zoo.cfg<br></code></pre></td></tr></table></figure><ol start="5"><li>修改配置文件conf/zoo.cfg，比如修改dataDir、dataLogDir和clientPort等，当然如果不额外指定dataLogDir，则事务日志文件也会存储到dataDir中。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> -p /usr/local/zookeeper/apache-zookeeper-3.7.1-bin/data<br></code></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">tickTime</span>=<span class="hljs-string">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-string">10syncLimit=5</span><br><span class="hljs-attr">dataDir</span>=<span class="hljs-string">/usr/local/zookeeper/apache-zookeeper-3.7.1-bin/data</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-string">2181</span><br></code></pre></td></tr></table></figure><ol start="6"><li>根据自己的需求选择是否配置zk的环境变量，也就是在任意目录之下可以使用bin中的命令</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim /etc/profile<br><span class="hljs-comment"># 文件末尾增加如下配置</span><br><span class="hljs-built_in">export</span> ZOOKEEPER_HOME=/usr/local/zookeeper/apache-zookeeper-3.7.1-bin<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$ZOOKEEPER_HOME</span>/bin<br><br><span class="hljs-comment"># 让profile文件生效</span><br><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><ol start="7"><li>启动与停止zkServer</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">zkServer.sh start <span class="hljs-comment"># 启动</span><br>zkServer.sh start-foreground <span class="hljs-comment"># 前端启动</span><br>zkServer.sh status <span class="hljs-comment"># 查看状态</span><br>zkServer.sh stop <span class="hljs-comment"># 停止</span><br></code></pre></td></tr></table></figure><h4 id="1-1-2-docker"><a href="#1-1-2-docker" class="headerlink" title="1.1.2 docker"></a>1.1.2 docker</h4><ol><li><a href="https://hub.docker.com/">https://hub.docker.com/</a></li><li>搜索zookeeper镜像，版本选择: 3.7.1</li><li>拉取镜像</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull zookeeper:3.7.1<br></code></pre></td></tr></table></figure><ol start="4"><li>运行zookeeper container</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d --name test-zk-server -p 2281:2182 zookeeper:3.7.1<br></code></pre></td></tr></table></figure><h4 id="1-1-3-源码"><a href="#1-1-3-源码" class="headerlink" title="1.1.3 源码"></a>1.1.3 源码</h4><ol><li>下载源码：<a href="https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.7.1/apache-zookeeper-3.7.1.tar.gz">https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.7.1/apache-zookeeper-3.7.1.tar.gz</a></li><li>maven构建：在源码根目录下执行如下命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mvn clean install ‐‐DskipTests<br></code></pre></td></tr></table></figure><ol start="3"><li>导入到idea中</li><li>创建zoo.cfg文件并配置，和centos配置方式一样</li><li>寻找启动类</li></ol><blockquote><p>bin/zkServer.cmd 或 bin/zkServer.sh，也就是服务端启动的时候，会通过QuorumPeerMain进行启动</p><p>ZOOMAIN=org.apache.zookeeper.server.quorum.QuorumPeerMain</p></blockquote><ol start="6"><li>配置启动类</li></ol><p><img src="/image/zookeeper/1.png"></p><ol start="7"><li>日志输出</li></ol><p>​    a- 将conf文件下的log.properties文件复制到zookeeper-server的resources文件夹下 </p><p>​    b- 在zookeeper-server的pom.xml中添加slf4j的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">denpendency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">denpendency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="8"><li>动zk server-standalone</li></ol><h3 id="1-2-客户端安装启动"><a href="#1-2-客户端安装启动" class="headerlink" title="1.2 客户端安装启动"></a>1.2 客户端安装启动</h3><h4 id="1-2-1-centos"><a href="#1-2-1-centos" class="headerlink" title="1.2.1 centos"></a>1.2.1 centos</h4><blockquote><p>通过zkCli.sh连接</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">zkCli.sh <span class="hljs-comment"># 默认连接本机的2181端口</span><br>zkCli.sh -server 127.0.0.1:2181 <span class="hljs-comment"># 指定zk server</span><br></code></pre></td></tr></table></figure><h4 id="1-2-2-源码"><a href="#1-2-2-源码" class="headerlink" title="1.2.2 源码"></a>1.2.2 源码</h4><blockquote><p>找到zkCli.cmd，发现客户端是通过ZookeeperMain运行的</p></blockquote><p><img src="/image/zookeeper/2.png"></p><h4 id="1-2-3-prettyZoo"><a href="#1-2-3-prettyZoo" class="headerlink" title="1.2.3 prettyZoo"></a>1.2.3 prettyZoo</h4><p><a href="https://github.com/vran-dev/PrettyZoo/releases">https://github.com/vran-dev/PrettyZoo/releases</a></p><h4 id="1-2-3-web图形化界面zkui"><a href="#1-2-3-web图形化界面zkui" class="headerlink" title="1.2.3 web图形化界面zkui"></a>1.2.3 web图形化界面zkui</h4><p><a href="https://github.com/DeemOpen/zkui">https://github.com/DeemOpen/zkui</a></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>来到zk-server所在机器<br><span class="hljs-symbol">2 </span>下载源码：git clone https://github.<span class="hljs-keyword">com</span>/DeemOpen/zkui<br><span class="hljs-symbol">3 </span>mvn clean install<br><span class="hljs-symbol">4 </span>复制config.cfg到jar包所在目录: target<br><span class="hljs-symbol">5 </span>打开配置文件，配置zkServer=zkServer=<span class="hljs-number">192.168</span>.<span class="hljs-number">0.8</span>:<span class="hljs-number">2181</span><br><span class="hljs-symbol">6 </span>zkui默认端口在<span class="hljs-number">9090</span>: serverPort=<span class="hljs-number">9090</span><br><span class="hljs-symbol">7 </span>运行jar包: java -jar zkui-<span class="hljs-number">2.0</span>-SNAPSHOT-jar-with-dependencies.jar<br><span class="hljs-symbol">8 </span>访问地址: localhost:<span class="hljs-number">9090</span><br><span class="hljs-symbol">9 </span>默认用户名密码：admin manager，可以通过userSet修改<br></code></pre></td></tr></table></figure><h2 id="2-Zookeeper-Sessions"><a href="#2-Zookeeper-Sessions" class="headerlink" title="2 Zookeeper Sessions"></a>2 Zookeeper Sessions</h2><p><a href="https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#ch_zkSessions">https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#ch_zkSessions</a></p><p>可以通过zkCli.sh 查看session相关信息，比如sessionTimeout=30000毫秒、seession id=0x10000314a5a0002 </p><p>Zookeeper连接是TCP长连接，超时时间指的是客户端和服务端因为一些原因断开了连接，如果在超时时间内能够重新连接上，则会话依然有效。</p><h2 id="3-数据模型与基本操作"><a href="#3-数据模型与基本操作" class="headerlink" title="3  数据模型与基本操作"></a>3  数据模型与基本操作</h2><h3 id="3-1-数据模型"><a href="#3-1-数据模型" class="headerlink" title="3.1 数据模型"></a>3.1 数据模型</h3><p><a href="https://zookeeper.apache.org/doc/current/zookeeperOver.html#sc_dataModelNameSpace">https://zookeeper.apache.org/doc/current/zookeeperOver.html#sc_dataModelNameSpace</a></p><p><img src="/image/zookeeper/3.png"></p><h3 id="3-2-基本操作"><a href="#3-2-基本操作" class="headerlink" title="3.2 基本操作"></a>3.2 基本操作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看帮助</span><br><span class="hljs-built_in">help</span><br><br><span class="hljs-comment"># 创建节点</span><br>create /gupao<br>create /gupao/jack<br>create /gupao/james<br><br><span class="hljs-comment"># 创建节点并往节点上存数据</span><br>create /gupao/jack/age 17<br>create /gupao/jack/hobby coding<br><br><span class="hljs-comment"># 获取ZNode</span><br><span class="hljs-built_in">ls</span> /<br><span class="hljs-built_in">ls</span> /gupao<br><span class="hljs-built_in">ls</span> -R /gupao<br><br><span class="hljs-comment"># 查询某个 查询某个ZNode ZNode数据数据</span><br>get /gupao/jack<br>get /gupao/jack/age<br>get /gupao/jack/hobby<br><br><span class="hljs-comment"># 修改ZNode的值</span><br><span class="hljs-built_in">set</span> /gupao/jack/age 16<br>get /gupao/jack/age<br><br><span class="hljs-comment"># 删除节点，当某个节点下存在子节点时，不能直接删除该节点</span><br>delete /gupao/jack/age<br><span class="hljs-built_in">ls</span> -R /<br>deleteall /gupao<br><span class="hljs-built_in">ls</span> -R /<br></code></pre></td></tr></table></figure><h3 id="3-3-节点状态"><a href="#3-3-节点状态" class="headerlink" title="3.3  节点状态"></a>3.3  节点状态</h3><p><a href="https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#sc_zkStatStructure">https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#sc_zkStatStructure</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查询节点状态信息 查询节点状态信息((详情详情)) 总共11个</span><br><span class="hljs-built_in">stat</span> /gupao<br>get -s /gupao<br></code></pre></td></tr></table></figure><h4 id="3-3-1-基本"><a href="#3-3-1-基本" class="headerlink" title="3.3.1 基本"></a>3.3.1 基本</h4><p>（1）numChildren：当前节点子节点的数量 </p><p>（2）dataLength：当前节点保存的数据长度 </p><p>（3）ephemeralOwner：当前节点是否为临时节点，如果为临时节点则该值为 sessionid，否则为0</p><h4 id="3-3-2-时间相关"><a href="#3-3-2-时间相关" class="headerlink" title="3.3.2 时间相关"></a>3.3.2 时间相关</h4><p>（1）ctime：当前节点比创建的时间。比如ctime = Thu Jul 21 22:00:07 UTC 2022 </p><p>（2）mtime：当前节点最后一次被修改的时间。比如mtime = Thu Jul 21 22:08:47 UTC 2022</p><h4 id="3-3-3-版本相关"><a href="#3-3-3-版本相关" class="headerlink" title="3.3.3 版本相关"></a>3.3.3 版本相关</h4><p>（1）dataVersion：当前节点的数据被修改的次数，也就是数据的版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">set</span> -v 2 /gupao 888<br><span class="hljs-built_in">set</span> -v 1 /gupao 888<br><br><span class="hljs-built_in">stat</span> /gupao<br></code></pre></td></tr></table></figure><p>（2）cversion：子节点的版本号，是节点的版本，不是数据的版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">reate /gupao/test1<br><span class="hljs-built_in">stat</span> /gupao<br>create /gupao/test2<br><span class="hljs-built_in">stat</span> /gupao<br></code></pre></td></tr></table></figure><p>（3）aversion：acl的版本号</p><h4 id="3-3-4-zxid"><a href="#3-3-4-zxid" class="headerlink" title="3.3.4  zxid"></a>3.3.4  zxid</h4><p><a href="https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#sc_timeInZk">https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#sc_timeInZk</a></p><p>zxid是事务编号，8字节的整型数，即64个比特位，前32位标识epoch，后32位用来计数。</p><p>zxid的初始值为0，每一次事务请求都会把后面32位的值+1，比如进行了10次事务请求，则zxid变为 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00001010，每进行一次leader选举，前32位的值就会+1，并把后面的32位清零，则zxid变为 00000000 00000000 00000000 00000001 00000000 00000000 00000000 00000000，若一直没有进行leader选举，同时一直在发生事务请求，则后面32位会一直增加，极限值是00000000 00000000 00000000 00000000 11111111 11111111 11111111 11111111，此时再发生事务请求，则把前面的32位+1，变成00000000 00000000 00000000 00000001 00000000 00000000 00000000 00000000 </p><p>（1）czxid：表示当前节点被创建时的事务id </p><p>（2）mzxid：表示当前节点被最后一次更新时的事务id </p><p>（3）pzxid：表示该节点的子节点最后一次被修改时的事务id。只有子节点变化才会影响 pzxid，子节点的数据变化不会影响pzxid</p><h2 id="4-节点特性"><a href="#4-节点特性" class="headerlink" title="4 节点特性"></a>4 节点特性</h2><p>查看create命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">[zk: localhost:2181(CONNECTED) 22] create<br>create [-s] [-e] [-c] [-t ttl] path [data] [acl]<br></code></pre></td></tr></table></figure><h3 id="4-1-持久节点PERSISTENT"><a href="#4-1-持久节点PERSISTENT" class="headerlink" title="4.1  持久节点PERSISTENT"></a>4.1  持久节点PERSISTENT</h3><blockquote><p>创建节点默认是持久节点，不会因为客户端宕机而删除节点</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">create /jack 666<br><span class="hljs-built_in">stat</span> /jack jack <span class="hljs-comment">## ephemeralOwner ephemeralOwner = 0x0</span><br>quit<br>zkCli.sh<br><span class="hljs-built_in">ls</span> /<br></code></pre></td></tr></table></figure><h3 id="4-2-临时节点EPHEMERAL"><a href="#4-2-临时节点EPHEMERAL" class="headerlink" title="4.2  临时节点EPHEMERAL"></a>4.2  临时节点EPHEMERAL</h3><blockquote><p>会因为客户端宕机而删除节点</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">create -e /test 111<br><span class="hljs-built_in">stat</span> /test <span class="hljs-built_in">test</span> <span class="hljs-comment">## ephemeralOwner ephemeralOwner = 0x100000aa4c70002 sessionid</span><br>quit<br>zkCli.sh<br><span class="hljs-built_in">ls</span> /<br></code></pre></td></tr></table></figure><h3 id="4-3-有序节点SEQUENTIAL"><a href="#4-3-有序节点SEQUENTIAL" class="headerlink" title="4.3 有序节点SEQUENTIAL"></a>4.3 有序节点SEQUENTIAL</h3><blockquote><p>会给节点名称添加一个自增的序号</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#  持久有序节点</span><br>create -s /order<br>create -s /order<br>create -s /order<br><span class="hljs-comment"># 临时有序节点</span><br>create -s -e /product<br>create -s -e /product<br>create -s -e /product<br></code></pre></td></tr></table></figure><h3 id="4-4-容器节点"><a href="#4-4-容器节点" class="headerlink" title="4.4 容器节点"></a>4.4 容器节点</h3><p><a href="https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#Container+Nodes">https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#Container+Nodes</a></p><blockquote><p>3.6.0后新加的节点类型，当一个节点下的子节点都被删除后，这个容器节点也会自动删除</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">create -c /jack-container<br>create /jack-container/sub1<br>create /jack-container/sub2<br><span class="hljs-built_in">ls</span> -R /jack-container<br><br>delete /jack-container/sub1<br>delete /jack-container/sub2<br><br><span class="hljs-comment"># 等待一段时间之后，查看节点是否存在</span><br></code></pre></td></tr></table></figure><h3 id="4-5-TTL节点"><a href="#4-5-TTL节点" class="headerlink" title="4.5  TTL节点"></a>4.5  TTL节点</h3><p><a href="https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#TTL+Nodes">https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#TTL+Nodes</a></p><blockquote><p>3.6.0后新加的节点类型，可以给持久节点设置一个超时时间，需要在配置文件中添加配置：</p><p>zookeeper.extendedTypesEnabled=true      重启服务</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">reate -t 10 /zk-ttl 111<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB高级应用</title>
    <link href="/2023/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    <url>/2023/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-复制集"><a href="#1-复制集" class="headerlink" title="1 复制集"></a>1 复制集</h2><h3 id="1-1-复制集机制与原理"><a href="#1-1-复制集机制与原理" class="headerlink" title="1.1 复制集机制与原理"></a>1.1 复制集机制与原理</h3><h4 id="1-1-1-复制集作用"><a href="#1-1-1-复制集作用" class="headerlink" title="1.1.1 复制集作用"></a>1.1.1 复制集作用</h4><ol><li><p>MongoDB 复制集的主要意义在于实现服务高可用 </p></li><li><p>它的实现依赖于两个方面的功能： </p></li></ol><p>​        • 数据写入时将数据迅速复制到另一个独立节点上 </p><p>​        • 在接受写入的节点发生故障时自动选举出一个新的替代节点</p><ol start="3"><li><p>在实现高可用的同时，复制集实现了其他几个附加作用： </p><p> • 数据分发：将数据从一个区域复制到另一个区域，减少另一个 区域的读延迟 </p><p> • 读写分离：不同类型的压力分别在不同的节点上执行 </p><p> • 异地容灾：在数据中心故障时候快速切换到异地</p></li></ol><h4 id="1-1-2-复制集结构"><a href="#1-1-2-复制集结构" class="headerlink" title="1.1.2 复制集结构"></a>1.1.2 复制集结构</h4><p>一个典型的复制集由3个以上具有投票权的节点组成，包括：</p><p> • 一个主节点（PRIMARY）：接受写入操作和选举时投票 </p><p>• 两个（或多个）从节点（SECONDARY）：复制主节点上的新数据和选举时投票 </p><p>• 不推荐使用 Arbiter（投票节点）</p><h4 id="1-1-3-数据是如何复制的？"><a href="#1-1-3-数据是如何复制的？" class="headerlink" title="1.1.3 数据是如何复制的？"></a>1.1.3 数据是如何复制的？</h4><p>● 当一个修改操作，无论是插入、更新或删除，到达主节点时，它对数据的操作将被记录下来（经过一些必要的转换），这些记录称为 oplog。</p><p> ● 从节点通过在主节点上打开一个 tailable 游标不断获取新进入主节点的 oplog，并在自己的数据上回放，以此保持跟主节点的数据一致</p><h4 id="1-1-4-故障恢复"><a href="#1-1-4-故障恢复" class="headerlink" title="1.1.4 故障恢复"></a>1.1.4 故障恢复</h4><p>通过选举完成故障恢复：</p><p>● 具有投票权的节点之间两两互相发送心跳； ● 当5次心跳未收到时判断为节点失联； ● 如果失联的是主节点，从节点会发起选举，选出新的主节点； ● 如果失联的是从节点则不会产生新的选举；● 选举基于 RAFT一致性算法实现，选举成功的必要条件是大多数投票节点存活； ● 复制集中最多可以有50个节点，但具有投票权的节点最多7个。</p><p><strong>影响选举的因素</strong>：● 整个集群必须有大多数节点存活； ● 被选举为主节点的节点必须：能够与多数节点建立连接；具有较新的oplog；具有较高的优先级（如果有配置）</p><p><strong>常见配置选项</strong>：• 是否具有投票权（v 参数）：有则参与投票； • 优先级（priority 参数）：优先级越高的节点越优先成为主节点。优先级为0的节点无法成为主节点； • 隐藏（hidden 参数）：复制数据，但对应用不可见。隐藏节点可以具有投票仅，但优先级必须为0； • 延迟（slaveDelay 参数）：复制 n 秒之前的数据，保持与主节点的时间差。</p><h4 id="1-1-5-复制集注意事项"><a href="#1-1-5-复制集注意事项" class="headerlink" title="1.1.5 复制集注意事项"></a>1.1.5 复制集注意事项</h4><ol><li>关于硬件</li></ol><p>​    • 因为正常的复制集节点都有可能成为主节点，它们的地位是一样的，因此硬件配置上必须 一致；</p><p>​    • 为了保证节点不会同时宕机，各节点使用的硬件必须具有独立性。</p><ol start="2"><li>关于软件</li></ol><p>​    • 复制集各节点软件版本必须一致，以避免出现不可预知的问题。</p><ol start="3"><li>增加节点不会增加系统写性能！</li></ol><h3 id="1-2-搭建复制集"><a href="#1-2-搭建复制集" class="headerlink" title="1.2 搭建复制集"></a>1.2 搭建复制集</h3><ol><li>准备</li></ol><p>● 安装最新的 MongoDB 版本 </p><p>● Windows 系统请事先配置好 MongoDB 可执行文件的环境变量 </p><p>● Linux 和 Mac 系统请配置 PATH 变量 </p><p>● 确保有 10GB 以上的硬盘空间</p><ol start="2"><li>创建数据目录</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> -p /data/db&#123;1,2,3&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li> 准备配置文件</li></ol><p>复制集的每个mongod进程应该位于不同的服务器。现在在一台机器上运行3个进程，因此要为它们各自配置：</p><p>● 不同的端口。示例中将使用 28017/28018/28019</p><p>● 不同的数据目录。示例中将使用： /data/db1 /data/db2  /data/db3 </p><p>● 不同日志文件路径。示例中将使用： /data/db1/mongod.log  /data/db2/mongod.log  /data/db3/mongod.log </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># /data/db1/mongod.conf</span><br><span class="hljs-attr">systemLog:</span><br>   <span class="hljs-attr">destination:</span> <span class="hljs-string">file</span><br>   <span class="hljs-attr">path:</span> <span class="hljs-string">/data/db1/mongod.log</span> <span class="hljs-comment"># log path</span><br>   <span class="hljs-attr">logAppend:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">storage:</span><br>   <span class="hljs-attr">dbPath:</span> <span class="hljs-string">/data/db1</span> <span class="hljs-comment"># data directory</span><br><span class="hljs-attr">net:</span><br>   <span class="hljs-attr">bindIp:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>   <span class="hljs-attr">port:</span> <span class="hljs-number">28017</span> <span class="hljs-comment"># port</span><br><span class="hljs-attr">replication:</span><br>   <span class="hljs-attr">replSetName:</span> <span class="hljs-string">rs0</span><br><span class="hljs-attr">processManagement:</span><br>   <span class="hljs-attr">fork:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ol start="4"><li>启动 MongoDB 进程</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">mongod -f /data/db1/mongod.conf<br>mongod -f /data/db2/mongod.conf<br>mongod -f /data/db3/mongod.conf<br></code></pre></td></tr></table></figure><p>注意：如果启用了 SELinux，可能阻止上述进程启动。简单起见请关闭 SELinux。</p><ol start="5"><li> 配置复制集</li></ol><p><strong>方法1:</strong> 此方式hostname 需要能被解析</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># mongo --port 28017</span><br><span class="hljs-comment"># hostname -f</span><br>&gt; rs.initiate() <span class="hljs-comment"># 这个时候 SECONDARY&gt; 这个时候变成了从节点 在等几秒钟 再按一下回车就变成了PARIMARY了 可以正常负责读和写了</span><br>&gt; rs.add(”HOSTNAME:28018<span class="hljs-string">&quot;)</span><br><span class="hljs-string">&gt; rs.add(”HOSTNAME:28019&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>方法2</strong>：在主节点配置即可，无须重复配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># mongo --port 28017</span><br><span class="hljs-comment"># mongo localhost:28018</span><br>rs.initiate(&#123;<br>   _id: <span class="hljs-string">&quot;rs0&quot;</span>,<br>   members: [&#123;<br>       _id: 0,<br>       host: <span class="hljs-string">&quot;localhost:28017&quot;</span><br>   &#125;,&#123;<br>       _id: 1,<br>       host: <span class="hljs-string">&quot;localhost:28018&quot;</span><br>   &#125;,&#123;<br>       _id: 2,<br>       host: <span class="hljs-string">&quot;localhost:28019&quot;</span><br>   &#125;]<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="6"><li>验证</li></ol><p>MongoDB 主节点进行写入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># mongo localhost:28017</span><br>&gt; db.test.insert(&#123; a:1 &#125;);<br>&gt; db.test.insert(&#123; a:2 &#125;);<br></code></pre></td></tr></table></figure><p>MongoDB 从节点进行读</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># mongo localhost:28018</span><br>&gt; rs.slaveOk() <span class="hljs-comment"># secondary OK（）</span><br>&gt; db.test.find()<br><span class="hljs-comment"># --------隔一段时间</span><br>&gt; db.test.find()<br></code></pre></td></tr></table></figure><h2 id="2-事务"><a href="#2-事务" class="headerlink" title="2 事务"></a>2 事务</h2><p>mongodb的一致性需要借助writeConcern和readConcern的帮忙。</p><h3 id="2-1-写操作事务-writeConcern"><a href="#2-1-写操作事务-writeConcern" class="headerlink" title="2.1 写操作事务-writeConcern"></a>2.1 写操作事务-writeConcern</h3><p>writeConcern 决定一个写操作落到多少个节点上才算成功。</p><p> writeConcern 的取值包括： • 0：发起写操作，不关心是否成功； • 1~集群最大数据节点数：写操作需要被复制到指定节点数才算成 功； • majority：写操作需要被复制到大多数节点上才算成功。 </p><p>发起写操作的程序将阻塞到写操作到达指定的节点数为止。</p><p>journal 定义如何才算成功。取值包括： • true: 写操作落到 journal 文件中才算成功; • false: 写操作到达内存即算作成功</p><p><strong>writeConcern 实践</strong>：</p><ol><li>在复制集测试writeConcern参数</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">db.test.insert( &#123;count: 1&#125;, &#123;writeConcern: &#123;w:<span class="hljs-string">&quot;majority&quot;</span>&#125;&#125;)<br>db.test.insert( &#123;count: 1&#125;, &#123;writeConcern: &#123;w: 3 &#125;&#125;)<br>db.test.insert( &#123;count: 1&#125;, &#123;writeConcern: &#123;w: 4 &#125;&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>配置延迟节点，模拟网络延迟（复制延迟）</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">conf = rs.conf()<br>conf.members[2].slaveDelay = 5<br>conf.members[2].priority = 0<br>rs.reconfig(conf)<br></code></pre></td></tr></table></figure><ol start="3"><li>观察复制延迟下的写入，以及timeout参数</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">db.test.insert( &#123;count: 1&#125;, &#123;writeConcern: &#123;w: 3&#125;&#125;)<br>db.test.insert( &#123;count: 1&#125;, &#123;writeConcern: &#123;w: 3,wtimeout:3000 &#125;&#125;)<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong>:</p><p>• 虽然多于半数的 writeConcern 都是安全的，但通常只会设置 majority，因为这是等待写入延迟时间最短的选择； </p><p>• 不要设置 writeConcern 等于总节点数，因为一旦有一个节点故障，所有写操作都将失败； </p><p>• writeConcern 虽然会增加写操作延迟时间，但并不会显著增加集群压力，因此无论是否等待，写操作最终都会复制到所有节点上。 设置 writeConcern 只是让写操作等待复制后再返回而已； </p><p>• 应对重要数据应用 {w: “majority”}，普通数据可以应用 {w: 1} 以确保最佳性能。</p><h3 id="2-2-读操作事务-readPreference"><a href="#2-2-读操作事务-readPreference" class="headerlink" title="2.2 读操作事务-readPreference"></a>2.2 读操作事务-readPreference</h3><p>在读取数据的过程中需要关注以下两个问题： 从哪里读？ 什么样的数据可以读？ 第一个问题是是由 readPreference 来解决；第二个问题则是由 readConcern 来解决。</p><p>readPreference 决定使用哪一个节点来满足正在发起的读请求。 可选值包括： • primary: 只选择主节点； • primaryPreferred：优先选择主节点，如果不可用则选择从节点； • secondary：只选择从节点； • secondaryPreferred：优先选择从节点， 如果从节点不可用则选 择主节点； • nearest：选择最近的节点；</p><p><strong>readPreference 与 Tag</strong></p><blockquote><p>readPreFerence 是类别，Tag 是可以做分组，tag的粒度可以做得比前者细</p></blockquote><p>readPreference 只能控制使用一类节点。Tag 则可以将节点选择控制到一个或几个节点。考虑以下场景： • 一个 5 个节点的复制集； • 3 个节点硬件较好，专用于服务线上客户； • 2 个节点硬件较差，专用于生成报表； 可以使用 Tag 来达到这样的控制目的： • 为 3 个较好的节点打上 {purpose: “online”}； • 为 2 个较差的节点打上 {purpose: “analyse”}； • 在线应用读取时指定 online，报表读取时指定 reporting；</p><p><a href="https://www.mongodb.com/docs/manual/core/read-preference/">https://www.mongodb.com/docs/manual/core/read-preference/</a></p><p><strong>readPreference 配置</strong></p><p>通过 MongoDB 的连接串参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mongodb://host1:27107,host2:27107,host3:27017/?replicaSet=rs&amp;readPreference=secondary<br></code></pre></td></tr></table></figure><p>通过 MongoDB 驱动程序 API：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">MongoCollection.withReadPreference(ReadPreferencereadPref)<br></code></pre></td></tr></table></figure><p>Mongo Shell：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">db.collection.find(&#123;&#125;).readPref( “secondary” )<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong>:</p><ol><li>指定 readPreference 时也应注意高可用问题。例如将 readPreference 指定 primary，则发生故障转移不存在 primary 期间将没有节点可读。如果业务允许，则应选择 primaryPreferred； </li><li>使用 Tag 时也会遇到同样的问题，如果只有一个节点拥有一个特定 Tag，则在这个节点失效时将无节点可读。这在有时候是期望的结果，有时候不是。</li><li>如果报表使用的节点失效，即使不生成报表，通常也不希望将报表负载转移到其他节点上，此时只有一个节点有报表 Tag 是合理的选择； </li><li>如果线上节点失效，通常希望有替代节点，所以应该保持多个节点有同样的 Tag；</li><li> Tag 有时需要与优先级、选举权综合考虑。例如做报表的节点通常不会希望它成为主节点，则优先级应为 0。</li></ol><h3 id="2-3-读操作事务-readConcern"><a href="#2-3-读操作事务-readConcern" class="headerlink" title="2.3 读操作事务-readConcern"></a>2.3 读操作事务-readConcern</h3><blockquote><p>数据的隔离级别</p></blockquote><p>在 readPreference 选择了指定的节点后，readConcern 决定这个节点上的数据哪些是可读的，类似于关系数据库的隔离级别。可选值包括：</p><p>• available：读取所有可用的数据; （mongo 默认的级别） </p><p>• local：读取所有可用且属于当前分片的数据; （很少用） </p><p>• majority：读取在大多数节点上提交完成的数据; （解决脏读，达到读已提交，通过MVCC去解决的）</p><p>• linearizable：可线性化读取文档; （线性化读取） </p><p>• snapshot：读取最近快照中的数据; （解决脏读、不可重复读、 幻读，达到可重复读，通过快照去解决的）</p><h4 id="2-3-1-readConcern-local-和-available"><a href="#2-3-1-readConcern-local-和-available" class="headerlink" title="2.3.1 readConcern: local 和 available"></a>2.3.1 readConcern: local 和 available</h4><p>在复制集中 local 和 available 是没有区别的。两者的区别主要体现在分片集上。考虑以下场景：</p><p>• 一个 chunk x 正在从 shard1 向 shard2 迁移的场景下； • 整个迁移过程中 chunk x 中的部分数据会在 shard1 和 shard2 中 同时存在，但源分片 shard1仍然是 chunk x 的负责方： • 所有对 chunk x 的读写操作仍然进入 shard1； • config 中记录的信息 chunk x 仍然属于 shard1； • 此时如果读 shard2，则会体现出 local 和 available 的区别： • local：只取应该由 shard2 负责的数据（不包括 x）； • available：shard2 上有什么就读什么（包括 x）；</p><p><strong>注意事项：</strong></p><p>• 虽然看上去总是应该选择 local，但毕竟对结果集进行过滤会造成额外消耗。在一些无关紧要的场景（例如统计）下，也可以考虑 available； </p><p>• MongoDB &lt;=3.6 不支持对从节点使用 {readConcern: “local”}；</p><p> • 从主节点读取数据时默认 readConcern 是 local，从从节点读取数据时默认 readConcern 是 available（向前兼容原因）。</p><h4 id="2-3-2-readConcern-majority"><a href="#2-3-2-readConcern-majority" class="headerlink" title="2.3.2 readConcern: majority"></a>2.3.2 readConcern: majority</h4><p>只读取大多数据节点上都提交了的数据，这个时候数据的不会被回滚的是安全的。</p><p>使用 writeConcern + readConcern majority 来实现安全的读写分离。</p><h4 id="2-3-3-readConcern-linearizable"><a href="#2-3-3-readConcern-linearizable" class="headerlink" title="2.3.3 readConcern: linearizable"></a>2.3.3 readConcern: linearizable</h4><p>只读取大多数节点确认过的数据。和 majority 最大差别是保证绝对的操作线性顺序：在写操作自然时间后面的发生的读，一定可以读到之前的写；只对读取单个文档时有效； 可能导致非常慢的读，因此总是建议配合使用 maxTimeMS；</p><p>这种情况是为了解决，主节点在写入数据后宕机，数据没有同步到其他节点，其他节点成为主节点，在后面的时间节点恢复变为 Secondary,因为之前作为主节点执行写数据又与其他节点不一样的情况，这个时候希望他能读到正常的数据，而不是旧数据。</p><h4 id="2-3-4-readConcern-snapshot"><a href="#2-3-4-readConcern-snapshot" class="headerlink" title="2.3.4 readConcern: snapshot"></a>2.3.4 readConcern: snapshot</h4><p>{readConcern: “snapshot”} 只在多文档事务中生效。 将一个事务的 readConcern 设置为 snapshot，将保证在事务中的读： • 不出现脏读； • 不出现不可重复读； • 不出现幻读。 因为所有的读都将使用同一个快照，直到事务提交为止该快照才被释放。</p><h4 id="2-3-5-readConcern-小结"><a href="#2-3-5-readConcern-小结" class="headerlink" title="2.3.5 readConcern: 小结"></a>2.3.5 readConcern: 小结</h4><p>• available：读取所有可用的数据 </p><p>• local：读取所有可用且属于当前分片的数据，默认设置 </p><p>• majority：数据读一致性的充分保证，可能你最需要关注的 </p><p>• linearizable：增强处理 majority 情况下主节点失联时候的例外情况</p><p> • snapshot：最高隔离级别，接近于 Seriazable</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB入门</title>
    <link href="/2023/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%E5%85%A5%E9%97%A8/"/>
    <url>/2023/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-初始MongoDB"><a href="#1-初始MongoDB" class="headerlink" title="1 初始MongoDB"></a>1 初始MongoDB</h2><p>MongoDB是一个以JSON为数据模型的文档数据库，文档来自于”JSON Document”，并非一般理解的PDF、WORD文档。是由上市公司MongoDB Inc.开发，位于美国纽约。是一个应用数据库，非关系型数据库，即NOSQL。主要特点：建模可选，JSON数据模型比较适合开发者，横向扩展可以支持很大数据量和并发，理论无上限。MongoDB的文档指的是JSON对象，对应Java中更像是一个Object对象的概念，而不是文件的概念。</p><p>MongoDB的使用场景：电商，物联网，内容管理(Web前端)，社交，航空业，电信业等。</p><h3 id="1-1-MongoDB特点"><a href="#1-1-MongoDB特点" class="headerlink" title="1.1 MongoDB特点"></a>1.1 MongoDB特点</h3><p>数据模型不一样：MongoDB是JSON模型。</p><p>开发模式不一样：传统的数据库是需要建模的，MongoDB是不要求先建模的，可以按照程序的模型，直接把程序的数据模型直接扔到MongoDB就可以直接保存，支持数据库的操作。</p><p>面向对象的数据模型：在Java和Python中都是使用面向对象的方式开发，一般后端返回给前端的数据交互都是JSON，所以MongoDB数据库模型是直接和Java对象吻合的，JSON其实就是一种对象。</p><h3 id="1-2-MongoDB-VS-关系型数据库"><a href="#1-2-MongoDB-VS-关系型数据库" class="headerlink" title="1.2 MongoDB VS 关系型数据库"></a>1.2 MongoDB VS 关系型数据库</h3><table><thead><tr><th></th><th>MongoDB</th><th>RDBMS</th></tr></thead><tbody><tr><td>数据模型</td><td>文档类型</td><td>关系类型</td></tr><tr><td>数据库类型</td><td>OLTP</td><td>OLTP</td></tr><tr><td>CRUD操作</td><td>MQL/SQL</td><td>SQL</td></tr><tr><td>高可用</td><td>复制集</td><td>集群模式</td></tr><tr><td>横向扩展能力</td><td>通过原生分片完善支持</td><td>中间件/应用入侵式</td></tr><tr><td>索引支持</td><td>B树，全文索引，地理位置索引，多键值索引，TTL索引</td><td>B树</td></tr><tr><td>开发难度</td><td>容易</td><td>困难</td></tr><tr><td>数据容量</td><td>没有理论上限</td><td>千万、亿</td></tr><tr><td>扩展方式</td><td>垂直扩展+水平扩展</td><td>垂直扩展</td></tr></tbody></table><blockquote><p>OLTP: OLTP(Online Transaction Processing)数据库，也称交易型数据库，是能够提供实时在线处理事务时保证强一致性（ACID） 的关系型数据库。事务(Transaction)是操作数据库中数据的操作序列，要求保证ACID，即原子性(Atomicity)、 一致性 (Consistency)、隔离性(Isolation)、持久性(Durability)。</p></blockquote><p>OLTP(Online Transaction Processing)) 是用来做前端交互式应用的</p><p>OLAP(Online analytical processing) 是在线分析处理，顾名思义就是OLAP是用于数据分析的</p><h2 id="2-MongoDB优势"><a href="#2-MongoDB优势" class="headerlink" title="2 MongoDB优势"></a>2 MongoDB优势</h2><ol><li>JSON 结构和对象模型接近，开发代码量低 </li><li> JSON 的动态模型意味着更容易响应新的业务需求 </li><li>复制集提供99.999% 高可用 </li><li>分表架构支持海量数据和无缝扩容</li></ol><h2 id="3-MongoDB安装与使用"><a href="#3-MongoDB安装与使用" class="headerlink" title="3 MongoDB安装与使用"></a>3 MongoDB安装与使用</h2><h3 id="3-1-MongoDB安装"><a href="#3-1-MongoDB安装" class="headerlink" title="3.1 MongoDB安装"></a>3.1 MongoDB安装</h3><p>下载地址：<a href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a></p><p>安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> -p /data /data/db<br><span class="hljs-built_in">mkdir</span> -p /data /data/logs<br><span class="hljs-built_in">cd</span> data<br><br><span class="hljs-comment">#https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.2.24.tgz</span><br>curl -O https://fastdl.mongodb.org/linux/mongodblinux-x86_64-rhel70-4.2.24.tgz<br>tar -xvf mongodb-linux-x86_64-rhel70-4.2.24.tgz<br><br><span class="hljs-comment">#设置环境变量</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/data/mongodb-linux-x86_64-rhel70-4.2.24/bin<br>vim /etc/profile<br><span class="hljs-built_in">source</span> /etc/profile<br><span class="hljs-built_in">cd</span> /data/mongodb-linux-x86_64-rhel70-4.2.24/bin<br></code></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">dbpath</span> = <span class="hljs-string">/data/db #数据文件存放目录</span><br><span class="hljs-attr">logpath</span> = <span class="hljs-string">/data/logs/mongodb.log #日志文件存放目录</span><br><span class="hljs-attr">port</span> = <span class="hljs-string">27017 #端口</span><br><span class="hljs-attr">fork</span> = <span class="hljs-string">true #以守护程序的方式启用，即在后台运行</span><br><span class="hljs-comment">#auth=true #需要认证。如果放开注释，就必须创建MongoDB的账号，使用账号与密码才可远程访问，第一次安装建议注释</span><br><span class="hljs-attr">bind_ip</span>=<span class="hljs-string">0.0.0.0 #允许远程访问，或者直接注释，127.0.0.1是只允许本地访问</span><br></code></pre></td></tr></table></figure><p>启动mongodb:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 以command line 设置参数的方式启动</span><br>mongod --dbpath /data/db --port 27017 --logpath /data/logs/mongod.log --fork -bind_ip 0.0.0.0<br><span class="hljs-comment"># 以文件方式启动</span><br>mongod -f mongodb.conf<br><br><span class="hljs-comment">#测试安装结果</span><br>mongod<br><br><span class="hljs-comment">#关闭</span><br>pkill mongod<br>mongod --shutdown<br><br><span class="hljs-comment">#测试启动结果</span><br>netstat -nltp | grep mongod<br>ps -ef | grep mongo<br><br><span class="hljs-comment">#开放端口</span><br>firewall-cmd --zone=public --add-port=27017/tcp --permanent<br>firewall-cmd --zone=public --add-port=28017/tcp --permanent<br><span class="hljs-comment"># 使配置生效</span><br>firewall-cmd --reload<br><span class="hljs-comment"># 查看开放端口操作是否成功</span><br>firewall-cmd --zone=public --list-ports<br></code></pre></td></tr></table></figure><p>浏览器访问：ip:27017</p><p>导入样本数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#官网下载</span><br><span class="hljs-comment">#解压</span><br>tar -xvf dump.tar.gz<br><span class="hljs-comment">#还原数据</span><br>mongorestore -h localhost:27017<br></code></pre></td></tr></table></figure><h3 id="3-2-基本操作"><a href="#3-2-基本操作" class="headerlink" title="3.2 基本操作"></a>3.2 基本操作</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata">&gt;<span class="hljs-keyword">use</span> DATABASE_NAME<br>如果数据库不存在，则创建数据库，否则切换到指定数据库。<br>&gt;<span class="hljs-keyword">use</span> crud<br>switched to <span class="hljs-keyword">db</span> crud<br>&gt;<span class="hljs-keyword">db</span><br>crud<br></code></pre></td></tr></table></figure><h4 id="3-2-1-使用-insert-完成插入操作"><a href="#3-2-1-使用-insert-完成插入操作" class="headerlink" title="3.2.1 使用 insert 完成插入操作"></a>3.2.1 使用 insert 完成插入操作</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">使用 <span class="hljs-keyword">insert</span> 完成插入操作<br>操作格式：<br>db.&lt;集合&gt;.insertOne(&lt;<span class="hljs-type">JSON</span>对象&gt;)<br>db.&lt;集合&gt;.insertMany([&lt;<span class="hljs-type">JSON</span> <span class="hljs-number">1</span>&gt;, &lt;<span class="hljs-type">JSON</span> <span class="hljs-number">2</span>&gt;, …&lt;<span class="hljs-type">JSON</span> n&gt;])<br>示例：<br>db.fruit.insertOne(&#123;<span class="hljs-type">name</span>: &quot;apple&quot;&#125;)<br>db.fruit.insertMany([<br>   &#123;<span class="hljs-type">name</span>: &quot;apple&quot;&#125;,<br>   &#123;<span class="hljs-type">name</span>: &quot;pear&quot;&#125;,<br>   &#123;<span class="hljs-type">name</span>: &quot;orange&quot;&#125;<br>])<br></code></pre></td></tr></table></figure><h4 id="3-2-2-使用-find-查询文档"><a href="#3-2-2-使用-find-查询文档" class="headerlink" title="3.2.2 使用 find 查询文档"></a>3.2.2 使用 find 查询文档</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">关于 find:<br> find 是 MongoDB 中查询数据的基本指令，相当于 SQL 中的SELECT。<br> find 返回的是游标。<br> find 示例：<br>db<span class="hljs-selector-class">.movies</span><span class="hljs-selector-class">.find</span>( &#123; <span class="hljs-string">&quot;year&quot;</span> : <span class="hljs-number">1975</span> &#125; ) <span class="hljs-comment">//单条件查询</span><br>db<span class="hljs-selector-class">.movies</span><span class="hljs-selector-class">.find</span>( &#123; <span class="hljs-string">&quot;year&quot;</span> : <span class="hljs-number">1989</span>, <span class="hljs-string">&quot;title&quot;</span> : <span class="hljs-string">&quot;Batman&quot;</span>&#125; ) <span class="hljs-comment">//多条件and查询</span><br>db<span class="hljs-selector-class">.movies</span><span class="hljs-selector-class">.find</span>( &#123; <span class="hljs-variable">$and</span> : <span class="hljs-selector-attr">[ &#123;<span class="hljs-string">&quot;title&quot;</span> : <span class="hljs-string">&quot;Batman&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;category&quot;</span> : <span class="hljs-string">&quot;action&quot;</span> &#125;]</span> &#125; ) <span class="hljs-comment">// and的另一种形式</span><br>db<span class="hljs-selector-class">.movies</span><span class="hljs-selector-class">.find</span>( &#123; <span class="hljs-variable">$or</span>: <span class="hljs-selector-attr">[&#123;<span class="hljs-string">&quot;year&quot;</span> : 1989&#125;, &#123;<span class="hljs-string">&quot;title&quot;</span> :<span class="hljs-string">&quot;Batman&quot;</span>&#125;]</span> &#125; ) <span class="hljs-comment">//多条件or查询</span><br>db<span class="hljs-selector-class">.movies</span><span class="hljs-selector-class">.find</span>( &#123; <span class="hljs-string">&quot;title&quot;</span> : /^B/&#125; ) <span class="hljs-comment">//按正则表达式查找</span><br></code></pre></td></tr></table></figure><p>空的查询文档{}会匹配集合的全部内容。若是不指定查询文档，默认就是{}</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>linit(n)</td><td>限制查询结果返回数量n</td></tr><tr><td>skip(n)</td><td>跳过指定数目的文档</td></tr><tr><td>sort({key:1 or -1})</td><td>对查询结果进行排序</td></tr><tr><td>explain()</td><td>用于获取查询执行过程报告</td></tr><tr><td>snapshot()</td><td>对查询结果使用快照</td></tr><tr><td>count()</td><td>查询文档的总数量</td></tr></tbody></table><p>游标使用过程：</p><p>（1）声明游标：var cursor=db.collectioName.find({query}, {projection})</p><p>（2）打开游标：cursor.hasNext()判断游标是否已经取到尽头</p><p>（3）读取数据：cursor.Next()取出游标的下一个文档</p><p>（4）关闭游标：cursor.close()此步骤可省略,通常为自动关闭,也可 以显示关闭</p><p>（5）使用print输出游标结果集</p><p>示例： </p><p>1.声明游标 var cursor = db.orders.find() </p><p>2.使用printjson输出游标结果集： while (cursor.hasNext()) { print(tojson(cursor.next())) }</p><p><strong>查询条件对照表</strong></p><table><thead><tr><th>SQL</th><th>MQL</th></tr></thead><tbody><tr><td>a = 1</td><td>{ a : 1 }</td></tr><tr><td>a &lt;&gt; 1</td><td>{ a: {$ne: 1}}</td></tr><tr><td>a &gt; 1</td><td>{ a: {$gt: 1}}</td></tr><tr><td>a &gt;= 1</td><td>{ a: {$gte: 1}}</td></tr><tr><td>a &lt; 1</td><td>{ a: {$lt: 1}}</td></tr><tr><td>a &lt;= 1</td><td>{ a: {$lte: 1}}</td></tr></tbody></table><p><strong>查询逻辑对照表</strong></p><table><thead><tr><th>SQL</th><th>MQL</th></tr></thead><tbody><tr><td>a = 1 ADN b = 1</td><td>{a: 1,b: 1} 或{$and: [{a:1}，{b: 1}]}</td></tr><tr><td>a = 1 OR b = 1</td><td>{$or:[{a:1},{b:1}]}</td></tr><tr><td>a IS NULL</td><td>{a: {$exists: false}}</td></tr><tr><td>a IN (1,2,3)</td><td>{a:{$in: [1,2,3]}}</td></tr></tbody></table><table><thead><tr><th>查询逻辑逻辑运算符</th></tr></thead><tbody><tr><td>$lt: 存在并小于</td></tr><tr><td>$lte: 存在并小于等于</td></tr><tr><td>$gt: 存在并大于</td></tr><tr><td>$gte: 存在并大于等于</td></tr><tr><td>$ne: 不存在或存在但不等于</td></tr><tr><td>$in: 存在并在指定数组中</td></tr><tr><td>$nin: 不存在或不在指定数组中</td></tr><tr><td>$or: 匹配两个或多个条件中的一个</td></tr><tr><td>$and: 匹配全部条件</td></tr></tbody></table><h4 id="3-2-3-使用-find-搜索子文档"><a href="#3-2-3-使用-find-搜索子文档" class="headerlink" title="3.2.3 使用 find 搜索子文档"></a>3.2.3 使用 find 搜索子文档</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">find</span> 支持使用“field.sub_field”的形式查询子文档。假设有一个文档：<br>db.fruit.insertOne(&#123;<br>    name: <span class="hljs-string">&quot;apple&quot;</span>,<br>    <span class="hljs-keyword">from</span>: &#123;<br>        country: <span class="hljs-string">&quot;China&quot;</span>,<br>        province: <span class="hljs-string">&quot;Guangdon&quot;</span><br>   &#125;<br>&#125;)<br>考虑以下查询的意义：<br>db.fruit.<span class="hljs-built_in">find</span>( &#123; <span class="hljs-string">&quot;from.country&quot;</span> : <span class="hljs-string">&quot;China&quot;</span> &#125; ) 上面这条是要查询 要查询子文档，<span class="hljs-keyword">from</span>.country<br>db.fruit.<span class="hljs-built_in">find</span>( &#123; <span class="hljs-string">&quot;from&quot;</span> : &#123;country: <span class="hljs-string">&quot;China&quot;</span>&#125; &#125;) 这条要找文档里面有一个<span class="hljs-keyword">from</span>字段，<span class="hljs-keyword">from</span>字段的值为<span class="hljs-attribute">country</span>=<span class="hljs-string">&quot;China&quot;</span><br>如果要查询子文档，必须在子文档里写上路径<br></code></pre></td></tr></table></figure><h4 id="3-2-4-使用-find-搜索数组"><a href="#3-2-4-使用-find-搜索数组" class="headerlink" title="3.2.4 使用 find 搜索数组"></a>3.2.4 使用 find 搜索数组</h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mel">find 支持对数组中的元素进行搜索。假设有一个文档：<br>db.fruit.insert([<br>   &#123; <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-keyword">color</span>: [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span> ] &#125;,<br>   &#123; <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;Mango&quot;</span>, <span class="hljs-keyword">color</span>: [<span class="hljs-string">&quot;yellow&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>] &#125;<br>])<br>考虑以下查询的意义：db.fruit.find(&#123;<span class="hljs-keyword">color</span>: <span class="hljs-string">&quot;red&quot;</span>&#125;) <span class="hljs-comment">//查找颜色为红色的水果有哪些</span><br>db.fruit.find(&#123;$or: [&#123;<span class="hljs-keyword">color</span>: <span class="hljs-string">&quot;red&quot;</span>&#125;, &#123;<span class="hljs-keyword">color</span>:<span class="hljs-string">&quot;yellow&quot;</span>&#125;]&#125;) <span class="hljs-comment">// 查找颜色为红色和黄色的水果有哪些</span><br></code></pre></td></tr></table></figure><h4 id="3-2-5-使用-find-搜索数组中的对象"><a href="#3-2-5-使用-find-搜索数组中的对象" class="headerlink" title="3.2.5 使用 find 搜索数组中的对象"></a>3.2.5 使用 find 搜索数组中的对象</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stata">考虑以下文档，在其中搜索<br><span class="hljs-keyword">db</span>.movies.insertOne( &#123;<br>    <span class="hljs-string">&quot;title&quot;</span> : <span class="hljs-string">&quot;Raiders of the Lost Ark&quot;</span>,<br>    <span class="hljs-string">&quot;filming_locations&quot;</span> : [<br>       &#123; <span class="hljs-string">&quot;city&quot;</span> : <span class="hljs-string">&quot;Los Angeles&quot;</span>, <span class="hljs-string">&quot;state&quot;</span> : <span class="hljs-string">&quot;CA&quot;</span>, <span class="hljs-string">&quot;country&quot;</span> : <span class="hljs-string">&quot;USA&quot;</span> &#125;,<br>       &#123; <span class="hljs-string">&quot;city&quot;</span> : <span class="hljs-string">&quot;Rome&quot;</span>, <span class="hljs-string">&quot;state&quot;</span> : <span class="hljs-string">&quot;Lazio&quot;</span>, <span class="hljs-string">&quot;country&quot;</span> : <span class="hljs-string">&quot;Italy&quot;</span> &#125;,<br>       &#123; <span class="hljs-string">&quot;city&quot;</span> : <span class="hljs-string">&quot;Florence&quot;</span>, <span class="hljs-string">&quot;state&quot;</span> : <span class="hljs-string">&quot;SC&quot;</span>, <span class="hljs-string">&quot;country&quot;</span> : <span class="hljs-string">&quot;USA&quot;</span> &#125;<br>     ]<br>&#125;)<br><span class="hljs-comment">// 查找城市是 Rome 的记录</span><br><span class="hljs-keyword">db</span>.movies.find(&#123;<span class="hljs-string">&quot;filming_locations.city&quot;</span>: <span class="hljs-string">&quot;Rome&quot;</span>&#125;).pretty()<br></code></pre></td></tr></table></figure><h4 id="3-2-6-模糊查询Like"><a href="#3-2-6-模糊查询Like" class="headerlink" title="3.2.6 模糊查询Like"></a>3.2.6 模糊查询Like</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">db.movies.<span class="hljs-keyword">find</span>(&#123;<span class="hljs-string">&quot;filming_locations.city&quot;</span>: <span class="hljs-regexp">/Rome/</span>&#125;).pretty()<br>采用 <span class="hljs-regexp">/ /</span>,中间就是模糊查询的内容，比如：“<span class="hljs-regexp">/ Rome /</span>”，查询名字包含：Rome,如果是以什么开头就在左边增加^ 反之亦然<br></code></pre></td></tr></table></figure><h4 id="3-2-7-正则使用"><a href="#3-2-7-正则使用" class="headerlink" title="3.2.7 正则使用"></a>3.2.7 正则使用</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">&#123;&lt;field&gt;: &#123;<span class="hljs-symbol">$rege</span>x: <span class="hljs-regexp">/pattern/</span>, <span class="hljs-symbol">$optio</span>ns: <span class="hljs-string">&#x27;&#x27;</span>&#125; &#125;<br>db.movies.<span class="hljs-built_in">find</span>(&#123;<span class="hljs-string">&quot;filming_locations.city&quot;</span>: &#123;<span class="hljs-symbol">$rege</span>x:<span class="hljs-regexp">/Rome/</span>&#125; &#125;).pretty()<br></code></pre></td></tr></table></figure><h4 id="3-2-8-使用-find-搜索数组中的对象，相当于是内联外联"><a href="#3-2-8-使用-find-搜索数组中的对象，相当于是内联外联" class="headerlink" title="3.2.8 使用 find 搜索数组中的对象，相当于是内联外联"></a>3.2.8 使用 find 搜索数组中的对象，相当于是内联外联</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">在数组中搜索子对象的多个字段时，如果使用 <span class="hljs-variable">$elemMatch</span>，它表示必须是同一个子对象满足多个条件。考虑以下两个查询：<br>db.getCollection(<span class="hljs-string">&#x27;movies&#x27;</span>).<span class="hljs-built_in">find</span>(&#123;<br>        <span class="hljs-string">&quot;filming_locations.city&quot;</span>: <span class="hljs-string">&quot;Rome&quot;</span>,<br>        <span class="hljs-string">&quot;filming_locations.country&quot;</span>: <span class="hljs-string">&quot;USA&quot;</span><br>&#125;)<br>db.getCollection(<span class="hljs-string">&#x27;movies&#x27;</span>).<span class="hljs-built_in">find</span>(&#123; <span class="hljs-string">&quot;filming_locations&quot;</span>: &#123; <span class="hljs-variable">$elemMatch</span>:&#123;<span class="hljs-string">&quot;city&quot;</span>:<span class="hljs-string">&quot;Rome&quot;</span>, <span class="hljs-string">&quot;country&quot;</span>: <span class="hljs-string">&quot;USA&quot;</span>&#125;&#125;&#125;)<br></code></pre></td></tr></table></figure><h4 id="3-2-9-控制-find-返回的字段"><a href="#3-2-9-控制-find-返回的字段" class="headerlink" title="3.2.9 控制 find 返回的字段"></a>3.2.9 控制 find 返回的字段</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">find</span> 可以指定只返回指定的字段：_id字段必须明确指明不返回，否则默认返回；在 MongoDB 中我们称这为投影（projection）；<br> <span class="hljs-attribute">db</span>.movies.find(&#123;<span class="hljs-string">&quot;category&quot;</span>: <span class="hljs-string">&quot;action&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-number">0</span> (<span class="hljs-number">0</span>代表不返回id), title:<span class="hljs-number">1</span> (<span class="hljs-number">1</span> 代表返回title)&#125;)<br> <span class="hljs-attribute">db</span>.movies.find(&#123;&#125;,&#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-number">0</span> , title:<span class="hljs-number">1</span> &#125;)<br></code></pre></td></tr></table></figure><h4 id="3-2-10-使用-remove-删除文档"><a href="#3-2-10-使用-remove-删除文档" class="headerlink" title="3.2.10 使用 remove 删除文档"></a>3.2.10 使用 remove 删除文档</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">remove 命令需要配合查询条件使用；<br>● 匹配查询条件的的文档会被删除；<br>● 指定一个空文档条件会删除所有文档；<br>● 以下示例：<br>db<span class="hljs-selector-class">.testcol</span><span class="hljs-selector-class">.remove</span>( &#123; <span class="hljs-selector-tag">a</span> : <span class="hljs-number">1</span> &#125; ) <span class="hljs-comment">// 删除a等于1的记录</span><br>db<span class="hljs-selector-class">.testcol</span><span class="hljs-selector-class">.remove</span>( &#123; <span class="hljs-selector-tag">a</span> : &#123; <span class="hljs-variable">$lt</span> : <span class="hljs-number">5</span> &#125; &#125; ) <span class="hljs-comment">// 删除a小于5的记录</span><br>db<span class="hljs-selector-class">.testcol</span><span class="hljs-selector-class">.remove</span>( &#123;&#125; ) <span class="hljs-comment">// 删除所有记录</span><br>db<span class="hljs-selector-class">.testcol</span><span class="hljs-selector-class">.remove</span>() <span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure><h4 id="3-2-11-使用-update-更新文档"><a href="#3-2-11-使用-update-更新文档" class="headerlink" title="3.2.11 使用 update 更新文档"></a>3.2.11 使用 update 更新文档</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php">Update 操作执行格式：db.&lt;集合&gt;.<span class="hljs-title function_ invoke__">update</span>(&lt;查询条件&gt;, &lt;更新字段&gt;)<br>以下数据为例：<br>db.fruit.<span class="hljs-title function_ invoke__">insertMany</span>([<br>   &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;apple&quot;</span>&#125;,<br>   &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;pear&quot;</span>&#125;,<br>   &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;orange&quot;</span>&#125;<br>])<br>db.fruit.<span class="hljs-title function_ invoke__">updateOne</span>(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;apple&quot;</span>&#125;, &#123;<span class="hljs-variable">$set</span>: &#123;<span class="hljs-attr">from</span>:<span class="hljs-string">&quot;China&quot;</span>&#125;&#125;)<br>查询 name 为 apple 的记录，将找到记录的 <span class="hljs-keyword">from</span> 设置为 China<br><br>使用 updateOne 表示无论条件匹配多少条记录，始终只更新第一条；<br>使用 updateMany 表示条件匹配多少条就更新多少条；<br>updateOne/updateMany 方法要求更新条件部分必须具有以下之一，否则将报错：<br><span class="hljs-variable">$set</span>/<span class="hljs-variable">$unset</span><br><span class="hljs-variable">$push</span>/<span class="hljs-variable">$pushAll</span>/<span class="hljs-variable">$pop</span><br><span class="hljs-variable">$pull</span>/<span class="hljs-variable">$pullAll</span><br><span class="hljs-variable">$addToSet</span><br><span class="hljs-comment">// 报错</span><br>db.fruit.<span class="hljs-title function_ invoke__">updateOne</span>(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;apple&quot;</span>&#125;, &#123;<span class="hljs-attr">from</span>: <span class="hljs-string">&quot;China&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><h4 id="3-2-12-使用-update-更新数组"><a href="#3-2-12-使用-update-更新数组" class="headerlink" title="3.2.12 使用 update 更新数组"></a>3.2.12 使用 update 更新数组</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">● <span class="hljs-symbol">$pus</span>h: 增加一个对象到数组底部<br>● <span class="hljs-symbol">$pus</span>hAll: 增加多个对象到数组底部<br>● <span class="hljs-symbol">$pop</span>: 从数组底部删除一个对象<br>● <span class="hljs-symbol">$pull</span>: 如果匹配指定的值，从数组中删除相应的对象<br>● <span class="hljs-symbol">$pullAll</span>: 如果匹配任意的值，从数据中删除相应的对象<br>● <span class="hljs-symbol">$addToSet</span>: 如果不存在则增加一个值到数组<br></code></pre></td></tr></table></figure><h4 id="3-2-13-使用-drop-删除集合"><a href="#3-2-13-使用-drop-删除集合" class="headerlink" title="3.2.13 使用 drop 删除集合"></a>3.2.13 使用 drop 删除集合</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">● 使用 <span class="hljs-keyword">db</span>.&lt;集合&gt;.<span class="hljs-keyword">drop</span>() 来删除一个集合<br>● 集合中的全部文档都会被删除<br>● 集合相关的索引也会被删除<br><span class="hljs-keyword">db</span>.colToBeDropped.<span class="hljs-keyword">drop</span>()<br></code></pre></td></tr></table></figure><h4 id="3-2-14-使用-dropDatabase-删除数据库"><a href="#3-2-14-使用-dropDatabase-删除数据库" class="headerlink" title="3.2.14 使用 dropDatabase 删除数据库"></a>3.2.14 使用 dropDatabase 删除数据库</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss">● 使用 db.dropDatabase() 来删除数据库<br>● 数据库相应文件也会被删除，磁盘空间将被释放<br><span class="hljs-keyword">use</span> tempDB<br>db.dropDatabase()<br><span class="hljs-keyword">show</span> collections <span class="hljs-comment">// No collections</span><br><span class="hljs-keyword">show</span> dbs <span class="hljs-comment">// The db is gone</span><br></code></pre></td></tr></table></figure><h3 id="3-3-SpringBoot整合"><a href="#3-3-SpringBoot整合" class="headerlink" title="3.3 SpringBoot整合"></a>3.3 SpringBoot整合</h3><p>添加pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-lang<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">## 端口号</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">8084</span><br><span class="hljs-comment">## 服务名称</span><br><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">mongodb-application</span><br><span class="hljs-comment">## mongodb配置</span><br><span class="hljs-attr">spring.data.mongodb.host</span>=<span class="hljs-string">47.113.147.179</span><br><span class="hljs-attr">spring.data.mongodb.port</span>=<span class="hljs-string">27017</span><br><span class="hljs-comment">#spring.data.mongodb.username=</span><br><span class="hljs-comment">#spring.data.mongodb.password=</span><br><span class="hljs-attr">spring.data.mongodb.database</span>=<span class="hljs-string">springboot_db</span><br><span class="hljs-comment">#spring.data.mongodb.uri=mongodb://name:password@localhost:27017/test</span><br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> MongoTemplate mongoTemplate;<br></code></pre></td></tr></table></figure><h3 id="3-4-聚合查询"><a href="#3-4-聚合查询" class="headerlink" title="3.4 聚合查询"></a>3.4 聚合查询</h3><blockquote><p>分析性、统计型的场景、复杂数据的计算和处理</p></blockquote><p>MongoDB 聚合框架（Aggregation Framework）是一个计算框架，它可以：作用在一个或几个集合上；对集合中的数据进行的一系列运算，比如数据的计算；将这些数据转化为期望的形式，比如类型的处理。从效果而言，聚合框架相当于 SQL 查询中的：GROUP BY，LEFT OUTER JOIN，AS 等</p><h4 id="3-4-1-管道-Pipeline-和步骤-Stage"><a href="#3-4-1-管道-Pipeline-和步骤-Stage" class="headerlink" title="3.4.1 管道(Pipeline)和步骤(Stage)"></a>3.4.1 管道(Pipeline)和步骤(Stage)</h4><p>整个聚合运算过程称为管道（Pipeline），它是由多个步骤 （Stage）组成的， 每个管道：</p><ol><li>接受一系列文档（原始数据）；</li><li> 每个步骤对这些文档进行一系列运算；</li><li> 结果文档输出给下一个步骤；</li></ol><h4 id="3-4-2-聚合运算的基本格式"><a href="#3-4-2-聚合运算的基本格式" class="headerlink" title="3.4.2 聚合运算的基本格式"></a>3.4.2 聚合运算的基本格式</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">pipeline = [<span class="hljs-variable">$stage1</span>, <span class="hljs-variable">$stage2</span>, ...<span class="hljs-variable">$stageN</span>]; // 这个pipeline 就是一系列的计算步骤组成<br>db.&lt;COLLECTION&gt;.aggregate(<br>   pipeline,<br>   &#123; options &#125;<br>);<br></code></pre></td></tr></table></figure><p><strong>常见步骤</strong></p><table><thead><tr><th>步骤</th><th>作用</th><th>SQL等价运算符</th></tr></thead><tbody><tr><td>$match</td><td>过滤</td><td>WHERE</td></tr><tr><td>$project</td><td>投影</td><td>AS</td></tr><tr><td>$sort</td><td>排序</td><td>ORDER BY</td></tr><tr><td>$group</td><td>分组</td><td>GROUP BY</td></tr><tr><td>$skip/$limit</td><td>结果限制</td><td>SKIP/LIMIT</td></tr><tr><td>$lookup</td><td>左外连接</td><td>LEFT OUTER JOIN</td></tr><tr><td>$unwind</td><td>展开数组</td><td></td></tr><tr><td>$graphLookup</td><td>图搜索</td><td></td></tr><tr><td>$facet/$bucket</td><td>分面搜索</td><td></td></tr></tbody></table><p><strong>常见步骤中的运算符</strong></p><table><thead><tr><th>$match</th><th>$project</th><th>$group</th></tr></thead><tbody><tr><td>查询过滤 $eq/ $gt/ $gte/ $lt/ $lte/</td><td>选择需要的或者排除不 需要的字段 $map/ $reduce/ $filter</td><td>聚合计算 $sum/ $avg</td></tr><tr><td>$and/ $or/ $not/ $in</td><td>$range</td><td>$push/ $addToSet</td></tr><tr><td>$geoWithin/ $intersect …</td><td>$multipy/ $divide/ $substract/ $add …</td><td>$first/ $last/ $max/ $min …</td></tr></tbody></table><p><strong>MQL 常用步骤与 SQL 对比</strong></p><p><img src="/image/MongoDB/1.png"></p><p><img src="/image/MongoDB/2.png"></p><h4 id="3-4-3-MQL特有步骤-unwind"><a href="#3-4-3-MQL特有步骤-unwind" class="headerlink" title="3.4.3 MQL特有步骤 $unwind"></a>3.4.3 MQL特有步骤 $unwind</h4><p>在做报表的时候，可能需要把用户的分数展出来，可以利用 MongoDB的 $unwind 把整个数组的数据展出来变成一行一行展示。</p><p><img src="/image/MongoDB/3.png"></p><h4 id="3-4-4-MQL特有步骤-bucket"><a href="#3-4-4-MQL特有步骤-bucket" class="headerlink" title="3.4.4 MQL特有步骤 $bucket"></a>3.4.4 MQL特有步骤 $bucket</h4><p>如果是在做电商目录和产品数量会非常有用，需要统计一下商品，100块钱的商品有多少、200的有多少，这个运算的话就不需要一个个去查询，然后再后面通过union或者是程序代码来汇总了.</p><p><img src="/image/MongoDB/4.png"></p><h4 id="3-4-5-MQL-特有步骤-facet"><a href="#3-4-5-MQL-特有步骤-facet" class="headerlink" title="3.4.5 MQL 特有步骤 $facet"></a>3.4.5 MQL 特有步骤 $facet</h4><p>更高阶的应用，把$bucket 组合起来使用，比如需要统计更多纬度和更复杂的需求的时候，这个$facet ，可以把多个纬度的需求放在同一个查询来完成</p><p><img src="/image/MongoDB/5.png"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Minio原理分析</title>
    <link href="/2023/05/10/%E4%B8%AD%E9%97%B4%E4%BB%B6/minio/Minio%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <url>/2023/05/10/%E4%B8%AD%E9%97%B4%E4%BB%B6/minio/Minio%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Minio分布式存储原理"><a href="#1-Minio分布式存储原理" class="headerlink" title="1 Minio分布式存储原理"></a>1 Minio分布式存储原理</h2><p>MinIO是一款自称是高性能，分布式对象存储服务器的软件，在MinIO的设计中，每个MinIO服务器都是相互独立的节点，共同存储对象数据，MinIO采用分布式架构，并将这些节点联合起来形成一个集群，以便更好的负载均衡，提高性能和可伸缩性，是一个去中心化的设计。</p><p>MinIO在分布式存储实现中引入了一种可扩展哈希表数据结构，其具有很好的可扩展性和动态伸缩性，同时还能够支持高并发读取和写入操作。当一个新对象存储到MinIO集群中时，MinIO节点会根据哈希函数计算出该对象的存储地址，对该对象进行切分和编码，然后将切分片段和冗余因子存储在不同的MinIO节点上。</p><p>MinIO集群中的所有节点通过一致性哈希（Consistent Hashing）算法实现数据的负载均衡与故障恢复。一致性哈希算法是一种用于动态增删节点的分布式哈希算法，它能保证极高的数据迁移效率。</p><p>具体的处理流程如下：</p><ol><li><p>通过哈希函数计算出对象的存储节点。</p></li><li><p>将对象切分为多个数据块，并通过Reed-Solomon纠删码技术编码，生成校验块。</p></li><li><p>将数据块和校验块按块组合的方式存储在各个节点中。</p></li><li><p>在对象读取时，根据哈希函数计算出对象对应的节点地址，到该节点地址所在的MinIO节点上读取数据。</p></li><li><p>如果某个MinIO节点出现故障，那么它上面的数据就会自动迁移到其他存储节点上，从而保证数据的高可用性和冗余机制。</p></li></ol><p>通过以上的数据分片和分散，保证了数据安全、高可用性、高负载均衡和高读写性能等多方面的需求。</p><p><strong>Minio数据一致性问题</strong>，是通过dsync分布式锁管理器解决的：</p><ul><li>任何一个节点的锁请求都会广播给集群内的所有在线节点</li><li>如果收到N/2+1个节点的同意，则获取所成功 </li><li>通过stale lock检测机制，判断节点的状态及持有锁情况</li></ul><h2 id="2-Minio对象存储和元数据"><a href="#2-Minio对象存储和元数据" class="headerlink" title="2 Minio对象存储和元数据"></a>2 Minio对象存储和元数据</h2><p>MinIO是一款对象存储服务器，主要用于存储非结构化的数据，例如各种类型的文件等。在存储对象的同时，MinIO还会生成对象的元数据，用于描述对象的基本信息。</p><p>在MinIO中，每个对象都有一个唯一的对象名（Object Name），类似于文件系统中的文件名。而Bucket则用于组织和管理对象，相当于文件系统中的目录。</p><p>除了Object Name和Bucket，每个对象还有一些其他的元数据，包括对象大小、对象的创建和修改时间、对象的MIME type等。这些元数据可以在创建对象时一并设置，也可以通过修改元数据接口进行修改。另外MinIO还支持自定义元数据，用户可以通过配置存储策略来自动添加自定义元数据。</p><p>MinIO的元数据存储采用了键-值(key-value)的存储方式，并且将元数据存储在一个扁平的键值对集合中，其中键值对可以表示出对象所属的Bucket和Object。元数据存储使用了etcd这样的轻量级分布式键值存储系统，确保元数据的高可靠性和实时更新，同时也保证了元数据的高效读写。</p><p>除了以上的元数据，MinIO还支持用户在使用过程中自定义一些额外的元数据，例如某个对象的归属者、某个对象的使用权限等等。这些元数据分别对应不同的系统配置，有利于实现更加复杂的对象访问控制、元数据管理以及其他高级功能，如利用元数据来实现搜索等功能。</p><p>综上所述，MinIO提供了完善的对象存储和元数据管理机制，帮助用户高效存储和管理大量的非结构化数据，并支持自定义元数据来实现更加复杂的业务需求。</p><h2 id="3-Minio纠删码"><a href="#3-Minio纠删码" class="headerlink" title="3 Minio纠删码"></a>3 Minio纠删码</h2><p>MinIO是一个基于对象存储的开源云存储服务。纠删码是MinIO用于数据容错的关键技术之一。</p><p>纠删码是一种冗余数据存储技术，可以将原始数据切分成多个片段，并计算出若干冗余数据进行存储。当部分数据片段损坏或者丢失时，通过计算冗余数据，可以恢复出原始数据。</p><p>MinIO的纠删码实现采用了Reed-Solomon纠删码算法。Reed-Solomon算法通过布洛赫乘法（Blomberger Multiplication）在有限域上进行计算，将原始数据切分成若干个数据块（Data Block），并计算出若干个校验块（Parity Block）进行冗余存储。具体步骤如下：</p><ol><li><p>将原始数据划分为多个数据块。</p></li><li><p>计算出若干校验块。</p></li><li><p>将所有数据块和校验块按顺序拼接成一个大的数据块，并对其进行编码。</p></li><li><p>对编码后的数据块进行切分，得到多个“条带”（Stripe）。</p></li><li><p>在实际存储时，将每个条带拆分为若干数据块和校验块，并在不同的存储节点上进行存储。具体方式可以采用多个存储节点进行副本存储、通过容错码实现块的冗余存储等。</p></li><li><p>当数据损坏或丢失时，通过计算校验块进行数据恢复。</p></li></ol><p>MinIO中的Reed-Solomon实现比较高效，通常情况下只需要4-6个校验块就可以实现数据冗余，极大提高了数据的容错能力。同时，在存储大文件时，MinIO会自动将文件切分成若干个条带，可以充分利用存储节点的存储带宽和磁盘读写能力。</p><h2 id="4-Minio权限控制策略"><a href="#4-Minio权限控制策略" class="headerlink" title="4 Minio权限控制策略"></a>4 Minio权限控制策略</h2><p>MinIO提供了细粒度的权限控制策略，方便管理员根据需要对存储桶、对象和目录设置各项权限。</p><p>MinIO权限控制采用AWS S3的访问策略来设置权限。一个访问策略是一个JSON格式的文本，描述了用户或者群组能够对MinIO上的哪些资源进行哪些操作。</p><p>下面是一个权限控制示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;s3:ListBucket&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;arn:aws:s3:::mybucket&quot;</span><span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;s3:GetObject&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;arn:aws:s3:::mybucket/myfolder/*&quot;</span><span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>本示例中，权限控制规则包括两项：允许用户列出 mybucket 里面的内容；允许用户读取 mybucket/myfolder 文件夹下的所有对象。</p><p>下面是一个常见的权限控制策略的代码示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;s3:GetBucketLocation&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;s3:ListBucket&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;arn:aws:s3:::my-bucket&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;s3:GetObject&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;s3:PutObject&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;arn:aws:s3:::my-bucket/my-folder/*&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;AWS&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>          <span class="hljs-string">&quot;arn:aws:iam::123456789012:user/username&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-string">&quot;arn:aws:iam::123456789012:role/rolename&quot;</span><br>        <span class="hljs-punctuation">]</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>本策略允许任何人进行 my-bucket 存储桶的读和列出操作，允许指定的用户或角色进行 my-bucket/my-folder 存储桶下文件夹中的对象的读和写操作。</p><p>除了上述的简单设置外，MinIO还支持更加复杂的权限控制规则，例如基于 IP 地址、时间戳、Requester、Referer 来限制访问等等。</p><p>总之，MinIO提供了完善而细致的权限控制策略，可以根据业务需要灵活设置，同时也支持更加高级的权限控制方式的实现。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Minio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Minio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes存储与进阶</title>
    <link href="/2023/05/08/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/k8s/Kubernetes%E5%AD%98%E5%82%A8%E4%B8%8E%E8%BF%9B%E9%98%B6/"/>
    <url>/2023/05/08/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/k8s/Kubernetes%E5%AD%98%E5%82%A8%E4%B8%8E%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="1-K8s-Storage"><a href="#1-K8s-Storage" class="headerlink" title="1 K8s Storage"></a>1 K8s Storage</h2><p><a href="https://kubernetes.io/docs/concepts/storage/">https://kubernetes.io/docs/concepts/storage/</a></p><h3 id="1-1-Volume"><a href="#1-1-Volume" class="headerlink" title="1.1 Volume"></a>1.1 Volume</h3><p>（1）定义一个pod，其中包含两个container</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">volume-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volume-pod</span> <span class="hljs-comment"># 使用哪个volume</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/nginx-volume</span> <span class="hljs-comment"># 对应container中的路径</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">busybox-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&#x27;echo The app is running! &amp;&amp; sleep 3600&#x27;</span>]<br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volume-pod</span> <span class="hljs-comment"># 使用哪个volume</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/busybox-volume</span> <span class="hljs-comment"># 对应container中的路径</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volume-pod</span> <span class="hljs-comment"># volume名称</span><br>    <span class="hljs-attr">hostPath:</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/tmp/volume-pod</span> <span class="hljs-comment"># volume对应的宿主机路径</span><br></code></pre></td></tr></table></figure><p>（2）根据文件创建Pod并查看运行情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建Pod</span><br>kubectl apply -f volume-pod.yaml<br><span class="hljs-comment"># 查看Pod运行情况</span><br>kubectl get pods -o wide<br>kubectl describe pod volume-pod<br><span class="hljs-comment"># 来到Pod运行的worker节点，比如w1</span><br>docker ps | grep volume-pod<br><span class="hljs-comment"># 查看Pod Volume对应的宿主机路径</span><br><span class="hljs-built_in">ls</span> /tmp/volume-pod<br><span class="hljs-comment"># 进入到两个容器中，查看容器对应的路径</span><br>docker <span class="hljs-built_in">exec</span> -it containerid sh<br><span class="hljs-built_in">ls</span> /busybox-volume<br><span class="hljs-built_in">ls</span> /nginx-volume<br><span class="hljs-comment"># 在容器中创建文件或者在宿主机上创建文件，看看是否同步，发现是同步的，说明Pod里面的Container是共享volume的</span><br><span class="hljs-comment"># 查看两个container中的hosts文件是否一样，发现也是一样的，说明Pod里面的Container是共享network的</span><br>docker <span class="hljs-built_in">exec</span> -it containerid <span class="hljs-built_in">cat</span> /etc/hosts<br></code></pre></td></tr></table></figure><h3 id="1-2-PV-PVC-Pod介绍"><a href="#1-2-PV-PVC-Pod介绍" class="headerlink" title="1.2 PV PVC Pod介绍"></a>1.2 PV PVC Pod介绍</h3><h4 id="1-2-1-PersistentVolume-PV"><a href="#1-2-1-PersistentVolume-PV" class="headerlink" title="1.2.1 PersistentVolume-PV"></a>1.2.1 PersistentVolume-PV</h4><p><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistent-volumes">https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistent-volumes</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pv</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">capacity:</span><br>    <span class="hljs-attr">storage:</span> <span class="hljs-string">5Gi</span> <span class="hljs-comment"># 存储空间大小</span><br>  <span class="hljs-attr">volumeMode:</span> <span class="hljs-string">Filesystem</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span> <span class="hljs-comment"># 只允许一个Pod进行独占式读写操作</span><br>  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-string">Recycle</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">slow</span><br>  <span class="hljs-attr">mountOptions:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">hard</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">nfsvers=4.1</span><br>  <span class="hljs-attr">nfs:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/tmp</span> <span class="hljs-comment"># 远端服务器的目录</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span> <span class="hljs-comment"># 远端的服务器</span><br></code></pre></td></tr></table></figure><h4 id="1-2-2-PersistentVolumeClaim-PVC"><a href="#1-2-2-PersistentVolumeClaim-PVC" class="headerlink" title="1.2.2 PersistentVolumeClaim-PVC"></a>1.2.2 PersistentVolumeClaim-PVC</h4><p><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims">https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">myclaim</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>  <span class="hljs-attr">volumeMode:</span> <span class="hljs-string">Filesystem</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">8Gi</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">slow</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">release:</span> <span class="hljs-string">&quot;stable&quot;</span><br>    <span class="hljs-attr">matchExpressions:</span><br>      <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">key:</span> <span class="hljs-string">environment</span>, <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span>, <span class="hljs-attr">values:</span> [<span class="hljs-string">dev</span>]&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-3-Pod使用PVC"><a href="#1-2-3-Pod使用PVC" class="headerlink" title="1.2.3  Pod使用PVC"></a>1.2.3  Pod使用PVC</h4><p><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#claims-as-volumes">https://kubernetes.io/docs/concepts/storage/persistent-volumes/#claims-as-volumes</a></p><p>（1）前提是PV和PVC已经绑定在一起，也就是PV能够满足PVC的要求 </p><p>（2）同时PV和PVC的storageClassName要一样</p><p>（3）PersistentVolumeController会发现两者有关系，然后将PV的名字添加在PVC中，这样就建立了绑定关系</p><h3 id="1-3-PV-PVC-Pod实战"><a href="#1-3-PV-PVC-Pod实战" class="headerlink" title="1.3 PV PVC Pod实战"></a>1.3 PV PVC Pod实战</h3><p>需求：Nginx持久化存储，步骤：1.共享存储使用NFS，比如选择在master节点 。2.创建PV和PV。3.Nginx Pod中使用PVC</p><p><strong>NFC简介</strong>：NFS(network file system)网络文件系统，是FreeBSD支持的文件系统中的一种，允许网络中的计算机之间通过TCP/IP网络共享资源</p><ol><li>Master节点搭建NFS</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#安装nfs</span><br>yum install -y nfs-utils<br><span class="hljs-comment"># 创建nfs目录</span><br><span class="hljs-built_in">mkdir</span> -p /nfs/data/<br><span class="hljs-built_in">mkdir</span> -p /nfs/data/nginx<br><span class="hljs-comment"># 授予权限</span><br><span class="hljs-built_in">chmod</span> -R 777 /nfs/data<br><span class="hljs-comment"># 配置exports文件</span><br>: vi /etc/exports<br>/nfs/data *(rw,no_root_squash,<span class="hljs-built_in">sync</span>)<br><span class="hljs-comment"># 使得配置生效</span><br>exportfs -r<br><span class="hljs-comment"># 查看生效</span><br>exportfs<br><span class="hljs-comment"># 启动rpcbind、nfs服务</span><br>systemctl restart rpcbind &amp;&amp; systemctl <span class="hljs-built_in">enable</span> rpcbind<br>systemctl restart nfs &amp;&amp; systemctl <span class="hljs-built_in">enable</span> nfs<br><span class="hljs-comment"># 查看rpc服务的注册情况</span><br>rpcinfo -p localhost<br><span class="hljs-comment"># showmount测试</span><br>showmount -e master-ip<br></code></pre></td></tr></table></figure><ol start="2"><li>定义PV，PVC和Pod文件</li></ol><blockquote><p>nginx-pv-pvc-demo.yaml</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 定义PV</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-pv</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteMany</span><br>  <span class="hljs-attr">capacity:</span><br>    <span class="hljs-attr">storage:</span> <span class="hljs-string">2Gi</span><br>  <span class="hljs-attr">nfs:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/nfs/data/nginx</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.51</span> <span class="hljs-comment"># master节点的ip</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 定义PVC，用于绑定PV,自动根据accessModes和storage绑定，多种参数绑定形式。</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-pvc</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteMany</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">2Gi</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 定义Nginx Pod，指定需要使用的PVC</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-persistent-storage</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>      <span class="hljs-attr">volumes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-persistent-storage</span><br>          <span class="hljs-attr">persistentVolumeClaim:</span><br>          <span class="hljs-attr">claimName:</span> <span class="hljs-string">nginx-pvc</span><br></code></pre></td></tr></table></figure><ol start="3"><li>创建资源并测试</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 根据yaml文件创建资源：pod、pv、pvc</span><br>kubectl apply -f nginx-pv-pvc-demo.yaml<br><span class="hljs-comment"># 查看资源</span><br>kubectl get pv,pvc<br>kubectl get pods -o wide<br>kubectl describe pod nginx<br>kubectl describe pv nginx-pv<br>kubectl describe pvc nginx-pvc<br><span class="hljs-comment"># 在master对应的nfs/data/nginx中新建jack.html</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello jack pv pvc pod.&quot;</span> &gt; jack.html<br><span class="hljs-comment"># 进入nginx容器查看/usr/share/nginx/html</span><br>kubectl get pods -o wide<br>docker <span class="hljs-built_in">exec</span> -it containerid sh<br><span class="hljs-built_in">ls</span> /usr/share/nginx/html<br><span class="hljs-built_in">cat</span> /usr/share/nginx/html/jack.html<br><span class="hljs-comment"># 查看nginx pod ip并访问资源</span><br>kubectl get pods -o wide<br>curl nginx_pod_ip/jack.html<br><span class="hljs-comment"># 删除nginx pod并查看新nginx pod的资源</span><br>kubectl delete pod nginx-pod<br>curl nginx-new-pod-ip/jack.html<br></code></pre></td></tr></table></figure><p>手动创建PV是比较麻烦的，可以交给StorageClass操作。</p><h2 id="2-Resouce"><a href="#2-Resouce" class="headerlink" title="2 Resouce"></a>2 Resouce</h2><p><a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#example-1">https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#example-1</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">frontend</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">app</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">images.my-company.example/app:v4</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;64Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;250m&quot;</span><br>      <span class="hljs-attr">limits:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;128Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;500m&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">log-aggregator</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">images.my-company.example/log-aggregator:v6</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;64Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;250m&quot;</span><br>      <span class="hljs-attr">limits:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;128Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;500m&quot;</span><br></code></pre></td></tr></table></figure><h2 id="3-Dashboard"><a href="#3-Dashboard" class="headerlink" title="3 Dashboard"></a>3 Dashboard</h2><p><a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/</a></p><p>（1）创建dashboard.yaml文件，记得把image替换成阿里云的，以及配置成NodePort访问形式.</p><p>（2）定义访问dashboard需要的account文件并运行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">admin-user</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kubernetes-dashboard</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">admin-user</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">cluster-admin</span><br><span class="hljs-attr">subjects:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">admin-user</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">kubernetes-dashboard</span><br></code></pre></td></tr></table></figure><p>（3）创建访问dashboard需要的token</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl -n kubernetes-dashboard get secret $(kubectl -n kubernetes-dashboard get sa/admin-user -o jsonpath=<span class="hljs-string">&quot;&#123;.secrets[0].name&#125;&quot;</span>) -o go-template=<span class="hljs-string">&quot;&#123;&#123;.data.token | base64decode&#125;&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>（4）访问K8s_ip:30018，输入token</p><p><img src="/image/k8s/19.png"></p><h2 id="4-Controller进阶"><a href="#4-Controller进阶" class="headerlink" title="4 Controller进阶"></a>4 Controller进阶</h2><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/">https://kubernetes.io/docs/concepts/workloads/controllers/</a></p><h3 id="4-1-Job"><a href="#4-1-Job" class="headerlink" title="4.1 Job"></a>4.1 Job</h3><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/job/">https://kubernetes.io/docs/concepts/workloads/controllers/job/</a></p><p>对于RS，RC之类的控制器，能够保持Pod按照预期数目持久地运行下去，它们针对的是持久性的任 务，比如web服务。而有些操作其实不需要持久，比如压缩文件，希望任务完成之后，Pod就结束运行，不需要保持在系统中，此时就需要用到Job。所以可以这样理解，Job是对RS、RC等持久性控制器的补充。负责批量处理短暂的一次性任务，仅执行一次，并保证处理的一个或者多个Pod成功结束。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">job-demo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">job-demo</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">counter</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>        <span class="hljs-attr">command:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;bin/sh&quot;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;-c&quot;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i; done&quot;</span><br></code></pre></td></tr></table></figure><h3 id="4-2-CronJob"><a href="#4-2-CronJob" class="headerlink" title="4.2 CronJob"></a>4.2 CronJob</h3><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/">https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/</a></p><p>相当于定时任务</p><h3 id="4-3-StatefulSet"><a href="#4-3-StatefulSet" class="headerlink" title="4.3 StatefulSet"></a>4.3 StatefulSet</h3><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/</a></p><p>之前接触的Pod的管理对象比如RC、Deployment、DaemonSet和Job都是面向无状态的服务，但是现实中有很多服务是有状态的，比如MySQL集群、MongoDB集群、ZK集群等。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 定义Service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 定义StatefulSet</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">&quot;nginx&quot;</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">terminationGracePeriodSeconds:</span> <span class="hljs-number">10</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br></code></pre></td></tr></table></figure><h3 id="4-4-DaemonSet"><a href="#4-4-DaemonSet" class="headerlink" title="4.4 DaemonSet"></a>4.4 DaemonSet</h3><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/">https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看kube-proxy类型</span><br>kubectl get pods kube-proxy-9jgb6 -n kube-system -o yaml | grep kind<br><span class="hljs-comment"># 查看calico.yaml文件</span><br><span class="hljs-comment"># 搜索&quot;DaemonSet&quot;，发现calico-node也是DaemonSet类型</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes使用CICD实战</title>
    <link href="/2023/05/06/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/k8s/Kubernetes%E4%BD%BF%E7%94%A8CICD%E5%AE%9E%E6%88%98/"/>
    <url>/2023/05/06/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/k8s/Kubernetes%E4%BD%BF%E7%94%A8CICD%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1-部署SpringBoot项目"><a href="#1-部署SpringBoot项目" class="headerlink" title="1 部署SpringBoot项目"></a>1 部署SpringBoot项目</h2><p>（1）得到Spring Boot项目的image，这块之前Docker中聊过，就不具体展开，镜像已经推送到阿里仓库</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">registry.cn-hangzhou.aliyuncs.com<span class="hljs-regexp">/jack-kubernetes/</span>springboot-demo-image<br></code></pre></td></tr></table></figure><p>（2）编写springboot-demo.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#以Deployment部署Pod</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-demo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">springboot-demo</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">springboot-demo</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-demo</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">registry.cn-hangzhou.aliyuncs.com/jack-kubernetes/springbootdemo-image</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 创建Pod的Service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">springboot-demo</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 创建Ingress，定义访问规则，一定要记得提前创建好nginx ingress controller</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-ingress</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">kubernetes.io/ingress.class:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">springboot.jack.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">service:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-service</span><br>          <span class="hljs-attr">port:</span><br>            <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>（3）根据yaml文件创建资源并查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f springboot-demo.yaml<br>kubectl get all<br></code></pre></td></tr></table></figure><p>（4）在win上配置hosts文件</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.0.52</span> springboot.jack.com<br></code></pre></td></tr></table></figure><p>（5）浏览器访问</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>springboot.jack.com/K8s<br></code></pre></td></tr></table></figure><h2 id="2-Windows上准备"><a href="#2-Windows上准备" class="headerlink" title="2 Windows上准备"></a>2 Windows上准备</h2><p>（1）修改代码，即更新项目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMappiing(&quot;/k8s&quot;)</span><br>String <span class="hljs-title function_">k8s</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">hostAddress</span> <span class="hljs-operator">=</span> InetAddress.getLocalHost().getHostAddress();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello k8s, 当前服务的地址是：&quot;</span> + hostAddress;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）安装配置Git</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">（1）下载安装git[略]<br>（2）配置并生成ssh_key<br>git config --global user.name <span class="hljs-string">&quot;hiourearth&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;hiourearth@gmail.com&quot;</span><br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;hiourearth@gmail.com&quot;</span><br>（3）打开C:\Users\Jack\.ssh，查看id_rsa.pub文件中的值<br></code></pre></td></tr></table></figure><h2 id="3-搭建并配置Gitlab"><a href="#3-搭建并配置Gitlab" class="headerlink" title="3 搭建并配置Gitlab"></a>3 搭建并配置Gitlab</h2><blockquote><p>使用192.168.0.8 这台机器</p></blockquote><p><a href="https://about.gitlab.com/install/#centos-7">https://about.gitlab.com/install/#centos-7</a></p><p>（1）说明：安装gitlab的机器至少要有4G的内存，因为gitlab比较消耗内存</p><p>（2）安装必要的依赖并配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum install -y curl policycoreutils-python openssh-server<br>sudo systemctl <span class="hljs-built_in">enable</span> sshd<br>sudo systemctl start sshd<br>sudo firewall-cmd --permanent --add-service=http<br>sudo systemctl reload firewalld<br></code></pre></td></tr></table></figure><p>（3）添加gitlab仓库地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建gitlab-ce.repo文件</span><br><span class="hljs-built_in">cd</span> /etc/yum.repos.d/<br>vim gitlab-ce.repo<br><span class="hljs-comment"># 文件内容为</span><br>[gitlab-ce]<br>name=Gitlab CE Repository<br>baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el<span class="hljs-variable">$releasever</span>/<br>gpgcheck=0<br>enabled=1<br></code></pre></td></tr></table></figure><p>（4）设置gitlab域名并安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo EXTERNAL_URL=<span class="hljs-string">&quot;https://gitlab.jack.com&quot;</span> yum install -y gitlab-ce<br></code></pre></td></tr></table></figure><p>（5）配置windows的hosts文件 </p><p>（6）访问：<a href="https://gitlab.jack.com/">https://gitlab.jack.com</a> </p><p>（7）查看root账号的密码，后面可以修改一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> /etc/gitlab/initial_root_password<br></code></pre></td></tr></table></figure><p>（8）gitlab常见操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">（1）vim /etc/gitlab/gitlab.rb 找到对应修改内容<br>（2）gitlab-ctl reconfigure 重新加载一下配置<br>（3）gitlab-ctl status 查看gitlab状态<br>（4）sudo gitlab-ctl stop 停止gitlab<br>（5）sudo gitlab-ctl start 开启gitlab<br></code></pre></td></tr></table></figure><h2 id="4-项目关联Gitlab"><a href="#4-项目关联Gitlab" class="headerlink" title="4  项目关联Gitlab"></a>4  项目关联Gitlab</h2><p>（1）将公钥上传到gitlab：右上角-&gt;Preferences-&gt;SSH Keys</p><p>（2）在gitlab上创建名称为“springboot-demo”的project</p><p>（3）将本地项目push到gitlab上</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 使用terminal打开项目的根目录</span><br>git init<br>git add .<br>git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br>git remote add jack-gitlab git@gitlab.jack.com:root/springboot-demo.git<br>git remote -v<br>git push -u jack-gitlab master<br></code></pre></td></tr></table></figure><h2 id="5-安装配置Jenkins"><a href="#5-安装配置Jenkins" class="headerlink" title="5 安装配置Jenkins"></a>5 安装配置Jenkins</h2><blockquote><p>因为后面需要在jenkins的目录下创建文件执行，所以选择K8s集群中的一台node作为Jenkins的安装机器，比如这里选用w2，也就是192.168.0.53</p></blockquote><p>官网：<a href="https://jenkins.io/">https://jenkins.io/</a></p><p>（1）下载jenkins.war </p><p>（2）运行jenkins</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">nohup</span> java -jar jenkins.war --httpPort=8888 &amp;<br>lsof -i:8888<br><span class="hljs-built_in">tail</span> -f nohup.out<br></code></pre></td></tr></table></figure><p>（3）浏览器访问：192.168.0.53:8888</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">密码: cat <span class="hljs-regexp">/root/</span>.jenkins<span class="hljs-regexp">/secrets/i</span>nitialAdminPassword<br>然后会等待一会，包括镜像拉取以及插件安装[选择推荐的插件]<br></code></pre></td></tr></table></figure><p>（4）新建用户</p><p>（5）配置Jenkins URL</p><p><img src="/image/k8s/10.png"></p><p>（7）配置java maven和git等：Dashboard-&gt; Manage Jenkins-&gt; Global Tool Configuration</p><p><img src="/image/k8s/11.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 配置一下w2这台机器的git信息</span><br>git config --global user.name <span class="hljs-string">&quot;hiourearth&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;hiourearth@gmail.com&quot;</span><br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;hiourearth@gmail.com&quot;</span><br><span class="hljs-built_in">cat</span> /root/.ssh/id_rsa.pub<br><span class="hljs-comment"># 将公钥上传到gitlab上</span><br></code></pre></td></tr></table></figure><p><img src="/image/k8s/12.png"></p><h2 id="6-准备Docker-Hub和K8s集群"><a href="#6-准备Docker-Hub和K8s集群" class="headerlink" title="6 准备Docker Hub和K8s集群"></a>6 准备Docker Hub和K8s集群</h2><p>（1）Docker Hub：直接使用阿里容器镜像仓库，在w2这台机器上登录一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo docker login --username=hiourearth registry.cn-hangzhou.aliyuncs.com<br></code></pre></td></tr></table></figure><p>（2）K8s集群：就用之前搭建的3台机器组成的K8s集群</p><p>（3）目前的环境：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Gitlab</span>: git@gitlab.jack.com:root/springboot-demo.git<br><span class="hljs-attribute">Jenkins</span>: <span class="hljs-number">192.168.2.53:8888</span><br><span class="hljs-attribute">Docker</span> hub: hiourearth<br><span class="hljs-attribute">K8s</span> cluster: <span class="hljs-number">192.168.0.51</span> <span class="hljs-number">52</span> <span class="hljs-number">53</span><br></code></pre></td></tr></table></figure><h2 id="7-Jenkins拉取项目"><a href="#7-Jenkins拉取项目" class="headerlink" title="7 Jenkins拉取项目"></a>7 Jenkins拉取项目</h2><p>（1）创建Jenkins的Task</p><p><img src="/image/k8s/13.png"></p><p>（2）在w2上配置hosts： vim /etc/hosts</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">192.168.0.8 gitlab.jack.com<br><span class="hljs-comment"># 测试git是否配置成功</span><br>ssh -T git@gitlab.jack.com<br></code></pre></td></tr></table></figure><p>（3）流水线中编写拉取代码的脚本，然后点击“保存”</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">node &#123;<br>def mvnHome<br>stage(<span class="hljs-string">&#x27;Git Pull&#x27;</span>) &#123; // <span class="hljs-keyword">for</span> display purposes<br>git <span class="hljs-string">&#x27;git@gitlab.jack.com:root/springboot-demo.git&#x27;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）来到“Dashboard”，并点击执行按钮</p><p>（5）到w2这台机器上，观察/root/.jenkins/workspace目录，看看项目是否拉取成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> /root/.jenkins/workspace/springbootdemo/src/main/java/com/jack/springbootdemo/SpringbootDemoApplication.java<br></code></pre></td></tr></table></figure><h2 id="8-Jenkins-Maven打包"><a href="#8-Jenkins-Maven打包" class="headerlink" title="8  Jenkins Maven打包"></a>8  Jenkins Maven打包</h2><p>（1）新增一个脚本语句</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">node &#123;<br>def mvnHome<br>stage(<span class="hljs-string">&#x27;Git Pull&#x27;</span>) &#123; // <span class="hljs-keyword">for</span> display purposes<br>git <span class="hljs-string">&#x27;git@gitlab.jack.com:root/springboot-demo.git&#x27;</span><br>&#125;<br>stage(<span class="hljs-string">&#x27;Maven Build&#x27;</span>) &#123;<br>sh <span class="hljs-string">&quot;mvn clean package&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）观察worspace目录下是否生成target文件</p><h2 id="9-构建和push镜像"><a href="#9-构建和push镜像" class="headerlink" title="9 构建和push镜像"></a>9 构建和push镜像</h2><p>（1）来到w2上的workspace目录：cd /root/.jenkins/workspace</p><p>（2）在scripts目录下准备一个文件，名称为springboot-demo-build-image.sh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> /root/.jenkins/workspace/scripts/<br>vim /root/.jenkins/workspace/scripts/springboot-demo-build-image.sh<br></code></pre></td></tr></table></figure><p>（3）编辑sh文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入到kubernetes-demo目录</span><br><span class="hljs-built_in">cd</span> ../springboot-demo<br><span class="hljs-comment"># 编写Dockerfile文件</span><br><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt; Dockerfile</span><br><span class="hljs-string">FROM openjdk:8-jre-alpine</span><br><span class="hljs-string">COPY target/springboot-demo-0.0.1-SNAPSHOT.jar springboot-demo.jar</span><br><span class="hljs-string">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;springboot-demo.jar&quot;]</span><br><span class="hljs-string">EOF</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Dockerfile created successfully!&quot;</span><br><span class="hljs-comment"># 基于指定目录下的Dockerfile构建镜像</span><br>docker build -t registry.cn-hangzhou.aliyuncs.com/jack-kubernetes/springbootdemo-image .<br><span class="hljs-comment"># push镜像，这边需要阿里云镜像仓库登录，记得提前在w2上登录一下</span><br>docker push registry.cn-hangzhou.aliyuncs.com/jack-kubernetes/springboot-demoimage<br></code></pre></td></tr></table></figure><p>（4）踩坑经验</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 01 文件权限</span><br>/root/.jenkins/workspace/scripts/springboot-demo-build-image.sh: Permission denied<br><span class="hljs-comment"># 解决</span><br><span class="hljs-built_in">chmod</span> +x /root/.jenkins/workspace/scripts/springboot-demo-build-image.sh<br><br><span class="hljs-comment"># 02 docker没有运行</span><br>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?<br><span class="hljs-comment"># 解决</span><br>systemctl start docker<br>systemctl <span class="hljs-built_in">enable</span> docker<br><br><span class="hljs-comment"># 03 push权限</span><br>docker login --username=hiourearth registry.cn-hangzhou.aliyuncs.com<br></code></pre></td></tr></table></figure><p>（5）jenkins上添加脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">node &#123;<br>def mvnHome<br>stage(<span class="hljs-string">&#x27;Git Pull&#x27;</span>) &#123; // <span class="hljs-keyword">for</span> display purposes<br>git <span class="hljs-string">&#x27;git@gitlab.jack.com:root/dockerfile-demo.git&#x27;</span><br>&#125;<br>stage(<span class="hljs-string">&#x27;Maven Build&#x27;</span>) &#123;<br>sh <span class="hljs-string">&quot;mvn clean package&quot;</span><br>&#125;<br>stage(<span class="hljs-string">&#x27;Build Image&#x27;</span>) &#123;<br>sh <span class="hljs-string">&quot;/root/.jenkins/workspace/scripts/springboot-demo-build-image.sh&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（6）jenkins构建，并查看阿里镜像仓库</p><h2 id="10-K8s拉取镜像并运行"><a href="#10-K8s拉取镜像并运行" class="headerlink" title="10  K8s拉取镜像并运行"></a>10  K8s拉取镜像并运行</h2><p>（1）在/root/.jenkins/workspace/scripts/目录下创建springboot-demo.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 以Deployment部署Pod</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-demo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">springboot-demo</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">springboot-demo</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-demo</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">registry.cn-hangzhou.aliyuncs.com/jack-kubernetes/springbootdemo-image</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 创建Pod的Service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">springboot-demo</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 创建Ingress，定义访问规则，一定要记得提前创建好nginx ingress controller</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-ingress</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">kubernetes.io/ingress.class:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">springboot.jack.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-service</span><br>            <span class="hljs-attr">port:</span><br>              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>（2）在/root/.jenkins/workspace/scripts/目录创建K8s-deploy-springboot-demo.sh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl delete -f /root/.jenkins/workspace/scripts/springboot-demo.yaml<br>kubectl apply -f /root/.jenkins/workspace/scripts/springboot-demo.yaml<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;K8s deploy success!&quot;</span><br></code></pre></td></tr></table></figure><p>（3）踩坑经历</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 01 权限</span><br>/root/.jenkins/workspace/scripts/K8s-deploy-springboot-demo.sh: Permission denied<br><span class="hljs-comment"># 解决</span><br><span class="hljs-built_in">chmod</span> +x /root/.jenkins/workspace/scripts/K8s-deploy-springboot-demo.sh<br><br><span class="hljs-comment"># 02 w2执行不了kubectl</span><br>切换到master上，<span class="hljs-built_in">cd</span> ~ ---&gt; <span class="hljs-built_in">cat</span> .kube/config ---&gt;复制内容<br>切换到worker02上 <span class="hljs-built_in">cd</span> ~ ---&gt; 新建文件 .kube/config ---&gt;粘贴内容<br></code></pre></td></tr></table></figure><p>（4）增加Jenkins中的脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">node &#123;<br>def mvnHome<br>stage(<span class="hljs-string">&#x27;Git Pull&#x27;</span>) &#123; // <span class="hljs-keyword">for</span> display purposes<br>git <span class="hljs-string">&#x27;git@gitlab.jack.com:root/springboot-demo.git&#x27;</span><br>&#125;<br>stage(<span class="hljs-string">&#x27;Maven Build&#x27;</span>) &#123;<br>sh <span class="hljs-string">&quot;mvn clean package&quot;</span><br>&#125;<br>stage(<span class="hljs-string">&#x27;Build Image&#x27;</span>) &#123;<br>sh <span class="hljs-string">&quot;/root/.jenkins/workspace/scripts/springboot-demo-build-image.sh&quot;</span><br>&#125;<br>stage(<span class="hljs-string">&#x27;K8S Deploy&#x27;</span>) &#123;<br>sh <span class="hljs-string">&quot;/root/.jenkins/workspace/scripts/K8s-deploy-springboot-demo.sh&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）jenkins构建，并查看K8s集群中image和资源</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get pods<br>kubectl get deploy<br>kubectl get service<br></code></pre></td></tr></table></figure><p>（6）浏览器访问</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>springboot.jack.com/K8s<br></code></pre></td></tr></table></figure><h2 id="11-webhook测试自动化部署"><a href="#11-webhook测试自动化部署" class="headerlink" title="11 webhook测试自动化部署"></a>11 webhook测试自动化部署</h2><p>（1）当用户进行git push提交代码到github时，能够通知jenkins自动构建 </p><p>注意：jenkins的ip一定要是gitlab能够访问到的地址 </p><p>（2）打开jenkins中springboot-demo pipeline，构建触发器，记录下触发器的地址：<a href="http://192.168.0.53:8888/project/springboot-demo">http://192.168.0.53:8888/project/springboot-demo</a></p><p><img src="/image/k8s/14.png"></p><p>（3）在gitlab上配置webhook的地址，即jenkins对应的触发器地址： <a href="http://192.168.0.53:8888/project/springboot-demo%EF%BC%8C%E7%84%B6%E5%90%8E%E7%82%B9%E5%87%BB%E4%B8%8B%E6%96%B9%E7%9A%84%E2%80%9CAdd">http://192.168.0.53:8888/project/springboot-demo，然后点击下方的“Add</a> webhook”</p><p><img src="/image/k8s/15.png"></p><p>（4）当提示“Url is blocked: Requests to the local network are not allowed”，需要做一下设置，以 root账号登录gitlab，然后再配置一下第（2）步</p><p><img src="/image/k8s/16.png"></p><p>（5）安装Jenkins插件</p><blockquote><p>Dashboard-&gt; Manage Jenkins-&gt; Manage Plugins-&gt; 可选插件</p><p>搜索 : gitlab plugin和gitlab hook 并安装</p></blockquote><p><img src="/image/k8s/17.png"></p><p>（6）因为是测试环境，所以暂时可以先不配置jenkins需要的token，也就是说在Jenkins中取消Gitlab Server的认证</p><blockquote><p>Dashboard-&gt; Manage Jenkins-&gt; Configure System</p></blockquote><p><img src="/image/k8s/18.png"></p><p>（7）测试一下Push Event</p><p>（8）整体测试 </p><p>打开idea工程，更改代码，git add/commit/push，观察springboot-demo构建任务的变化，最终通过浏览器访问springboot.jack.com</p>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes基础使用以及网络分析</title>
    <link href="/2023/04/28/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/k8s/Kubernetes%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90/"/>
    <url>/2023/04/28/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/k8s/Kubernetes%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基础操作"><a href="#1-基础操作" class="headerlink" title="1 基础操作"></a>1 基础操作</h2><h3 id="1-1-Pod"><a href="#1-1-Pod" class="headerlink" title="1.1 Pod"></a>1.1 Pod</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#查看Pod详情信息</span><br>kubectl describe pod pod-name -n ns<br><br><span class="hljs-comment">#Status</span><br>挂起（Pending）：Pod已被K8s系统接受，但有一个或多个容器镜像尚未创建，等待时间包括调度Pod的时间和通过网络下载镜像的时间，着可能需要花点时间。<br>运行中（Running）：Pod已经绑定到了一个节点上，Pod中所有的容器都已被创建，至少有一个容器正在运行，或者正处于启动或重启状态。<br>成功（Successed）：Pod中的所有容器都被成功终止，并且不会再次重启。<br>失败（Failed）：Pod中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非0状态退出或者被系统终止。<br>未知（Unknown）：因为某些原因无法取得Pod的状态，通常是因为与Pod所在主机通信失败。<br></code></pre></td></tr></table></figure><h3 id="1-2-ReplicaSet-RS"><a href="#1-2-ReplicaSet-RS" class="headerlink" title="1.2 ReplicaSet(RS)"></a>1.2 ReplicaSet(RS)</h3><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/</a></p><p>（1）创建frontend.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">aapiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">frontend</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">guestbook</span><br>    <span class="hljs-attr">tier:</span> <span class="hljs-string">frontend</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-comment"># modify replicas according to your case</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">tier:</span> <span class="hljs-string">frontend</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">tier:</span> <span class="hljs-string">frontend</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">php-redis</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">gcr.io/google_samples/gb-frontend:v3</span><br></code></pre></td></tr></table></figure><p>（2）常见操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#创建Pod</span><br>kubectl apply -f frontend.yaml<br><br><span class="hljs-comment">#查看Pod</span><br>kubectl get pods<br>kubectl get pods -o wide<br><br><span class="hljs-comment">#查看rs资源</span><br>kubectl get rs<br>kubectl describe rs frontend<br><br><span class="hljs-comment">#对Pod进行扩缩容</span><br>kubectl scale rs frontend --replicas=5<br><br><span class="hljs-comment">#删除单个Pod</span><br>kubectl delete pods frontendd-21tc9<br><br><span class="hljs-comment">#删除rs</span><br>kubectl delete -f frontend.yaml<br></code></pre></td></tr></table></figure><h3 id="1-3-Deployment"><a href="#1-3-Deployment" class="headerlink" title="1.3 Deployment"></a>1.3 Deployment</h3><p>（1）创建nginx-deployment.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.14.2</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>（2）常见操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建Pod</span><br>kubectl apply -f nginx-deployment.yaml<br><br><span class="hljs-comment"># 查看Pod</span><br>kubectl get pods<br>kubectl get pods -o wide<br><br><span class="hljs-comment"># 查看deployment资源</span><br>kubectl get deploy<br>kubectl describe deploy nginx-deployment<br><br><span class="hljs-comment"># 对Pod进行扩缩容</span><br>kubectl scale deploy nginx-deployment --replicas=5<br><br><span class="hljs-comment"># 删除单个Pod</span><br>kubectl delete pods nginx-deployment-9456bbbf9-77ljp<br><br><span class="hljs-comment"># 删除rs</span><br>kubectl delete -f nginx-deployment.yaml<br><br><span class="hljs-comment"># 查看当前nginx的版本</span><br>kubectl get deploy -o wide<br><br><span class="hljs-comment"># 更新nginx的版本为1.16.1</span><br>kubectl <span class="hljs-built_in">set</span> image deployment/nginx-deployment nginx=nginx:1.16.1<br>kubectl get deploy -o wide<br></code></pre></td></tr></table></figure><h3 id="1-4-Label-and-Selector"><a href="#1-4-Label-and-Selector" class="headerlink" title="1.4  Label and Selector"></a>1.4  Label and Selector</h3><p><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/">https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-comment"># 表示该deployment具有一个label，key为app，value为nginx，可以通过kubectl getdeploy --show-labels 查看</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># 表示该deployment管理的Pod匹配条件，而这个条件是根据label进行匹配的</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span> <span class="hljs-comment"># 定义一个Pod的模板</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span> <span class="hljs-comment"># 表示该pod具有一个label，key为app，value为nginx，可以通过kubectl get pods --show-labels 查看</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.14.2</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h3 id="1-5-Namespace"><a href="#1-5-Namespace" class="headerlink" title="1.5 Namespace"></a>1.5 Namespace</h3><p><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/">https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#查看命名空间</span><br>kubectl get namespace<br>kubectl get ns<br><br><span class="hljs-comment">#创建命名空间</span><br>kubectl create namespace test-ns<br>kubectl get ns<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#定义podyaml：nginx-pod-ns.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">jack-ns</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#构建Pod</span><br>kubectl apply -f nginx-pod-ns.yaml<br><br><span class="hljs-comment">#查看指定命名空间下的资源</span><br>kubectl get pods<br>kubectl get pods -n test-ns<br>kubectl get all -n test-ns<br>kubectl get pods --all-namespaces<br></code></pre></td></tr></table></figure><h2 id="2-Network"><a href="#2-Network" class="headerlink" title="2 Network"></a>2 Network</h2><h3 id="2-1-Pod-Network"><a href="#2-1-Pod-Network" class="headerlink" title="2.1 Pod Network"></a>2.1 Pod Network</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建两个Pod</span><br>kubectl run nginx --image=nginx<br>kubectl run tomcat --image=tomcat:8.0<br><span class="hljs-comment"># 查看两个Pod详情</span><br>kubectl get pods -o wide<br><span class="hljs-comment"># 结果输出</span><br>NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES<br>nginx 1/1 Running 0 2m 10.244.190.76 w1 &lt;none&gt; &lt;none&gt;<br>tomcat 1/1 Running 0 17s 10.244.80.205 w2 &lt;none&gt; &lt;none&gt;<br><span class="hljs-comment"># 任意一台node访问pod_ip</span><br>curl 10.244.190.76<br>curl 10.244.80.205:8080<br><span class="hljs-comment"># 进入nginx pod中访问tomcat pod</span><br>kubectl <span class="hljs-built_in">exec</span> -it nginx bash<br>curl 10.244.80.205:8080<br><span class="hljs-comment"># 进入tomcat pod中访问物理机</span><br>kubectl <span class="hljs-built_in">exec</span> -it tomcat bash<br>ping 192.168.0.52<br>ping 192.168.0.53<br></code></pre></td></tr></table></figure><p>在K8s Cluster中，通过Calico网络插件，可以实现Node访问Pod、Pod之间通信以及Pod访问 Node</p><p><img src="/image/k8s/9.png"></p><h3 id="2-2-Service"><a href="#2-2-Service" class="headerlink" title="2.2 Service"></a>2.2 Service</h3><p>对于上述的Pod虽然实现了集群内部互相通信，但是Pod是不稳定的，比如通过Deployment管理 Pod，随时可能对Pod进行扩缩容，这时候Pod的IP地址是变化的。能够有一个固定的IP，使得集群内能够访问。也就是之前在架构描述的时候所提到的，能够把相同或者具有关联的Pod，打上Label，组成 Service。而Service有固定的IP，不管Pod怎么创建和销毁，都可以通过Service的IP进行访问。</p><p><a href="https://kubernetes.io/docs/concepts/services-networking/service/">https://kubernetes.io/docs/concepts/services-networking/service/</a></p><h4 id="2-2-1-ClusterIP"><a href="#2-2-1-ClusterIP" class="headerlink" title="2.2.1  ClusterIP"></a>2.2.1  ClusterIP</h4><p>（1）创建whoami-deployment.yaml文件，并且apply</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">whoami-deployment</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">whoami</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">whoami</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">whoami</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">whoami</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">jwilder/whoami</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8000</span><br></code></pre></td></tr></table></figure><p>（2）查看pod以及service</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get pods -o wide<br>kubectl get service<br></code></pre></td></tr></table></figure><p>（3）通过pod_ip进行访问</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl pod_ip:8000<br></code></pre></td></tr></table></figure><p>（4）创建whoami pod的service，定义whoami-serivce.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">whoami-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">whoami</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8000</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span><br></code></pre></td></tr></table></figure><p>（5）查看service</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get service<br>kubectl describe service whoami-service<br></code></pre></td></tr></table></figure><p>（6）访问service</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl service_ip<br><span class="hljs-keyword">while</span> <span class="hljs-built_in">sleep</span> 0.2; <span class="hljs-keyword">do</span> curl service_ip; <span class="hljs-keyword">done</span>;<br></code></pre></td></tr></table></figure><p>（7）对pod进行扩容，然后再次访问</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl scale deployment whoami-deployment --replicas=5<br>kubectl get pods<br><span class="hljs-keyword">while</span> <span class="hljs-built_in">sleep</span> 0.2; <span class="hljs-keyword">do</span> curl service_ip; <span class="hljs-keyword">done</span>;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-NodePort"><a href="#2-2-2-NodePort" class="headerlink" title="2.2.2  NodePort"></a>2.2.2  NodePort</h4><p>因为外部能够访问到集群的物理机器IP，所以就是在集群中每台物理机器上暴露一个相同的 IP，比如32008</p><p>（1）修改whoami-service.yaml文件中的类型为NodePort</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">whoami-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">whoami</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8000</span><br>    <span class="hljs-attr">nodePort:</span> <span class="hljs-number">32008</span> <span class="hljs-comment"># 可以指定一个物理机上不重复的端口，范围在20000-40000之间</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span> <span class="hljs-comment"># 把ClusterIP修改成NodePort</span><br></code></pre></td></tr></table></figure><p>（2）查看service</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get service<br>kubectl describe service whoami-service<br></code></pre></td></tr></table></figure><p>（3）访问测试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl centos_ip:32008<br></code></pre></td></tr></table></figure><h4 id="2-2-3-Ingress"><a href="#2-2-3-Ingress" class="headerlink" title="2.2.3  Ingress"></a>2.2.3  Ingress</h4><p>（1）创建tomcat pod和tomcat service，定义在tomcat.yaml文件中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">tomcat-deployment</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">tomcat</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">tomcat</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">tomcat</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tomcat</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">tomcat:8.0</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">tomcat-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">tomcat</span><br></code></pre></td></tr></table></figure><p>（2）运行tomcat.yaml并查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f tomcat.yaml<br>kubectl get svc<br>kubectl get pods<br>curl tomcat-pod_ip:8080<br>curl tomcat-service_ip<br></code></pre></td></tr></table></figure><p>（3）以Deployment Pod的方式创建Nginx Ingress Controller，文件名称为nginx-ingresscontroller.yaml</p><blockquote><p>文件内容：<a href="https://kubernetes.github.io/ingress-nginx/deploy/#quick-start">https://kubernetes.github.io/ingress-nginx/deploy/#quick-start</a></p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 给w1添加label，这样在nginx-ingress-controller.yaml中搜索&quot;nodeSelector&quot;时，就可以根据name: ingress进行匹配了</span><br>kubectl label node w1 name=ingress<br>kubectl get nodes --show-labels<br>kubectl get node w1 --show-labels<br><span class="hljs-comment"># 在nginx-ingress-controller.yaml中添加一行配置，可以在nodeSelector上面一行添加</span><br>hostNetwork: <span class="hljs-literal">true</span><br><span class="hljs-comment"># 将nginx-ingress-controller.yaml中的3个image替换成阿里镜像仓库中的内容</span><br>registry.cn-hangzhou.aliyuncs.com/jack-kubernetes/ingress-nginx-controller<br>registry.cn-hangzhou.aliyuncs.com/jack-kubernetes/kube-webhook-certgen<br>registry.cn-hangzhou.aliyuncs.com/jack-kubernetes/kube-webhook-certgen<br><span class="hljs-comment"># 运行yaml文件</span><br>kubectl apply -f nginx-ingress-controller.yaml<br><span class="hljs-comment"># 这样w1上的80和443端口就会被nginx-ingress-controller使用</span><br>lsof -i:80<br>lsof -i:443<br><span class="hljs-comment"># 查看资源</span><br>kubectl get pods -n ingress-nginx -o wide<br>kubectl get all -n ingress-nginx<br></code></pre></td></tr></table></figure><p>（4）定义ingress规则</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#ingress</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-ingress</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">tomcat.jack.tomcat</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>          <span class="hljs-attr">backend:</span><br>            <span class="hljs-attr">serviceName:</span> <span class="hljs-string">tomcat-service</span><br>            <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>（5）应用并查看ingress规则</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f nginx-ingress.yaml<br>kubectl get ingress<br>kubectl describe ingress nginx-ingress<br>kubectl get service<br>kubectl get pods<br></code></pre></td></tr></table></figure><p>（6）在win上配置hosts文件</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.0.52</span> tomcat.jack.com<br></code></pre></td></tr></table></figure><p>（7）访问tomcat.jack.com</p>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes初识</title>
    <link href="/2023/04/27/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/k8s/Kubernetes%E5%88%9D%E8%AF%86/"/>
    <url>/2023/04/27/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/k8s/Kubernetes%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-K8s基本概念"><a href="#1-K8s基本概念" class="headerlink" title="1 K8s基本概念"></a>1 K8s基本概念</h2><p>官网：<a href="https://kubernetes.io/">https://kubernetes.io/</a></p><p>Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态，其服务、支持和工具的使用范围相当广泛。Kubernetes 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有八个字符的关系。</p><h3 id="1-1-核心组件概念"><a href="#1-1-核心组件概念" class="headerlink" title="1.1 核心组件概念"></a>1.1 核心组件概念</h3><h4 id="1-1-1-Container-容器"><a href="#1-1-1-Container-容器" class="headerlink" title="1.1.1 Container-容器"></a>1.1.1 Container-容器</h4><p>每个运行的容器都是可重复的； 包含依赖环境在内的标准，意味着无论你在哪里运行它都会得到相同的行为。容器将应用程序从底层的主机设施中解耦。 这使得在不同的云或 OS 环境中部署更加容易。Kubernetes 集群中的每个<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点</a>都会运行容器， 这些容器构成分配给该节点的 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a>。也就是Docker通过Image创建的Container。</p><p><img src="/image/k8s/1.png"></p><h4 id="1-1-2-Pod"><a href="#1-1-2-Pod" class="headerlink" title="1.1.2 Pod"></a>1.1.2 Pod</h4><p>Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。其中包含一个或多个Container。</p><p><img src="/image/k8s/2.png"></p><p>下面是一个 Pod 示例，它由一个运行镜像 <code>nginx:1.14.2</code> 的容器组成。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#simple-pod.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.14.2</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>要创建上面显示的 Pod，请运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f simple-pod.yaml<br></code></pre></td></tr></table></figure><h4 id="1-1-3-ReplicaSet"><a href="#1-1-3-ReplicaSet" class="headerlink" title="1.1.3 ReplicaSet"></a>1.1.3 ReplicaSet</h4><p>ReplicaSet 的目的是维护一组在任何时候都处于运行状态的 Pod 副本的稳定集合。 因此，它通常用来保证给定数量的、完全相同的 Pod 的可用性。</p><p>ReplicaSet 确保任何时间都有指定数量的 Pod 副本在运行。 然而，Deployment 是一个更高级的概念，它管理 ReplicaSet，并向 Pod 提供声明式的更新以及许多其他有用的功能。 因此，我们建议使用 Deployment 而不是直接使用 ReplicaSet， 除非你需要自定义更新业务流程或根本不需要更新。这实际上意味着，可能永远不需要操作 ReplicaSet 对象：而是使用 Deployment。</p><p><img src="/image/k8s/3.png"></p><h4 id="1-1-4-Deployment"><a href="#1-1-4-Deployment" class="headerlink" title="1.1.4 Deployment"></a>1.1.4 Deployment</h4><p>一个 Deployment 为 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a> 和 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a> 提供声明式的更新能力。</p><p><img src="/image/k8s/4.png"></p><h4 id="1-1-5-Label-标签"><a href="#1-1-5-Label-标签" class="headerlink" title="1.1.5 Label-标签"></a>1.1.5 Label-标签</h4><p><strong>标签（Labels）</strong> 是附加到 Kubernetes 对象（比如 Pod）上的键值对。 标签旨在用于指定对用户有意义且相关的对象的标识属性，但不直接对核心系统有语义含义。 标签可以用于组织和选择对象的子集。标签可以在创建时附加到对象，随后可以随时添加和修改。 每个对象都可以定义一组键/值标签。每个键对于给定对象必须是唯一的。标签能够支持高效的查询和监听操作。</p><p><img src="/image/k8s/5.png"></p><h4 id="1-1-6-Service-服务"><a href="#1-1-6-Service-服务" class="headerlink" title="1.1.6 Service-服务"></a>1.1.6 Service-服务</h4><p>Kubernetes 中 Service 是 将运行在一个或一组 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a> 上的网络应用程序公开为网络服务的方法。具有相同标签Label的pod的集合。</p><p><img src="/image/k8s/6.png"></p><h4 id="1-1-7-Node-节点"><a href="#1-1-7-Node-节点" class="headerlink" title="1.1.7 Node-节点"></a>1.1.7 Node-节点</h4><p>Kubernetes 通过将容器放入在节点（Node）上运行的 Pod 中来执行你的工作。节点可以是一个虚拟机或者物理机器，取决于所在的集群配置。</p><p><img src="/image/k8s/7.png"></p><h4 id="1-1-8-Node-Cluster"><a href="#1-1-8-Node-Cluster" class="headerlink" title="1.1.8 Node Cluster"></a>1.1.8 Node Cluster</h4><p><img src="/image/k8s/8.png"></p><h3 id="1-2-K8s架构"><a href="#1-2-K8s架构" class="headerlink" title="1.2 K8s架构"></a>1.2 K8s架构</h3><p><img src="/image/k8s/K8s%E6%9E%B6%E6%9E%84.jpg"></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-number">01</span>-总得要有一个操作集群的客户端，也就是和集群打交道<br>kubectl<br><span class="hljs-number">02</span>-请求肯定是到达<span class="hljs-keyword">Master</span> <span class="hljs-title">Node</span>，然后再分配给Worker <span class="hljs-keyword">Node</span><span class="hljs-title">创建Pod</span>之类的<br>关键是命令通过kubectl过来之后，需要认证授权<br><span class="hljs-number">03</span>-请求过来之后，<span class="hljs-keyword">Master</span> <span class="hljs-title">Node</span>中谁来接收？<br>APIServer<br><span class="hljs-number">04</span>-API收到请求之后，接下来调用哪个Worker <span class="hljs-keyword">Node</span><span class="hljs-title">创建Pod</span>，Container之类的，得要有调度策略<br>Scheduler<br>[https://kubernetes.io/docs/concepts/scheduling/kube-scheduler/]<br><span class="hljs-number">05</span>-Scheduler通过不同的策略，真正要分发请求到不同的Worker <span class="hljs-keyword">Node</span><span class="hljs-title">上创建内容，具体谁负责？</span><br><span class="hljs-title">Controller</span> Manager<br><span class="hljs-number">06</span>-Worker <span class="hljs-keyword">Node</span><span class="hljs-title">接收到创建请求之后，具体谁来负责</span><br><span class="hljs-title">Kubelet</span>服务，最终Kubelet会调用Docker Engine，创建对应的容器[这边是不是也反应出一点，在<span class="hljs-keyword">Node</span><span class="hljs-title">上需要有Docker</span> Engine，不然怎么创建维护容器？]<br><span class="hljs-number">07</span>-会不会涉及到域名解析的问题？<br>DNS<br><span class="hljs-number">08</span>-是否需要有监控面板能够监测整个集群的状态？<br>Dashboard<br><span class="hljs-number">09</span>-集群中节点的数据如何保存？分布式存储<br>ETCD<br><span class="hljs-number">10</span>-至于像容器的持久化存储，网络等可以先类比一下Docker中的内容<br></code></pre></td></tr></table></figure><h2 id="2-K8s安装"><a href="#2-K8s安装" class="headerlink" title="2 K8s安装"></a>2 K8s安装</h2><h3 id="2-1-K8s的常见安装方式"><a href="#2-1-K8s的常见安装方式" class="headerlink" title="2.1 K8s的常见安装方式"></a>2.1 K8s的常见安装方式</h3><ol><li>最难的方式，需要自己手动安装搭建K8s架构中的各个组件</li></ol><p><a href="https://github.com/kelseyhightower">https://github.com/kelseyhightower</a></p><ol start="2"><li>最简单的方式，在线体验</li></ol><p><a href="https://labs.play-with-k8s.com/">https://labs.play-with-k8s.com/</a></p><ol start="3"><li>第三方服务：阿里ACK，腾讯TKE</li></ol><p>阿里ACK：<a href="https://www.aliyun.com/product/kubernetes">https://www.aliyun.com/product/kubernetes</a></p><p>腾讯TKE：<a href="https://cloud.tencent.com/product/tke">https://cloud.tencent.com/product/tke</a></p><ol start="4"><li>minikube</li></ol><p><a href="https://minikube.sigs.k8s.io/docs/start/">https://minikube.sigs.k8s.io/docs/start/</a></p><ol start="5"><li>kubeadm</li></ol><p><a href="https://github.com/kubernetes/kubeadm">https://github.com/kubernetes/kubeadm</a></p><h3 id="2-2-kubeadm搭建K8s集群"><a href="#2-2-kubeadm搭建K8s集群" class="headerlink" title="2.2 kubeadm搭建K8s集群"></a>2.2 kubeadm搭建K8s集群</h3><h4 id="2-2-1-版本选择"><a href="#2-2-1-版本选择" class="headerlink" title="2.2.1 版本选择"></a>2.2.1 版本选择</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">centos7</span><br><span class="hljs-attribute">Docker</span> Community: <span class="hljs-number">20</span>.<span class="hljs-number">10</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">K8s</span> Version: v1.<span class="hljs-number">23</span>.<span class="hljs-number">14</span><br><span class="hljs-attribute">Calico</span> Version: v3.<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h4 id="2-2-2-准备centos机器"><a href="#2-2-2-准备centos机器" class="headerlink" title="2.2.2 准备centos机器"></a>2.2.2 准备centos机器</h4><blockquote><p>配置要求：每台机器至少2C2G，不然运行不起来</p></blockquote><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.0.51</span> master<br><span class="hljs-number">192.168.0.52</span> worker01<br><span class="hljs-number">192.168.0.53</span> worker02<br></code></pre></td></tr></table></figure><h4 id="2-2-3-安装Docker"><a href="#2-2-3-安装Docker" class="headerlink" title="2.2.3 安装Docker"></a>2.2.3 安装Docker</h4><blockquote><p>3台机器</p></blockquote><p>安装步骤查看docker专题</p><h4 id="2-2-4-安装依赖和更新"><a href="#2-2-4-安装依赖和更新" class="headerlink" title="2.2.4 安装依赖和更新"></a>2.2.4 安装依赖和更新</h4><blockquote><p>3台机器</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum -y update<br>yum install -y conntrack ipvsadm ipset jq sysstat curl iptables libseccomp<br></code></pre></td></tr></table></figure><h4 id="2-2-5-修改hosts文件"><a href="#2-2-5-修改hosts文件" class="headerlink" title="2.2.5 修改hosts文件"></a>2.2.5 修改hosts文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#1.master</span><br>sudo hostnamectl set-hostname m<br>vi /etc/hosts<br>192.168.0.51 m<br>192.168.0.52 w1<br>192.168.0.53 w2<br><br><span class="hljs-comment">#2.2台worker</span><br>sudo hostnamectl set-hostname w1/w2<br>vi /etc/hosts<br>192.168.0.51 m<br>192.168.0.52 w1<br>192.168.0.53 w2<br><br><span class="hljs-comment">#3.彼此ping测试一下</span><br></code></pre></td></tr></table></figure><h4 id="2-2-6-系统基础配置"><a href="#2-2-6-系统基础配置" class="headerlink" title="2.2.6 系统基础配置"></a>2.2.6 系统基础配置</h4><blockquote><p>3台机器</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># (1)关闭防火墙</span><br>systemctl stop firewalld &amp;&amp; systemctl <span class="hljs-built_in">disable</span> firewalld<br><br><span class="hljs-comment"># (2)关闭selinux</span><br><span class="hljs-comment">#【SELinux 全称 Security Enhanced Linux (安全强化 Linux)，是 MAC (Mandatory Access Control，强制访问控制系统)的一个实现，目的在于明确的指明某个进程可以访问哪些资源(文件、网络端口等)。】</span><br>setenforce 0<br>sed -i <span class="hljs-string">&#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27;</span> /etc/selinux/config<br><br><span class="hljs-comment"># (3)关闭swap</span><br><span class="hljs-comment">#【在Linux下，SWAP的作用类似Windows系统下的“虚拟内存”。当物理内存不足时，拿出部分硬盘空间当SWAP分区（虚拟成内存）使用，从而解决内存容量不足的情况。】</span><br>swapoff -a<br>sed -i <span class="hljs-string">&#x27;/swap/s/^\(.*\)$/#\1/g&#x27;</span> /etc/fstab<br><br><span class="hljs-comment"># (4)配置iptables的ACCEPT规则</span><br>iptables -F &amp;&amp; iptables -X &amp;&amp; iptables -F -t nat &amp;&amp; iptables -X -t nat &amp;&amp; iptables -P FORWARD ACCEPT<br><br><span class="hljs-comment"># (5)设置系统参数</span><br><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt; /etc/sysctl.d/k8s.conf</span><br><span class="hljs-string">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="hljs-string">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="hljs-string">EOF</span><br>sysctl --system<br></code></pre></td></tr></table></figure><h4 id="2-2-7-配置K8s的yum源"><a href="#2-2-7-配置K8s的yum源" class="headerlink" title="2.2.7  配置K8s的yum源"></a>2.2.7  配置K8s的yum源</h4><blockquote><p>3台机器</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="hljs-string">[kubernetes]</span><br><span class="hljs-string">name=Kubernetes</span><br><span class="hljs-string">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="hljs-string">enabled=1</span><br><span class="hljs-string">gpgcheck=0</span><br><span class="hljs-string">repo_gpgcheck=0</span><br><span class="hljs-string">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="hljs-string">       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><h4 id="2-2-8-安装kubeadm、kubectl和kubelet"><a href="#2-2-8-安装kubeadm、kubectl和kubelet" class="headerlink" title="2.2.8  安装kubeadm、kubectl和kubelet"></a>2.2.8  安装kubeadm、kubectl和kubelet</h4><blockquote><p>3台机器</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#（1）列出可以安装的版本</span><br>yum list kubeadm --showduplicates | <span class="hljs-built_in">sort</span> -r<br><span class="hljs-comment">#（2）安装kubeadm、kubectl和kubelet</span><br>yum install -y kubeadm-1.23.14 kubelet-1.23.14 kubectl-1.23.14<br></code></pre></td></tr></table></figure><h4 id="2-2-9-设置Docker与K8s为同一个cgroup"><a href="#2-2-9-设置Docker与K8s为同一个cgroup" class="headerlink" title="2.2.9 设置Docker与K8s为同一个cgroup"></a>2.2.9 设置Docker与K8s为同一个cgroup</h4><blockquote><p>3台机器</p></blockquote><p>（1）Docker</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># docker</span><br>vi /etc/docker/daemon.json<br><span class="hljs-comment"># 添加这行</span><br><span class="hljs-string">&quot;exec-opts&quot;</span>: [<span class="hljs-string">&quot;native.cgroupdriver=systemd&quot;</span>],<br><span class="hljs-comment"># 重启docker</span><br>systemctl restart docker<br></code></pre></td></tr></table></figure><p>（2）K8s</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># kubelet</span><br>sed -i <span class="hljs-string">&quot;s/cgroup-driver=systemd/cgroup-driver=cgroupfs/g&quot;</span> /etc/systemd/system/kubelet.service.d/10-kubeadm.conf<br><span class="hljs-comment"># 重启kubelet</span><br>systemctl restart kubelet &amp;&amp; systemctl <span class="hljs-built_in">enable</span> kubelet<br></code></pre></td></tr></table></figure><h4 id="2-2-10-准备安装K8s组件需要的image"><a href="#2-2-10-准备安装K8s组件需要的image" class="headerlink" title="2.2.10 准备安装K8s组件需要的image"></a>2.2.10 准备安装K8s组件需要的image</h4><blockquote><p>3台机器</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubeadm config images list<br><br>k8s.gcr.io/kube-apiserver:v1.23.14<br>k8s.gcr.io/kube-controller-manager:v1.23.14<br>k8s.gcr.io/kube-scheduler:v1.23.14<br>k8s.gcr.io/kube-proxy:v1.23.14<br>k8s.gcr.io/pause:3.6<br>k8s.gcr.io/etcd:3.5.5-0<br>k8s.gcr.io/coredns/coredns:v1.8.6<br></code></pre></td></tr></table></figure><p>下载镜像需要科学上网，可以通过香港服务器下载后再上传到自己的镜像仓库中使用。</p><p>拉取镜像的sh：kubeadm-pull-image.sh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">set</span> -e<br><br>KUBE_VERSION=v1.23.14<br>KUBE_PAUSE_VERSION=3.6<br>ETCD_VERSION=3.5.5-0<br><br>ALIYUN_URL=registry.cn-hangzhou.aliyuncs.com/jack-kubernetes<br>GCR_URL=k8s.gcr.io<br><br>images=(kube-proxy:<span class="hljs-variable">$&#123;KUBE_VERSION&#125;</span><br>kube-scheduler:<span class="hljs-variable">$&#123;KUBE_VERSION&#125;</span><br>kube-controller-manager:<span class="hljs-variable">$&#123;KUBE_VERSION&#125;</span><br>kube-apiserver:<span class="hljs-variable">$&#123;KUBE_VERSION&#125;</span><br>pause:<span class="hljs-variable">$&#123;KUBE_PAUSE_VERSION&#125;</span><br>etcd:<span class="hljs-variable">$&#123;ETCD_VERSION&#125;</span><br>)<br><br><span class="hljs-keyword">for</span> imageName <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;images[@]&#125;</span> ; <span class="hljs-keyword">do</span><br>docker pull <span class="hljs-variable">$ALIYUN_URL</span>/<span class="hljs-variable">$imageName</span><br>docker tag <span class="hljs-variable">$ALIYUN_URL</span>/<span class="hljs-variable">$imageName</span> <span class="hljs-variable">$GCR_URL</span>/<span class="hljs-variable">$imageName</span><br>docker rmi <span class="hljs-variable">$ALIYUN_URL</span>/<span class="hljs-variable">$imageName</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull registry.cn-hangzhou.aliyuncs.com/jack-kubernetes/coredns:v1.8.6<br>docker tag registry.cn-hangzhou.aliyuncs.com/jack-kubernetes/coredns:v1.8.6 k8s.gcr.io/coredns/coredns:v1.8.6<br>docker rmi registry.cn-hangzhou.aliyuncs.com/jack-kubernetes/coredns:v1.8.6<br></code></pre></td></tr></table></figure><h4 id="2-2-11-搭建Master"><a href="#2-2-11-搭建Master" class="headerlink" title="2.2.11 搭建Master"></a>2.2.11 搭建Master</h4><blockquote><p>Master Node</p></blockquote><p>（1）初始化Master</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># --pod-network-cidr可以随意设置，推荐10.**.**.**开头，用于pod之间通信</span><br>kubeadm init --kubernetes-version=1.23.14 --apiserver-advertiseaddress=192.168.0.51 --pod-network-cidr=10.244.0.0/16<br><span class="hljs-comment">#记录下初始化过程中重要的日志信息</span><br></code></pre></td></tr></table></figure><p>（2）记录下join的内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubeadm <span class="hljs-built_in">join</span> 192.168.0.51:6443 --token bi2z4y.nmwqwaz5e5scqhb3 \ --discovery-token-ca-cert-hash sha256:5791deaa7119c6536cd4869ea9a152b00ae4b70b1aa19750137a077e4c6afed0<br></code></pre></td></tr></table></figure><p>（3）根据日志提示进行如下操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$HOME</span>/.kube<br>sudo <span class="hljs-built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/config<br>sudo <span class="hljs-built_in">chown</span> $(<span class="hljs-built_in">id</span> -u):$(<span class="hljs-built_in">id</span> -g) <span class="hljs-variable">$HOME</span>/.kube/config<br></code></pre></td></tr></table></figure><p>（4）查看cluster-info和健康检查</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl cluster-info<br>curl -k https://localhost:6443/healthz<br></code></pre></td></tr></table></figure><p>（5）查看系统Pod</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get pods -n kube-system<br></code></pre></td></tr></table></figure><p>（6）kube init流程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进行一系列检查，以确定这台机器可以部署kubernetes</span><br><span class="hljs-comment"># 生成kubernetes对外提供服务所需要的各种证书可对应目录</span><br><span class="hljs-built_in">ls</span> /etc/kubernetes/pki/*<br><span class="hljs-comment"># 为其他组件生成访问kube-ApiServer所需的配置文件</span><br><span class="hljs-built_in">ls</span> /etc/kubernetes/<br><span class="hljs-comment"># 生成master节点需要的Pod文件。</span><br><span class="hljs-built_in">ls</span> /etc/kubernetes/manifests/*.yaml<br><span class="hljs-comment"># 一旦这些 YAML 文件出现在被 kubelet 监视的/etc/kubernetes/manifests/目录下，kubelet就</span><br>会自动创建这些yaml文件定义的pod，即master组件的容器。<br><span class="hljs-comment"># master容器启动后，kubeadm会通过检查localhost：6443/healthz这个master组件的健康状态检查URL，等待master组件完全运行起来</span><br><span class="hljs-comment"># 为集群生成一个bootstrap token</span><br><span class="hljs-comment"># 将ca.crt等master节点的重要信息，通过ConfigMap的方式保存在etcd中，工后续部署node节点使用</span><br><span class="hljs-comment"># 最后一步是安装默认插件。kubernetes默认kube-proxy和DNS两个插件是必须安装的</span><br></code></pre></td></tr></table></figure><p>（7）安装calico网络插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 选择网络插件</span><br>https://kubernetes.io/docs/concepts/cluster-administration/addons/<br><span class="hljs-comment"># calico网络插件</span><br>https://projectcalico.docs.tigera.io/getting-started/kubernetes/<br><span class="hljs-comment"># 提前拉取镜像</span><br>docker pull docker.io/calico/kube-controllers:v3.20.3<br>docker pull docker.io/calico/pod2daemon-flexvol:v3.20.3<br>docker pull docker.io/calico/node:v3.20.3<br>docker pull docker.io/calico/cni:v3.20.3<br><span class="hljs-comment"># 安装calico:v3.20</span><br>kubectl apply -f https://docs.projectcalico.org/v3.20/manifests/calico.yaml<br><span class="hljs-comment"># 查看calico是否安装成功</span><br>watch kubectl get pods --all-namespaces<br></code></pre></td></tr></table></figure><h4 id="2-2-12-搭建Worker-Node"><a href="#2-2-12-搭建Worker-Node" class="headerlink" title="2.2.12 搭建Worker Node"></a>2.2.12 搭建Worker Node</h4><p>（1）查看node状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get nodes<br></code></pre></td></tr></table></figure><p>（2）在2台worker node上执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubeadm <span class="hljs-built_in">join</span> 192.168.0.51:6443 --token bi2z4y.nmwqwaz5e5scqhb3 \ --discovery-token-ca-cert-hash sha256:5791deaa7119c6536cd4869ea9a152b00ae4b70b1aa19750137a077e4c6afed0<br></code></pre></td></tr></table></figure><p>（3）查看node状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get nodes -w<br></code></pre></td></tr></table></figure><h4 id="2-2-13-K8s搭建之后的常见问题"><a href="#2-2-13-K8s搭建之后的常见问题" class="headerlink" title="2.2.13  K8s搭建之后的常见问题"></a>2.2.13  K8s搭建之后的常见问题</h4><ol><li>Node NotReady</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 问题描述</span><br>kubectl get nodes<br>NAME STATUS ROLES<br>k8s-master Ready control-plane,master<br>k8s-worker01 NotReady &lt;none&gt;<br>k8s-worker02 NotReady &lt;none&gt;<br><span class="hljs-comment"># 问题排查思路</span><br>在NotReady的node上执行：journalctl -f -u kubelet<br>查看其出错可能的原因：<br>（1）kubelet服务没有设置为开机启动：systemctl restart kubelet &amp;&amp; systemctl <span class="hljs-built_in">enable</span> kubelet<br>（2）网络环境发生了变化<br>（3）机器资源不足<br>...<br><span class="hljs-comment">#如果找不到问题，可以使用reset命令重新搭建</span><br></code></pre></td></tr></table></figure><ol start="2"><li> Worker如何使用kubectl</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 问题描述，在w1节点上通过kubectl get pods查看资源，发现报错</span><br>The connection to the server localhost:8080 was refused - did you specify the right host or port?<br><span class="hljs-comment"># 解决方案</span><br>需要在worker节点上添加可以操作集群的权限，具体设置如下：<br>切换到master上，<span class="hljs-built_in">cd</span> ~ ---&gt; <span class="hljs-built_in">cat</span> .kube/config ---&gt;复制内容<br>切换到worker02上 <span class="hljs-built_in">cd</span> ~ ---&gt; 新建文件 .kube/config ---&gt;粘贴内容<br></code></pre></td></tr></table></figure><ol start="3"><li>token忘记了怎么办</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># token是用于worker节点加入master节点的凭证，默认有效期是24小时，格式如下</span><br>kubeadm <span class="hljs-built_in">join</span> 192.168.0.51:6443 --token bi2z4y.nmwqwaz5e5scqhb3 \ --discovery-token-ca-cert-hash sha256:5791deaa7119c6536cd4869ea9a152b00ae4b70b1aa19750137a077e4c6afed0<br><br><span class="hljs-comment"># 查看token是否还在有效期内</span><br>kubeadm token list<br>[root@~]<span class="hljs-comment"># kubeadm token list</span><br>TOKEN TTL EXPIRES USAGES<br>DESCRIPTION<br>ykv2ae.fsa5wj7rrxrm1xsd 21h 2022-12-06T06:17:45Z<br>authentication,signing The default bootstrap token generated by <span class="hljs-string">&#x27;kubeadm init&#x27;</span>.<br><br><span class="hljs-comment"># 如果在有效期内，则生成一个token-hash，和token一起组成用于join的内容</span><br>openssl x509 -pubkey -<span class="hljs-keyword">in</span> /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed <span class="hljs-string">&#x27;s/^.* //&#x27;</span><br><br><span class="hljs-comment"># 如果token已经过期了，则先生成一个新的token和token-hash，用于join的内容</span><br>kubeadm token create --print-join-command<br>kubeadm token list<br><br><span class="hljs-comment"># 默认token有效期是24小时，如果想设置有效期，则可以通过--ttl来设置，0表示永不过期</span><br>kubeadm token create --print-join-command --ttl=0<br><br><span class="hljs-comment"># 如果要删除token，则执行如下命令</span><br>kubeadm token delete 3nc3wu.pfn3mlgxafuut606<br></code></pre></td></tr></table></figure><h2 id="3-K8s初体验"><a href="#3-K8s初体验" class="headerlink" title="3  K8s初体验"></a>3  K8s初体验</h2><p><a href="https://kubernetes.io/docs/concepts/workloads/pods/">https://kubernetes.io/docs/concepts/workloads/pods/</a></p><p>（1）定义一个名称为simple-pod.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.14.2</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br><br></code></pre></td></tr></table></figure><p>（2）通过kubectl apply创建Pod</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f simple-pod.yaml<br></code></pre></td></tr></table></figure><p>（3）查看Pod</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看Pod</span><br>kubectl get pods<br>kubectl get pods -w<br><span class="hljs-comment"># 查看pod运行详情</span><br>kubectl get pods -o wide<br><span class="hljs-comment"># 查看pod详情</span><br>kubectl describe pod nginx<br><span class="hljs-comment"># 比如pod被调度在了w2节点上，此时来到w2机器，使用docker的方式查看container的情况</span><br>docker ps<br></code></pre></td></tr></table></figure><p>（4）删除Pod</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl delete -f simple-pod.yaml<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker实战</title>
    <link href="/2023/04/26/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/docker/Docker%E5%AE%9E%E6%88%98/"/>
    <url>/2023/04/26/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/docker/Docker%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1-MySQL高可用集群-PXC"><a href="#1-MySQL高可用集群-PXC" class="headerlink" title="1 MySQL高可用集群-PXC"></a>1 MySQL高可用集群-PXC</h2><p>PXC官网：<a href="https://www.percona.com/">https://www.percona.com/</a></p><p><strong>多主 + 同步复制的方案 + 强一致性</strong></p><p>docker中PXC镜像就是将mysql镜像包装了一层，以便进行高可用集群的搭建，搭建步骤如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#拉取percona-xtradb-cluster的镜像</span><br>docker pull percona/percona-xtradb-cluster:5.7.21<br><br><span class="hljs-comment">#tag一下</span><br>docker tag percona/percona-xtradb-cluster:5.7.21 pxc<br>docker images<br><br><span class="hljs-comment">#创建一个单独的网段，给mysql数据库集群使用</span><br>docker network create --subnet=172.19.0.0/24 pxc-cluster-net<br>docker network <span class="hljs-built_in">ls</span><br>docker network inspect pxc-cluster-net<br><br><span class="hljs-comment">#创建volume，为了给3个container持久化数据使用</span><br>docker volume create pxc-v1<br>docker volume create pxc-v2<br>docker volume create pxc-v3<br>docker volume <span class="hljs-built_in">ls</span><br><br><span class="hljs-comment">#创建node1容器</span><br>docker run -d --name=node1 -p 3301:3306 -v pxc-v1:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=test666 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=test666 --net=pxc-cluster-net --priviledge pxc<br>docker ps<br>docker inspect node1<br><span class="hljs-comment">#创建node2容器</span><br>docker run -d --name=node2 -p 3302:3306 -v pxc-v2:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=test666 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=test666 --net=pxc-cluster-net -e CLUSTER_JOIN=node1 pxc<br>docker ps<br>docker inspect node2<br><span class="hljs-comment">#创建node3容器</span><br>docker run -d --name=node3 -p 3303:3306 -v pxc-v3:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=test666 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=test666 --net=pxc-cluster-net -e CLUSTER_JOIN=node1 pxc<br>docker ps<br>docker inspect node3<br></code></pre></td></tr></table></figure><p>MYSQL其他高可用集群方案：</p><ol><li>MMM: Master-Master Replication Manager for MySQL：支持故障转移、主从切换</li><li>MHA：Master High Availability：支持故障主持、主从切换</li></ol><h2 id="2-Docker-Compose-实战"><a href="#2-Docker-Compose-实战" class="headerlink" title="2 Docker Compose-实战"></a>2 Docker Compose-实战</h2><p>官网：<a href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a></p><p>Docker Compose能够在 Docker 节点上，以单引擎模式(Single-Engine Mode)进行多容器应用的部署和管理。也就是单节点的容器编排工具。</p><h3 id="2-1-需求"><a href="#2-1-需求" class="headerlink" title="2.1 需求"></a>2.1 需求</h3><p>访问一个网页地址，每次能够得到访问的次数，采用Python+Redis实现 Python写后台代码，Redis作为次数存储 python写好业务代码，将其通过Dockerfile生成image，然后创建一个container redis镜像直接从镜像仓库获取。</p><h3 id="2-2-创建py业务代码的image"><a href="#2-2-创建py业务代码的image" class="headerlink" title="2.2 创建py业务代码的image"></a>2.2 创建py业务代码的image</h3><ol><li>创建文件夹compose-case</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> compose-case<br><span class="hljs-built_in">cd</span> compose-case<br></code></pre></td></tr></table></figure><ol start="2"><li>编写app.py文件</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">import</span> redis<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br>app = Flask(__name__)<br>cache = redis.Redis(host=<span class="hljs-string">&#x27;redis&#x27;</span>, port=<span class="hljs-number">6379</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_hit_count</span>():<br>    retries = <span class="hljs-number">5</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> cache.incr(<span class="hljs-string">&#x27;hits&#x27;</span>)<br>        <span class="hljs-keyword">except</span> redis.exceptions.ConnectionError <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-keyword">if</span> retries == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">raise</span> exc<br>            retries -= <span class="hljs-number">1</span><br>            time.sleep(<span class="hljs-number">0.5</span>)<br>            <br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():<br>    count = get_hit_count()<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;</span>.<span class="hljs-built_in">format</span>(count)<br></code></pre></td></tr></table></figure><ol start="3"><li>在compose-case下新建requirements.txt文件</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">flask</span><br><span class="hljs-attribute">redis</span><br></code></pre></td></tr></table></figure><ol start="4"><li>编写Dockerfile</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span>-alpine<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /code</span><br><span class="hljs-keyword">ENV</span> FLASK_APP app.py<br><span class="hljs-keyword">ENV</span> FLASK_RUN_HOST <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apk add --no-cache gcc musl-dev linux-headers</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> requirements.txt requirements.txt</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;flask&quot;</span>, <span class="hljs-string">&quot;run&quot;</span>]</span><br></code></pre></td></tr></table></figure><ol start="5"><li>根据Dockerfile构建image并查看</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker build -t python-app-image .<br>docker images<br></code></pre></td></tr></table></figure><h3 id="2-3-之前的方式"><a href="#2-3-之前的方式" class="headerlink" title="2.3 之前的方式"></a>2.3 之前的方式</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建网络</span><br>docker network create --subnet=172.20.0.0/24 app-net<br><span class="hljs-comment"># 创建python程序的container，并指定网段</span><br>docker run -d --name web -p 5000:5000 --network app-net python-app-image<br><span class="hljs-comment"># 创建redis的container，并指定网段</span><br>docker run -d --name redis --network app-net redis:alpine<br><span class="hljs-comment"># 访问测试</span><br>curl centosip:5000<br></code></pre></td></tr></table></figure><h3 id="2-4-docker-compose实现"><a href="#2-4-docker-compose实现" class="headerlink" title="2.4 docker-compose实现"></a>2.4 docker-compose实现</h3><ol><li> 安装docker-compose</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#或者手动下载安装包并放到指定目录下重命名</span><br>sudo curl -L <span class="hljs-string">&quot;https://github.com/docker/compose/releases/download/1.24.1/dockercompose-<span class="hljs-subst">$(uname -s)</span>-<span class="hljs-subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose<br><br><span class="hljs-built_in">chmod</span> +x /usr/local/bin/docker-compose<br>docker-compose version<br></code></pre></td></tr></table></figure><ol start="2"><li>创建docker-compose.yaml文件</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5000:5000&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">app-net</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;redis:alpine&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">app-net</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">app-net:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br></code></pre></td></tr></table></figure><ol start="3"><li> 启动并访问测试</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker-compose up -d<br>curl centosip:5000<br></code></pre></td></tr></table></figure><ol start="4"><li>扩容</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker-compose up --scale web=5 -d<br>docker-compose ps<br>docker-compose logs web<br></code></pre></td></tr></table></figure><ol start="5"><li>docker-compose使用指南</li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vim">(<span class="hljs-number">1</span>) 查看版本<br>docker-compose <span class="hljs-keyword">version</span><br>(<span class="hljs-number">2</span>) 根据yml创建service<br>docker-compose <span class="hljs-keyword">up</span><br>指定yml：docker-compose <span class="hljs-keyword">up</span> -<span class="hljs-keyword">f</span> xxx.yml<br>后台运行：docker-compose <span class="hljs-keyword">up</span> -d<br>(<span class="hljs-number">3</span>) 查看启动成功的service<br>docker-compose <span class="hljs-keyword">ps</span><br>也可以使用docker <span class="hljs-keyword">ps</span><br>(<span class="hljs-number">4</span>) 查看images<br>docker-compose images<br>(<span class="hljs-number">5</span>) 停止/启动service<br>docker-compose <span class="hljs-keyword">stop</span>/start<br>(<span class="hljs-number">6</span>) 删除service[同时会删除掉network和volume]<br>docker-compose down<br>(<span class="hljs-number">7</span>) 进入到某个service<br>docker-compose exec redis <span class="hljs-keyword">sh</span><br></code></pre></td></tr></table></figure><h2 id="3-Docker-Swarm"><a href="#3-Docker-Swarm" class="headerlink" title="3 Docker Swarm"></a>3 Docker Swarm</h2><p>Docker Swarm是管理跨节点容器的编排工具，相较于Docker Compose而言，Compose只能编排单节点上的容器，Swarm将一群Docker节点虚拟化为一个主机，使得用户只要在单一主机上操作就能完成对整个容器集群的管理工作。</p><p>目前使用较多的是K8S，Swarm使用较少</p>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Minio初识</title>
    <link href="/2023/04/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/minio/Minio%E5%88%9D%E8%AF%86/"/>
    <url>/2023/04/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/minio/Minio%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-MinIO介绍"><a href="#1-MinIO介绍" class="headerlink" title="1 MinIO介绍"></a>1 MinIO介绍</h2><blockquote><p>官网：<a href="https://min.io/">https://min.io/</a></p><p>官方示例：<a href="https://gitcode.net/mirrors/minio/minio-java/-/tree/master">https://gitcode.net/mirrors/minio/minio-java/-/tree/master</a></p><p>下载(国内加速镜像)：<a href="https://dl.min.io/">https://dl.min.io/</a></p></blockquote><p>MinIO是一个分布式文件存储系统，基于Apache License V2.0协议开发，Go语言编写。完全兼容Amazon S3。易于使用、快速与其他应用结合。为海量数据存储、人工智能、大数据分析而设计。</p><p>优点：</p><ol><li>高性能   2. 可扩展性  3. 云原生支持  4. 代码开源</li></ol><p>特性：</p><ol><li>纠删编码   2. 提供bit rot保护   3.数据加密保护   4.连续复制  5.WORM防篡改   6. 全局统一性   7.多云网关</li></ol><h2 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2 环境搭建"></a>2 环境搭建</h2><h3 id="2-1-单机"><a href="#2-1-单机" class="headerlink" title="2.1 单机"></a>2.1 单机</h3><ol><li>下载MinIO</li></ol><p>地址-1：<a href="https://dl.min.io/">https://dl.min.io/</a>  (建议)  (server ==&gt; minio ==&gt; release ==&gt; linux-amd64 ==&gt; minio)</p><p>地址-2：<a href="https://min.io/download#/linux">https://min.io/download#/linux</a>  (国外镜像，很慢)</p><p><img src="/image/minio/1.png"></p><ol start="2"><li>部署MinIO</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 1、minio安装目录（创建|定位）</span><br><span class="hljs-built_in">mkdir</span> -p /data/minio/<br><span class="hljs-built_in">cd</span> /data/minio/<br><br><span class="hljs-comment"># 2、将下载的文件上传到安装目录</span><br><span class="hljs-comment">##--------【此处直接指定账号密码、采用后台启动的方式运行MinIO】----------------##</span><br><span class="hljs-comment"># 创建账号</span><br><span class="hljs-comment">#export MINIO_ACCESS_KEY=admin</span><br><span class="hljs-comment"># 创建密码</span><br><span class="hljs-comment">#export MINIO_SECRET_KEY=minio123456</span><br><span class="hljs-comment"># 后台启动（打印日志）</span><br><span class="hljs-comment">#nohup /data/minio/minio server /data/minio/ &gt; /data/minio/minio.log &amp;</span><br><span class="hljs-comment">##---------------------------------------------------------------------##</span><br><br><span class="hljs-comment">##--------【下方配置成系统服务、启动运行的方式 较为方便】----------------------##</span><br><span class="hljs-comment"># 3、创建启动脚本</span><br>vim /data/minio/start.sh<br><span class="hljs-comment">##--------写入内容-------------------------------------------------##</span><br><span class="hljs-comment">#####写入内容#####</span><br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">export</span> MINIO_ACCESS_KEY=admin<br><span class="hljs-built_in">export</span> MINIO_SECRET_KEY=minio123456<br>/data/minio/minio server /data/minio/ &gt; /data/minio/minio.log<br><span class="hljs-comment"># 默认端口：9000；还可以使用 自定义启动端口 和 控制台端口（默认端口不冲突的话 可以不设置）</span><br><span class="hljs-comment"># /data/minio/minio server --address :9000 --console-address :9001 /data/minio/ &gt; /data/minio/minio.log</span><br><span class="hljs-comment">##----------------------------------------------------------------##</span><br><br><span class="hljs-comment"># 4、创建停止脚本</span><br>vim /data/minio/stop.sh<br><span class="hljs-comment">#---写入内容-------------------------------------------------------------#</span><br><span class="hljs-comment">#!/bin/bash</span><br>ps -ef | grep minio | grep -v <span class="hljs-string">&#x27;grep&#x27;</span> | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>| xargs <span class="hljs-built_in">kill</span> -9<br><span class="hljs-keyword">if</span> $? != 0;<span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;minio service stop failed.&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><span class="hljs-comment">#-----------------------------------------------------------------------#</span><br><br><span class="hljs-comment"># 5、创建minio系统服务（将其加入系统服务）</span><br>vim /usr/lib/systemd/system/minio.service<br><span class="hljs-comment">#---写入内容------------------------------#</span><br>[Unit]<br>Description=Minio service<br>Documentation=https://docs.minio.io/<br>[Service]<br>WorkingDirectory=/data/minio/<br>ExecStart=/data/minio/start.sh<br>ExecStop=/data/minio/stop.sh<br>Restart=on-failure<br>RestartSec=5<br>[Install]<br>WantedBy=multi-user.target<br><span class="hljs-comment">#----------------------------------------#</span><br><br><span class="hljs-comment"># 6、修改相关文件权限</span><br><span class="hljs-built_in">chmod</span> +x /usr/lib/systemd/system/minio.service &amp;&amp; <span class="hljs-built_in">chmod</span> +x /data/minio/minio &amp;&amp; <span class="hljs-built_in">chmod</span> +x /data/minio/start.sh &amp;&amp; <span class="hljs-built_in">chmod</span> +x /data/minio/stop.sh<br><br><span class="hljs-comment"># 7、服务操作</span><br><span class="hljs-comment"># 7-1、重写加载服务（使配置文件变更生效）</span><br>systemctl daemon-reload<br><span class="hljs-comment"># 7-2、启动服务</span><br>systemctl start minio<br><span class="hljs-comment"># 7-3、关闭服务</span><br><span class="hljs-comment"># systemctl stop minio</span><br><span class="hljs-comment"># 7-4、加入自启动</span><br>systemctl <span class="hljs-built_in">enable</span> minio<br><span class="hljs-comment">##---------------------------------------------------------------------##</span><br><br><span class="hljs-comment"># 8、检查状态</span><br>ps -ef|grep minio<br></code></pre></td></tr></table></figure><ol start="3"><li>使用</li></ol><p>浏览器访问地址：<a href="http://ip:9000/">http://ip:9000</a> （登录输入之前配置的 access_key 和 secret_key）</p><p><img src="/image/minio/2.png"></p><h3 id="2-2-集群"><a href="#2-2-集群" class="headerlink" title="2.2 集群"></a>2.2 集群</h3><h4 id="2-2-1-系统环境"><a href="#2-2-1-系统环境" class="headerlink" title="2.2.1 系统环境"></a>2.2.1 系统环境</h4><p>Linux（CentOS 7、IP：192.168.61.142、192.168.61.143）</p><p>集群部署方式分为以下两种： </p><p>​    直接部署（未分组、不支持集群扩容） </p><p>​    分组扩容部署（支持 MinIO 官方方式扩容）【<strong>建议</strong>】</p><h4 id="2-2-2-挂载新硬盘"><a href="#2-2-2-挂载新硬盘" class="headerlink" title="2.2.2 挂载新硬盘"></a>2.2.2 挂载新硬盘</h4><p>MinIO在集群部署时，数据目录所对应的要求是一块物理盘，启动时MinIO会去格式化硬盘，不能是系统盘，若不然 会提示错误，所以系统预装没有新硬盘的情况下，需要执行系统挂载新硬盘操作。</p><h5 id="2-2-2-1-添加硬盘"><a href="#2-2-2-1-添加硬盘" class="headerlink" title="2.2.2.1 添加硬盘"></a>2.2.2.1 添加硬盘</h5><p>虚拟机关机</p><p><img src="/image/minio/3.png"></p><p><img src="/image/minio/4.png"></p><p><img src="/image/minio/5.png"></p><p>查看设备挂载情况，开启虚拟机</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">lsblk -f<br></code></pre></td></tr></table></figure><p><img src="/image/minio/6.png"></p><h5 id="2-2-2-2-新硬盘分区"><a href="#2-2-2-2-新硬盘分区" class="headerlink" title="2.2.2.2 新硬盘分区"></a>2.2.2.2 新硬盘分区</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># sdb（新磁盘名）</span><br>fdisk /dev/sdb<br><span class="hljs-comment"># 分区操作参考：</span><br><span class="hljs-comment"># n（回车）==&gt; p（回车）==&gt; &#123;1 | 2 | 3 | 4&#125;（回车）==&gt; 起始扇区[默认值]（回车）==&gt; 扇区大小[+xxxxM按需指定]（回车）</span><br><span class="hljs-comment"># w（保存分区信息</span><br></code></pre></td></tr></table></figure><p><img src="/image/minio/7.png"></p><h5 id="2-2-2-3-分区格式化"><a href="#2-2-2-3-分区格式化" class="headerlink" title="2.2.2.3 分区格式化"></a>2.2.2.3 分区格式化</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">mkfs -t ext4 /dev/sdb1<br>mkfs -t ext4 /dev/sdb2<br>mkfs -t ext4 /dev/sdb3<br>mkfs -t ext4 /dev/sdb4<br></code></pre></td></tr></table></figure><p><img src="/image/minio/8.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#查看结果</span><br>lsblk -f<br></code></pre></td></tr></table></figure><p><img src="/image/minio/9.png"></p><h5 id="2-2-2-4-挂载硬盘目录"><a href="#2-2-2-4-挂载硬盘目录" class="headerlink" title="2.2.2.4 挂载硬盘目录"></a>2.2.2.4 挂载硬盘目录</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">mount /dev/sdb1 /data/minio/data1<br>mount /dev/sdb2 /data/minio/data2<br>mount /dev/sdb3 /data/minio/data3<br>mount /dev/sdb4 /data/minio/data4<br><br><span class="hljs-comment">#查看结果</span><br>lsblk -f<br></code></pre></td></tr></table></figure><p><img src="/image/minio/10.png"></p><h5 id="2-2-2-5-设置自动挂载"><a href="#2-2-2-5-设置自动挂载" class="headerlink" title="2.2.2.5 设置自动挂载"></a>2.2.2.5 设置自动挂载</h5><p><img src="/image/minio/11.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim /etc/fstab<br><span class="hljs-comment"># 文件末尾添加</span><br><span class="hljs-comment">#UUID=33c07641-bae6-4f7b-987a-c58f1d370cc3 /dev/sdb1 /data/minio/data1/ ext4 defaults 0 0</span><br><span class="hljs-comment">#UUID=78c7e4b5-756e-4b14-9627-85b4cb11a388 /dev/sdb2 /data/minio/data2/ ext4 defaults 0 0</span><br><span class="hljs-comment">#UUID=f8c05a74-4f9c-447d-8d9f-0771bb6e493f /dev/sdb3 /data/minio/data3/ ext4 defaults 0 0</span><br><span class="hljs-comment">#UUID=aa96b070-bf21-4d13-9c00-9bf390d69618 /dev/sdb4 /data/minio/data4/ ext4 defaults 0 0</span><br>/dev/sdb1 /data/minio/data1/ ext4 defaults 0 0<br>/dev/sdb2 /data/minio/data2/ ext4 defaults 0 0<br>/dev/sdb3 /data/minio/data3/ ext4 defaults 0 0<br>/dev/sdb4 /data/minio/data4/ ext4 defaults 0 0<br></code></pre></td></tr></table></figure><p><img src="/image/minio/12.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#重新加载</span><br>mount -a<br></code></pre></td></tr></table></figure><h4 id="2-2-3-下载MinIO"><a href="#2-2-3-下载MinIO" class="headerlink" title="2.2.3 下载MinIO"></a>2.2.3 下载MinIO</h4><p>同单机一样</p><h4 id="2-2-4-安装部署"><a href="#2-2-4-安装部署" class="headerlink" title="2.2.4 安装部署"></a>2.2.4 安装部署</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#【注意：以下操作均在两节点上进行】</span><br><span class="hljs-comment"># 1、创建数据目录</span><br><span class="hljs-built_in">mkdir</span> -p /data/minio/&#123;data1,data2,data3,data4&#125;<br><br><span class="hljs-comment"># 2、创建配置目录【两个节点均操作】</span><br><span class="hljs-built_in">mkdir</span> -p /etc/minioconfig<br><br><span class="hljs-comment"># 3、定位到minio安装目录、将下载的文件上传到安装目录【两个节点均操作】</span><br><span class="hljs-built_in">cd</span> /data/minio/<br><br><span class="hljs-comment"># 4、创建MinIO启动脚本文件【两个节点均操作】</span><br>vim /data/minio/start.sh<br><span class="hljs-comment">##---【192.168.61.142】写入内容------------------------------##</span><br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">export</span> MINIO_ACCESS_KEY=admin<br><span class="hljs-built_in">export</span> MINIO_SECRET_KEY=minio123456<br>/data/minio/minio server --config-dir /etc/minioconfig \<br>--address <span class="hljs-string">&quot;192.168.61.142:9000&quot;</span> \<br>http://192.168.61.&#123;142...143&#125;/data/minio/data&#123;1...4&#125;<br><span class="hljs-comment">##---------------------------------------------------------##</span><br><span class="hljs-comment">##---【192.168.61.143】写入内容------------------------------##</span><br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">export</span> MINIO_ACCESS_KEY=admin<br><span class="hljs-built_in">export</span> MINIO_SECRET_KEY=minio123456<br>/data/minio/minio server --config-dir /etc/minioconfig \<br>--address <span class="hljs-string">&quot;192.168.61.143:9000&quot;</span> \<br>http://192.168.61.&#123;142...143&#125;/data/minio/data&#123;1...4&#125;<br><span class="hljs-comment">##---------------------------------------------------------##</span><br><br><span class="hljs-comment"># 5、创建MinIO停止脚本文件【两个节点均操作】</span><br>vim /data/minio/stop.sh<br><span class="hljs-comment">##---【192.168.61.142】写入内容-------------------------------------------##</span><br><span class="hljs-comment">#!/bin/bash</span><br>ps -ef | grep minio | grep -v <span class="hljs-string">&#x27;grep&#x27;</span> | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>| xargs <span class="hljs-built_in">kill</span> -9<br><span class="hljs-keyword">if</span> $? != 0;<span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;minio service stop failed.&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><span class="hljs-comment">##----------------------------------------------------------------------##</span><br><br><span class="hljs-comment"># 6、创建minio系统服务（将其加入系统服务）</span><br>vim /usr/lib/systemd/system/minio.service<br><span class="hljs-comment">##---写入内容----------------------------------##</span><br>[Unit]<br>Description=Minio service<br>Documentation=https://docs.minio.io/<br>[Service]<br>WorkingDirectory=/data/minio/<br>ExecStart=/data/minio/start.sh<br>ExecStop=/data/minio/stop.sh<br>Restart=on-failure<br>RestartSec=5<br>[Install]<br>WantedBy=multi-user.target<br><span class="hljs-comment">##--------------------------------------------##</span><br><br><span class="hljs-comment"># 7、修改相关文件权限</span><br><span class="hljs-built_in">chmod</span> +x /usr/lib/systemd/system/minio.service &amp;&amp; <span class="hljs-built_in">chmod</span> +x /data/minio/minio &amp;&amp; <span class="hljs-built_in">chmod</span> +x<br>/data/minio/start.sh &amp;&amp; <span class="hljs-built_in">chmod</span> +x /data/minio/stop.sh<br><span class="hljs-comment">#chmod +x /usr/lib/systemd/system/minio.service</span><br><span class="hljs-comment">#chmod +x /data/minio</span><br><span class="hljs-comment">#chmod +x /data/minio/start-run.sh</span><br><br><span class="hljs-comment"># 8、服务操作</span><br><span class="hljs-comment"># 8-1、重写加载服务（使配置文件变更生效）</span><br>systemctl daemon-reload<br><span class="hljs-comment"># 8-2、启动服务</span><br>systemctl start minio<br><span class="hljs-comment"># 8-3、关闭服务</span><br><span class="hljs-comment"># systemctl stop minio</span><br><span class="hljs-comment"># 8-4、加入自启动</span><br>systemctl <span class="hljs-built_in">enable</span> minio<br><br><span class="hljs-comment"># 9、查看minon集群状态</span><br>systemctl status minio.service -l<br></code></pre></td></tr></table></figure><h4 id="2-2-5-MinIO使用"><a href="#2-2-5-MinIO使用" class="headerlink" title="2.2.5 MinIO使用"></a>2.2.5 MinIO使用</h4><p>通过任意节点的ip都可以访问。</p><p>备注：实际场景中，如果想要实现对各个节点的均衡访问，还可以安装配置 Nginx 实现负载均衡，通过 Nginx 负载均衡进行反向代理，统一一个地址进行转发</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 1、安装nginx</span><br>yum install epel-release -y<br>yum install nginx -y<br>systemctl start nginx<br>systemctl status nginx<br>systemctl <span class="hljs-built_in">enable</span> nginx<br><br><span class="hljs-comment"># 2、添加配置文件</span><br>vim /etc/nginx/conf.d/minio.conf<br><span class="hljs-comment">## 配置如下内容 ##</span><br>upstream minio_api &#123;<br>    server 192.168.61.142:9000;<br>    server 192.168.61.143:9000;<br>&#125;<br>upstream minio_console &#123;<br>    server 192.168.61.142:9001;<br>    server 192.168.61.143:9001;<br>&#125;<br>server&#123;<br>    listen 19000;<br>    server_name 192.168.61.142;<br>    <br>    ignore_invalid_headers off;<br>    client_max_body_size 0;<br>    proxy_buffering off;<br>     <br>    location / &#123;<br>        proxy_set_header X-Forwarded-Proto <span class="hljs-variable">$scheme</span>;<br>        proxy_set_header Host <span class="hljs-variable">$http_host</span>;<br>        proxy_set_header X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>        <br>        proxy_connect_timeout 300;<br>        proxy_http_version 1.1;<br>        chunked_transfer_encoding off;<br>        proxy_ignore_client_abort on;<br>        proxy_pass http://minio_api;<br>    &#125;<br>&#125;<br><br>server&#123;<br>    listen 19001;<br>    server_name 192.168.61.142;<br>    <br>    ignore_invalid_headers off;<br>    client_max_body_size 0;<br>    proxy_buffering off;<br>    <br>    location / &#123;<br>        proxy_set_header X-Forwarded-Proto <span class="hljs-variable">$scheme</span>;<br>        proxy_set_header Host <span class="hljs-variable">$http_host</span>;<br>        proxy_set_header X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>        <br>        proxy_connect_timeout 300;<br>        proxy_http_version 1.1;<br>        chunked_transfer_encoding off;<br>        proxy_ignore_client_abort on;<br>        <br>        proxy_pass http://minio_console;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># 3、重启加载配置</span><br>nginx -t<br>nginx -s reload<br><span class="hljs-comment">#或者 systemctl reload nginx</span><br></code></pre></td></tr></table></figure><h3 id="2-3-客户端操作"><a href="#2-3-客户端操作" class="headerlink" title="2.3 客户端操作"></a>2.3 客户端操作</h3><h4 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1 概述"></a>2.3.1 概述</h4><p>MinIO Client 简称 mc，是 MinIO 服务器的客户端，对 ls，cat，cp，mirror，diff，find 等 UNIX 命令提供了一种替代方案，它支持文件系统和兼容Amazon S3的云存储服务（AWS Signature v2和v4），常见 mc 指令：</p><table><thead><tr><th>指令</th><th>说明</th><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>ls</td><td>列出文件和文件夹</td><td>rm</td><td>删除文件和对象</td></tr><tr><td>mb</td><td>创建一个存储桶或文件夹</td><td>events</td><td>管理对象通知</td></tr><tr><td>cat</td><td>显示文件和对象内容</td><td>watch</td><td>监听文件和对象的事件</td></tr><tr><td>pipe</td><td>将一个STDIN重定向到一个对象或者文件或者STDOUT</td><td>policy</td><td>管理访问策略</td></tr><tr><td>share</td><td>生成用于共享的URL</td><td>session</td><td>为cp命令管理保存的会话</td></tr><tr><td>cp</td><td>拷贝文件和对象</td><td>config</td><td>管理mc配置文件</td></tr><tr><td>mirror</td><td>给存储桶和文件夹做镜像</td><td>update</td><td>检查软件更新</td></tr><tr><td>find</td><td>基于参数查找文件</td><td>version</td><td>输出版本信息</td></tr><tr><td>diff</td><td>对两个文件夹或者存储桶比较差异</td><td></td><td></td></tr></tbody></table><h4 id="2-3-2-下载mc"><a href="#2-3-2-下载mc" class="headerlink" title="2.3.2 下载mc"></a>2.3.2 下载mc</h4><p>地址：<a href="https://dl.min.io/">https://dl.min.io/</a>    (client ==&gt; mc ==&gt; release ==&gt; linux-amd64 ==&gt; mc)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 若没有下载文件 也可直接安装</span><br><span class="hljs-comment"># wget http://dl.minio.org.cn/client/mc/release/linux-amd64/mc</span><br><br><span class="hljs-comment"># 1、mc安装目录（创建|定位）</span><br><span class="hljs-built_in">mkdir</span> -p /data/minio/mc<br><span class="hljs-built_in">cd</span> /data/minio/mc<br><br><span class="hljs-comment"># 2、将下载的文件上传到安装目录</span><br><br><span class="hljs-comment"># 3、授予权限</span><br><span class="hljs-built_in">chmod</span> +x mc<br><br><span class="hljs-comment"># 4、查看帮助</span><br>./mc -h<br><br><span class="hljs-comment"># 5、添加服务器节点</span><br>./mc config host add q1 http://192.168.61.142:9000 admin minio123456<br>./mc config host <span class="hljs-built_in">ls</span><br><br><span class="hljs-comment"># 6、查看信息</span><br><span class="hljs-comment"># 6-1、查看q1下的所有存储桶</span><br>./mc <span class="hljs-built_in">ls</span> q1<br><span class="hljs-comment"># 6-2、获取q1的服务器信息</span><br>./mc admin info q1<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Minio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Minio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker数据持久化与网络</title>
    <link href="/2023/04/21/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/docker/Docker%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/04/21/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/docker/Docker%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%8E%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="1-数据持久化"><a href="#1-数据持久化" class="headerlink" title="1 数据持久化"></a>1 数据持久化</h2><p>官网：<a href="https://docs.docker.com/storage/">https://docs.docker.com/storage/</a></p><h3 id="1-1-Volume"><a href="#1-1-Volume" class="headerlink" title="1.1 Volume"></a>1.1 Volume</h3><h4 id="1-1-1-初始Volume"><a href="#1-1-1-初始Volume" class="headerlink" title="1.1.1 初始Volume"></a>1.1.1 初始Volume</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">rm</span> -f $(docker ps -aq)<br><br>docker volume <span class="hljs-built_in">ls</span><br><br>docker run -d --name test-mysql -e MYSQL_ROOT_PASSWORD=jack123 mysql:5.7<br><br><span class="hljs-comment"># 查看volume</span><br>docker volume <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 查看mysql Dockerfile文件</span><br>VOLUME /var/lib/mysql<br><span class="hljs-comment"># 在容器中寻找该目录/var/lib/mysql</span><br>docker <span class="hljs-built_in">exec</span> -it test-mysql bash<br><span class="hljs-built_in">ls</span> /var/lib/mysql<br><span class="hljs-comment"># 在centos物理机中寻找与之对应的目录</span><br>docker volume inspect volume_name<br><span class="hljs-comment"># 查看物理机中的目录</span><br><span class="hljs-built_in">ls</span> /var/lib/docker/volumes/e2ca4be02931e3310f6f136eb663e173d314bb3b3f243bacef776936898d4926/_data<br></code></pre></td></tr></table></figure><h4 id="1-1-2-自定义Volume"><a href="#1-1-2-自定义Volume" class="headerlink" title="1.1.2  自定义Volume"></a>1.1.2  自定义Volume</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#创建并查看volume</span><br>docker volume create test-mysql-volume<br>docker volume <span class="hljs-built_in">ls</span><br>docker volume inspect test-mysql-volume<br><span class="hljs-built_in">ls</span> /var/lob/docker/volumes/test-mysql-volume/_data<br><br><span class="hljs-comment">#创建容器并使用自定义的volume</span><br>docker run -d --name test-mysql -v test-mysql-volume:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=test123 mysql:5.7<br><br><span class="hljs-comment">#再次查看volume对应的物理目录</span><br><span class="hljs-built_in">ls</span> /var/lib/docker/volumes/test-mysql-volume/_data<br><br><span class="hljs-comment"># 可以这样理解</span><br>-v test-mysql-volume:/var/lib/mysql  就等同于在Dockerfile中定义的VOLUME命令<br></code></pre></td></tr></table></figure><h4 id="1-1-3-Volume数据修改"><a href="#1-1-3-Volume数据修改" class="headerlink" title="1.1.3 Volume数据修改"></a>1.1.3 Volume数据修改</h4><p>（1）修改container目录的数据，观察物理机的数据变化</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it test-mysql bash<br><span class="hljs-built_in">cd</span> /var/lib/mysql<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;test volume test.&quot;</span> &gt; test-volume.txt<br><span class="hljs-built_in">exit</span><br><span class="hljs-built_in">cd</span> /var/lib/docker/volumes/test-mysql-volume/_data<br><span class="hljs-built_in">ls</span><br><span class="hljs-built_in">cat</span> test-volume.txt<br></code></pre></td></tr></table></figure><p>（2）修改物理机的数据，观察container目录的数据变化</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;test-centos.&quot;</span> &gt; test-centos.txt<br>docker <span class="hljs-built_in">exec</span> -it test-mysql bash<br><span class="hljs-built_in">cd</span> /var/lib/mysql<br><span class="hljs-built_in">ls</span><br><span class="hljs-built_in">cat</span> test-centos.txt<br></code></pre></td></tr></table></figure><h4 id="1-1-4-默认Volume"><a href="#1-1-4-默认Volume" class="headerlink" title="1.1.4 默认Volume"></a>1.1.4 默认Volume</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d --name test-nginx -p 60:80 nginx<br>docker volume <span class="hljs-built_in">ls</span> <span class="hljs-comment"># 发现并没有自动创建volume，是因为在nginx的Dockerfile文件中没有指定VOLUME</span><br></code></pre></td></tr></table></figure><h4 id="1-1-5-验证持久化效果"><a href="#1-1-5-验证持久化效果" class="headerlink" title="1.1.5 验证持久化效果"></a>1.1.5 验证持久化效果</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建容器并使用自定义volume</span><br>docker run -d --name test-mysql -v test-mysql-volume:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=test123 mysql:5.7<br><span class="hljs-comment"># 进入容器并创建数据库</span><br>docker <span class="hljs-built_in">exec</span> -it test-mysql bash<br>create database db_test<br>show databases;<br><span class="hljs-comment"># 删除mysql容器并查看volume是否存在</span><br>docker <span class="hljs-built_in">rm</span> -f test-mysql<br>docker volume <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 重新创建一个mysql container并使用test-mysql-volume</span><br>docker run -d --name any-mysql -v test-mysql-volume:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=test123 mysql:5.7<br><span class="hljs-comment"># 进入容器并查看数据</span><br>docker <span class="hljs-built_in">exec</span> -it any-mysql bash<br>mysql -uroot -ptest123<br>show databases;<br></code></pre></td></tr></table></figure><h3 id="1-2-Bind-Mounting"><a href="#1-2-Bind-Mounting" class="headerlink" title="1.2 Bind Mounting"></a>1.2 Bind Mounting</h3><p>想把容器中任意的目录和centos的目录做一个绑定，比如centos中的~/shop 与tomcat container中的/usr/local/tomcat/webapps/shop进行绑定</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建tomcat容器，并指定目录绑定关系</span><br>docker run -d --name my-tomcat -p 8888:8080 -v ~/shop:/usr/local/tomcat/webapps/shop tomcat:8.0<br><span class="hljs-comment"># 查看两个目录是否存在</span><br>centos: <span class="hljs-built_in">ls</span> ~<br>tomcat容器:<br>docker <span class="hljs-built_in">exec</span> -it my-tomcat bash<br><span class="hljs-built_in">ls</span> /usr/local/tomcat/webapps<br><span class="hljs-comment"># 在centos的shop文件夹下创建文件</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;p style=&#x27;color:orange; font-size:20pt;&#x27;&gt;Bind Mounting.&lt;/p&gt;&quot;</span> &gt; index.html<br><span class="hljs-comment"># 访问该页面</span><br>centosip:8888/shop/index.html<br></code></pre></td></tr></table></figure><h2 id="2-网络"><a href="#2-网络" class="headerlink" title="2 网络"></a>2 网络</h2><p>官网：<a href="https://docs.docker.com/network/">https://docs.docker.com/network/</a></p><h3 id="2-1-网卡"><a href="#2-1-网卡" class="headerlink" title="2.1 网卡"></a>2.1 网卡</h3><h4 id="2-1-1-查看linux中的网卡"><a href="#2-1-1-查看linux中的网卡" class="headerlink" title="2.1.1 查看linux中的网卡"></a>2.1.1 查看linux中的网卡</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 方式1</span><br>ip <span class="hljs-built_in">link</span> show<br><span class="hljs-comment"># 方式2</span><br><span class="hljs-built_in">ls</span> /sys/class/net<br><span class="hljs-comment"># 方式3</span><br>ip a<br></code></pre></td></tr></table></figure><h4 id="2-1-2-分析ip-a"><a href="#2-1-2-分析ip-a" class="headerlink" title="2.1.2 分析ip a"></a>2.1.2 分析ip a</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 状态: UP、DOWN、UNKNOW</span><br><span class="hljs-comment"># link/ether：MAC地址</span><br><span class="hljs-comment"># inet：该网卡绑定的IP4地址</span><br>eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group<br>default qlen 1000<br><span class="hljs-built_in">link</span>/ether 52:54:00:8a:fe:e6 brd ff:ff:ff:ff:ff:ff<br>inet 10.0.2.15/24 brd 10.0.2.255 scope global noprefixroute dynamic eth0<br>valid_lft 83668sec preferred_lft 83668sec<br>inet6 fe80::5054:ff:fe8a:fee6/64 scope <span class="hljs-built_in">link</span><br>valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><h4 id="2-1-3-网卡对应的配置文件"><a href="#2-1-3-网卡对应的配置文件" class="headerlink" title="2.1.3 网卡对应的配置文件"></a>2.1.3 网卡对应的配置文件</h4><blockquote><p>在Linux中网卡对应的其实就是文件，所以找到对应的网卡文件即可 </p><p>具体目录为：/etc/sysconfig/network-scripts/ </p></blockquote><p>比如打开ifcfg-eth0</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">DEVICE=<span class="hljs-string">&quot;eth0&quot;</span> <span class="hljs-comment"># 表示网卡名称</span><br>BOOTPROTO=<span class="hljs-string">&quot;dhcp&quot;</span> <span class="hljs-comment"># 表示网卡类型：dhcp-动态 static-静态 none-固定</span><br>ONBOOT=<span class="hljs-string">&quot;yes&quot;</span> <span class="hljs-comment"># 开机或重启网卡的时候，是否启用该网卡</span><br>TYPE=<span class="hljs-string">&quot;Ethernet&quot;</span> <span class="hljs-comment"># 表示接口类型：Ethernet-以太网 Bridge-桥接接口</span><br>HWADDR=00:0c:29:90:89:d9 <span class="hljs-comment"># HWADDR HardWare Address 硬件地址 MAC地址</span><br>NETMASK=255.255.255.0 <span class="hljs-comment"># 子网掩码 决定这个局域网中最多有多少台机器</span><br>IPADDR=192.168.0.100<br>GATEWAY=10.0.0.2 <span class="hljs-comment"># 网关</span><br>USERCTL=no <span class="hljs-comment"># 普通用户是否能控制网卡</span><br>PERSISTENT_DHCLIENT=<span class="hljs-string">&quot;yes&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-Network-Namespace"><a href="#2-2-Network-Namespace" class="headerlink" title="2.2 Network Namespace"></a>2.2 Network Namespace</h3><p>linux上，网络的隔离是通过network namespace来管理的，不同的network namespace是互相隔离的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看</span><br>ip netns list<br><span class="hljs-comment"># 添加</span><br>ip netns add ns1<br><span class="hljs-comment"># 删除</span><br>ip netns delete ns1<br></code></pre></td></tr></table></figure><h4 id="2-2-1-创建Namespace"><a href="#2-2-1-创建Namespace" class="headerlink" title="2.2.1 创建Namespace"></a>2.2.1 创建Namespace</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建一个network namespace</span><br>ip netns add ns1<br><span class="hljs-comment"># 查看该namespace下网卡的情况</span><br>ip netns <span class="hljs-built_in">exec</span> ns1 ip a<br><span class="hljs-comment"># 启动ns1上的lo网卡</span><br>ip netns <span class="hljs-built_in">exec</span> ns1 ifup lo 或 ip netns <span class="hljs-built_in">exec</span> ns1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> lo up<br>ip netns <span class="hljs-built_in">exec</span> ns1 ip a<br><span class="hljs-comment"># 再次创建一个network namespace</span><br>ip netns add ns2<br></code></pre></td></tr></table></figure><p><img src="/image/docker/4.png"></p><h4 id="2-2-2-连接Namespace之间的网络"><a href="#2-2-2-连接Namespace之间的网络" class="headerlink" title="2.2.2  连接Namespace之间的网络"></a>2.2.2  连接Namespace之间的网络</h4><p>veth pair：virtual ethernet pair，是一个成对的端口，可以实现上述功能</p><p><img src="/image/docker/5.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建一对link，也就是接下来要通过veth pair连接的link</span><br>ip <span class="hljs-built_in">link</span><br>ip <span class="hljs-built_in">link</span> add veth-ns1 <span class="hljs-built_in">type</span> veth peer name veth-ns2<br>ip <span class="hljs-built_in">link</span><br><span class="hljs-comment"># 将veth-ns1加入ns1中，将veth-ns2加入ns2中</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth-ns1 netns ns1<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth-ns2 netns ns2<br><span class="hljs-comment"># 查看宿主机和ns1，ns2的link情况</span><br>ip <span class="hljs-built_in">link</span><br>ip netns <span class="hljs-built_in">exec</span> ns1 ip <span class="hljs-built_in">link</span><br>ip netns <span class="hljs-built_in">exec</span> ns2 ip <span class="hljs-built_in">link</span><br><span class="hljs-comment"># 给veth-ns1和veth-ns2添加IP地址并启动</span><br>ip netns <span class="hljs-built_in">exec</span> ns1 ip addr add 192.168.0.11/24 dev veth-ns1<br>ip netns <span class="hljs-built_in">exec</span> ns1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth-ns1 up<br>ip netns <span class="hljs-built_in">exec</span> ns2 ip addr add 192.168.0.12/24 dev veth-ns2<br>ip netns <span class="hljs-built_in">exec</span> ns2 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth-ns2 up<br>ip netns <span class="hljs-built_in">exec</span> ns1 ip a<br>ip netns <span class="hljs-built_in">exec</span> ns2 ip a<br><span class="hljs-comment"># 彼此ping测试一下</span><br>ip netns <span class="hljs-built_in">exec</span> ns1 ping 192.168.0.12<br>ip netns <span class="hljs-built_in">exec</span> ns2 ping 192.168.0.11<br></code></pre></td></tr></table></figure><h4 id="2-2-3-容器的Network-Namespace"><a href="#2-2-3-容器的Network-Namespace" class="headerlink" title="2.2.3  容器的Network Namespace"></a>2.2.3  容器的Network Namespace</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建两个tomcat容器</span><br>docker run -d --name tomcat01 -p 8081:8080 tomcat:8.0<br>docker run -d --name tomcat02 -p 8082:8080 tomcat:8.0<br><span class="hljs-comment"># 进入容器并安装ip命令</span><br>docker <span class="hljs-built_in">exec</span> -it tomcat01 bash<br>apt update<br>apt install -y iproutes<br>docker <span class="hljs-built_in">exec</span> -it tomcat02 bash<br>apt update<br>apt install -y iproutes<br><span class="hljs-comment"># 查看容器的IP</span><br>docker <span class="hljs-built_in">exec</span> -it tomcat01 ip a<br>docker <span class="hljs-built_in">exec</span> -it tomcat02 ip a<br><span class="hljs-comment"># ping一下</span><br>docker <span class="hljs-built_in">exec</span> -it tomcat01 ping 172.17.0.3<br>docker <span class="hljs-built_in">exec</span> -it tomcat02 ping 172.17.0.2<br>ping 172.17.0.2<br>ping 172.17.0.3<br></code></pre></td></tr></table></figure><h3 id="2-3-Docker常见网络类型"><a href="#2-3-Docker常见网络类型" class="headerlink" title="2.3 Docker常见网络类型"></a>2.3 Docker常见网络类型</h3><h4 id="2-3-1-Bridge之docker0"><a href="#2-3-1-Bridge之docker0" class="headerlink" title="2.3.1 Bridge之docker0"></a>2.3.1 Bridge之docker0</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看centos的veth</span><br>ip <span class="hljs-built_in">link</span><br><span class="hljs-comment"># 查看两个tomcat容器的veth</span><br>docker <span class="hljs-built_in">exec</span> -it tomcat01 ip <span class="hljs-built_in">link</span><br>docker <span class="hljs-built_in">exec</span> -it tomcat02 ip <span class="hljs-built_in">link</span><br></code></pre></td></tr></table></figure><p><img src="/image/docker/6.png"></p><p><img src="/image/docker/7.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看docker中的网络模式</span><br>docker network <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 查看bridge的细节</span><br>docker network inspect bridge<br></code></pre></td></tr></table></figure><p><img src="/image/docker/8.png"></p><h4 id="2-3-2-Bridge网络模式实战"><a href="#2-3-2-Bridge网络模式实战" class="headerlink" title="2.3.2 Bridge网络模式实战"></a>2.3.2 Bridge网络模式实战</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建一个network，类型为bridge</span><br>docker network create --subnet=172.18.0.0/24 tomcat-net<br>docker network <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 查看tomcat-net细节</span><br>docker network inspect tomcat-net<br><span class="hljs-comment"># 创建tomcat容器并指定网络为tomcat-net</span><br>docker run -d --name custom-net-tomcat --network tomcat-net tomcat:8.0<br>docker <span class="hljs-built_in">exec</span> -it custom-net-tomcat ip <span class="hljs-built_in">link</span><br>ip <span class="hljs-built_in">link</span><br></code></pre></td></tr></table></figure><p><img src="/image/docker/9.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 此时在custom-net-tomcat容器中ping一下tomcat01的ip会如何？发现无法ping通</span><br>docker <span class="hljs-built_in">exec</span> -it custom-net-tomcat ping 172.17.0.2<br><span class="hljs-comment"># 让tomcat01网络连接tomcat-net</span><br>docker network connect tomcat-net tomcat01<br>docker network inspect tomcat-net<br><span class="hljs-comment"># 再次尝试在custom-net-tomcat中ping一下tomcat01</span><br>docker <span class="hljs-built_in">exec</span> -it custom-net-tomcat ping 172.18.0.2<br>docker <span class="hljs-built_in">exec</span> -it custom-net-tomcat ping tomcat01<br><span class="hljs-comment"># ping tomcat02，发现是不能ping通的</span><br>docker <span class="hljs-built_in">exec</span> -it custom-net-tomcat ping tomcat02<br></code></pre></td></tr></table></figure><p><img src="/image/docker/10.png"></p><h4 id="2-3-3-Host"><a href="#2-3-3-Host" class="headerlink" title="2.3.3 Host"></a>2.3.3 Host</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建一个tomcat容器，并且指定网络为host</span><br>docker run -d --name my-tomcat-host --network host tomcat:8.0<br><span class="hljs-comment"># 查看ip地址，可以发现和centos是一样的</span><br>docker <span class="hljs-built_in">exec</span> -it my-tomcat-host ip a<br><span class="hljs-comment"># 直接访问8080端口</span><br>curl centosip:8080<br><span class="hljs-comment"># 查看host网络细节</span><br>docker network inspect host<br></code></pre></td></tr></table></figure><h4 id="2-3-4-None"><a href="#2-3-4-None" class="headerlink" title="2.3.4 None"></a>2.3.4 None</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建一个tomcat容器，并且指定网络为none</span><br>docker run -d --name my-tomcat-none --network none tomcat:8.0<br><span class="hljs-comment"># 查看ip地址</span><br>docker <span class="hljs-built_in">exec</span> -it my-tomcat-none ip a<br><span class="hljs-comment"># 检查none网络</span><br>docker network inspect none<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker安装与基础使用</title>
    <link href="/2023/04/21/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/docker/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/04/21/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/docker/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Docker介绍与安装"><a href="#1-Docker介绍与安装" class="headerlink" title="1 Docker介绍与安装"></a>1 Docker介绍与安装</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p><img src="/image/docker/1.png"></p><p>Container是一种轻量级的虚拟化技术，不用模拟硬件创建虚拟机。</p><p>Docker是基于Linux Kernel的Namespace、CGroups、UnionFileSystem等技术封装成的一种自定义容器格式，从而提供一套虚拟运行环境。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Chroot：Change Root 隔离文件<br>Namespace：用来做隔离的，比如pid<span class="hljs-comment">[进程]</span>、net<span class="hljs-comment">[网络]</span>、mnt<span class="hljs-comment">[挂载点]</span>等<br>CGroups: Controller Groups用来做资源限制，比如内存和CPU等<br>Union file systems：用来做image和<span class="hljs-keyword">container</span>分层<br></code></pre></td></tr></table></figure><h3 id="1-2-安装-CentOS"><a href="#1-2-安装-CentOS" class="headerlink" title="1.2 安装(CentOS)"></a>1.2 安装(CentOS)</h3><p>参考文档：<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p><p>在线使用：<a href="https://labs.play-with-docker.com/">https://labs.play-with-docker.com/</a></p><ol><li>卸载之前的docker</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum remove docker \<br>docker-client \<br>docker-client-latest \<br>docker-common \<br>docker-latest \<br>docker-latest-logrotate \<br>docker-logrotate \<br>docker-engine<br></code></pre></td></tr></table></figure><ol start="2"><li>安装必要的依赖</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum install -y yum-utils \ <br>device-mapper-persistent-data \ <br>lvm2<br></code></pre></td></tr></table></figure><ol start="3"><li>设置docker仓库</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum-config-manager \ <br>--add-repo \ <br>https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><ol start="4"><li>查看可以安装的版本</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum list docker-ce --showduplicates | <span class="hljs-built_in">sort</span> -r<br></code></pre></td></tr></table></figure><ol start="5"><li>安装最新或指定版本</li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">安装最新版本：sudo yum install -y docker-ce docker-ce-<span class="hljs-keyword">cli</span> containerd.io dockercompose-<span class="hljs-keyword">plugin</span><br>安装指定版本：sudo yum install -y docker-ce-20.10.7 docker-ce-<span class="hljs-keyword">cli</span>-20.10.7 containerd.io docker-compose-<span class="hljs-keyword">plugin</span><br></code></pre></td></tr></table></figure><ol start="6"><li>启动docker并设置为开机启动</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo systemctl start docker &amp;&amp; sudo systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></td></tr></table></figure><ol start="7"><li>测试docker安装是否成功</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo docker run hello-world<br></code></pre></td></tr></table></figure><ol start="8"><li>配置镜像加速器</li></ol><p>镜像加速器设置方式: <a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><h3 id="1-3-Docker体验"><a href="#1-3-Docker体验" class="headerlink" title="1.3 Docker体验"></a>1.3 Docker体验</h3><p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p>（1）tomcat:8.0</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">拉取镜像：docker pull tomcat:8.0<br>根据镜像创建容器：docker run -d --name tomcat01 -p 8088:8080 tomcat:8.0<br></code></pre></td></tr></table></figure><p>（2）mysql</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d --name my-mysql -p 3301:3306 -e MYSQL_ROOT_PASSWORD=jack666 --privileged mysql:5.7<br></code></pre></td></tr></table></figure><h2 id="2-Image"><a href="#2-Image" class="headerlink" title="2 Image"></a>2 Image</h2><p><img src="/image/docker/2.png"></p><h3 id="2-1-根据Dockerfile构建镜像"><a href="#2-1-根据Dockerfile构建镜像" class="headerlink" title="2.1 根据Dockerfile构建镜像"></a>2.1 根据Dockerfile构建镜像</h3><p>MySQL Dockerfile：<a href="https://github.com/docker-library">https://github.com/docker-library</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker build -t custom-mysql-image<br></code></pre></td></tr></table></figure><h3 id="2-2-制作jar包镜像"><a href="#2-2-制作jar包镜像" class="headerlink" title="2.2 制作jar包镜像"></a>2.2 制作jar包镜像</h3><p>（1）创建一个Spring Boot项目 </p><p>（2）写一个controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DockerController</span>&#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    String <span class="hljs-title function_">dockerFile</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello docker&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）mvn clean package，并在target下找到”dockerfile-demo-0.0.1-SNAPSHOT.jar” </p><p>（4）上传”dockerfile-demo-0.0.1-SNAPSHOT.jar”到centos，并创建Dockerfile文件 </p><p>（5）编写Dockerfile内容</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">8</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> dockerfile-demo-0.0.1-SNAPSHOT.jar dockerfile-image.jar</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;dockerfile-image.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>（6）基于Dockerfile构建镜像并查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker build -t custom-docker-image<br>docker images<br></code></pre></td></tr></table></figure><p>（7）基于image创建container</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d -name docker01 -p 6666:8080 custom-docker-image<br></code></pre></td></tr></table></figure><p>（8）查看启动日志docker logs docker01 </p><p>（9）宿主机上访问curl localhost:6666/hello</p><h3 id="2-3-阿里镜像仓库"><a href="#2-3-阿里镜像仓库" class="headerlink" title="2.3 阿里镜像仓库"></a>2.3 阿里镜像仓库</h3><p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances">https://cr.console.aliyun.com/cn-hangzhou/instances</a></p><p>（1）进入个人实例：<a href="https://cr.console.aliyun.com/cn-hangzhou/instance/dashboard">https://cr.console.aliyun.com/cn-hangzhou/instance/dashboard</a> </p><p>（2）创建命名空间，比如test-kubernetes </p><p>（3）在centos上登录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo docker login --username=&#123;your name&#125; registry.cn-hangzhou.aliyuncs.com<br></code></pre></td></tr></table></figure><p>（4）给image打tag</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo docker tag 91b27814153f registry.cn-hangzhou.aliyuncs.com/test-kubernetes/custom-docker-image:v1.0<br><br>docker images<br></code></pre></td></tr></table></figure><p>（5）推送镜像到镜像仓库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo docker push registry.cn-hangzhou.aliyuncs.com/test-kubernetes/custom-docker-image:v1.0<br></code></pre></td></tr></table></figure><p>（6）下载镜像并运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull registry.cn-hangzhou.aliyuncs.com/test-kubernetes/custom-docker-image:v1.0<br>docker run -d --name docker01 -p 6661:8080 registry.cn-hangzhou.aliyuncs.com/test-kubernetes/custom-docker-image:v1.0<br></code></pre></td></tr></table></figure><h3 id="2-4-Image基本操作"><a href="#2-4-Image基本操作" class="headerlink" title="2.4 Image基本操作"></a>2.4 Image基本操作</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mel">(<span class="hljs-number">1</span>) 查看本地<span class="hljs-keyword">image</span>列表<br>docker images<br>docker <span class="hljs-keyword">image</span> <span class="hljs-keyword">ls</span><br>(<span class="hljs-number">2</span>) 获取远端镜像<br>docker pull<br>(<span class="hljs-number">3</span>) 删除镜像[注意此镜像如果正在使用，或者有关联的镜像，则需要先处理完] （-f 强制）<br>docker <span class="hljs-keyword">image</span> rm imageid<br>docker rmi -f imageid<br>docker rmi -f $(docker <span class="hljs-keyword">image</span> <span class="hljs-keyword">ls</span>) 删除所有镜像<br>(<span class="hljs-number">4</span>) 运行镜像<br>docker run <span class="hljs-keyword">image</span><br>(<span class="hljs-number">5</span>) 推送镜像<br>docker push<br></code></pre></td></tr></table></figure><h2 id="3-Container"><a href="#3-Container" class="headerlink" title="3 Container"></a>3 Container</h2><p>container是基于image之后的layer，也就是可以通过docker run image创建出 一个container出来。</p><p><img src="/image/docker/3.png"></p><h3 id="3-1-通过Container制作Image"><a href="#3-1-通过Container制作Image" class="headerlink" title="3.1  通过Container制作Image"></a>3.1  通过Container制作Image</h3><p>(1) 拉取tomcat镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull tomcat<br>docker images<br></code></pre></td></tr></table></figure><p>(2) 根据tomcat镜像创建出一个tomcat container</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d -it --name test-tomcat tomcat<br>docker ps<br></code></pre></td></tr></table></figure><p>(3) 进入test-tomcat容器中[这里也可以看出container其实就是一个最小内核的linux系统]</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it test-tomcat bash<br><span class="hljs-built_in">pwd</span><br><span class="hljs-built_in">cat</span> /etc/issue<br></code></pre></td></tr></table></figure><p>(4) 在tomcat的webapps目录下创建test文件夹，并且新建wel.html文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> <span class="hljs-built_in">test</span><br><span class="hljs-built_in">cd</span> <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;welcome to java.&quot;</span> &gt; wel.html<br></code></pre></td></tr></table></figure><p>(5) 退出容器，将其生成一个新的tomcat，名称为: customized-tomcat</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">exit</span><br>docker commit test-tomcat customized-tomcat<br>docker images<br></code></pre></td></tr></table></figure><p>(6) 基于customized-tomcat镜像创建新的容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d -it --name customized-tomcat01 -p 8001:8080 customized-tomcat <br>docker ps<br></code></pre></td></tr></table></figure><p>(7) 进入到customized-tomcat01容器中，看看文件是否存在</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it customized-tomcat01 bash<br><span class="hljs-built_in">cd</span> webapps<br><span class="hljs-built_in">ls</span><br><span class="hljs-built_in">cat</span> <span class="hljs-built_in">test</span>/wel.html<br></code></pre></td></tr></table></figure><p>(8) 访问centosip:8081/test/wel.html</p><h3 id="3-2-Container常见操作"><a href="#3-2-Container常见操作" class="headerlink" title="3.2  Container常见操作"></a>3.2  Container常见操作</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mel">(<span class="hljs-number">1</span>) 根据镜像创建容器<br>docker run -d --name -p <span class="hljs-number">9090</span>:<span class="hljs-number">8080</span> my-tomcat tomcat<br>(<span class="hljs-number">2</span>) 查看运行中的<span class="hljs-keyword">container</span><br>docker ps<br>(<span class="hljs-number">3</span>) 查看所有的<span class="hljs-keyword">container</span>[包含退出的]<br>docker ps -a<br>docker ps -aq<br>(<span class="hljs-number">4</span>) 删除<span class="hljs-keyword">container</span><br>docker rm containerid<br>docker rm -f $(docker ps -a) 删除所有<span class="hljs-keyword">container</span><br>(<span class="hljs-number">5</span>) 进入到一个<span class="hljs-keyword">container</span>中<br>docker <span class="hljs-keyword">exec</span> -it <span class="hljs-keyword">container</span> bash<br>(<span class="hljs-number">6</span>) 根据<span class="hljs-keyword">container</span>生成<span class="hljs-keyword">image</span><br>docker commit jack-tomcat gupao-customized-tomcat<br>(<span class="hljs-number">7</span>) 查看某个<span class="hljs-keyword">container</span>的日志<br>docker logs <span class="hljs-keyword">container</span><br>(<span class="hljs-number">8</span>) 查看容器资源使用情况<br>docker stats<br>docker stats <span class="hljs-keyword">container</span><br>(<span class="hljs-number">9</span>) 查看容器详情信息<br>docker inspect <span class="hljs-keyword">container</span><br>(<span class="hljs-number">10</span>) 停止/启动容器<br>docker stop/start <span class="hljs-keyword">container</span><br></code></pre></td></tr></table></figure><h3 id="3-3-设置Container资源限制"><a href="#3-3-设置Container资源限制" class="headerlink" title="3.3  设置Container资源限制"></a>3.3  设置Container资源限制</h3><p>（1）内存限制：–memory 如果不设置 –memory-swap，其大小和memory一样</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d -memory 100M --name test-tomcat-memory-limit tomcat<br>docker status<br></code></pre></td></tr></table></figure><p>（2）CPU限制：–cpu-shares 权重</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d --cpu-shares 10 test-tomcat-cpu-limit tomcat<br>docker status<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcd高级应用</title>
    <link href="/2023/04/20/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/etcd/etcd%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    <url>/2023/04/20/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/etcd/etcd%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-分布式锁"><a href="#1-分布式锁" class="headerlink" title="1 分布式锁"></a>1 分布式锁</h2><h3 id="1-1-Redis分布式锁"><a href="#1-1-Redis分布式锁" class="headerlink" title="1.1 Redis分布式锁"></a>1.1 Redis分布式锁</h3><p>➢ Set实现分布式锁：</p><p>⚫ SET key value [EX seconds] [NX|XX]，获取不到 锁的线程只能轮询去尝试获取锁（可用性） </p><p>⚫ NX参数实现互斥，一次性只能一个（互斥性）</p><p> ⚫ EX保证拿到锁的服务器挂掉了，能自动释放锁（活 性）</p><p> ⚫ SETNX无法原子性设置过期时间，所以并不常用</p><p>➢ 优点 </p><p>⚫ 快、简单，在允许偶发锁失效的场景下推荐使用 </p><p>➢ 缺点 </p><p>⚫ 通过轮询抢占锁的机制不是很可靠，当某线程占用锁时间较长时可能导致其他线程抢占锁失 败 </p><p>⚫ 如果master和slave结构，如果存在脑裂或者数据丢失情况，导致锁的数据没有同步，就导致 了分布式锁的失效 </p><p>⚫ 解锁时，为了保证原子性（查询锁，判断值并删除），需要在redis服务端用脚本来实现查询 并删除</p><h3 id="1-2-Zookeeper分布式锁"><a href="#1-2-Zookeeper分布式锁" class="headerlink" title="1.2 Zookeeper分布式锁"></a>1.2 Zookeeper分布式锁</h3><h4 id="1-2-1-基于唯一节点实现"><a href="#1-2-1-基于唯一节点实现" class="headerlink" title="1.2.1 基于唯一节点实现"></a>1.2.1 基于唯一节点实现</h4><p>⚫ 唯一节点保证互斥性 ⚫ Zap协议保证一致性 ⚫ 临时节点保证活性 ⚫ Watch机制保证可用性</p><p><img src="/image/etcd/2.png"></p><p>缺点：会发生惊群效应，当释放锁时所有竞争都将被唤醒</p><h4 id="1-2-2-基于有序节点实现"><a href="#1-2-2-基于有序节点实现" class="headerlink" title="1.2.2 基于有序节点实现"></a>1.2.2 基于有序节点实现</h4><p><img src="/image/etcd/4.png"></p><p>流程：<br><img src="/image/etcd/5.png"></p><h3 id="1-3-Etcd实现分布式锁"><a href="#1-3-Etcd实现分布式锁" class="headerlink" title="1.3 Etcd实现分布式锁"></a>1.3 Etcd实现分布式锁</h3><p>Etcd是具备事务特性的，所以天然能保证原子性操作 ；可以根据key的create_revision来保证互斥性； Etcd集群通过Raft保证了数据的强一致性 ； Etcd通过Lease来保证活性 ；Etcd通过Watch来保证可用性</p><p><img src="/image/etcd/6.png"></p><p>流程：</p><ol><li><p>准备：</p><p> 客户端连接Etcd，以/lock为前缀创建全局唯一的key；客户端分别为自己的key创建租约 Lease，租约的过期时间默认60s；每个客户端创建的具体key为/lock/leaseId</p></li><li><p>创建定时任务作为租约的“心跳”：</p><p> 当一个客户端持有锁期间，其它客户端只能等待，为了避免等待期间租约失效，客户端会调 用keepalive进行自动续约。此外，如果持有锁期间客户端崩溃，心跳停止，key 将因租约 到期而被删除，从而锁释放，避免死锁。</p></li><li><p>客户端将自己全局唯一的 key 写入 Etcd</p><p> 进行 put 操作，将步骤 1 中创建的 key 绑定租约写入 Etcd，根据 Etcd 的 Revision 机 制，假设两个客户端 put 操作返回的 Revision 分别为 1、2，客户端需记录 Revision 用 以接下来判断自己是否获得锁。</p></li><li><p>客户端判断是否获得锁</p><p> 客户端以前缀 /lock/ 读取 keyValue 列表（keyValue 中带有 key 对应的 Revision）， 判断自己 key 的 Revision 是否为当前列表中最小的，如果是则认为获得锁；否则监听列 表中前一个 Revision 比自己小的 key 的删除事件，一旦监听到删除事件或者因租约失效 而删除的事件，则自己获得锁。</p></li><li><p>执行业务</p></li><li><p>释放锁</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>etcd</category>
      
    </categories>
    
    
    <tags>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Quarkus入门</title>
    <link href="/2023/04/20/spring%E6%A1%86%E6%9E%B6/Quarkus/Quarkus%E5%85%A5%E9%97%A8/"/>
    <url>/2023/04/20/spring%E6%A1%86%E6%9E%B6/Quarkus/Quarkus%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>官网：<a href="https://quarkus.io/">https://quarkus.io/</a></p><p>快速开始：</p><ol><li>new project</li></ol><p><img src="/image/Quarkus/1.png"></p><ol start="2"><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.26<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>编写代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br><span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>&#125;<br><br><span class="hljs-meta">@ApplicationScoped</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(User user)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;say hello: &quot;</span> + user.getUserName() + <span class="hljs-string">&quot;  &quot;</span> + user.getPassword();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Path(&quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleResource</span>&#123;<br>    <span class="hljs-meta">@Inject</span><br>    UserService userService;<br>    <br>    <span class="hljs-meta">@GET</span><br>    <span class="hljs-meta">@Produces(MediaType.TEXT_PLAIN)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setUsername(<span class="hljs-string">&quot;test&quot;</span>);<br>        user.setPassword(<span class="hljs-string">&quot;666&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.userService.sayHello(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>修改端口</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">quarlkus.http.port</span>=<span class="hljs-string">6060</span><br></code></pre></td></tr></table></figure><ol start="5"><li>启动程序，访问localhost:6060/hello</li></ol>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>Quarkus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>Quarkus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcd的MVCC和租约和Watch原理分析</title>
    <link href="/2023/04/18/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/etcd/etcdMVCC%E5%92%8C%E7%A7%9F%E7%BA%A6%E5%92%8CWatch%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <url>/2023/04/18/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/etcd/etcdMVCC%E5%92%8C%E7%A7%9F%E7%BA%A6%E5%92%8CWatch%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-MVCC流程"><a href="#1-MVCC流程" class="headerlink" title="1 MVCC流程"></a>1 MVCC流程</h2><p>mvcc(多版本并发控制，mysql中也使用到了)解决的就是读写时的线程安全问题，线程不用去争抢读写锁。</p><p><img src="/image/etcd/MVCC-%E6%9E%B6%E6%9E%84%E6%B5%81%E7%A8%8B.jpg"></p><p>查询</p><p><img src="/image/etcd/MVCC-%E6%9F%A5%E8%AF%A2.jpg"></p><p>更新</p><p><img src="/image/etcd/MVCC-%E6%9B%B4%E6%96%B0.jpg"></p><h2 id="2-Lease-租约-流程"><a href="#2-Lease-租约-流程" class="headerlink" title="2 Lease(租约)流程"></a>2 Lease(租约)流程</h2><p>一个key一个TTL太占内存，同时性能不高。说白了就相当于租房的一个合同而已，这个合同可以管理很多key，在合同的时间围之内，我的key存在你那里是有效的，你不能删除我关联到此Lease上的key-value。</p><h3 id="2-1-架构"><a href="#2-1-架构" class="headerlink" title="2.1 架构"></a>2.1 架构</h3><ol><li>创建Lease流程（跟put流程差不多）最 终会保存LeaseId到ItemMap和boltdb中</li><li>Lease关联key流程：在put的时候会 根据参数去掉Attach方法，将Key关 联到Lease的key内存集合ItemSet中</li><li>过期自动淘汰流程</li></ol><p><img src="/image/etcd/Lease%E6%9E%B6%E6%9E%84.jpg"></p><h3 id="2-2-源码"><a href="#2-2-源码" class="headerlink" title="2.2 源码"></a>2.2 源码</h3><p><img src="/image/etcd/Lease%E6%BA%90%E7%A0%81.jpg"></p><h3 id="2-3-优化"><a href="#2-3-优化" class="headerlink" title="2.3 优化"></a>2.3 优化</h3><p>➢ 续期的优化 </p><p>⚫ 从网络通信上优化，http转成了gRPC </p><p>⚫ 从TTL上优化，以前一个key要创建一个TTL，现在多个key绑定同一个Lease </p><p>➢ 淘汰优化 </p><p>⚫ 以前是遍历所有的TTL，看到没到期 </p><p>⚫ 现在所有的Lease存一个对象到最小堆里，按到期时间升序排，只要找堆顶的少数数据就可以停止循环找了</p><h2 id="3-Watch流程"><a href="#3-Watch流程" class="headerlink" title="3 Watch流程"></a>3 Watch流程</h2><h3 id="3-1-推拉模式"><a href="#3-1-推拉模式" class="headerlink" title="3.1 推拉模式"></a>3.1 推拉模式</h3><p>➢ 拉模式   </p><p>⚫ Etcdv2的实现方式 </p><p>⚫ 一般通过定时任务定时拉取，时效性不高，一般不会发生消息堆积 </p><p>⚫ 当watch过多的时候，QPS过高会导致接口崩溃，同时销毁大量的socket资源 </p><p>➢ 推模式</p><p>⚫ Etcdv3的实现方式 </p><p>⚫ 一般基于发布订阅的方式去实现，时效性高，可能造成消息堆积 </p><p>⚫ 当client因网络等异常出现连接闪断后，通过版本号，它就可从server端的boltdb中获取错过的 历史事件，而无需全量同步，它是etcd Watch机制数据增量同步的核心</p><h3 id="3-2-事件存储"><a href="#3-2-事件存储" class="headerlink" title="3.2 事件存储"></a>3.2 事件存储</h3><p>➢ 滑动窗口 </p><p>⚫ Etcdv2的实现方式 </p><p>⚫ 仅保存有限的最近历史版本到内存中（EventHistory中的eventQueue） </p><p>⚫ 优点就是eventQueue固定容量是1000，最多保存1000条事件，超过了就删除最早的事件，这不会 造成OOM，缺点就是不可靠啊 </p><p> ➢ MVCC</p><p>⚫ Etcdv3的实现方式 </p><p>⚫ MVCC机制则将历史版本保存在磁盘中，避免了历史版本的丢失，极大的提升了Watch机制的可靠性</p><h3 id="3-3-可靠的事件推送机制"><a href="#3-3-可靠的事件推送机制" class="headerlink" title="3.3 可靠的事件推送机制"></a>3.3 可靠的事件推送机制</h3><p>➢ 整体架构 ➢ 最新的事件推送 ➢ 发生异常了重试机制 ➢ 历史事件推送</p><h3 id="3-4-架构"><a href="#3-4-架构" class="headerlink" title="3.4 架构"></a>3.4 架构</h3><p><img src="/image/etcd/Watch%E6%9E%B6%E6%9E%84.jpg"></p><h3 id="3-5-源码"><a href="#3-5-源码" class="headerlink" title="3.5 源码"></a>3.5 源码</h3><p><img src="/image/etcd/Watch%E6%BA%90%E7%A0%81.jpg"></p><h3 id="3-6-异常场景重试流程"><a href="#3-6-异常场景重试流程" class="headerlink" title="3.6 异常场景重试流程"></a>3.6 异常场景重试流程</h3><p>➢ 发生异常比如网络波动，或者channel满了，事件没有被执行怎么办？ </p><ol><li><p>Etcd的watch并不会丢弃，这个时候会将watch从synced watcherGroup删除，并放到victim  watchBatch中 </p></li><li><p>然后上面说的那个sync VictimLoop协程开始干活，就是不断去看victim watchBatch里面有没有watch，有就重试事件的执行</p></li></ol><p>➢ syncVictimsLoop工作流程 </p><ol><li> 遍历victim watcherBatch数据结构，尝试将堆积的事件再次推送到watcher的接收channel中。若推送失败，则再次加入到victim watcherBatch数据结构中等待下次重试。 </li><li>若推送成功，watcher监听的最小版本号(minRev)小于等于server当前版本号(currentRev)，说明可能还有历史事件未推送，需加入到unsynced watcherGroup中，由下面介绍的历史事件推送机制， 推送minRev到currentRev之间的事件。 </li><li>若watcher的最小版本号大于server当前版本号，则加入到synced watcher集合中，进入上面介绍的最新事件通知机制。</li></ol><h3 id="3-7-高效匹配watch"><a href="#3-7-高效匹配watch" class="headerlink" title="3.7 高效匹配watch"></a>3.7 高效匹配watch</h3><p>➢ 监听单个key的watch ⚫ 使用map进行存储匹配</p><p>➢ 监听key范围或者前缀的watch ⚫ 使用区间树进行匹配</p><p><img src="/image/etcd/1.png"></p>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>etcd</category>
      
    </categories>
    
    
    <tags>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcd读写以及数据一致性原理分析</title>
    <link href="/2023/04/17/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/etcd/etcd%E8%AF%BB%E5%86%99%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <url>/2023/04/17/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/etcd/etcd%E8%AF%BB%E5%86%99%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-读流程"><a href="#1-读流程" class="headerlink" title="1 读流程"></a>1 读流程</h2><p>架构：</p><p><img src="/image/etcd/etcd%E8%AF%BB%E6%B5%81%E7%A8%8B%E6%9E%B6%E6%9E%84.jpg"></p><p>流程1：etcd客户端发起一个get请求，这个 请求底层是基于gRPC完成的</p><p>流程2：然后etcd服务端通过gRPC接收请求， 在gRPC中会注册多个过滤器，不过最终会调 用到KVServer中的接口</p><p>流程3：KVServer接收到请求后会调Raft模块， 去拿集群中最新的版本号</p><p>流程4：拿到版本号之后，KVServer继续调用 MVCC模块，根据key和版本号去拿treeIndex中的一个版本，根据上面那个版本去boltdb拿真实的value</p><h3 id="1-1-客户端"><a href="#1-1-客户端" class="headerlink" title="1.1 客户端"></a>1.1 客户端</h3><p>也就是流程1，具体步骤：</p><ol><li>etcdctl启动客户端（实际就是Go语言底层执行main方法）</li><li>启动过程中拿底层操作系统的cmd指令，并根据不同的参数封装各种命令，然后通过传进来的参数选择执行不同的命令</li><li>在客户端进行负载均衡，etcd默认的是round-robin算法</li><li>最终etcd客户端创建gRPC客户端，调etcd服务端的KVServer模块</li></ol><p>源码流程：</p><p><img src="/image/etcd/etcd%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%BB%E6%BA%90%E7%A0%81.jpg"></p><h3 id="1-2-服务端"><a href="#1-2-服务端" class="headerlink" title="1.2 服务端"></a>1.2 服务端</h3><p>前置：启动etcdserver端</p><p>流程2：KVServer接收get请求</p><p>流程3：等待数据同步</p><p>流程4：去数据库里面拿数据</p><h4 id="1-2-1-前置"><a href="#1-2-1-前置" class="headerlink" title="1.2.1 前置"></a>1.2.1 前置</h4><ol><li>启动server/main.go中的main方法</li><li>创建一个Etcd的实例，里面有个etcdserver</li><li>创建一个etcdserver对象然后赋值给上面</li><li>创建了各种异步协程、通道、注册各种模块 （KVServer、拦截器）到gRPC</li><li>启动</li></ol><p><img src="/image/etcd/etcd%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%BB%E6%B5%81%E7%A8%8B%E5%89%8D%E7%BD%AE.jpg"></p><h4 id="1-2-2-流程"><a href="#1-2-2-流程" class="headerlink" title="1.2.2 流程"></a>1.2.2 流程</h4><ol><li>Etcdserver接收get请求，被拦截器给拦截</li><li>执行Key.go中Range，判断是否是线性读（默认线性读）</li><li>跟Leader进行通信，判断ReadIndex是不是最新的</li><li>不是的话就等着Raft那个携程进行数据同步</li><li>拿到最新的ReadIndex，然后根据key去数据库拿数据</li></ol><p><img src="/image/etcd/etcd%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%BB%E6%B5%81%E7%A8%8B.jpg"></p><h2 id="2-写流程"><a href="#2-写流程" class="headerlink" title="2 写流程"></a>2 写流程</h2><p> 写只能Leader处理，Follower只能读</p><p>⚫ 如何保证数据不丢失——集群来保证 </p><p>⚫ 写命令如何不重复执行——幂等性来保证</p><p>架构：</p><p><img src="/image/etcd/etcd%E5%86%99%E6%B5%81%E7%A8%8B%E6%9E%B6%E6%9E%84.jpg"></p><p>流程1：etcd客户端发起一个put请求</p><p>流程2：etcd服务端中的拦截器接收请求，先做配额限制</p><p>流程3：如果没有没有超过配额，进入KV模块</p><p>流程4：走Raft模块保证各节点的数据一致</p><p>流程5：各节点将Raft日志进行持久化，防止节点在数据存到 boltdb之前挂掉导致数据丢失</p><p>流程6：将要持久化到boltdb的数据发送给Apply</p><p>流程7：数据基于MVCC进行持久化</p><h3 id="2-1-客户端"><a href="#2-1-客户端" class="headerlink" title="2.1 客户端"></a>2.1 客户端</h3><p>与读流程差不多，不重复讲述</p><h3 id="2-2-服务端"><a href="#2-2-服务端" class="headerlink" title="2.2 服务端"></a>2.2 服务端</h3><h4 id="2-2-1-Quota-配额-模块"><a href="#2-2-1-Quota-配额-模块" class="headerlink" title="2.2.1 Quota(配额)模块"></a>2.2.1 Quota(配额)模块</h4><p>就是etcd boltdb中能存的最大字节，默认是2GB， 如果超过配额会报NO SPACE告警，调大配额，还需要执行etcdctl alarm disarm取消告警。⚫ 修改配额：启动服务端的时候加参数：–quota-backendbytes=20(20表示字节)</p><p><img src="/image/etcd/etcd%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%86%99%E6%B5%81%E7%A8%8B-Quota(%E9%85%8D%E9%A2%9D).jpg"></p><h4 id="2-2-2-KV模块"><a href="#2-2-2-KV模块" class="headerlink" title="2.2.2 KV模块"></a>2.2.2 KV模块</h4><p><img src="/image/etcd/etcd%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%86%99%E6%B5%81%E7%A8%8B-KV%E6%A8%A1%E5%9D%97.jpg"></p><h4 id="2-2-3-整体源码"><a href="#2-2-3-整体源码" class="headerlink" title="2.2.3 整体源码"></a>2.2.3 整体源码</h4><p><img src="/image/etcd/etcd%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%86%99%E6%BA%90%E7%A0%81.jpg"></p><h2 id="3-数据一致性—强一致性"><a href="#3-数据一致性—强一致性" class="headerlink" title="3 数据一致性—强一致性"></a>3 数据一致性—强一致性</h2><p>Raft协议：<a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p><p>➢ Leader，集群领导者， 唯一性，拥有同步日志的特权，需定时广播心跳给 Follower节点，以维持领导者身份 </p><p>➢ Candidate，竞选者，可以发起Leader选举 </p><p>➢ Follower，跟随者， 同步从Leader收到的日志，etcd启动的时候默认为此状态</p><p>数据同步过程：</p><p><img src="/image/etcd/etcd%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E8%BF%87%E7%A8%8B.jpg"></p><p>安全性：</p><p>➢ 选举规则 </p><p>⚫ 检查候选者的最后一条日志中的任期号，若小于自己则拒绝投票。如果任期号相同，日志却比自己短，也拒绝为其投票。 </p><p>⚫ 每个节点在同一个任期内只能为一个节点投票</p><p>➢ 日志复制规则 </p><p>⚫ Leader完全特性：如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大 任期号的所有Leader中 </p><p>⚫ 只附加原则：Leader只能追加日志条目，不能删除已持久化的日志条目 </p><p>⚫ 日志匹配原则：Leader在发送追加日志RPC消息时，会把新的日志条目紧接着之前的条目的索引 位置和任期号包含在里面。Follower节点会检查相同索引位置的任期号是否与Leader一致，一致 才能追加</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>➢ Etcd客户端读写流程</p><p> ⚫ 解析参数并选择命令 ⚫ 进行负载均衡重试等操作 ⚫ 发起gRPC请求</p><p>➢ Etcd服务端读流程</p><p>⚫ 前置开启服务以及各种携程，并注册拦截器，最终调KVServer模块 ⚫ 发起线性读保证安全</p><p>➢ Etcd服务端写流程</p><p> ⚫ 前置开启服务以及各种携程，并注册拦截器，调Quota进行配额限制、然后调KVServer进行限流、 校验、限制大小等操作 ⚫ 走Raft模块，保证各节点数据同步 ⚫ 收到各节点同步日志成功通知则走Apply模块，进行幂等性判断 ⚫ 走MVCC模块保存不同版本的KV</p>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>etcd</category>
      
    </categories>
    
    
    <tags>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcd基础使用</title>
    <link href="/2023/04/17/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/etcd/etcd%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/04/17/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/etcd/etcd%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://etcd.io/">https://etcd.io/</a></p><p><a href="https://www.etcd.cn/">https://www.etcd.cn/</a></p><h2 id="1-etcd架构"><a href="#1-etcd架构" class="headerlink" title="1 etcd架构"></a>1 etcd架构</h2><p><img src="/image/etcd/etcd%E6%9E%B6%E6%9E%84.jpg"></p><h2 id="2-特征，使用场景"><a href="#2-特征，使用场景" class="headerlink" title="2 特征，使用场景"></a>2 特征，使用场景</h2><h3 id="2-1-特征"><a href="#2-1-特征" class="headerlink" title="2.1 特征"></a>2.1 特征</h3><blockquote><p>使用简单</p><p>存储结构是key-value类型</p><p>能实时感知变化</p><p>权限校验</p><p>性能高</p><p>集群数据一致性</p></blockquote><h3 id="2-2-使用场景"><a href="#2-2-使用场景" class="headerlink" title="2.2 使用场景"></a>2.2 使用场景</h3><blockquote><p>存储数据</p><p>注册中心、配置中心</p><p>消息发布订阅</p><p>分布式锁</p><p>leader选举</p></blockquote><p>适当参考中文网，描述有些夸大</p><h2 id="3-部署"><a href="#3-部署" class="headerlink" title="3 部署"></a>3 部署</h2><h3 id="3-1-单节点"><a href="#3-1-单节点" class="headerlink" title="3.1 单节点"></a>3.1 单节点</h3><p>linux环境的二进制部署</p><p>1、下载软件：<a href="https://github.com/etcd-io/etcd/releases/">https://github.com/etcd-io/etcd/releases/</a> </p><p>2、复制到你的centos7系统的任意目录</p><p> 3、解压并配置 </p><p>4、注册系统服务 </p><p>5、启动</p><h3 id="3-2-集群"><a href="#3-2-集群" class="headerlink" title="3.2 集群"></a>3.2 集群</h3><p>集群部署分为仨方式：静态发现、动态发现、DNS发现</p><p>1、下载软件：<a href="https://github.com/etcd-io/etcd/releases/">https://github.com/etcd-io/etcd/releases/</a> </p><p>2、复制到三台服务器中 </p><p>3、解压并配置（配置不同了） </p><p>4、注册系统服务 </p><p>5、启动</p><h3 id="3-3-可视化控制台-Etcdkeeper"><a href="#3-3-可视化控制台-Etcdkeeper" class="headerlink" title="3.3 可视化控制台(Etcdkeeper)"></a>3.3 可视化控制台(Etcdkeeper)</h3><h4 id="3-3-1-centos7"><a href="#3-3-1-centos7" class="headerlink" title="3.3.1 centos7"></a>3.3.1 centos7</h4><p>1、下载软件：<a href="https://github.com/evildecay/etcdkeeper/releases/">https://github.com/evildecay/etcdkeeper/releases/</a> </p><p>2、复制到任意服务器并解压 </p><p>3、给权限 </p><p>4、注册系统服务 </p><p>5、启动并测试：http:192.168.8.137:8080/etcdkeeper </p><h4 id="3-3-2-windows"><a href="#3-3-2-windows" class="headerlink" title="3.3.2 windows"></a>3.3.2 windows</h4><p>1、下载软件：<a href="https://github.com/evildecay/etcdkeeper/releases/">https://github.com/evildecay/etcdkeeper/releases/</a> </p><p>2、复制到任意服务器并解压 </p><p>3、启动</p><h2 id="4-基础操作"><a href="#4-基础操作" class="headerlink" title="4 基础操作"></a>4 基础操作</h2><h3 id="4-1-查看命令"><a href="#4-1-查看命令" class="headerlink" title="4.1 查看命令"></a>4.1 查看命令</h3><p>输入etcdctl –h可以查看etcdctl的命令，注释如下：</p><table><thead><tr><th align="left">命令</th><th>注释</th><th>命令</th><th>注释</th><th>命令</th><th>注释</th></tr></thead><tbody><tr><td align="left">alarm disarm</td><td>解除所有的报警</td><td>elect</td><td>加入leader选举</td><td>lease timetolive</td><td>获取租约信息</td></tr><tr><td align="left">alarm list</td><td>列出所有报警</td><td>endpoint hashkv</td><td>打印指定实例的历史键值对的hash值</td><td>lock</td><td>获取命名锁</td></tr><tr><td align="left">auth disable</td><td>禁用Authentication</td><td>endpoint health</td><td>打印指定etcd实例的健康信息</td><td>make-mirror</td><td>指定一个etcd集群为镜像集群</td></tr><tr><td align="left">auth status</td><td>返回Authentication状态</td><td>endpoint status</td><td>打印指定etcd实例的状态信息</td><td>member add</td><td>为集群增加一个成员</td></tr><tr><td align="left">check datascale</td><td>对于给定服务实例检查持有数据的存储使用率</td><td>get</td><td>获取键值对</td><td>member list</td><td>罗列集群所有成员</td></tr><tr><td align="left">check perf</td><td>检查集群的性能</td><td>help</td><td>帮助</td><td>member promote</td><td>提升集群中的一个non-voting成员</td></tr><tr><td align="left">compaction</td><td>压缩历史事件</td><td>lease grant</td><td>创建租约</td><td>member remove</td><td>移除集群中的成员</td></tr><tr><td align="left">auth enable</td><td>启用Authentication</td><td>lease keep-alive</td><td>续约</td><td>member update</td><td>更新集群中的成员信息</td></tr><tr><td align="left">del</td><td>移除指定的或者范围的键值对</td><td>lease list</td><td>罗列所有有效的租约</td><td>move-leader</td><td>替换进群中的leader</td></tr><tr><td align="left">defrag</td><td>整理存储碎片</td><td>lease revoke</td><td>撤销租约</td><td>put</td><td>写入键值对</td></tr><tr><td align="left">role add</td><td>增加一个角色</td><td>role delete</td><td>删除一个角色</td><td>role get</td><td>获取一个角色的详细信息</td></tr><tr><td align="left">role grant-permission</td><td>给某个角色授予key</td><td>role list</td><td>罗列所有的角色</td><td>role revoke-permission</td><td>撤销一个角色的key</td></tr><tr><td align="left">snapshot restore</td><td>恢复快照</td><td>snapshot save</td><td>存储某个etcd节点的快照到指定位置</td><td>snapshot status</td><td>获取指定文件的后端快照文件状态</td></tr><tr><td align="left">txn</td><td>在一个事务内处理所有的请求</td><td>user add</td><td>增加一个用户</td><td>user delete</td><td>删除一个用户</td></tr><tr><td align="left">user get</td><td>获取用户的详细信息</td><td>user grant-role</td><td>给用户授予角色</td><td>user list</td><td>罗列所有用户</td></tr><tr><td align="left">user passwd</td><td>给用户修改密码</td><td>user revoke-role</td><td>撤销某个用户的角色</td><td>version</td><td>打印etcd版本</td></tr><tr><td align="left">watch</td><td>监测指定键或者前缀的事件流</td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="4-2-增、该"><a href="#4-2-增、该" class="headerlink" title="4.2 增、该"></a>4.2 增、该</h3><p> 命令格式：etcdctl put &lt; key&gt; &lt; value&gt;[options]</p><blockquote><p>Options选项： </p><p>⚫ –lease ： 设置key所使用的lease ID </p><p>⚫ –prev-kv：返回该key修改之前的值 </p><p>⚫ –ignore-lease：使用当前的lease更新key </p><p>⚫ –ignore-value：使用当前的value更新key</p></blockquote><h3 id="4-3-查"><a href="#4-3-查" class="headerlink" title="4.3 查"></a>4.3 查</h3><p>命令格式：etcdctl get &lt; key&gt; [options]</p><blockquote><p>Options选项： </p><p>⚫ –form-key： 按照字节序，筛选大于或等于的key </p><p>⚫ –prefix：筛选以该前缀的key </p><p>⚫ –keys-only：只输出key </p><p>⚫ –print-value-only：只输出value </p><p>⚫ –limit ：限制输出条数，当为0时不做限制 </p><p>⚫ –sort-by &lt;”create”|”key”|”modify”|”value”|”version”&gt;：按照创建时间、键、修改时间、值或版本号排序 </p><p>⚫ –order &lt;“ascend”|“descend”&gt; ：按照升序或降序排列 </p><p>⚫ –rev  ：指定 key 的版本。etcd 对 key 的写操作，会更新全局修订版本， 通过指定版本可以读取旧的数据 </p><p>⚫ –consistency &lt;“l”|“s”&gt; ：一致性，默认是 Linearizable，可以设置为 Serializable</p></blockquote><h3 id="4-4-删"><a href="#4-4-删" class="headerlink" title="4.4 删"></a>4.4 删</h3><p>命令格式：etcdctl del &lt; key&gt; [options]</p><blockquote><p>Options选项： </p><p>⚫ –form-key： 按照字节序，筛选大于或等于的key </p><p>⚫ –prefix：筛选以该前缀的key </p><p>⚫ –prev-kv：返回该key修改之前的值 </p><p>⚫ –range：该选项避免删除延迟，默认延迟2s</p></blockquote><h3 id="4-5-watch"><a href="#4-5-watch" class="headerlink" title="4.5 watch"></a>4.5 watch</h3><p>命令格式：etcdctl watch &lt; key&gt; [options]</p><blockquote><p> Options选项： </p><p>⚫ –prev-kv：返回该key修改之前的值 </p><p>⚫ –prefix：筛选以该前缀的key</p></blockquote><h3 id="4-6-租约"><a href="#4-6-租约" class="headerlink" title="4.6 租约"></a>4.6 租约</h3><blockquote><p> 命令格式：</p><p> ⚫ etcdctl lease grant ：创建租约 </p><p>⚫ etcdctl lease list：返回说有为过时或未被废弃的租约 </p><p>⚫ etcdctl lease revoke ：废弃租约 </p><p>⚫ etcdctl lease keep-alive [–once] ：周期性续约，–once只续约一次 </p><p>⚫ etcdctl lease timetolive [–once]  [–keys]：获取租约信息，–keys附带关键的key信息</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>etcd</category>
      
    </categories>
    
    
    <tags>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GraalVM安装与基本介绍</title>
    <link href="/2023/04/13/java%E5%9F%BA%E7%A1%80/GraalVM/GraalVM/"/>
    <url>/2023/04/13/java%E5%9F%BA%E7%A1%80/GraalVM/GraalVM/</url>
    
    <content type="html"><![CDATA[<h2 id="1-GraalVM基础使用"><a href="#1-GraalVM基础使用" class="headerlink" title="1 GraalVM基础使用"></a>1 GraalVM基础使用</h2><p>官网： <a href="https://www.graalvm.org/">https://www.graalvm.org/</a></p><p>github：<a href="https://github.com/oracle/graal">https://github.com/oracle/graal</a></p><p>SpringFramework6.x，SpringBoot 3.x 支持JDK17，GraalVM</p><h3 id="1-1-安装GraalVM"><a href="#1-1-安装GraalVM" class="headerlink" title="1.1 安装GraalVM"></a>1.1 安装GraalVM</h3><p><a href="https://www.graalvm.org/latest/docs/getting-started/#install-graalvm">https://www.graalvm.org/latest/docs/getting-started/#install-graalvm</a></p><p>以在Win10安装为例：<a href="https://www.graalvm.org/latest/docs/getting-started/windows/">https://www.graalvm.org/latest/docs/getting-started/windows/</a></p><p>（1）下载地址：<a href="https://github.com/graalvm/graalvm-ce-builds/releases">https://github.com/graalvm/graalvm-ce-builds/releases</a></p><p><img src="/image/GraalVM/1.png"></p><p>（2）将graalvm-ce-java17-windows-amd64-22.3.1.zip压缩包解压</p><p>（3）设置环境变量JAVA_HOME，可以通过图形化界面也可以通过命令行</p><p><img src="/image/GraalVM/2.png"></p><p>（4）打开cmd，输入java命令，验证是否安装配置成功 </p><p>（5）以管理员身份打开cmd窗口，验证是否配置成功</p><blockquote><p>如果发生修改完环境变量不生效的情况，</p><ol><li><p>删除C:\Windows\System32目录下的java.exe、javaw.exe、javaws.exe三个文件（如果没有就不用删）</p></li><li><p>删除环境变量Path中  ……\Oracle\Java\javapath的配置</p></li></ol></blockquote><p><img src="/image/GraalVM/3.png"></p><h3 id="1-2-安装Native-Image"><a href="#1-2-安装Native-Image" class="headerlink" title="1.2 安装Native Image"></a>1.2 安装Native Image</h3><p><a href="https://www.graalvm.org/latest/reference-manual/native-image/#install-native-image">https://www.graalvm.org/latest/reference-manual/native-image/#install-native-image</a></p><p>（1）查看默认graalvm中是否包含了native-image，发现没有</p><p><img src="/image/GraalVM/4.png"></p><p>（2）安装native-image，在graalvm目录下执行命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 也就是说配置好了graalvm之后，gu是可以直接使用的</span><br>gu install native-image<br></code></pre></td></tr></table></figure><p>（3）查看native-image是否安装成功</p><h3 id="1-3-安装使用Native-Image在Windows上的环境"><a href="#1-3-安装使用Native-Image在Windows上的环境" class="headerlink" title="1.3 安装使用Native Image在Windows上的环境"></a>1.3 安装使用Native Image在Windows上的环境</h3><p><a href="https://www.graalvm.org/latest/docs/getting-started/windows/#prerequisites-for-using-native-image-on-windows">https://www.graalvm.org/latest/docs/getting-started/windows/#prerequisites-for-using-native-image-on-windows</a></p><p>（1）下载VS Code 2022 Community安装程序</p><p><a href="https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=Community&amp;channel=Release&amp;version=VS2022&amp;source=VSLandingPage&amp;cid=2030&amp;passive=false">https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=Community&amp;channel=Release&amp;version=VS2022&amp;source=VSLandingPage&amp;cid=2030&amp;passive=false</a></p><p>（2）选择安装的内容及目录</p><p><img src="/image/GraalVM/6.png"></p><p><img src="/image/GraalVM/7.png"></p><p>（4）在Path中配置VS的环境变量</p><p>我的路径是：E:\Visual Studio\IDE</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">E</span>:\Visual Studio\IDE\VC\Tools\MSVC\<span class="hljs-number">14</span>.<span class="hljs-number">35</span>.<span class="hljs-number">32215</span>\bin\Hostx64\x64<br><span class="hljs-attribute">E</span>:\Visual Studio\IDE\VC\Tools\MSVC\<span class="hljs-number">14</span>.<span class="hljs-number">35</span>.<span class="hljs-number">32215</span>\include<br><span class="hljs-attribute">E</span>:\Visual Studio\IDE\VC\Tools\MSVC\<span class="hljs-number">14</span>.<span class="hljs-number">35</span>.<span class="hljs-number">32215</span>\lib\x64<br></code></pre></td></tr></table></figure><p>（5）安装完重启一下电脑</p><p>（6）查看是否安装成功</p><p><img src="/image/GraalVM/5.png"></p><p>（7）每次都要打开上述工具比较麻烦，所有添加以下配置可以在任意地方打开cmd执行。打开native-image.cmd文件，向其他添加一行即可</p><blockquote><p>我的路径：E:\JDK\graalvm-ce-java17-22.3.1\bin\native-image.cmd</p></blockquote><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">call</span> <span class="hljs-string">&quot;E:\Visual Studio\IDE\VC\Auxiliary\Build\vcvars64.bat&quot;</span><br></code></pre></td></tr></table></figure><h3 id="1-4-Hello-World测试"><a href="#1-4-Hello-World测试" class="headerlink" title="1.4 Hello World测试"></a>1.4 Hello World测试</h3><p>（1）准备HelloWorld的java源码文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, Native World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）编译成Class文件并用java命令运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh'">javac HelloWorld.java<br>java HelloWorld<br></code></pre></td></tr></table></figure><p>（3）打开PowerShell窗口，查看运行时间</p><blockquote><p>Measure-Command{java HelloWorld}</p></blockquote><p><img src="/image/GraalVM/8.png"></p><p>（4）将Class文件打包成本地可执行文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">native-image HelloWorld<br></code></pre></td></tr></table></figure><p>（5）打开PowerShell窗口，运行这个可执行文件</p><p><img src="/image/GraalVM/9.png"></p><p>可见，运行速度提升了很多</p><h3 id="1-5-JVM-and-GraalVM"><a href="#1-5-JVM-and-GraalVM" class="headerlink" title="1.5 JVM and GraalVM"></a>1.5 JVM and GraalVM</h3><ol><li>JVM and GraalVM</li></ol><p><a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html</a></p><p><img src="/image/GraalVM/10.png"></p><ol start="2"><li>GraalVM</li></ol><p><img src="/image/GraalVM/11.png"></p><h2 id="2-GraalVM编译普通的Maven项目"><a href="#2-GraalVM编译普通的Maven项目" class="headerlink" title="2  GraalVM编译普通的Maven项目"></a>2  GraalVM编译普通的Maven项目</h2><h3 id="2-1-静态代码"><a href="#2-1-静态代码" class="headerlink" title="2.1 静态代码"></a>2.1 静态代码</h3><p>（1）创建一个普通的maven工程</p><p>（2）打开idea的terminal窗口，检查java和mvn版本</p><p><img src="/image/GraalVM/12.png"></p><p>（3）创建包和类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello world, GraalVM Simple Maven!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）引入native plugin</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">native.maven.plugin.version</span>&gt;</span>0.9.20<span class="hljs-tag">&lt;/<span class="hljs-name">native.maven.plugin.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>native<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.graalvm.buildtools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>native-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;native.maven.plugin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">extensions</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>build-native<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile-no-fork<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>test-native<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>graalvm-demo<span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span><br>                        <span class="hljs-comment">&lt;!-- 你的启动类路径 --&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>org.example.Main<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">verbose</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">verbose</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（5）打开terminal，打包该工程为可执行文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn -Pnative native:compile<br></code></pre></td></tr></table></figure><p>（6）执行文件</p><p><img src="/image/GraalVM/13.png"></p><h3 id="2-2-动态代码-Reachebility-Metadata"><a href="#2-2-动态代码-Reachebility-Metadata" class="headerlink" title="2.2 动态代码-Reachebility Metadata"></a>2.2 动态代码-Reachebility Metadata</h3><p><a href="https://www.graalvm.org/latest/reference-manual/native-image/metadata/">https://www.graalvm.org/latest/reference-manual/native-image/metadata/</a></p><p>GraalVm会将各种动态代码在编译过程中生成Reachebility Metadata（各种JSON文件），包括动态代理，泛型等</p><p>（1）定义接口和实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Protocol</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DubboProtocol</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Protocol</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Dubbo Protocol!&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GrpcProtocol</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Protocol</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Grpc Protocol!&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）创建反射使用的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;org.example.service.impl.&quot;</span>+args[<span class="hljs-number">0</span>]);<br>clazz.getMethod(<span class="hljs-string">&quot;sayHello&quot;</span>).invoke(clazz.getConstructor().newInstance());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）正常运行程序，发现会报错，因为没有指定args[0]</p><p>（4）指定args参数</p><p><img src="/image/GraalVM/14.png"></p><p>（5）再次运行程序，发现运行正常</p><p>（6）native打包成本地可执行文件，然后运行可执行文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn -Pnative native:compile<br>.\target\graalvm-demo.exe<br>.\target\graalvm-demo.exe DubboProtocol<br></code></pre></td></tr></table></figure><p><img src="/image/GraalVM/15.png"></p><p>（7）在JVM Options中添加一段配置，用于生成各种json文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">-agentlib:native-image-agent=config-output-dir=src/main/resources/META-INF/native-image/<br></code></pre></td></tr></table></figure><p><img src="/image/GraalVM/20.png"></p><p>（8）以JVM的形式正常运行主函数，然后观察对应目录下的变化</p><p><img src="/image/GraalVM/16.png"></p><p>（9）再次native image这段代码，同时查看target目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn -Pnative native:compile<br></code></pre></td></tr></table></figure><p><img src="/image/GraalVM/17.png"></p><p>（10）再次运行可执行文件</p><p><img src="/image/GraalVM/18.png"></p><p>GrpcProtocol找不到，只需要打开resources目录下的reflect-config.json文件，配置一下GrpcProtocol，然后再native-image 打包成可执行文件</p><p><img src="/image/GraalVM/19.png"></p><h2 id="3-Spring-Boot-3-0集成"><a href="#3-Spring-Boot-3-0集成" class="headerlink" title="3 Spring Boot 3.0集成"></a>3 Spring Boot 3.0集成</h2><p>相关文档：</p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.introducing-graalvm-native-images">https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.introducing-graalvm-native-images</a></p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.introducing-graalvm-native-images.key-differences-with-jvm-deployments">https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.introducing-graalvm-native-images.key-differences-with-jvm-deployments</a></p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.introducing-graalvm-native-images.understanding-aot-processing">https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.introducing-graalvm-native-images.understanding-aot-processing</a></p><p>（1）创建Spring Boot 3.x工程</p><p><img src="/image/GraalVM/21.png"></p><p><img src="/image/GraalVM/22.png"></p><p>（2）编写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot3GrallvmDemoApplication</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(Springboot3GrallvmDemoApplication.class, args);<br>&#125;<br><br><span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World Spring Boot3 GraalVM demo&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）以JVM的形式运行Spring Boot，查看启动时间并访问hello</p><h3 id="3-1-使用GraalVM编译"><a href="#3-1-使用GraalVM编译" class="headerlink" title="3.1 使用GraalVM编译"></a>3.1 使用GraalVM编译</h3><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.developing-your-first-application.native-build-tools">https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.developing-your-first-application.native-build-tools</a></p><p>（1）打开terminal，执行如下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn -Pnative native:compile<br></code></pre></td></tr></table></figure><p>或者打开maven的plugins，执行native:compile</p><p><img src="/image/GraalVM/23.png"></p><p>（2）直接运行可执行文件，并查看启动时间</p><p><img src="/image/GraalVM/24.png"></p><h3 id="3-2-编译成docker-image"><a href="#3-2-编译成docker-image" class="headerlink" title="3.2 编译成docker image"></a>3.2 编译成docker image</h3><p>（1）在pom文件中指定镜像名称</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">spring-boot.build-image.imageName</span>&gt;</span>s3gb:v1<span class="hljs-tag">&lt;/<span class="hljs-name">spring-boot.build.image.imageName</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）使用如下命令打包成docker image</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn -Pnative spring-boot:build-image<br></code></pre></td></tr></table></figure><p><img src="/image/GraalVM/25.png"></p><h2 id="4-GraalVM内存管理"><a href="#4-GraalVM内存管理" class="headerlink" title="4  GraalVM内存管理"></a>4  GraalVM内存管理</h2><p><a href="https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/MemoryManagement/">https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/MemoryManagement/</a></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>GraalVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDK</tag>
      
      <tag>GraalVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Sleuth+Zipkin</title>
    <link href="/2023/04/12/spring%E6%A1%86%E6%9E%B6/springcloud/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/Spring%20Cloud%20Sleuth+Zipkin/"/>
    <url>/2023/04/12/spring%E6%A1%86%E6%9E%B6/springcloud/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/Spring%20Cloud%20Sleuth+Zipkin/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Spring-Cloud-Sleuth"><a href="#1-Spring-Cloud-Sleuth" class="headerlink" title="1 Spring Cloud Sleuth"></a>1 Spring Cloud Sleuth</h2><p><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2022.0-Release-Notes">https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2022.0-Release-Notes</a></p><h3 id="1-1-目前调用链路存在的问题及解决方案"><a href="#1-1-目前调用链路存在的问题及解决方案" class="headerlink" title="1.1 目前调用链路存在的问题及解决方案"></a>1.1 目前调用链路存在的问题及解决方案</h3><p>存在的问题：整个微服务调用的链路是怎么样的？以及调用发生了问题该如何定位？每个服务调用到 底花了多长时间？</p><p>解决方案：链路追踪 </p><p>常见的链路追踪产品：Spring Cloud Sleuth+Zipkin、SkyWalking、阿里鹰眼、Jaeger、Pinpoint、 大众点评Cat等</p><h3 id="1-2-Sleuth介绍"><a href="#1-2-Sleuth介绍" class="headerlink" title="1.2 Sleuth介绍"></a>1.2 Sleuth介绍</h3><p><a href="https://spring.io/projects/spring-cloud-sleuth#overview">https://spring.io/projects/spring-cloud-sleuth#overview</a></p><p>SC Sleuth是通过扩展Logging日志的方式实现链路追踪的。</p><p><img src="/image/springcloud/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/SpringCloudSleuth+Zipkin/1.png"></p><h3 id="1-3-微服务整合Sleuth"><a href="#1-3-微服务整合Sleuth" class="headerlink" title="1.3 微服务整合Sleuth"></a>1.3 微服务整合Sleuth</h3><p>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">sleuth:</span><br>    <span class="hljs-attr">sampler:</span><br>      <span class="hljs-attr">probability:</span> <span class="hljs-number">1.0</span><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">root:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h3 id="1-4-Tracer"><a href="#1-4-Tracer" class="headerlink" title="1.4  Tracer"></a>1.4  Tracer</h3><p>如果想要通过代码方式获取到traceid、spanid等，可以查看brave包下的Tracer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">tracer.currentSpan().context().traceId()<br>tracer.currentSpan().context().spanId()<br></code></pre></td></tr></table></figure><h2 id="2-Zipkin"><a href="#2-Zipkin" class="headerlink" title="2  Zipkin"></a>2  Zipkin</h2><p><a href="https://zipkin.io/">https://zipkin.io/</a></p><p><img src="/image/springcloud/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/SpringCloudSleuth+Zipkin/2.png"></p><p>工作流程：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">┌─────────────┐ ┌───────────────────────┐  ┌─────────────┐  ┌──────────────────┐<br>│ <span class="hljs-keyword">User</span> Code   │ │ Trace Instrumentation │  │ Http Client │  │ Zipkin Collector │<br>└─────────────┘ └───────────────────────┘  └─────────────┘  └──────────────────┘<br>       │                 │                         │                 │<br>           ┌─────────┐<br>       │ ──┤<span class="hljs-keyword">GET</span> /foo ├─▶ │ ────┐                   │                 │<br>           └─────────┘         │ <span class="hljs-type">record</span> tags<br>       │                 │ ◀───┘                   │                 │<br>                           ────┐<br>       │                 │     │ <span class="hljs-keyword">add</span> trace headers │                 │<br>                           ◀───┘<br>       │                 │ ────┐                   │                 │<br>                               │ <span class="hljs-type">record</span> <span class="hljs-type">timestamp</span><br>       │                 │ ◀───┘                   │                 │<br>                             ┌─────────────────┐<br>       │                 │ ──┤<span class="hljs-keyword">GET</span> /foo         ├─▶ │                 │<br>                             │X-B3-TraceId: aa │     ────┐<br>       │                 │   │X-B3-SpanId: <span class="hljs-number">6</span>b  │   │     │           │<br>                             └─────────────────┘         │ invoke<br>       │                 │                         │     │ request   │<br>                                                         │<br>       │                 │                         │     │           │<br>                                 ┌────────┐          ◀───┘<br>       │                 │ ◀─────┤<span class="hljs-number">200</span> OK  ├─────── │                 │<br>                           ────┐ └────────┘<br>       │                 │     │ <span class="hljs-type">record</span> duration   │                 │<br>            ┌────────┐     ◀───┘<br>       │ ◀──┤<span class="hljs-number">200</span> OK  ├── │                         │                 │<br>            └────────┘       ┌────────────────────────────────┐<br>       │                 │ ──┤ asynchronously report span     ├────▶ │<br>                             │                                │<br>                             │&#123;                               │<br>                             │  &quot;traceId&quot;: &quot;aa&quot;,              │<br>                             │  &quot;id&quot;: &quot;6b&quot;,                   │<br>                             │  &quot;name&quot;: &quot;get&quot;,                │<br>                             │  &quot;timestamp&quot;: <span class="hljs-number">1483945573944000</span>,│<br>                             │  &quot;duration&quot;: <span class="hljs-number">386000</span>,           │<br>                             │  &quot;annotations&quot;: [              │<br>                             │<span class="hljs-comment">--snip--                        │</span><br>                             └────────────────────────────────┘<br></code></pre></td></tr></table></figure><h3 id="2-1-下载搭建Zipkin-Server"><a href="#2-1-下载搭建Zipkin-Server" class="headerlink" title="2.1 下载搭建Zipkin Server"></a>2.1 下载搭建Zipkin Server</h3><p>（1）下载链接：<a href="https://repo1.maven.org/maven2/io/zipkin/zipkin-server/">https://repo1.maven.org/maven2/io/zipkin/zipkin-server/</a></p><p>（2）启动zipkin server</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -jar zipkin-server-2.23.2-exec.jar<br></code></pre></td></tr></table></figure><p>（3）浏览器访问9411端口</p><p><img src="/image/springcloud/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/SpringCloudSleuth+Zipkin/3.png"></p><h3 id="2-2-微服务整合Zipkin客户端"><a href="#2-2-微服务整合Zipkin客户端" class="headerlink" title="2.2 微服务整合Zipkin客户端"></a>2.2 微服务整合Zipkin客户端</h3><p>（1）引入依赖：此时就不需要单独的sleuth依赖了，因为zipkin中包含了sleuth</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）写配置：注意zipkin和sleuth的父级配置项都是spring</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">zipkin:</span><br>    <span class="hljs-attr">base-url:</span> <span class="hljs-string">http://localhost:9411</span><br>  <span class="hljs-attr">sleuth:</span><br>    <span class="hljs-attr">sampler:</span><br>      <span class="hljs-attr">probability:</span> <span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><h3 id="2-3-Data-Model"><a href="#2-3-Data-Model" class="headerlink" title="2.3 Data Model"></a>2.3 Data Model</h3><p><a href="https://zipkin.io/pages/data_model.html">https://zipkin.io/pages/data_model.html</a></p><p>向Zipkin报告数据的最流行方式是通过HTTP或Kafka，尽管许多其他方式存在选项，例如Apache ActiveMQ，gRPC和RabbitMQ。</p><h3 id="2-4-持久化到MySQL"><a href="#2-4-持久化到MySQL" class="headerlink" title="2.4  持久化到MySQL"></a>2.4  持久化到MySQL</h3><p>（1）执行mysql.sql</p><p><a href="https://github.com/openzipkin/zipkin/blob/master/zipkin-storage/mysql-v1/src/main/resources/mysql.sql">https://github.com/openzipkin/zipkin/blob/master/zipkin-storage/mysql-v1/src/main/resources/mysql.sql</a></p><p>（2）重启zipkin server，设置其数据持久化方式为MySQL</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -jar zipkin-server-2.23.2-exec.jar --STORAGE_TYPE=mysql --MYSQL_HOST=127.0.0.1 --MYSQL_TCP_PORT=3306 --MYSQL_USER=root --MYSQL_PASS=root123 --MYSQL_DB=db_zipkin<br></code></pre></td></tr></table></figure><h3 id="2-5-持久化到ElasticSearch"><a href="#2-5-持久化到ElasticSearch" class="headerlink" title="2.5 持久化到ElasticSearch"></a>2.5 持久化到ElasticSearch</h3><p>（1）下载es</p><p><a href="https://www.elastic.co/cn/downloads/past-releases#elasticsearch">https://www.elastic.co/cn/downloads/past-releases#elasticsearch</a></p><p>（2）启动es</p><p>以windows环境为例，解压es的压缩包，来到bin文件夹之下，执行elasticsearch.bat文件，默认会监 听在9200端口</p><p>（3）重启zipkin server，设置其数据持久化方式为es</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -jar zipkin-server-2.23.2-exec.jar --STORAGE_TYPE=elasticsearch --ES_HOSTS=127.0.0.1:9200<br></code></pre></td></tr></table></figure><h2 id="3-Micrometer"><a href="#3-Micrometer" class="headerlink" title="3 Micrometer"></a>3 Micrometer</h2><p>在Spring Boot 3.X中Sleuth被替换成Micrometer</p><p><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2022.0-Release-Notes">https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2022.0-Release-Notes</a></p><p><a href="https://docs.spring.io/spring-boot/docs/3.0.0/reference/html/actuator.html#actuator.observability">https://docs.spring.io/spring-boot/docs/3.0.0/reference/html/actuator.html#actuator.observability</a></p><p><a href="https://micrometer.io/docs/observation">https://micrometer.io/docs/observation</a></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>链路追踪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zipkin</tag>
      
      <tag>Sleuth</tag>
      
      <tag>链路追踪</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx安装</title>
    <link href="/2023/04/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx%E5%AE%89%E8%A3%85/"/>
    <url>/2023/04/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>地址从<code>http://nginx.org/en/download.html</code>复制</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft<br>wget http://nginx.org/download/nginx-1.20.2.tar.gz<br></code></pre></td></tr></table></figure><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xzvf nginx-1.20.2.tar.gz<br></code></pre></td></tr></table></figure><h2 id="安装依赖环境"><a href="#安装依赖环境" class="headerlink" title="安装依赖环境"></a>安装依赖环境</h2><p>gcc环境：基本运行环境</p><p>pcre：用于nginx的http模块解析正则表达式</p><p>zlib：用户进行gzip压缩</p><p>openssl：用于nginx https协议的传输</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum install -y gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel<br></code></pre></td></tr></table></figure><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>–prefix=/usr/local/soft/nginx ：把nginx安装到/usr/local/soft/nginx，可以自定义修改目录。所以后面会有一个源码目录nginx-1.20.2，一个编译安装后的目录nginx。</p><p>–with-http_ssl_module ：启用ssl模块，使用ssl功能</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft/nginx-1.20.2<br>./configure --prefix=/usr/local/soft/nginx --with-http_ssl_module<br>make &amp;&amp; sudo make install<br><span class="hljs-built_in">cd</span> /usr/local/soft/nginx/<br></code></pre></td></tr></table></figure><p>测试配置是否成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/usr/local/soft/nginx/sbin/nginx -t -c /usr/local/soft/nginx/conf/nginx.conf<br></code></pre></td></tr></table></figure><h2 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/soft/</span>nginx<span class="hljs-regexp">/sbin/</span>nginx<br></code></pre></td></tr></table></figure><p>浏览器直接访问IP（HTTP协议默认80端口，不需要输入）</p><h2 id="copy-vimfile"><a href="#copy-vimfile" class="headerlink" title="copy vimfile"></a>copy vimfile</h2><p>为了让VIM查看nginx配置文件时语法高亮，需要把相应文件copy到VIM目录。先确定本机的vimfiles目录在哪个位置。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">find / -name vimfiles<br><span class="hljs-built_in">cd</span> /usr/local/soft/nginx-1.20.2<br><span class="hljs-built_in">cp</span> -r contrib/vim/* /usr/share/vim/vimfiles/<br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sh">nginx -s reopen <span class="hljs-comment">#重启Nginx</span><br><br>nginx -s reload <span class="hljs-comment">#重新加载Nginx配置文件，然后以优雅的方式重启Nginx</span><br><br>nginx -s stop <span class="hljs-comment">#强制停止Nginx服务</span><br><br>nginx -s quit <span class="hljs-comment">#优雅地停止Nginx服务（即处理完所有请求后再停止服务）</span><br><br>nginx -t <span class="hljs-comment">#检测配置文件是否有语法错误，然后退出</span><br><br>nginx -?,-h <span class="hljs-comment">#打开帮助信息</span><br><br>nginx -v <span class="hljs-comment">#显示版本信息并退出</span><br><br>nginx -V <span class="hljs-comment">#显示版本和配置选项信息，然后退出</span><br><br>nginx -t <span class="hljs-comment">#检测配置文件是否有语法错误，然后退出</span><br><br>nginx -T <span class="hljs-comment">#检测配置文件是否有语法错误，转储并退出</span><br><br>nginx -q <span class="hljs-comment">#在检测配置文件期间屏蔽非错误信息</span><br><br>nginx -p prefix <span class="hljs-comment">#设置前缀路径(默认是:/usr/share/nginx/)</span><br><br>nginx -c filename <span class="hljs-comment">#设置配置文件(默认是:/etc/nginx/nginx.conf)</span><br><br>nginx -g directives <span class="hljs-comment">#设置配置文件外的全局指令</span><br><br>killall nginx <span class="hljs-comment">#杀死所有nginx进程</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ保证消息可靠性</title>
    <link href="/2023/04/06/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7/"/>
    <url>/2023/04/06/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Producer保证消息高可靠"><a href="#1-Producer保证消息高可靠" class="headerlink" title="1  Producer保证消息高可靠"></a>1  Producer保证消息高可靠</h2><p>（1）尽量采用同步或者异步的方式发送消息，最好不要使用oneway的方式发送，也就是说当把消息发到broker之后，一定要得到broker的响应 </p><p>（2）建立数据库消息发送表，防止消息还没来得及发送当前系统就宕机了，这样等系统恢复的时候，可以根据消息发送表中的记录决定是否需要重新发送，发送成功之后要将对应表中的记录删除或者更新成发送成功状态，可以避免重复发送消息 </p><p>（3）消息发送的重试机制，当producer向broker发送消息时，因为网络原因或者broker挂了，这样情况下肯定得不到broker的 响应，解决方案就是要做好重试机制，默认重试的次数是2，如果2次依然不能满足要求，这时候可以考虑开启一个定时任务，不断重试，或者人工补偿。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultMQProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRetryTimeWhenSendFailed</span><span class="hljs-params">(<span class="hljs-type">int</span> retryTimeWhenSendFailed)</span> &#123;<br>        <span class="hljs-built_in">this</span>.retryTimeWhenSendFailed = retryTimeWhenSendFailed; <span class="hljs-comment">//默认为2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）消息最大大小为4M，如果消息超过了这个大小，发送会有限制，并且在broker端其实对于消息的处理默认上线也是4MB， 所以producer要发送的消息如果超过4M，记得做划分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultMQProducer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">masMessageSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">4</span>; <span class="hljs-comment">//4M</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-集群保证消息高可靠"><a href="#2-集群保证消息高可靠" class="headerlink" title="2 集群保证消息高可靠"></a>2 集群保证消息高可靠</h2><h3 id="2-1-集群搭建"><a href="#2-1-集群搭建" class="headerlink" title="2.1 集群搭建"></a>2.1 集群搭建</h3><p>（1）NameServer集群部署在不同的节点上：可以防止单点故障 </p><p>（2）Broker集群部署[比如采用双主双从架构]：可以防止单点故障、提高读写性能、增加消息的可靠性等 </p><p>（3）Producer、Consumer、Broker都要设置好nameserver的集群地址，防止获取不到最新的路由信息</p><h3 id="2-2-Broker主从复制策略"><a href="#2-2-Broker主从复制策略" class="headerlink" title="2.2 Broker主从复制策略"></a>2.2 Broker主从复制策略</h3><p>两种选择：同步复制[同步双写]和异步复制 </p><p>一般情况下，broker的刷盘策略选择异步刷盘，而复制策略选择同步双写，这样做是为了在消息可靠性与性能之间能够平衡一下</p><h3 id="2-3-Broker刷盘策略"><a href="#2-3-Broker刷盘策略" class="headerlink" title="2.3 Broker刷盘策略"></a>2.3 Broker刷盘策略</h3><p>两种选择：同步刷盘和异步刷盘 </p><p>在同步刷盘的策略下，只要producer收到了SEND_OK，那么消息一定是被持久化到了broker的磁盘中，以commitlog的形式保存，这样消息就不容易丢失了 </p><p>而在异步刷盘的策略下，即使producer把消息发送到broker，但是不能完全保证消息被持久化到了磁盘，所以消息可能会丢失 </p><p>这两种方式虽然同步刷盘的消息可靠性更高，但是在一般场景下，为了追求更好的性能，通常采用异步刷盘的方式</p><h3 id="2-4-Broker磁盘选择"><a href="#2-4-Broker磁盘选择" class="headerlink" title="2.4 Broker磁盘选择"></a>2.4 Broker磁盘选择</h3><p><a href="https://zh.wikipedia.org/wiki/RAID">https://zh.wikipedia.org/wiki/RAID</a></p><p>Broker磁盘的存储介质可以选择RAID 10或者分布式存储，避免磁盘损坏导致消息丢失</p><h2 id="3-DLedger"><a href="#3-DLedger" class="headerlink" title="3 DLedger"></a>3 DLedger</h2><p>DLedger，它是基于RAFT协议的commitlog存储库，解决了自动选举brokermaster和日志复制的问题。</p><p><a href="https://github.com/openmessaging/dledger">https://github.com/openmessaging/dledger</a></p><p>DLedger作为RocketMQ的消息存储</p><p>搭建：<a href="https://rocketmq.apache.org/zh/docs/bestPractice/02dledger">https://rocketmq.apache.org/zh/docs/bestPractice/02dledger</a></p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E5%8F%AF%E9%9D%A0%E6%80%A7/RocketMQ%E6%9E%B6%E6%9E%84-DLedger.jpg"></p><h2 id="4-Consumer保证消息高可靠性"><a href="#4-Consumer保证消息高可靠性" class="headerlink" title="4 Consumer保证消息高可靠性"></a>4 Consumer保证消息高可靠性</h2><h3 id="4-1-消息重试机制"><a href="#4-1-消息重试机制" class="headerlink" title="4.1 消息重试机制"></a>4.1 消息重试机制</h3><p>当一条消息初次消费失败，消息队列 RocketMQ 会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 RocketMQ 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。在消息队列 RocketMQ 中，这种正常情况下无法被消费的消息称为死信消息（Dead-LetterMessage）</p><p>存储死信消息的特殊队列称为死信队列 （Dead-Letter Queue）。 一条消息进入死信队列，意味着某些因素导致消费者无法正常消费该消息，因此，通常需要对其进行特殊处理。排查可疑因素并解决问题后，可以在消息队列 RocketMQ控制台重新发送该消息，让消费者 重新消费一次。</p><h3 id="4-2-给Broker一个反馈"><a href="#4-2-给Broker一个反馈" class="headerlink" title="4.2 给Broker一个反馈"></a>4.2 给Broker一个反馈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br>   <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            System.out.println(msgs);<br>            <span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="4-3-消费消息幂等处理"><a href="#4-3-消费消息幂等处理" class="headerlink" title="4.3 消费消息幂等处理"></a>4.3 消费消息幂等处理</h3><p>如何避免消息重复消费？可以使用唯一的msgid，或者业务id，比如orderid，利用数据库日志表或 redis主键进行幂等处理。</p><h2 id="5-如何处理消息积压"><a href="#5-如何处理消息积压" class="headerlink" title="5 如何处理消息积压"></a>5 如何处理消息积压</h2><p>（1）消费者出错，肯定是程序或者其他问题导致的，如果容易修复，先把问题修复，让consumer恢复正常消费 </p><p>（2）如果时间来不及处理很麻烦，做转发处理，写一个临时的consumer消费方案，先把消息消费，然后再转发到一个新的topic和MQ资源，这个新的topic的机器资源单独申请，要能承载住当前积压的消息 </p><p>（3）处理完积压数据后，修复consumer，去消费新的MQ和现有的MQ数据，新MQ消费完成后恢复原状 </p><p>（4）增加consumer的数量 </p><p>（5）限流</p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
      <category>RocketMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ源码解析</title>
    <link href="/2023/04/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/04/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-NameServer"><a href="#1-NameServer" class="headerlink" title="1 NameServer"></a>1 NameServer</h2><h3 id="1-1-NameServer启动流程"><a href="#1-1-NameServer启动流程" class="headerlink" title="1.1 NameServer启动流程"></a>1.1 NameServer启动流程</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/NameServer%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.jpg"></p><h3 id="1-2-NameServer处理Broker注册信息"><a href="#1-2-NameServer处理Broker注册信息" class="headerlink" title="1.2 NameServer处理Broker注册信息"></a>1.2 NameServer处理Broker注册信息</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/NameServer%E5%A4%84%E7%90%86Broker%E6%B3%A8%E5%86%8C%E4%BF%A1%E6%81%AF.jpg"></p><h2 id="2-Broker"><a href="#2-Broker" class="headerlink" title="2 Broker"></a>2 Broker</h2><h3 id="2-1-Broker启动与注册信息"><a href="#2-1-Broker启动与注册信息" class="headerlink" title="2.1 Broker启动与注册信息"></a>2.1 Broker启动与注册信息</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Broker%E5%90%AF%E5%8A%A8%E4%B8%8E%E6%B3%A8%E5%86%8C%E4%BF%A1%E6%81%AF.jpg"></p><h3 id="2-2-Broker消息的存储结构"><a href="#2-2-Broker消息的存储结构" class="headerlink" title="2.2 Broker消息的存储结构"></a>2.2 Broker消息的存储结构</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Broker%E6%B6%88%E6%81%AF%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg"></p><h4 id="2-2-1-CommitLog"><a href="#2-2-1-CommitLog" class="headerlink" title="2.2.1 CommitLog"></a>2.2.1 CommitLog</h4><p>默认大小是1G，可以通过MessageStoreConfig中的mappedFileSizeCommitLog属性查看。</p><p>CommitLog是消息存储的真正物理文件，文件名按照文件偏移量递增。</p><p>一个CommitLog是被多个ConsumerQueue所共享的。</p><p>CommitLog采用的是顺序写随机读的方式</p><h4 id="2-2-2-ConsumerQueue"><a href="#2-2-2-ConsumerQueue" class="headerlink" title="2.2.2 ConsumerQueue"></a>2.2.2 ConsumerQueue</h4><p>consumerqueue是逻辑消息队列，一个topic下有几个队列，则会在对应的目录存储相应的 consumerqueue文件。</p><p>consumerqueue不会存储具体的消息，只负责记录所属topic在commitlog中的偏移量，是消息的逻辑队列，类似于数据库的索引文件，存储的是指向物理存储的地址。</p><h4 id="2-2-3-IndexFile"><a href="#2-2-3-IndexFile" class="headerlink" title="2.2.3 IndexFile"></a>2.2.3 IndexFile</h4><p>IndexFile则提供了一种可以通过key或时间区间来查询消息的方法</p><h3 id="2-3-Broker消息处理整体流程"><a href="#2-3-Broker消息处理整体流程" class="headerlink" title="2.3 Broker消息处理整体流程"></a>2.3 Broker消息处理整体流程</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Broker%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.jpg"></p><h4 id="2-3-1-Broker接收消息流程SendMessageProcessor"><a href="#2-3-1-Broker接收消息流程SendMessageProcessor" class="headerlink" title="2.3.1 Broker接收消息流程SendMessageProcessor"></a>2.3.1 Broker接收消息流程SendMessageProcessor</h4><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Broker%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8BSendMessageProcessor.jpg"></p><h4 id="2-3-2-Broker分发消息流程ReputMessageService"><a href="#2-3-2-Broker分发消息流程ReputMessageService" class="headerlink" title="2.3.2 Broker分发消息流程ReputMessageService"></a>2.3.2 Broker分发消息流程ReputMessageService</h4><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Broker%E5%88%86%E5%8F%91%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8BReputMessageService.jpg"></p><h4 id="2-3-3-Broker消费消息流程PullMessageProcessor"><a href="#2-3-3-Broker消费消息流程PullMessageProcessor" class="headerlink" title="2.3.3 Broker消费消息流程PullMessageProcessor"></a>2.3.3 Broker消费消息流程PullMessageProcessor</h4><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Broker%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8BPullMessageProcessor.jpg"></p><h3 id="2-4-过期文件的处理"><a href="#2-4-过期文件的处理" class="headerlink" title="2.4 过期文件的处理"></a>2.4 过期文件的处理</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Broker%E8%BF%87%E6%9C%9F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4.jpg"></p><h2 id="3-Producer"><a href="#3-Producer" class="headerlink" title="3 Producer"></a>3 Producer</h2><h3 id="3-1-Producer发送消息-同步"><a href="#3-1-Producer发送消息-同步" class="headerlink" title="3.1 Producer发送消息(同步)"></a>3.1 Producer发送消息(同步)</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Producer%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF(%E5%90%8C%E6%AD%A5).jpg"></p><h2 id="4-Consumer"><a href="#4-Consumer" class="headerlink" title="4 Consumer"></a>4 Consumer</h2><p>Consumer消费消息支持两种模式：推模式和拉模式 </p><p>推模式：当producer把消息发送到broker之后，broker将消息推送给consumer，但这种推模式其实也是基于拉模式实现的 </p><p>拉模式：consumer主动向broker拉消息 </p><p>两种模式用的最多的是推模式，所以就以推模式为例进行分析</p><h3 id="4-1-Consumer启动"><a href="#4-1-Consumer启动" class="headerlink" title="4.1 Consumer启动"></a>4.1 Consumer启动</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Consumer%E5%90%AF%E5%8A%A8.jpg"></p><h3 id="4-2-Consumer线程消费消息"><a href="#4-2-Consumer线程消费消息" class="headerlink" title="4.2 Consumer线程消费消息"></a>4.2 Consumer线程消费消息</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Consumer%E7%BA%BF%E7%A8%8B%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
      <category>RocketMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ组件介绍与基本使用</title>
    <link href="/2023/03/29/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/03/29/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E#%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB">https://github.com/alibaba/spring-cloud-alibaba/wiki/版本说明#组件版本关系</a></p><h2 id="1-组件介绍"><a href="#1-组件介绍" class="headerlink" title="1 组件介绍"></a>1 组件介绍</h2><h3 id="1-1-Message-Queue"><a href="#1-1-Message-Queue" class="headerlink" title="1.1 Message Queue"></a>1.1 Message Queue</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1.png"></p><p>RocketMQ支持多master的架构。思考一个问题：当有多个master的时候，发往Topic的多条消息会在多个master的Broker上存储。那么，发往某一个Topic的多条消息，是不是在所有的Broker上存储完全相同的内容？</p><p>肯定不是的。如果所有的master存储相同的内容，而slave又跟master存储相同的内容：第一个，浪费了存储空间。第二个，无法通过增加机器数量线性的提升Broker的性能，也就是只能垂直扩展，通过升级硬件的方式提升性能，无法实现横向（水平）扩展。那么在分布式的环境中，RocketMQ的性能肯定会受到非常大的限制。一句话，不符合分片的思想。</p><p>在kafka中设计了一个partiton，一个topic可以拆分成多个partition，这些partition可以分布在不同的Broker上，这样就实现了数据的分片。也决定了kafka可以实现横向扩展。</p><p>RocketMQ中设计了一个叫做Message Queue的逻辑概念，左右跟partition类似。</p><p>首先，创建Topic的时候会指定队列的数量，一个叫writeQueueNums（写队列数量），一个readQueueNums（读队列数量）。写队列的数量决定了有几个Message Queue，读队列的数量决定了有一个线程来消费这些Message Queue（只是用来负载）。服务端创建一个Topic默认8个队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">defaultTopicQueueNums</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure><p>topic不存在，生产者发送消息时创建默认4个队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">defaultTopicNums</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><h3 id="1-2-Producer-and-Consumer"><a href="#1-2-Producer-and-Consumer" class="headerlink" title="1.2 Producer and Consumer"></a>1.2 Producer and Consumer</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/2.png"></p><h4 id="1-2-1-Producer"><a href="#1-2-1-Producer" class="headerlink" title="1.2.1 Producer"></a>1.2.1 Producer</h4><p>生产者，用于生产消息，会定时从NameServer拉取路由信息（不用配置RocketMQ的服务地址），然后路由信息与指定的Broker建立TCP长连接，从而将消息发送到Broker中。发送逻辑一致的Producer可以组成一个Group。RocketMQ的生产者同样支持批量发送，不过List要自己传进去。Producer写数据只能操作master节点。</p><h4 id="1-2-2-Consumer"><a href="#1-2-2-Consumer" class="headerlink" title="1.2.2 Consumer"></a>1.2.2 Consumer</h4><p>消息的消费者，通过NameServer 集群获得Topic的路由信息，连接到对应的Broker上消费消息。消费逻辑一致的Consumer可以组成一个Group，这时候消息会在Consumer之间负载。由于Master和Slave都可以读取消息，因此Consumer会与Master和Slave都建立连接。</p><p>注意：同一个consumer group内的消费者应该订阅同一个topic。或者反过来，消费不同topic的消费者不应该采用相同的consumer group名字。如果不一样，后面的消费者的订阅，会覆盖前面的订阅。</p><p>消费者有两种消费方式：一种是集群消费（消息轮询），一种是广播消费（全部收到相同副本）。从消费模型来说，RocketMQ支持pull和push两种模式。</p><ol><li><p>pull模式</p><p> Pull模式是consumer 轮询从broker拉取消息。pull有两种实现范式：</p><p> 一种是普通轮询（Polling）。不管服务端数据有无更新，客户端每隔定长时间请求拉取一次数据，可能有更新数据返回，也可能什么都没有。普通轮询的缺点：因为大部分时候没有数据，这些无效的请求会大大的浪费服务器的资源。而且定时请求的间隔过长的时候，会导致消息延迟。</p><p> 另一种是长轮询，RocketMQ的pull用长轮询来实现。客户端发起Long Polling，如果此时服务端没有相关数据，会hold住请求，直到服务端有相关数据，或者等待一定时间超时才会返回。返回后，客户端又会立即再次发起下一次Long Polling（所谓的hold住请求指的服务端暂时不回复结果，保存相关请求，不关闭请求连接，等相关数据准备好，写回客户端）。长轮询解决了轮询的问题，唯一的缺点是服务器在挂起的时候比较消耗内存。</p></li><li><p>push模式</p><p> push模式是Broker推送消息给consumer，RocketMQ的push模式实际上是基于pull模式实现的，只不过是在pull模式上封装了一层，所以RocketMQ push模式并不是真正意义上的“推模式”。在RokcetMQ中，PushConsumer会注册MessageListener监听器，取到消息后，唤醒MessageListener的consumeMessage()来消费，对用户而言，感觉消息是被推送过来的。</p></li></ol><h3 id="1-3-Topic"><a href="#1-3-Topic" class="headerlink" title="1.3 Topic"></a>1.3 Topic</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/3.png"></p><p>Topic用于将消息按主题做划分，比如订单消息、物流消息。注意，跟kafka不同的是，在RocketMQ中，topic是一个逻辑概念，消息不是按topic划分存储的。</p><p>Producer将消息发往指定的topic，Consumer订阅这个topic就可以收到相应的消息。跟kafka一样，如果topic不存在，会自动创建.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//BrokerConfig</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">autoCreateTopicEnable</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>Topic跟生产者和消费者都是多对多的关系，一个生产者可以发送消息到多个topic，一个消费者可以订阅多个topic。</p><h3 id="1-4-Tag"><a href="#1-4-Tag" class="headerlink" title="1.4 Tag"></a>1.4 Tag</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/4.png"></p><h3 id="1-5-Broker"><a href="#1-5-Broker" class="headerlink" title="1.5 Broker"></a>1.5 Broker</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/5.png"></p><p>RocketMQ的服务，或者说一个进程，叫做Broker，Broker的作用是存储和转发消息。RocketMQ单机大约能承受10万QPS的请求。</p><p>为了提升Broker的可用性(防止单点故障)，以及提升服务器的性能(实现负载)，通常会做集群的部署。跟kafka获取redis cluster一样，RocketMQ集群的每个Broker节点保存总数据的一部分，因此可以实现横向扩展。为了提高可靠性(防止数据丢失)，每个Broker可以有自己的副本(slave)。</p><p>默认情况下，读写都发生在master上。在slaveReadEnable=true的情况下，slave也可以参与读负载。但是默认只有BrokerId=1的slave才会参与读负载，而且是在master消费慢的情况下，由whichBrokerWhenConsumeSlowly这个参数决定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">whichBrokerWhenConsumeSlowly</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="1-6-NameServer"><a href="#1-6-NameServer" class="headerlink" title="1.6 NameServer"></a>1.6 NameServer</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/6.png"></p><p>当不同的消息存储在不同的Broker上，生产者和消费者对于Broker的选取，或者说路由选择是一个非常关键的问题。所以，跟分布式的服务调用的场景需要一个注册中心一样，在RocketMQ中需要有一个角色来管理Broker的信息。kafka是用Zookeeper管理的，RocketMQ是用NameServer。</p><p>可以把NameServer理解是RocketMQ的路由中心，每一个NameServer节点都保存着全量的路由信息，为了保证高可用，nameServer自身也可以做集群的部署，它的作用有点像Eureka或者Redis的Sentinel。也就是说，Broker会在NameServer上注册自己，Producer和Consumer用NameServer来发现Broker。</p><h3 id="1-7-RocketMQ-Cluster"><a href="#1-7-RocketMQ-Cluster" class="headerlink" title="1.7  RocketMQ Cluster"></a>1.7  RocketMQ Cluster</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/7.png"></p><h2 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2 基本使用"></a>2 基本使用</h2><h3 id="2-1-简单案例"><a href="#2-1-简单案例" class="headerlink" title="2.1 简单案例"></a>2.1 简单案例</h3><p>（1）引入rocketmq-client包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.rocketmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>rocketmq-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.9.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）创建Consumer并启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-string">&quot;simple_consumer_group&quot;</span>);<br>        consumer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>        consumer.subscribe(<span class="hljs-string">&quot;simple_topic&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>        consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;<br>                System.out.printLn(<span class="hljs-string">&quot;%s Receive New Message: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);<br>                <span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>            &#125;<br>        &#125;);<br>        consumer.start();<br>        System.out.printLn(<span class="hljs-string">&quot;Consumer Started.%n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）创建Producer并启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SyncProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;simple_consumer_group&quot;</span>);<br>        producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>        producer.start();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;simple_topic&quot;</span>, <span class="hljs-string">&quot;TAGA&quot;</span>, (<span class="hljs-string">&quot;Hello ROCKETMQ&quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));<br>            <span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> producer.send(message);<br>            System.out.printLn(sendResult);<br>        &#125;<br>        producer.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-生产者发送消息方式"><a href="#2-2-生产者发送消息方式" class="headerlink" title="2.2 生产者发送消息方式"></a>2.2 生产者发送消息方式</h3><h4 id="2-2-1-同步"><a href="#2-2-1-同步" class="headerlink" title="2.2.1 同步"></a>2.2.1 同步</h4><p>producer发送消息给broker时，只有当broker服务器刷盘成功，返回sendResult.OK才算成 功，例如上述简单案例中的producer#send(msg)方法</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/8.png"></p><h4 id="2-2-2-异步"><a href="#2-2-2-异步" class="headerlink" title="2.2.2 异步"></a>2.2.2 异步</h4><p>异步发送是指发送方发出一条消息后，不等服务端返回响应，接着发送下一条消息的通讯方式。消息队列RocketMQ的异步发送，需要实现异步发送回调接口（SendCallback）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Consumer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-string">&quot;test_consumer&quot;</span>);<br>consumer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>consumer.subscribe(<span class="hljs-string">&quot;async_topic&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>);<br>consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>System.out.println(msgs);<br><span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>e.printStackTrace();<br><span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;<br>&#125;<br>&#125;<br>&#125;);<br>consumer.start();<br>System.out.println(<span class="hljs-string">&quot;Consumer Started.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//ASyncProducer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ASyncProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;async_producer&quot;</span>);<br>producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>producer.start();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;async_topic&quot;</span>,<span class="hljs-string">&quot;tag_sync&quot;</span>,<span class="hljs-string">&quot;OrderID188&quot;</span>, (<span class="hljs-string">&quot;Hello ASync &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));<br><span class="hljs-comment">// 异步回调</span><br>producer.send(message, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SendCallback</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(SendResult sendResult)</span> &#123;<br>System.out.println(sendResult);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onException</span><span class="hljs-params">(Throwable e)</span> &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;);<br>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-3-单向"><a href="#2-2-3-单向" class="headerlink" title="2.2.3 单向"></a>2.2.3 单向</h4><p>发送方只负责发送消息，不等待服务端返回响应且没有回调函数触发，即只发送请求不等待应答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Consumer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer03</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-string">&quot;oneway_consumer&quot;</span>);<br>consumer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>consumer.subscribe(<span class="hljs-string">&quot;oneway_topic&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>);<br>consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>System.out.println(msgs);<br><span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>e.printStackTrace();<br><span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;<br>&#125;<br>&#125;<br>&#125;);<br>consumer.start();<br>System.out.println(<span class="hljs-string">&quot;Consumer Started.&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//OnewayProducer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OnewayProducer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;oneway_producer&quot;</span>);<br>producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>producer.start();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;oneway_topic&quot;</span> <span class="hljs-comment">/* Topic */</span>, <span class="hljs-string">&quot;TagA&quot;</span> <span class="hljs-comment">/* Tag */</span>, (<span class="hljs-string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));<br>producer.sendOneway(msg);<br>&#125;<br>Thread.sleep(<span class="hljs-number">5000</span>);<br>producer.shutdown();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-4-三种发送模式对比"><a href="#2-2-4-三种发送模式对比" class="headerlink" title="2.2.4 三种发送模式对比"></a>2.2.4 三种发送模式对比</h4><table><thead><tr><th>发送方式</th><th>TPS</th><th>可靠性</th><th>返回值</th><th>应用场景</th></tr></thead><tbody><tr><td>Sync</td><td>快</td><td>高</td><td>有</td><td>重要消息，比如：短信、邮件等</td></tr><tr><td>ASync</td><td>较快</td><td>较高</td><td>有</td><td>对并发要求和响应时间比较高的场景，同时需要回调函数</td></tr><tr><td>Oneway</td><td>最快</td><td>不高</td><td>无</td><td>对于可靠性要求不高的场景，也不需要返回值，比如日志收集</td></tr></tbody></table><h3 id="2-3-消费消息模式"><a href="#2-3-消费消息模式" class="headerlink" title="2.3 消费消息模式"></a>2.3 消费消息模式</h3><h4 id="2-3-1-集群模式-负载均衡模式"><a href="#2-3-1-集群模式-负载均衡模式" class="headerlink" title="2.3.1 集群模式(负载均衡模式)"></a>2.3.1 集群模式(负载均衡模式)</h4><p>Clustering：也是默认的模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Consumer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer04</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(Strin[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-string">&quot;consumer_model_group&quot;</span>);<br>consumer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>consumer.setMessageModel(MessageModel.CLUSTERING);<br>consumer.subscribe(<span class="hljs-string">&quot;consumer_model_topic&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>);<br>consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>System.out.println(msgs);<br><span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>e.printStackTrace();<br><span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;<br>&#125;<br>&#125;<br>&#125;);<br>consumer.start();<br>System.out.println(<span class="hljs-string">&quot;Consumer Started.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Producer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer01</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;test_producer01&quot;</span>);<br>producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>producer.start();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;consumer_model_topic&quot;</span>, <span class="hljs-string">&quot;TAGA&quot;</span>, (<span class="hljs-string">&quot;consumer model &quot;</span>+i).getBytes(RemotingHelper.DEFAULT_CHARSET));<br><span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> producer.send(message);<br>System.out.println(sendResult);<br>&#125;<br>producer.shutdown();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>观察producer返回结果，可以发现，10条消息被发送到了consumer_model_topic下的4个队列上。</p><p>启动两个Consumer04实例，观察两个Consumer实例的输出，可以发现其中一个consumer获取到了2个队列[2和3]上的5条消 息，另外一个consumer获取到了2个队列[0和1]上的5条消息</p><h4 id="2-3-2-广播模式"><a href="#2-3-2-广播模式" class="headerlink" title="2.3.2  广播模式"></a>2.3.2  广播模式</h4><p>将Consumer的consumer.setMessageModel(MessageModel.CLUSTERING)修改成 consumer.setMessageModel(MessageModel.BROADCASTING) </p><p>（1）将Consumer04的消费模式更改为BROADCASTING </p><p>（2）重启Consumer04的两个实例 </p><p>（3）通过Producer01再次发送10条消息，观察Consumer04中的console打印，可以发现，每个Consumer04实例都会消费所有的消息</p><h4 id="2-3-3-集群模式与广播模式思考"><a href="#2-3-3-集群模式与广播模式思考" class="headerlink" title="2.3.3 集群模式与广播模式思考"></a>2.3.3 集群模式与广播模式思考</h4><p>（1）负载均衡模式下，某个topic下有4个队列，consumer有5个实例</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/9.png"></p><p>（2）负载均衡模式下，某个topic下有4个队列，consumer有2个实例</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/10.png"></p><p>（3）负载均衡模式下，某个topic下有4个队列，consumer有3个实例</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/11.png"></p><p>（4）广播模式下，某个topic下有4个队列，consumer有多少个实例</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/12.png"></p><h3 id="2-4-消息类型"><a href="#2-4-消息类型" class="headerlink" title="2.4 消息类型"></a>2.4 消息类型</h3><h4 id="2-4-1-普通消息-Normal-Message"><a href="#2-4-1-普通消息-Normal-Message" class="headerlink" title="2.4.1 普通消息-Normal Message"></a>2.4.1 普通消息-Normal Message</h4><p>普通消息</p><h4 id="2-4-2-延迟消息-Delay-Message"><a href="#2-4-2-延迟消息-Delay-Message" class="headerlink" title="2.4.2 延迟消息-Delay Message"></a>2.4.2 延迟消息-Delay Message</h4><p>msg通过producer发送到broker之后，不会立即被consumer消息，而是要等待到指定的时间 之后才能被消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Consumer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledMessageConsumer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-string">&quot;schedule_consumer_group&quot;</span>);<br>consumer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>consumer.subscribe(<span class="hljs-string">&quot;schedule_topic&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; messages, ConsumeConcurrentlyContext context)</span> &#123;<br><span class="hljs-keyword">for</span> (MessageExt message : messages) &#123;<br>System.out.println(<span class="hljs-string">&quot;Receive message[msgId=&quot;</span> + message.getMsgId() + <span class="hljs-string">&quot;] &quot;</span> + (System.currentTimeMillis() - message.getStoreTimestamp()) + <span class="hljs-string">&quot;ms later&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>&#125;<br>&#125;);<br>consumer.start();<br>System.out.println(<span class="hljs-string">&quot;Consumer Started.&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//Producer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledMessageProducer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;schedule_producer_group&quot;</span>);<br>producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>producer.start();<br><span class="hljs-type">int</span> <span class="hljs-variable">totalMessagesToSend</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; totalMessagesToSend; i++) &#123;<br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;schedule_topic&quot;</span>, (<span class="hljs-string">&quot;Hello scheduled message &quot;</span> + i).getBytes());<br><span class="hljs-comment">// String messageDelayLevel = &quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;;</span><br>message.setDelayTimeLevel(<span class="hljs-number">4</span>);<br><span class="hljs-comment">// Send the message</span><br><span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> producer.send(message);<br>System.out.println(sendResult);<br>&#125;<br>Thread.sleep(<span class="hljs-number">5000</span>);<br>producer.shutdown();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>延迟等级对应时间：<a href="https://rocketmq.apache.org/docs/4.x/producer/04message3/">https://rocketmq.apache.org/docs/4.x/producer/04message3/</a></p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/13.png"></p><h4 id="2-4-3-批量消息-Batch-Message"><a href="#2-4-3-批量消息-Batch-Message" class="headerlink" title="2.4.3 批量消息-Batch Message"></a>2.4.3 批量消息-Batch Message</h4><p><a href="https://rocketmq.apache.org/docs/4.x/producer/05message4">https://rocketmq.apache.org/docs/4.x/producer/05message4</a></p><p>Producer发送单个消息的最大限制是4M，可以通过maxMessageSize进行设置，同时broker对于单个消息的最大限制也是4M，在MessageStoreConfig中的maxMessageSize属性可以看到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Consumer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BatchConsumer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-string">&quot;batch_consumer_group&quot;</span>);<br>consumer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>consumer.subscribe(<span class="hljs-string">&quot;batch_topic&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>);<br>consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;<br>System.out.println(msgs);<br><span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>&#125;<br>&#125;);<br>consumer.start();<br>System.out.println(<span class="hljs-string">&quot;Consumer Started.&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//Producer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BatchProducer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;batch_producer_group&quot;</span>);<br>producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>producer.start();<br>List&lt;Message&gt; messages = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>messages.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;batch_topic&quot;</span>, <span class="hljs-string">&quot;TagA&quot;</span>, <span class="hljs-string">&quot;OrderID001&quot;</span>, <span class="hljs-string">&quot;Hello world 0&quot;</span>.getBytes()));<br>messages.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;batch_topic&quot;</span>, <span class="hljs-string">&quot;TagA&quot;</span>, <span class="hljs-string">&quot;OrderID002&quot;</span>, <span class="hljs-string">&quot;Hello world 1&quot;</span>.getBytes()));<br>messages.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;batch_topic&quot;</span>, <span class="hljs-string">&quot;TagA&quot;</span>, <span class="hljs-string">&quot;OrderID003&quot;</span>, <span class="hljs-string">&quot;Hello world 2&quot;</span>.getBytes()));<br><span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> producer.send(messages);<br>System.out.println(sendResult);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-4-过滤消息-Filter-Message"><a href="#2-4-4-过滤消息-Filter-Message" class="headerlink" title="2.4.4 过滤消息-Filter Message"></a>2.4.4 过滤消息-Filter Message</h4><p><a href="https://rocketmq.apache.org/docs/featureBehavior/07messagefilter">https://rocketmq.apache.org/docs/featureBehavior/07messagefilter</a></p><p>可以根据TAG和SQL语句进行过滤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Consumer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterConsumer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-string">&quot;filter_consumer_group&quot;</span>);<br>consumer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>consumer.subscribe(<span class="hljs-string">&quot;filter_topic&quot;</span>,<span class="hljs-string">&quot;TagB&quot;</span>);<br>consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;<br><span class="hljs-keyword">for</span> (MessageExt msg : msgs) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(msg.getBody());<br>System.out.println(msg);<br>System.out.println(body+<span class="hljs-string">&quot; &quot;</span>+msg.getTags());<br>&#125;<br><span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>&#125;<br>&#125;);<br>consumer.start();<br>System.out.println(<span class="hljs-string">&quot;Consumer Started.&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//Producer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterProducer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;filter_producer_group&quot;</span>);<br>producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>producer.start();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">tag</span> <span class="hljs-operator">=</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;TagA&quot;</span> : <span class="hljs-string">&quot;TagB&quot;</span>;<br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;filter_topic&quot;</span>, tag, (<span class="hljs-string">&quot;Hello Filter Message &quot;</span> + i).getBytes());<br><span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> producer.send(message);<br>System.out.println(sendResult);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-5-顺序消息-Ordered-Message"><a href="#2-4-5-顺序消息-Ordered-Message" class="headerlink" title="2.4.5 顺序消息-Ordered Message"></a>2.4.5 顺序消息-Ordered Message</h4><p><a href="https://rocketmq.apache.org/docs/featureBehavior/03fifomessage">https://rocketmq.apache.org/docs/featureBehavior/03fifomessage</a></p><p>（1）什么是顺序消息 </p><p>消息生产的顺序要与消息消费的顺序一致。 </p><p>（2）目前消息的生产和消费是怎样的 </p><p>目前的情况下，producer会使用Round Robin的方式把消息发送到不同的queue中，consumer消费消息的时候是通过多线程从各个queue上获取消息的，显然不能保证有序性。 </p><p>（3）全局有序 </p><p>全局有序：在某个topic下，所有的消息都要保证消费有序 </p><p>此时topic中的queue只能有一个，这样producer往一个queue上发送消息，并且consumer只能有一 个，并且采用单线程的方式消息。 但在高并发的场景下，性能比较低，所以一般情况下用得比较少。 </p><p>（4）局部有序 </p><p>局部有序：某个topic下有多个queue，但是每个queue中的消息被消费时都是有序的 </p><p>此时需要保证只有一个producer，并且选择指定的队列进行发送消息，同时consumer中使用单线程进行消费 这时候在高并发的场景下，性能比较高，所以这种局部有序用得比较多。</p><p>（5）局部有序的应用场景 </p><p>比如在下单场景中，用户下了一个订单，订单的orderid为order001，接下来会向指定的queue发送消息，并且是按照顺序发送的，比如：订单支付消息、订单发货消息、订单物流消息等，然后consumer消费的时候，需要按照这种顺序进行消息，所以需要保证单线程。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//局部有序demo</span><br><span class="hljs-comment">//Consumer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderlyConsumer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-string">&quot;orderly_consumer_group&quot;</span>);<br>consumer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>consumer.subscribe(<span class="hljs-string">&quot;orderly_topic&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>);<br>consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerOrderly</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ConsumeOrderlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span>&#123;<br><span class="hljs-keyword">for</span> (MessageExt msg : msgs) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 业务逻辑的处理</span><br>Thread.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">5</span>));<br>System.out.println(Thread.currentThread().getName()+ <span class="hljs-string">&quot; &quot;</span>+<span class="hljs-string">&quot;queueId:&quot;</span>+msg.getQueueId()+ <span class="hljs-string">&quot; body: &quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(msg.getBody()));<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br><span class="hljs-keyword">return</span> ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ConsumeOrderlyStatus.SUCCESS;<br>&#125;<br>&#125;);<br>consumer.start();<br>System.out.println(<span class="hljs-string">&quot;Consumer Started.&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//Producer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderlyProducer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;orderly_producer_group&quot;</span>);<br>producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>producer.start();<br>String[] flows = &#123;<span class="hljs-string">&quot;订单支付&quot;</span>, <span class="hljs-string">&quot;订单发货&quot;</span>, <span class="hljs-string">&quot;订单物流&quot;</span>,<span class="hljs-string">&quot;订单完成&quot;</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">flow</span> <span class="hljs-operator">=</span> flows[i % <span class="hljs-number">4</span>];<br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;orderly_topic&quot;</span>, <span class="hljs-string">&quot;TagA&quot;</span>, flow.getBytes());<br><span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> producer.send(message, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueueSelector</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> MessageQueue <span class="hljs-title function_">select</span><span class="hljs-params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> &#123;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">queueId</span> <span class="hljs-operator">=</span> (Integer) arg;<br>System.out.println(<span class="hljs-string">&quot;queueId: &quot;</span> + queueId);<br><span class="hljs-comment">// 也就是选择了某一个queue</span><br><span class="hljs-keyword">return</span> mqs.get(queueId);<br>&#125;<br>&#125;, <span class="hljs-number">1</span>); <span class="hljs-comment">// 选择queueId为1的queue</span><br>System.out.println(sendResult);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-6-事务消息-Transactional-Message"><a href="#2-4-6-事务消息-Transactional-Message" class="headerlink" title="2.4.6 事务消息-Transactional Message"></a>2.4.6 事务消息-Transactional Message</h4><p><a href="https://rocketmq.apache.org/docs/featureBehavior/04transactionmessage">https://rocketmq.apache.org/docs/featureBehavior/04transactionmessage</a></p><p>RocketMQ提供类似XA或Open XA的分布式事务功能，通过消息队列RocketMQ事务消息，能达到分布式事务的最终一致。 </p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Transaction Consumer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionConsumer</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQConsumer</span>(<span class="hljs-string">&quot;transaction_consumer_group&quot;</span>);<br>        consumer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>        consumer.subscribe(<span class="hljs-string">&quot;transaction_topic&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>        consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, COnsumeConcurrentlyContext context)</span> &#123;<br>                <span class="hljs-keyword">for</span>(MessageExt msg : msgs)&#123;<br>                    System.out.println(msg.getTags()+<span class="hljs-string">&quot; : &quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(msg.getBody()));<br>                &#125;<br>                <span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>            &#125;<br>        &#125;);<br>        consumer.start();<br>        System.out.println(<span class="hljs-string">&quot;Consumer started..&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Transaction Producer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionProducer</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">TransactionMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionMQProducer</span>(<span class="hljs-string">&quot;trans_producer_group&quot;</span>);<br>        <span class="hljs-comment">//执行本地事务需要用到的监听器</span><br>        <span class="hljs-type">TransactionListener</span> <span class="hljs-variable">transactionListener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionListenerImpl</span>();<br>        <span class="hljs-comment">//用于回查本地事务状态的线程池</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">100</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">2000</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>                thread.setName(<span class="hljs-string">&quot;client-transaction-msg-check-thread&quot;</span>);<br>                <span class="hljs-keyword">return</span> thread;<br>            &#125;<br>        &#125;);<br>       producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>        producer.setExecutorService(executorService);<br>        producer.setTransactionListener(transactionListener);<br>        producer.start();<br>        String[] tags = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;TagA&quot;</span>, <span class="hljs-string">&quot;TagB&quot;</span>, <span class="hljs-string">&quot;TagC&quot;</span>, <span class="hljs-string">&quot;TagD&quot;</span>, <span class="hljs-string">&quot;TagE&quot;</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;transaction_topic&quot;</span>, tags[i % tags.length], <span class="hljs-string">&quot;KEY&quot;</span>+i, (<span class="hljs-string">&quot;Hello RocketMQ&quot;</span>+i).getBytes(RemotingHelper.DEFAULT_CHARSET));<br>               <span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> producer.sendMessageInTransaction(msg, <span class="hljs-literal">null</span>);<br>                System.out.pringln(<span class="hljs-string">&quot;%s%n&quot;</span>, sendResult);<br>                Thread.sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//用于执行本地事务</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionListenerImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransactionListener</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> LocalTransactionState <span class="hljs-title function_">executeLocalTransaction</span><span class="hljs-params">(Message msg, Object arg)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;本地事务执行。。。&quot;</span>);<br>        <br>        <span class="hljs-keyword">if</span>(msg.getTags().equals(<span class="hljs-string">&quot;TagA&quot;</span>))&#123;<br>            <span class="hljs-comment">//如果msg的tag值为TagA，则提交一个COMMIT_MESSAGE状态</span><br>            <span class="hljs-keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(msg.getTags().equals(<span class="hljs-string">&quot;TagB&quot;</span>)) &#123;<br>            <span class="hljs-comment">//如果msg的tag值为TagB，则提交一个ROLLBACK_MESSAGE状态</span><br>            <span class="hljs-keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果msg的tag为其他，则提交一个LocalTransactionState.UNKNOW，表示需要rocketmq主动向本地事务进行回查</span><br>            <span class="hljs-keyword">return</span> LocalTransactionState.UNKNOW;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> LocalTransactionState <span class="hljs-title function_">checkLocalTransaction</span><span class="hljs-params">(MessageExt msg)</span> &#123;<br>        <span class="hljs-comment">//检查本地事务</span><br>        <span class="hljs-keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-RocketMQ刷盘机制"><a href="#3-RocketMQ刷盘机制" class="headerlink" title="3 RocketMQ刷盘机制"></a>3 RocketMQ刷盘机制</h2><p>所谓的刷盘机制就是将broker application内存中的数据，持久化到commitlog文件中。 可以采用同步刷盘或者异步刷盘的方式。 </p><p>broker.conf文件中的配置项为：flushDiskType =SYNC_FLUSH / ASYNC_FLUSH</p><h3 id="3-1-同步刷盘"><a href="#3-1-同步刷盘" class="headerlink" title="3.1 同步刷盘"></a>3.1 同步刷盘</h3><p>所谓的同步刷盘如图所示，也就是说当producer发送消息给broker时，消息只要持久化到磁盘中才算成功。</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/14.png"></p><h3 id="3-2-异步刷盘"><a href="#3-2-异步刷盘" class="headerlink" title="3.2 异步刷盘"></a>3.2 异步刷盘</h3><p>所谓的异步刷盘，就是producer将消息发送给broker之后，broker虽然也会进行刷盘操作，但是对于producer而言不关心，直接返回success。</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/15.png"></p><h2 id="4-RocketMQ零拷贝"><a href="#4-RocketMQ零拷贝" class="headerlink" title="4 RocketMQ零拷贝"></a>4 RocketMQ零拷贝</h2><p>RocketMQ中使用的是mmap的方式，当然也有其他实现方式，比如sendfile。mmap适合小数据量读写，sendFile 适合大文件传输。</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/RoekctMQ%E9%9B%B6%E6%8B%B7%E8%B4%9D.jpg"></p><h2 id="5-SpringBoot集成"><a href="#5-SpringBoot集成" class="headerlink" title="5 SpringBoot集成"></a>5 SpringBoot集成</h2><p><a href="https://docs.spring.io/spring-boot/docs/2.7.6/reference/html/messaging.html#messaging">https://docs.spring.io/spring-boot/docs/2.7.6/reference/html/messaging.html#messaging</a></p><p>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.rocketmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">rocketmq:</span><br>  <span class="hljs-attr">name-server:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:9876</span><br>  <span class="hljs-attr">producer:</span><br>    <span class="hljs-attr">group:</span> <span class="hljs-string">spring-boot-producer-group</span><br>  <span class="hljs-attr">consumer:</span><br>    <span class="hljs-attr">group:</span> <span class="hljs-string">spring-boot-consumer-group</span><br></code></pre></td></tr></table></figure><p>（3）生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/rocketmq&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RocketMQController</span> &#123;<br>    <br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RocketMQTemplate rocketMQTemplate;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/produce&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">produce</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.rocketMQTemplate.convertAndSend(<span class="hljs-string">&quot;springboot-topic&quot;</span>, <span class="hljs-string">&quot;Hello Spring Boot Rocketmq&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;produce success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@RocketMQMessageListener(consumerGroup = &quot;$&#123;rocketmq.consumer.group&#125;&quot;,topic = &quot;springboot-topic&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootConsumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RocketMQListener</span>&lt;String&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String msg)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Spring Boot 获取到消息内容: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-Spring-Cloud集成-Spring-Cloud-Stream"><a href="#6-Spring-Cloud集成-Spring-Cloud-Stream" class="headerlink" title="6 Spring Cloud集成(Spring Cloud Stream)"></a>6 Spring Cloud集成(Spring Cloud Stream)</h2><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/RocketMQ-en">https://github.com/alibaba/spring-cloud-alibaba/wiki/RocketMQ-en</a></p><p><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/2.2.x/spring-cloud-alibaba-examples/rocketmq-example/readme-zh.md">https://github.com/alibaba/spring-cloud-alibaba/blob/2.2.x/spring-cloud-alibaba-examples/rocketmq-example/readme-zh.md</a></p><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rocketmq<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6-1-SC-Stream3-X之前的用法"><a href="#6-1-SC-Stream3-X之前的用法" class="headerlink" title="6.1 SC Stream3.X之前的用法"></a>6.1 SC Stream3.X之前的用法</h3><h4 id="6-1-1-默认用法"><a href="#6-1-1-默认用法" class="headerlink" title="6.1.1 默认用法"></a>6.1.1 默认用法</h4><p>（1）写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9999</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">stream:</span><br>      <span class="hljs-attr">rocketmq:</span><br>        <span class="hljs-attr">binder:</span><br>          <span class="hljs-comment"># 指定rocketmq nameserver的地址</span><br>          <span class="hljs-attr">name-server:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:9876</span><br>          <span class="hljs-comment"># 如果没有group，则启动会报错</span><br>          <span class="hljs-attr">group:</span> <span class="hljs-string">stream-group</span><br>        <span class="hljs-attr">bindings:</span><br>          <span class="hljs-comment"># 定义name为output的binding，用于发送消息给rocketmq</span><br>          <span class="hljs-attr">output:</span><br>            <span class="hljs-comment"># 发送给rocketmq上的哪个topic</span><br>            <span class="hljs-attr">destination:</span> <span class="hljs-string">springcloud-stream-topic</span><br>          <span class="hljs-comment"># 定义name为input的binding，用于从rocketmq上获取消息</span><br>          <span class="hljs-attr">input:</span><br>            <span class="hljs-comment"># 从rocketmq上的哪个topic获取消息</span><br>            <span class="hljs-attr">destination:</span> <span class="hljs-string">springcloud-stream-topic</span><br></code></pre></td></tr></table></figure><p>（2）添加注解，在入口类添加@Enable驱动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringApplication</span><br><span class="hljs-comment">//向spring ioc容器中注入这两个接口实现类，用于代码中进行依赖注入。这个地方会显示过期，跟SpringCloud Stream版本有关</span><br><span class="hljs-meta">@EnableBinding(&#123;Source.class, Sink.class&#125;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringCloudStreamDemoApplication</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(SpringCloudStreamDemoApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/producer&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerController</span>&#123;<br>    <br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> Source source;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/stream-produce&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">streamProduce</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.source.output().send(MessageBuilder.withPayload(<span class="hljs-string">&quot;stream msg...&quot;</span>).build());<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;stream produce successfully.&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamConsumer</span>&#123;<br>    <span class="hljs-meta">@StreamListener(Sink.INPUT)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveMsg</span><span class="hljs-params">(String msg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;receive msg: &quot;</span> + msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-1-2-自定义用法"><a href="#6-1-2-自定义用法" class="headerlink" title="6.1.2 自定义用法"></a>6.1.2 自定义用法</h4><p>（1）模仿官方的Source接口，自定义TextSource接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//官方</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Source</span> &#123;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">OUTPUT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;output&quot;</span>;<br><br><span class="hljs-meta">@Output(Source.OUTPUT)</span><br>MessageChannel <span class="hljs-title function_">output</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//自定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestSource</span> &#123;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">OUTPUT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test-output&quot;</span>;<br><br><span class="hljs-meta">@Output(TestSource.OUTPUT)</span><br>MessageChannel <span class="hljs-title function_">output</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）模仿官方的Sink接口，自定义TestSource接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//官方</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Sink</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">INPUT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;input&quot;</span>;<br><br><span class="hljs-meta">@Input(Sink.INPUT)</span><br>SubscribableChannel <span class="hljs-title function_">input</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//自定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestSink</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">INPUT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test-input&quot;</span>;<br>    <br><span class="hljs-meta">@Input(TestSink.INPUT)</span><br>SubscribableChannel <span class="hljs-title function_">input</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9999</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">stream:</span><br>      <span class="hljs-attr">rocketmq:</span><br>        <span class="hljs-attr">binder:</span><br>          <span class="hljs-comment"># 指定rocketmq nameserver的地址</span><br>          <span class="hljs-attr">name-server:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:9876</span><br>          <span class="hljs-comment"># 如果没有group，则启动会报错</span><br>          <span class="hljs-attr">group:</span> <span class="hljs-string">stream-group</span><br>        <span class="hljs-attr">bindings:</span><br>          <span class="hljs-comment"># 定义name为output的binding，用于发送消息给rocketmq</span><br>          <span class="hljs-attr">output:</span><br>            <span class="hljs-comment"># 发送给rocketmq上的哪个topic</span><br>            <span class="hljs-attr">destination:</span> <span class="hljs-string">springcloud-stream-topic</span><br>          <span class="hljs-comment"># 定义name为input的binding，用于从rocketmq上获取消息</span><br>          <span class="hljs-attr">input:</span><br>            <span class="hljs-comment"># 从rocketmq上的哪个topic获取消息</span><br>            <span class="hljs-attr">destination:</span> <span class="hljs-string">springcloud-stream-topic</span><br>          <br>          <span class="hljs-comment"># 自定义output和input</span><br>          <span class="hljs-comment"># 定义name为test-output的binding，用于发送消息给rocketmq</span><br>          <span class="hljs-attr">test-output:</span><br>            <span class="hljs-comment"># 发送给rocketmq上的哪个topic</span><br>            <span class="hljs-attr">destination:</span> <span class="hljs-string">springcloud-stream-topic</span><br>          <span class="hljs-comment"># 定义name为test-input的binding，用于从rocketmq上获取消息</span><br>          <span class="hljs-attr">test-input:</span><br>            <span class="hljs-comment"># 从rocketmq上的哪个topic获取消息</span><br>            <span class="hljs-attr">destination:</span> <span class="hljs-string">springcloud-stream-topic</span><br></code></pre></td></tr></table></figure><p>（4）写注解：在入口类上添加TestSource和TestSink</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableBinding(&#123;Source.class, Sink.class,TestSource.class,TestSink.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringCloudStreamDemoApplication</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(SpringCloudStreamDemoApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//生产者</span><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> TestSource testSource;<br><span class="hljs-meta">@RequestMapping(&quot;/test-stream-produce&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testStreamProduce</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">this</span>.testSource.output().send(MessageBuilder.withPayload(<span class="hljs-string">&quot;test stream msg...&quot;</span>).build());<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;test stream produce successfully.&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//消费者</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStreamConsumer</span> &#123;<br><span class="hljs-meta">@StreamListener(TestSink.INPUT)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveMsg</span><span class="hljs-params">(String msg)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;test receive msg: &quot;</span> + msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-SC-Stream-3-X之后的用法"><a href="#6-2-SC-Stream-3-X之后的用法" class="headerlink" title="6.2 SC Stream 3.X之后的用法"></a>6.2 SC Stream 3.X之后的用法</h3><p><a href="https://docs.spring.io/spring-cloud-stream/docs/current/reference/html/spring-cloud-stream.html#_producing_and_consuming_messages">https://docs.spring.io/spring-cloud-stream/docs/current/reference/html/spring-cloud-stream.html#_producing_and_consuming_messages</a></p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
      <category>RocketMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ安装与配置</title>
    <link href="/2023/03/29/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/03/29/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E#%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB">https://github.com/alibaba/spring-cloud-alibaba/wiki/版本说明#组件版本关系</a></p><h2 id="1-单机"><a href="#1-单机" class="headerlink" title="1 单机"></a>1 单机</h2><p>nameserver默认端口：9876</p><p>rocketmq默认端口：10911</p><p>路径：/usr/local/soft</p><h3 id="1-1-基于Binary搭建"><a href="#1-1-基于Binary搭建" class="headerlink" title="1.1 基于Binary搭建"></a>1.1 基于Binary搭建</h3><h4 id="1-1-1-下载"><a href="#1-1-1-下载" class="headerlink" title="1.1.1 下载"></a>1.1.1 下载</h4><p>官网：<a href="http://rocketmq.apache.org/">http://rocketmq.apache.org/</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft<br>wget https://archive.apache.org/dist/rocketmq/4.9.4/rocketmq-all-4.9.4-bin-release.zip<br></code></pre></td></tr></table></figure><h4 id="1-1-2-解压"><a href="#1-1-2-解压" class="headerlink" title="1.1.2 解压"></a>1.1.2 解压</h4><p>解压二进制包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">unzip rocketmq-all-4.9.4-bin-release.zip<br><span class="hljs-built_in">mv</span> rocketmq-all-4.9.4-bin-release rocketmq<br></code></pre></td></tr></table></figure><p>创建数据存储目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> -p /usr/local/soft/rocketmq/store/broker-a /usr/local/soft/rocketmq/store/broker-a/consumequeue /usr/local/soft/rocketmq/store/broker-a/commitlog /usr/local/soft/rocketmq/store/broker-a/index <br>/usr/local/soft/rocketmq/broker-a/logs<br></code></pre></td></tr></table></figure><h4 id="1-1-3-修改配置文件"><a href="#1-1-3-修改配置文件" class="headerlink" title="1.1.3 修改配置文件"></a>1.1.3 修改配置文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft/rocketmq/conf<br>vim broker.conf<br></code></pre></td></tr></table></figure><p>增加内容</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#Broker 对外服务的监听端口</span><br>listenPort=<span class="hljs-number">10911</span><br><span class="hljs-comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br>autoCreateTopicEnable=true<br><span class="hljs-comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br>autoCreateSubscriptionGroup=true<br><span class="hljs-comment">#nameServer地址，分号分割</span><br>namesrvAddr=localhost:<span class="hljs-number">9876</span><br><span class="hljs-comment">#存储路径</span><br>storePathRootDir=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/soft/</span>rocketmq<span class="hljs-regexp">/store/</span>broker-a<br><span class="hljs-comment">#commitLog 存储路径</span><br>storePathCommitLog=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/soft/</span>rocketmq<span class="hljs-regexp">/store/</span>broker-a/commitlog<br><span class="hljs-comment">#消费队列存储路径存储路径</span><br>storePathConsumeQueue=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/soft/</span>rocketmq<span class="hljs-regexp">/store/</span>broker-a/consumequeue<br><span class="hljs-comment">#消息索引存储路径</span><br>storePathIndex=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/soft/</span>rocketmq<span class="hljs-regexp">/store/</span>broker-a/index<br><span class="hljs-comment">#checkpoint 文件存储路径</span><br>storeCheckpoint=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/soft/</span>rocketmq<span class="hljs-regexp">/store/</span>broker-a/checkpoint<br><span class="hljs-comment">#abort 文件存储路径</span><br>abortFile=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/soft/</span>rocketmq<span class="hljs-regexp">/store/</span>broker-a/abort<br></code></pre></td></tr></table></figure><p>在虚拟机中有可能因为内存不够而启动失败，修改bin目录下的runbroker.sh 和 runserver.sh 文件，比如把8g 4g 改成512m， 4g 2g改成256m</p><h4 id="1-1-4-启动"><a href="#1-1-4-启动" class="headerlink" title="1.1.4 启动"></a>1.1.4 启动</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">nohup</span> sh mqnamesrv &amp;<br><span class="hljs-built_in">nohup</span> sh mqbroker -c /usr/local/soft/rocketmq/conf/broker.conf -n localhost:9876 &amp;<br></code></pre></td></tr></table></figure><p>验证是否启动成功，同时可以观察一下10911端口是否被占用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">tail</span> -f nohup.out<br>jps -l<br><br>lsof -i:9876<br>netstat -ano | grep <span class="hljs-string">&quot;9876&quot;</span><br><br>lsof -i:10911<br>netstat -ano | grep <span class="hljs-string">&quot;10911&quot;</span><br></code></pre></td></tr></table></figure><h4 id="1-1-5-避坑"><a href="#1-1-5-避坑" class="headerlink" title="1.1.5 避坑"></a>1.1.5 避坑</h4><ol><li>网卡问题踩坑解决方案 </li></ol><p>如果centos上有多个网卡，此时broker使用的ip地址可能不是自己想要的，可以给broker设置对应的ip地址，在conf/broker.conf中进行设置，最后一行加上 brokerIP1=192.168.1.8，然后停止broker后再启动： nohup sh bin/mqbroker -c conf/broker.conf -n localhost:9876 &amp;</p><h4 id="1-1-6-关闭服务"><a href="#1-1-6-关闭服务" class="headerlink" title="1.1.6 关闭服务"></a>1.1.6 关闭服务</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft/rocketmq/bin<br><br>sh mqshutdown namesrv<br>sh mqshutdown broker<br></code></pre></td></tr></table></figure><h4 id="1-1-7-Dashboard"><a href="#1-1-7-Dashboard" class="headerlink" title="1.1.7 Dashboard"></a>1.1.7 Dashboard</h4><p>（1）下载rocketmq-dashboard源码并解压 下载链接：<a href="https://github.com/apache/rocketmq-dashboard">https://github.com/apache/rocketmq-dashboard</a> </p><p>（2）进入源码的resources目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> rocketmq-dashboard/src/main/resources/ <br></code></pre></td></tr></table></figure><p>（3）修改application.yml文件 </p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/1.png"></p><p>（4）回到rocketmq-dashboard的根目录，执行maven打包命令</p><p>（5）进入rocketmq-dashboard的target目录，找到打包好的jar包，启动该jar包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">nohup</span> java -jar rocketmq-dashboard-1.0.1-SNAPSHOT.jar &amp;<br><span class="hljs-built_in">tail</span> -f nohup.out<br>lsof -i:18080<br></code></pre></td></tr></table></figure><p>（6）通过浏览器访问</p><h3 id="1-2-基于Source搭建"><a href="#1-2-基于Source搭建" class="headerlink" title="1.2 基于Source搭建"></a>1.2 基于Source搭建</h3><h4 id="1-2-1-源码准备"><a href="#1-2-1-源码准备" class="headerlink" title="1.2.1 源码准备"></a>1.2.1 源码准备</h4><p>（1）解压源码包 </p><p>（2）来到源码根目录，打开terminal，使用mvn构建一下 </p><p>（3）将源码导入到idea中 </p><p>（4）将distribution中的conf文件夹复制到根目录下</p><h4 id="1-2-2-启动NameServer"><a href="#1-2-2-启动NameServer" class="headerlink" title="1.2.2  启动NameServer"></a>1.2.2  启动NameServer</h4><p>（1）配置启动参数</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/2.png"></p><p>（2）通过NamesrvStartup#main方法启动</p><p>（3）查看端口监听</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">netstat -ano | findstr <span class="hljs-string">&quot;9876&quot;</span><br></code></pre></td></tr></table></figure><h4 id="1-2-3-启动Broker"><a href="#1-2-3-启动Broker" class="headerlink" title="1.2.3 启动Broker"></a>1.2.3 启动Broker</h4><p>（1）修改conf文件夹下的broker.conf配置</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">brokerClusterName = DefaultCluster<br>brokerName = broker-a<br>brokerId = 0<br>namesrvAddr=localhost:9876<br>deleteWhen = 04<br>brokerRole = ASYNC_MASTER<br>flushDiskType = ASYNC_FLUSH<br>autoCreateTopicEnable=true<br>storePathRootDir=D:<span class="hljs-symbol">\\</span>share<span class="hljs-symbol">\\</span>vip<span class="hljs-symbol">\\</span>sc<span class="hljs-symbol">\\</span>rocketmq<span class="hljs-symbol">\\</span>store<br>storePathCommitLog=D:<span class="hljs-symbol">\\</span>share<span class="hljs-symbol">\\</span>vip<span class="hljs-symbol">\\</span>sc<span class="hljs-symbol">\\</span>rocketmq<span class="hljs-symbol">\\</span>store<span class="hljs-symbol">\\</span>commitlog<br>storePathConsumeQueue=D:<span class="hljs-symbol">\\</span>share<span class="hljs-symbol">\\</span>vip<span class="hljs-symbol">\\</span>sc<span class="hljs-symbol">\\</span>rocketmq<span class="hljs-symbol">\\</span>store<span class="hljs-symbol">\\</span>consumequeue<br>storePathIndex=D:<span class="hljs-symbol">\\</span>share<span class="hljs-symbol">\\</span>vip<span class="hljs-symbol">\\</span>sc<span class="hljs-symbol">\\</span>rocketmq<span class="hljs-symbol">\\</span>store<span class="hljs-symbol">\\</span>index<br>storeCheckpoint=D:<span class="hljs-symbol">\\</span>share<span class="hljs-symbol">\\</span>vip<span class="hljs-symbol">\\</span>sc<span class="hljs-symbol">\\</span>rocketmq<span class="hljs-symbol">\\</span>store<span class="hljs-symbol">\\</span>checkpoint<br></code></pre></td></tr></table></figure><p>（2）配置启动参数</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/3.png"></p><p>（3）通过BrokerStartup#main启动Broker，观察控制台打印信息</p><p>（4）查看端口监听</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">netstat -ano | findstr <span class="hljs-string">&quot;10911&quot;</span><br></code></pre></td></tr></table></figure><h4 id="1-2-4-Dashboard"><a href="#1-2-4-Dashboard" class="headerlink" title="1.2.4 Dashboard"></a>1.2.4 Dashboard</h4><p>（1）下载rocketmq-dashboard源码并解压 下载链接：<a href="https://github.com/apache/rocketmq-dashboard">https://github.com/apache/rocketmq-dashboard</a> </p><p>（2）进入源码的resources目录 cd rocketmq-dashboard/src/main/resources/ </p><p>（3）修改application.yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">18080</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">encoding:</span><br>      <span class="hljs-attr">charset:</span> <span class="hljs-string">UTF-8</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">force:</span> <span class="hljs-literal">true</span><br>      <br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">rocketmq-dashboard</span><br>    <br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">config:</span> <span class="hljs-string">classpath:logback.xml</span><br><span class="hljs-attr">rocketmq:</span><br>  <span class="hljs-attr">config:</span><br>    <span class="hljs-comment">#nameserver地址</span><br>    <span class="hljs-attr">namesrvAddrs:</span><br>      <span class="hljs-number">-127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:9876</span><br></code></pre></td></tr></table></figure><p>（4）打开App类，启动 </p><p>（5）查看端口监听</p><p>（6）通过浏览器访问rocketmq-dashboard</p><h2 id="2-集群"><a href="#2-集群" class="headerlink" title="2 集群"></a>2 集群</h2><p>二主二从异步集群部署</p><h3 id="2-1-节点规划"><a href="#2-1-节点规划" class="headerlink" title="2.1 节点规划"></a>2.1 节点规划</h3><p>第一台机器 192.168.44.163，端口规划：<br>9876 NameServer1<br>10910 BrokerA-master<br>10921 BrokerB-slave</p><p>第二台机器 192.168.44.164，端口规划：<br>9876 NameServer2<br>10920 BrokerB-master<br>10911 BrokerA-slave</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/4.png"></p><h3 id="2-2-下载解压"><a href="#2-2-下载解压" class="headerlink" title="2.2 下载解压"></a>2.2 下载解压</h3><p>从官网首页最新发布版本进入下载地址 <a href="http://rocketmq.apache.org/">http://rocketmq.apache.org/</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">unzip rocketmq-all-4.7.1-bin-release.zip<br><span class="hljs-built_in">mv</span> rocketmq-all-4.7.1-bin-release rocketmq<br></code></pre></td></tr></table></figure><p>在两台机器上都下载、解压好。</p><p>在rocketmq/conf目录下，有三种建议配置模式：</p><ol><li><p>2m-2s-async(2主2从异步) —— 本文采用这种</p></li><li><p>2m-2s-sync (2主2从同步)</p></li><li><p>2m-noslave (2主)</p></li></ol><p>现在需要修改两台机器上2m-2s-async这个目录中的文件。配置文件修改之前先备份。</p><h3 id="2-3-配置第一台机器"><a href="#2-3-配置第一台机器" class="headerlink" title="2.3 配置第一台机器"></a>2.3 配置第一台机器</h3><p>192.168.44.163的两个配置文件</p><p>（1）broker-a.properties</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft/rocketmq/conf/2m-2s-async<br>vim broker-a.properties<br></code></pre></td></tr></table></figure><p>修改的内容（名字自定义，保持一致，否则不能组成集群）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">brokerClusterName</span>=<span class="hljs-string">test-cluster</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#增加的内容</span><br><span class="hljs-comment">#Broker 对外服务的监听端口</span><br><span class="hljs-attr">listenPort</span>=<span class="hljs-string">10910</span><br><span class="hljs-comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="hljs-attr">autoCreateTopicEnable</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="hljs-attr">autoCreateSubscriptionGroup</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#nameServer地址，分号分割</span><br><span class="hljs-attr">namesrvAddr</span>=<span class="hljs-string">192.168.44.163:9876;192.168.44.164:9876</span><br><span class="hljs-comment">#存储路径</span><br><span class="hljs-attr">storePathRootDir</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-a</span><br><span class="hljs-comment">#commitLog 存储路径</span><br><span class="hljs-attr">storePathCommitLog</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-a/commitlog</span><br><span class="hljs-comment">#消费队列存储路径存储路径</span><br><span class="hljs-attr">storePathConsumeQueue</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-a/consumequeue</span><br><span class="hljs-comment">#消息索引存储路径</span><br><span class="hljs-attr">storePathIndex</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-a/index</span><br><span class="hljs-comment">#checkpoint 文件存储路径</span><br><span class="hljs-attr">storeCheckpoint</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/checkpoint</span><br><span class="hljs-comment">#abort 文件存储路径</span><br><span class="hljs-attr">abortFile</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/abort</span><br></code></pre></td></tr></table></figure><p>（2）broker-b-s.properties</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim  broker-b-s.properties<br></code></pre></td></tr></table></figure><p>修改的内容（名字自定义，保持一致，否则不能组成集群）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">brokerClusterName</span>=<span class="hljs-string">test-cluster</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#增加的内容</span><br><span class="hljs-comment">#Broker 对外服务的监听端口</span><br><span class="hljs-attr">listenPort</span>=<span class="hljs-string">10921</span><br><span class="hljs-comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="hljs-attr">autoCreateTopicEnable</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="hljs-attr">autoCreateSubscriptionGroup</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#nameServer地址，分号分割</span><br><span class="hljs-attr">namesrvAddr</span>=<span class="hljs-string">192.168.44.163:9876;192.168.44.164:9876</span><br><span class="hljs-comment">#存储路径</span><br><span class="hljs-attr">storePathRootDir</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-b-s</span><br><span class="hljs-comment">#commitLog 存储路径</span><br><span class="hljs-attr">storePathCommitLog</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-b-s/commitlog</span><br><span class="hljs-comment">#消费队列存储路径存储路径</span><br><span class="hljs-attr">storePathConsumeQueue</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-b-s/consumequeue</span><br><span class="hljs-comment">#消息索引存储路径</span><br><span class="hljs-attr">storePathIndex</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-b-s/index</span><br><span class="hljs-comment">#checkpoint 文件存储路径</span><br><span class="hljs-attr">storeCheckpoint</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/checkpoint</span><br><span class="hljs-comment">#abort 文件存储路径</span><br><span class="hljs-attr">abortFile</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/abort</span><br></code></pre></td></tr></table></figure><h3 id="2-4-配置第二台机器"><a href="#2-4-配置第二台机器" class="headerlink" title="2.4 配置第二台机器"></a>2.4 配置第二台机器</h3><p>192.168.44.164的两个配置文件，修改的内容基本一致，主要是注意一下端口号、路径名。</p><p>（1）broker-b.properties</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft/rocketmq/conf/2m-2s-async<br>vim  broker-b.properties<br></code></pre></td></tr></table></figure><p>修改的内容（名字自定义，保持一致，否则不能组成集群）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">brokerClusterName</span>=<span class="hljs-string">test-cluster</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#增加的内容</span><br><span class="hljs-comment">#Broker 对外服务的监听端口</span><br><span class="hljs-attr">listenPort</span>=<span class="hljs-string">10920</span><br><span class="hljs-comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="hljs-attr">autoCreateTopicEnable</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="hljs-attr">autoCreateSubscriptionGroup</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#nameServer地址，分号分割</span><br><span class="hljs-attr">namesrvAddr</span>=<span class="hljs-string">192.168.44.163:9876;192.168.44.164:9876</span><br><span class="hljs-comment">#存储路径</span><br><span class="hljs-attr">storePathRootDir</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-b</span><br><span class="hljs-comment">#commitLog 存储路径</span><br><span class="hljs-attr">storePathCommitLog</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-b/commitlog</span><br><span class="hljs-comment">#消费队列存储路径存储路径</span><br><span class="hljs-attr">storePathConsumeQueue</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-b/consumequeue</span><br><span class="hljs-comment">#消息索引存储路径</span><br><span class="hljs-attr">storePathIndex</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-b/index</span><br><span class="hljs-comment">#checkpoint 文件存储路径</span><br><span class="hljs-attr">storeCheckpoint</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/checkpoint</span><br><span class="hljs-comment">#abort 文件存储路径</span><br><span class="hljs-attr">abortFile</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/abort</span><br></code></pre></td></tr></table></figure><p>（2）broker-a-s.properties</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft/rocketmq/conf/2m-2s-async<br>vim  broker-a-s.properties<br></code></pre></td></tr></table></figure><p>修改的内容（名字自定义，保持一致，否则不能组成集群）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">brokerClusterName</span>=<span class="hljs-string">test-cluster</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#Broker 对外服务的监听端口</span><br><span class="hljs-attr">listenPort</span>=<span class="hljs-string">10911</span><br><span class="hljs-comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="hljs-attr">autoCreateTopicEnable</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="hljs-attr">autoCreateSubscriptionGroup</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#nameServer地址，分号分割</span><br><span class="hljs-attr">namesrvAddr</span>=<span class="hljs-string">192.168.44.163:9876;192.168.44.164:9876</span><br><span class="hljs-comment">#存储路径</span><br><span class="hljs-attr">storePathRootDir</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-a-s</span><br><span class="hljs-comment">#commitLog 存储路径</span><br><span class="hljs-attr">storePathCommitLog</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-a-s/commitlog</span><br><span class="hljs-comment">#消费队列存储路径存储路径</span><br><span class="hljs-attr">storePathConsumeQueue</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-a-s/consumequeue</span><br><span class="hljs-comment">#消息索引存储路径</span><br><span class="hljs-attr">storePathIndex</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-a-s/index</span><br><span class="hljs-comment">#checkpoint 文件存储路径</span><br><span class="hljs-attr">storeCheckpoint</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/checkpoint</span><br><span class="hljs-comment">#abort 文件存储路径</span><br><span class="hljs-attr">abortFile</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/abort</span><br></code></pre></td></tr></table></figure><h3 id="2-5-创建数据目录"><a href="#2-5-创建数据目录" class="headerlink" title="2.5 创建数据目录"></a>2.5 创建数据目录</h3><p>第一台机器163执行（只需要执行一次）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> -p /usr/local/soft/rocketmq/store/broker-a /usr/local/soft/rocketmq/store/broker-a/consumequeue /usr/local/soft/rocketmq/store/broker-a/commitlog /usr/local/soft/rocketmq/store/broker-a/index /usr/local/soft/rocketmq/logs /usr/local/soft/rocketmq/store/broker-b-s /usr/local/soft/rocketmq/store/broker-b-s/consumequeue /usr/local/soft/rocketmq/store/broker-b-s/commitlog /usr/local/soft/rocketmq/store/broker-b-s/index<br></code></pre></td></tr></table></figure><p>第二台机器164执行（只需要执行一次）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> -p /usr/local/soft/rocketmq/store/broker-a-s /usr/local/soft/rocketmq/store/broker-a-s/consumequeue /usr/local/soft/rocketmq/store/broker-a-s/commitlog /usr/local/soft/rocketmq/store/broker-a-s/index /usr/local/soft/rocketmq/logs /usr/local/soft/rocketmq/store/broker-b /usr/local/soft/rocketmq/store/broker-b/consumequeue /usr/local/soft/rocketmq/store/broker-b/commitlog /usr/local/soft/rocketmq/store/broker-b/index<br></code></pre></td></tr></table></figure><h3 id="2-6-启动两个NameServer"><a href="#2-6-启动两个NameServer" class="headerlink" title="2.6 启动两个NameServer"></a>2.6 启动两个NameServer</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#启动第一台机器163的NameServer</span><br><span class="hljs-built_in">nohup</span> sh /usr/local/soft/rocketmq/bin/mqnamesrv &gt;/usr/local/soft/rocketmq/logs/mqnamesrv.log 2&gt;&amp;1 &amp;<br><br><span class="hljs-comment">#启动第二台机器164的NameServer</span><br><span class="hljs-built_in">nohup</span> sh /usr/local/soft/rocketmq/bin/mqnamesrv &gt;/usr/local/soft/rocketmq/logs/mqnamesrv.log 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><h3 id="2-7-启动Broker"><a href="#2-7-启动Broker" class="headerlink" title="2.7 启动Broker"></a>2.7 启动Broker</h3><p>1、启动节点1，163的 broker-a-master，在163上面执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">nohup</span> sh /usr/local/soft/rocketmq/bin/mqbroker -c /usr/local/soft/rocketmq/conf/2m-2s-async/broker-a.properties &gt; /usr/local/soft/rocketmq/logs/broker-a.log 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><p>在虚拟机中可能由于内存不够导致无法启动，改动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim /usr/local/soft/rocketmq/bin/runbroker.sh<br><br><span class="hljs-comment">#把8g和4g改成512m和256m</span><br>JAVA_OPT=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;JAVA_OPT&#125;</span> -server -Xms512m -Xmx512m -Xmn256m&quot;</span><br></code></pre></td></tr></table></figure><p>2、启动节点2，164的broker-a-s，在164上面执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">nohup</span> sh /usr/local/soft/rocketmq/bin/mqbroker -c /usr/local/soft/rocketmq/conf/2m-2s-async/broker-a-s.properties &gt; /usr/local/soft/rocketmq/logs/broker-a-s.log 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><p>3、启动节点2，164的 broker-b-master，在164上面执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">nohup</span> sh /usr/local/soft/rocketmq/bin/mqbroker -c /usr/local/soft/rocketmq/conf/2m-2s-async/broker-b.properties &gt; /usr/local/soft/rocketmq/logs/broker-b.log 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><p>4、启动节点1，163的broker-b-s，在163上面执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">nohup</span> sh /usr/local/soft/rocketmq/bin/mqbroker -c /usr/local/soft/rocketmq/conf/2m-2s-async/broker-b-s.properties &gt; /usr/local/soft/rocketmq/logs/broker-b-s.log 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><p>查看端口启动状态：<br>netstat -an|grep 109</p><p>第一台机器 192.168.44.163，端口规划：<br>9876 NameServer1<br>10910 BrokerA-master<br>10921 BrokerB-slave</p><p>第二台机器 192.168.44.164，端口规划：<br>9876 NameServer2<br>10920 BrokerB-master<br>10911 BrokerA-slave</p><h2 id="3-常用管理命令"><a href="#3-常用管理命令" class="headerlink" title="3 常用管理命令"></a>3 常用管理命令</h2><p><a href="https://blog.csdn.net/gwd1154978352/article/details/80829534">https://blog.csdn.net/gwd1154978352/article/details/80829534</a></p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
      <category>RocketMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sentinel规则持久化</title>
    <link href="/2023/03/27/spring%E6%A1%86%E6%9E%B6/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2023/03/27/spring%E6%A1%86%E6%9E%B6/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>官网：<a href="https://github.com/alibaba/Sentinel/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95">https://github.com/alibaba/Sentinel/wiki/动态规则扩展</a></p><h2 id="1-客户端内存的规则"><a href="#1-客户端内存的规则" class="headerlink" title="1 客户端内存的规则"></a>1 客户端内存的规则</h2><h3 id="1-1-规则的存储"><a href="#1-1-规则的存储" class="headerlink" title="1.1 规则的存储"></a>1.1 规则的存储</h3><p><img src="/image/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/sentinel%E5%86%85%E5%AD%98%E8%A7%84%E5%88%99%E7%9A%84%E5%AD%98%E5%82%A8.jpg"></p><h3 id="1-2-规则的获取"><a href="#1-2-规则的获取" class="headerlink" title="1.2 规则的获取"></a>1.2 规则的获取</h3><p><img src="/image/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/sentinel%E5%86%85%E5%AD%98%E8%A7%84%E5%88%99%E7%9A%84%E8%8E%B7%E5%8F%96.jpg"></p><h2 id="2-Dashboard规则管理"><a href="#2-Dashboard规则管理" class="headerlink" title="2 Dashboard规则管理"></a>2 Dashboard规则管理</h2><h3 id="2-1-三种模式"><a href="#2-1-三种模式" class="headerlink" title="2.1 三种模式"></a>2.1 三种模式</h3><table><thead><tr><th>推送模式</th><th>说明</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>原始模式</td><td>API将规则推送至客户端并直接更新到内存中，扩展写数据源(WritableDateSource)</td><td>简单，无任何依赖</td><td>不保证一致性；规则保存在内存中，重启即消失，严重不建议用于生产环境</td></tr><tr><td>Pull模式</td><td>扩展写数据源(WritableDataSource)，客户端主动向某个规则管理中心定期轮询拉取规则，这个规则中心可以是RDBMS、文件等</td><td>简单，无任何依赖；规则持久化</td><td>不保证一致性；实时性不保证，拉取过于频繁也可能会有性能问题</td></tr><tr><td>Push模式</td><td>扩展读数据源(ReadableDataSource)，规则中心统一推送，客户端通过注册监听的方式时刻监听变化，比如使用Nacos、Zookeeper等配置中心。这种方式有更好的实时性和一致性保证。<strong>生产环境下一般采用push模式的数据源</strong></td><td>规则持久化；一致性；快速</td><td>引入第三方依赖</td></tr></tbody></table><h3 id="2-2-原始模式"><a href="#2-2-原始模式" class="headerlink" title="2.2 原始模式"></a>2.2 原始模式</h3><p><img src="/image/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/1.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">dashboard调用客户端的常见api：<br>http://localhost:8720/api                  -&gt; ApiCommandHandler<br>http://localhost:8720/getRules?<span class="hljs-built_in">type</span>=flow   -&gt; FetchActiveRuleCommandHandler<br>http://localhost:8720/setRules?<span class="hljs-built_in">type</span>=flow   -&gt; ModifyRulesCommandHandler<br></code></pre></td></tr></table></figure><h3 id="2-3-Pull模式"><a href="#2-3-Pull模式" class="headerlink" title="2.3 Pull模式"></a>2.3 Pull模式</h3><p><img src="/image/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/2.png"></p><h4 id="2-3-1-代码实现"><a href="#2-3-1-代码实现" class="headerlink" title="2.3.1 代码实现"></a>2.3.1 代码实现</h4><p>（1）创建FileDataSourceInit实现InitFunc接口，用于本地规则的读取与写入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileDataSourceInit</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitFunc</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.printLn(<span class="hljs-string">&quot;Pull模式，FileDataSourceInit...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）根据Sentinel中提供的SPI机制，在指定目录下创建文件及配置</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//文件位置</span><br>resources/META-INF/services/com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.csp</span><span class="hljs-selector-class">.sentinel</span><span class="hljs-selector-class">.init</span><span class="hljs-selector-class">.InitFunc</span><br><br><span class="hljs-comment">//文件内容</span><br>com<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.user</span><span class="hljs-selector-class">.initFuc</span>.FileDataSourceInit<br></code></pre></td></tr></table></figure><p>（3）debug测试FileDataSourceInit#init方法是否调用</p><p>（4）在C:\Users\Jack\sentinel\rules目录创建几种规则的json文件，用于在本地存储对应的规则</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">流控规则：flow-<span class="hljs-keyword">rule</span>.json<br>降级规则：degrade-<span class="hljs-keyword">rule</span>.json<br>热点参数规则：param-flow-<span class="hljs-keyword">rule</span>.json<br>授权规则：authority-<span class="hljs-keyword">rule</span>.json<br>系统规则：<span class="hljs-keyword">system</span>-<span class="hljs-keyword">rule</span>.json<br></code></pre></td></tr></table></figure><p>（5）编辑FileDataSourceInit类，定义这些规则文件对应的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileDataSourceInit</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitFunc</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.printLn(<span class="hljs-string">&quot;Pull模式，FileDataSourceInit...&quot;</span>);<br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">rulePath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.home&quot;</span>) + <span class="hljs-string">&quot;\\sentinel\\rules&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">flowRulePath</span> <span class="hljs-operator">=</span> rulePath + <span class="hljs-string">&quot;\\flow-rule.json&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">degradeRulePath</span> <span class="hljs-operator">=</span> rulePath + <span class="hljs-string">&quot;\\degrade-rule.json&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">paramFlowRulePath</span> <span class="hljs-operator">=</span> rulePath + <span class="hljs-string">&quot;\\param-flow-rule.json&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">authorityRulePath</span> <span class="hljs-operator">=</span> rulePath + <span class="hljs-string">&quot;\\authority-rule.json&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">systemRulePath</span> <span class="hljs-operator">=</span> rulePath + <span class="hljs-string">&quot;\\system-rulle.json&quot;</span>;<br>        System.out.printLn(<span class="hljs-string">&quot;流控规则的文件全路径为: &quot;</span>+flowRulePath);<br>        <br>        <span class="hljs-comment">// 不存在的话就创建对应的文件夹及文件</span><br><span class="hljs-built_in">this</span>.mkdirIfNotExits(rulePath);<br><span class="hljs-built_in">this</span>.createFileIfNotExits(flowRulePath);<br><span class="hljs-built_in">this</span>.createFileIfNotExits(degradeRulePath);<br><span class="hljs-built_in">this</span>.createFileIfNotExits(paramFlowRulePath);<br><span class="hljs-built_in">this</span>.createFileIfNotExits(authorityRulePath);<br><span class="hljs-built_in">this</span>.createFileIfNotExits(systemRulePath);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mkdirIfNotExits</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-keyword">if</span>(!file.exists())&#123;<br>            file.mkdirs();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createFileIfNotExits</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-keyword">if</span>(!file.exists())&#123;<br>            file.createNewFile();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（6）完善流控规则的读写数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileDataSourceInit</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitFunc</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.printLn(<span class="hljs-string">&quot;Pull模式，FileDataSourceInit...&quot;</span>);<br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">rulePath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.home&quot;</span>) + <span class="hljs-string">&quot;\\sentinel\\rules&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">flowRulePath</span> <span class="hljs-operator">=</span> rulePath + <span class="hljs-string">&quot;\\flow-rule.json&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">degradeRulePath</span> <span class="hljs-operator">=</span> rulePath + <span class="hljs-string">&quot;\\degrade-rule.json&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">paramFlowRulePath</span> <span class="hljs-operator">=</span> rulePath + <span class="hljs-string">&quot;\\param-flow-rule.json&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">authorityRulePath</span> <span class="hljs-operator">=</span> rulePath + <span class="hljs-string">&quot;\\authority-rule.json&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">systemRulePath</span> <span class="hljs-operator">=</span> rulePath + <span class="hljs-string">&quot;\\system-rulle.json&quot;</span>;<br>        System.out.printLn(<span class="hljs-string">&quot;流控规则的文件全路径为: &quot;</span>+flowRulePath);<br>        <br>        <span class="hljs-comment">// 不存在的话就创建对应的文件夹及文件</span><br><span class="hljs-built_in">this</span>.mkdirIfNotExits(rulePath);<br><span class="hljs-built_in">this</span>.createFileIfNotExits(flowRulePath);<br><span class="hljs-built_in">this</span>.createFileIfNotExits(degradeRulePath);<br><span class="hljs-built_in">this</span>.createFileIfNotExits(paramFlowRulePath);<br><span class="hljs-built_in">this</span>.createFileIfNotExits(authorityRulePath);<br><span class="hljs-built_in">this</span>.createFileIfNotExits(systemRulePath);<br>        <br>        ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; ds = <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileRefreshableDataSource</span>&lt;&gt;(flowRulePath, source -&gt; JSON.parseObject(source, <br>                                                                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;List&lt;FlowRule&gt;&gt;()&#123;&#125;));<br>        <span class="hljs-comment">//将可读数据源注册至FlowRuleManager</span><br>        FlowRuleManager.register2Property(ds.getProperty());<br>        WritableDataSource&lt;List&lt;FlowRule&gt;&gt; wds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWritableDataSoure</span>&lt;&gt;(flowRulePath, <span class="hljs-built_in">this</span>::encodeJson);<br>        <span class="hljs-comment">//将可写数据源注册至transport模块的WritableDataSource中</span><br>        <span class="hljs-comment">//这样收到控制台推送的规则时，Sentinel会先更新到内存，然后将规则写入到文件中</span><br>        WritableDataSourceRegistry.registerFlowDataSource(wds);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mkdirIfNotExits</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-keyword">if</span>(!file.exists())&#123;<br>            file.mkdirs();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createFileIfNotExits</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-keyword">if</span>(!file.exists())&#123;<br>            file.createNewFile();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> &lt;T&gt; String <span class="hljs-title function_">encodeJson</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-keyword">return</span> JSON.toJSONString(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（7）测试Pull模式的流控规则是否生效，重启Spring Boot项目，访问 <a href="http://localhost:8081/user/hello%EF%BC%8C%E5%88%B7%E6%96%B0dashboard%EF%BC%8C%E7%BB%99/user/hello%E6%B7%BB%E5%8A%A0%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99%EF%BC%8C%E7%9C%8B%E7%9C%8B%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6flowrule.json%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%B0%E6%8D%AE%E3%80%82%E7%84%B6%E5%90%8E%E9%87%8D%E5%90%AFuser%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%86%8D%E6%AC%A1%E8%AE%BF%E9%97%AE%E8%AE%BF%E9%97%AEhttp://localhost:8081/user/hello%EF%BC%8C%E6%A3%80%E6%9F%A5%E8%A7%84">http://localhost:8081/user/hello，刷新dashboard，给/user/hello添加流控规则，看看本地文件flowrule.json中是否有数据。然后重启user服务，再次访问访问http://localhost:8081/user/hello，检查规</a> 则是否还存在。 </p><p>（8）通过dashboard修改流控规则，看看本地流控规则文件的数据变化。 修改本地流控规则文件，看看dashboard数据的变化。</p><p>（9）最后分别完善其他规则的代码</p><h4 id="2-3-2-源码分析"><a href="#2-3-2-源码分析" class="headerlink" title="2.3.2 源码分析"></a>2.3.2 源码分析</h4><p><img src="/image/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/sentinel-pull%E6%A8%A1%E5%BC%8F%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99%E6%BA%90%E7%A0%81.jpg"></p><h3 id="2-4-Push模式"><a href="#2-4-Push模式" class="headerlink" title="2.4 Push模式"></a>2.4 Push模式</h3><p><img src="/image/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/4.png"></p><h4 id="2-4-1-代码实现"><a href="#2-4-1-代码实现" class="headerlink" title="2.4.1 代码实现"></a>2.4.1 代码实现</h4><h5 id="2-4-1-1-sentinel-dashboard"><a href="#2-4-1-1-sentinel-dashboard" class="headerlink" title="2.4.1.1 sentinel-dashboard"></a>2.4.1.1 sentinel-dashboard</h5><p>（1）打开sentinel-dashboard pom文件，将sentinel-datasource-nacos依赖的scope[test]去掉 </p><p>（2）将sentinel-dashboard项目中的test/rule目录下的nacos文件夹复制到src的rule目录下 </p><p>（3）将src/nacos/NacosConfig中的nacos连接Bean地址更改成nacos-server所在地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> ConfigSerevice <span class="hljs-title function_">nacosConfigService</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> ConfigFactory.createCOnfigService(<span class="hljs-string">&quot;localhost:8848&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）打开src/v2文件夹，找到FlowControllerV2中如下的两个属性，将其更改成nacos的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(&quot;flowRuleDefaultProvider&quot;)</span> <span class="hljs-comment">// -&gt; flowRuleNacosProvider</span><br><span class="hljs-keyword">private</span> DynamicRuleProvider&lt;List&lt;FlowRuleEntity&gt;&gt; ruleProvider;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(&quot;flowRuleDefaultPublisher&quot;)</span> <span class="hljs-comment">// -&gt; flowRuleNacosPublisher</span><br><span class="hljs-keyword">private</span> DynamicRulePublisher&lt;List&lt;FlowRuleEntity&gt;&gt; rulePublisher;<br></code></pre></td></tr></table></figure><p>（5）找到dashboard的前端显示页面，修改一个流控规则菜单作为测试</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>文件位置<br>webapp<span class="hljs-regexp">/resources/</span>app<span class="hljs-regexp">/scripts/</span>directices<span class="hljs-regexp">/sidebar/</span>sidebar.html<br></code></pre></td></tr></table></figure><p>（6）找到流控规则V1的注释内容，将其修改为nacos</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 将下面这段代码注释去掉 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">ui-sref-active</span>=<span class="hljs-string">&quot;active&quot;</span> <span class="hljs-attr">ng-if</span>=<span class="hljs-string">&quot;entry.appType==0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">ui-sref</span>=<span class="hljs-string">&quot;dashboard.flow(&#123;app: entry.app&#125;)&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;glyhicon glyhicon-filter&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>流控规则<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（7）启动nacos-server，重启sentinel dashboard并访问</p><p>（8）访问<a href="http://localhost:8081/user/hello">http://localhost:8081/user/hello</a> ，并在sentinel dashboard中添加流控规则nacos</p><p><img src="/image/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/5.png"></p><p>（9）查看nacos-server的配置管理，可以看到对应的流控规则</p><p>（10）分别在sentinel dashboard和nacos server进行修改配置，看是否能够保证数据一致性</p><h5 id="2-4-1-2-user"><a href="#2-4-1-2-user" class="headerlink" title="2.4.1.2 user"></a>2.4.1.2 user</h5><ul><li>方式1</li></ul><p>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）注册数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosDataSourceInitFunc</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitFunc</span> &#123;<br>    <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">remoteAddress</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;localhost&quot;</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">groupId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SENTINEL_GROUP&quot;</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">dataId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.jack.user.UserApplication-flow-rules&quot;</span>;<br>ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleDataSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosDataSource</span>&lt;&gt;(remoteAddress, groupId, dataId, source -&gt; JSON.parseObject(source, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;List&lt;FlowRule&gt;&gt;() &#123;&#125;));<br>FlowRuleManager.register2Property(flowRuleDataSource.getProperty());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）添加SPI配置</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.user</span><span class="hljs-selector-class">.initfuc</span><span class="hljs-selector-class">.FileDataSourceFunc</span><br>com<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.user</span><span class="hljs-selector-class">.initfuc</span>.NacosDataSourceInitFunc<br></code></pre></td></tr></table></figure><ul><li>方式2</li></ul><p>(1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）写配置：bootstrap.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">datasource:</span><br>        <span class="hljs-comment">#可以配置为任意名称</span><br>        <span class="hljs-attr">ds1:</span><br>          <span class="hljs-attr">nacos:</span><br>            <span class="hljs-attr">server-addr:</span> <span class="hljs-string">$&#123;spring.cloud.nacos.config.server-addr&#125;</span><br>            <span class="hljs-attr">dataId:</span> <span class="hljs-string">com.test.user.UserApplication-flow-rules</span><br>            <span class="hljs-attr">groupId:</span> <span class="hljs-string">SENTINEL_GROUP</span><br>            <span class="hljs-attr">data-type:</span> <span class="hljs-string">json</span><br>            <span class="hljs-comment">#RuleType</span><br>            <span class="hljs-attr">rule-type:</span> <span class="hljs-string">flow</span><br></code></pre></td></tr></table></figure><p>（3）注释掉之前的本地持久化和手动nacos配置</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-id">#com</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.user</span><span class="hljs-selector-class">.initfuc</span><span class="hljs-selector-class">.FileDataSourceInit</span><br><span class="hljs-selector-id">#com</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.user</span><span class="hljs-selector-class">.initfuc</span>.NacosDataSourceInitFunc<br></code></pre></td></tr></table></figure><p>（4）重启user服务，并进行相应的测试</p><h4 id="2-4-2-源码分析"><a href="#2-4-2-源码分析" class="headerlink" title="2.4.2 源码分析"></a>2.4.2 源码分析</h4><p><img src="/image/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/sentinel-push%E6%A8%A1%E5%BC%8F%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99%E6%BA%90%E7%A0%81.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sentinel源码解析</title>
    <link href="/2023/03/27/spring%E6%A1%86%E6%9E%B6/springcloud/sentinel/sentinel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/03/27/spring%E6%A1%86%E6%9E%B6/springcloud/sentinel/sentinel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/springcloud/sentinel/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/sentinel%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>远程通信协议</title>
    <link href="/2023/03/23/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/03/23/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="1-HTTP请求流程"><a href="#1-HTTP请求流程" class="headerlink" title="1 HTTP请求流程"></a>1 HTTP请求流程</h2><p>在分布式架构中，有一个很重要的环节，就是分布式网络中的计算机节点彼此之间需要通信。这个通信的过程一定会涉及到通信协议相关的知识点。用浏览器访问各种网站，作为用户来说，只需要输入一个网址并且正确跳转就行。但是作为程序员，看到的可能就是这个响应背后的整体流程。所以通过一个http请求的整体流程来进行整理通信的知识。</p><h3 id="1-1-DNS服务-域名解析"><a href="#1-1-DNS服务-域名解析" class="headerlink" title="1.1 DNS服务(域名解析)"></a>1.1 DNS服务(域名解析)</h3><p>首先，访问一个域名，会经过DNS解析。DNS（Domain Name System），它和http协议一样是位于应用层的协议，主要提供域名到ip的解析服务。其实不用域名也可以访问目标主机的服务，但是ip本身不是那么容易记，所以使用域名进行替换使得用户更容易记住。</p><p>在很多大型网站，会引来CDN来加速静态内容的访问，这里简单介绍一下什么是CDN（Content Delivery Network），表示的是内容分发网络。CDN其实就是一种网络缓存技术，能够把一些相对稳定的资源放到距离最终用户较近的地方，一方面可以节省整个广域网的带宽消耗，另一方面可以提升用户的访问速度，改进用户体验。一般会把静态的文件（图片，脚本，静态页面）放到CDN中。如果引入CDN，解析的流程也会稍微复杂一点。</p><h3 id="1-2-HTTP协议通信原理"><a href="#1-2-HTTP协议通信原理" class="headerlink" title="1.2 HTTP协议通信原理"></a>1.2 HTTP协议通信原理</h3><p>说到通信，就得说起TCP和UDP这两种通信协议，以及建立连接得握手过程。而http协议的通信是基于tcp/ip协议之上的一个应用层协议，应用层协议除了http，还有ftp、dns、smtp、telnet等。涉及到网络协议，一定需要知道OSI七层网络模型和TCP/IP四层概念模型，</p><p>OSI七层网络模型包含：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p><p>tcp/ip四层概念模型包含：应用层、传输层、网络层、数据链路层。</p><p><img src="/image/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B.jpg"></p><p>当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层知道被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息）</p><p><img src="/image/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.jpg"></p><p><strong>客户端如何找到目标服务：</strong></p><p>​    在客户端发起请求的时候，会在数据链路层去组装目标机器的MAC地址，目标机器的MAC地址怎么得到？这里就涉及到一个ARP协议，这个协议简单来说就是已知目标机器的ip，需要获得目标机器得MAC地址。（发送一个广播消息，这个ip是谁的，请来认领。认领ip的机器会发送一个MAC地址的响应）。</p><p>​    有了这个目标MAC地址，数据包在链路上广播，MAC的网卡才能发现，这个包是给它的。MAC的网卡把包收进来，然后打开IP包，发现IP地址也是自己的，再打开TCP包，发现端口是自己，也就是80端口，而这个时候这台机器上有一个nginx是监听80端口。于是将请求提交给nginx，nginx返回一个网页。然后将网页需要发回请求的机器。然后层层封装，最后到MAC层。因为来的时候有源MAC地址，返回的时候，源MAC就变成了目标MAC，再返回给请求的机器。</p><p>​    为了避免每次都用ARP请求，机器本地也会进行ARP缓存。当然机器会不断地上线下线，IP也可能会变，所以ARP地MAC地址缓存过一段时间就会过期。</p><p><strong>接收到数据包以后地处理过程：</strong></p><p>​    当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上地报文首部。每层协议都要去检查报文首部中的协议标识，以确定接收数据的上层协议。</p><p><img src="/image/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.jpg"></p><p><strong>为什么有了MAC层还要走IP层？</strong></p><p>​    MAC地址是唯一的，那理论上，在任何两个设备之间，应该都可以通过mac地址发送数据，为什么还需要ip地址？</p><p>​    MAC地址就好像个人的身份证号，人的身份证号和人户口所在的城市，出生的日期有关，但是和人所在的位置没有关系，人是会移动的，知道一个人的身份证号，并不能找到它这个人，MAC地址类似，它是和设备的生产者，批次，日期之类的关联起来，知道一个设备的MAC，并不能在网络中将数据发送给它，除非它和发送方的在同一个网络内。</p><p>​    所以要实现机器之间的通信，还需要有ip地址的概念，ip地址表达的是当前机器在网络中的位置，类似于城市名+道路号+门牌号的概念。通过IP层的寻址，能知道按何种路径在全世界任意两台Internet上的机器间传输数据。</p><h3 id="1-3-分层负载"><a href="#1-3-分层负载" class="headerlink" title="1.3 分层负载"></a>1.3 分层负载</h3><h4 id="1-3-1-二层负载"><a href="#1-3-1-二层负载" class="headerlink" title="1.3.1 二层负载"></a>1.3.1 二层负载</h4><p>​    二层负载是针对MAC，负载均衡服务器对外依然提供一个VIP（虚IP），集群中不同的机器采用相同IP地址，但是机器的MAC地址不一样。当负载均衡服务器接收到请求之后，通过改写报文的目标MAC地址的方式将请求转发到目标机器实现负载均衡。二层负载均衡会通过一个虚拟MAC地址接收请求，然后再分配到真实的MAC地址。</p><h4 id="1-3-2-三层负载"><a href="#1-3-2-三层负载" class="headerlink" title="1.3.2 三层负载"></a>1.3.2 三层负载</h4><p>三层负载是针对IP，和二层负载均衡类似，负载均衡服务器对外依然提供一个VIP（虚IP），但是集群中不同的机器采用不同的IP地址。当负载均衡服务器接收到请求之后，根据不同的负载均衡算法，通过ip将请求转发至不同的真实服务器。三层负载均衡会通过一个IP地址接收请求，然后再分配到真实的IP地址。</p><h4 id="1-3-3-四层负载均衡"><a href="#1-3-3-四层负载均衡" class="headerlink" title="1.3.3 四层负载均衡"></a>1.3.3 四层负载均衡</h4><p>​    四层负载均衡工作在OSI模型的传输层，由于在传输层，只有TCP/UDP协议，这两种协议中除了包含源IP、目标IP以外，还包含源端口号及目的端口号。四层负载均衡服务器在接收到客户端请求后，以后通过修改数据包的地址信息（IP+端口号）将流量转发到应用服务器。四层通过虚拟IP+端口接收请求，然后再分配到真实的服务器。</p><h4 id="1-3-4-七层负载均衡"><a href="#1-3-4-七层负载均衡" class="headerlink" title="1.3.4 七层负载均衡"></a>1.3.4 七层负载均衡</h4><p>​    七层负载均衡工作在OSI模型的应用层，应用层协议较多，常用http、radius、dns等。七层负载就可以基于这些协议来负载。这些应用层协议中会包含很多有意义的内容。比如同一个Web服务器的负载均衡，除了根据IP加端口进行负载外，还可以根据七层的URL，浏览器类别来决定是否要进行负载均衡。七层通过虚拟的URL或主机名接收请求，然后再分配到真实的服务器。</p><h2 id="2-TCP-IP协议的深入分析"><a href="#2-TCP-IP协议的深入分析" class="headerlink" title="2 TCP/IP协议的深入分析"></a>2 TCP/IP协议的深入分析</h2><h3 id="2-1-TCP握手协议"><a href="#2-1-TCP握手协议" class="headerlink" title="2.1 TCP握手协议"></a>2.1 TCP握手协议</h3><p>TCP消息的可靠性首先来自于有效的连接建立，所以在数据进行传输前，需要通过三次握手建立一个连接，所谓的三次握手，就是在建立TCP链接时，需要客户端和服务端总共发送3个包来确认链接的建立，在socket编程中，这个过程由客户端执行connect来触发。</p><p><img src="/image/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg"></p><p>第一次握手（SYN=1，seq=x）客户端发送一个tcp的SYN标志位置1的包，指明客户端打算链接的服务器的端口，以及初始序号x，保存在包头的序列号（Sequence Number）字段里。发送完毕后，客户端进入SYN_SENT状态。</p><p>第二次握手（SYN=1，ACK=1，seq=y，ACKnum=x+1）服务器发会确认包（ACK）应答。即SYN标志位和ACK标志位均为1。服务器端选择自己ISN序列号，放到Seq域中，同时将确认序号（Acknowledgement Number）设置为客户的ISN加1，即X+1。发送完毕后，服务器端进入SYN_RCVD状态。</p><p>第三次握手（ACK=1，ACKnum=y+1）客户端再次发送确认包（ACK），SYN标志位为0，ACK标志位为1，并且把服务器发来ACK的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN发送完毕后，客户端进入EXTABLISHED状态，当服务器端接收到这个包时，也进入ESTABLISHED状态，TCP握手结束。</p><h3 id="2-2-SYN攻击"><a href="#2-2-SYN攻击" class="headerlink" title="2.2 SYN攻击"></a>2.2 SYN攻击</h3><p>在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP链接称为半连接（half-open connect），此时server处于SYN-RCVD状态，当收到ACK后，Server转入ESTABLEISED状态。SYN攻击就是Client在短时间内伪造大量不存在的ip地址，并向Server不断发送SYN包，server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击是一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server 上有大量半连接状态且源ip地址是随机的，则可以断定遭到SYN攻击了。</p><h3 id="2-3-TCP四次挥手协议"><a href="#2-3-TCP四次挥手协议" class="headerlink" title="2.3 TCP四次挥手协议"></a>2.3 TCP四次挥手协议</h3><p>四次挥手表示TCP断开连接的时候，需要客户端和服务端总共发送4个包以确认连接的断开；客户端或服务器均可主动发起挥手动作（因为tcp是一个全双工协议），在socket编程中，任何一方执行close()操作即可产生挥手操作。</p><p><img src="/image/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg"></p><p>单工：数据传输只支持数据在一个方向上传输。</p><p>半双工：数据传输允许数据在两个方向上传输，但是在某一时刻，只允许在一个方向上传输，实际上优点像切换方向的单工通信。</p><p>全双工：数据通信允许数据同时在两个方向上传输，因此全双工是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。</p><p>第一次挥手（FIN=1，seq=x）：假设客户端想要关闭连接，客户端发送一个FIN标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进入FIN_WAIT_1状态。</p><p>第二次挥手（ACK=1，ACKnum=x+1）：服务器端确认客户端的FIN包，发送一个确认包，表明自己接收到了客户端关闭连接的请求，但还没有准备号关闭连接。发送完毕后，服务器端进入CLOSE_WAIT状态，客户端接收到这个确认包之后，进入FIN_WAIT_2状态，等待服务器端关闭连接。</p><p>第三次挥手（FIN=1，seq=w）：服务器端准备好关闭连接时，向客户端发送关闭连接请求，FIN设置为1.发送完毕后，服务器端进入LAST_ACK状态，等待来自客户端的最后一个ACK。</p><p>第四次挥手（ACK=1，ACKnum=w+1）：客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入TIME_WAIT状态，等待可能出现的要求重传的Ack包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入CLOSED状态。客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segement Lifetime）之后，没有收到服务器端的ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入CLOSED状态。</p><p>假设Client端发起终端连接请求，也就是发送FIN报文，Server端接收到FIN报文后，意思是说“我Client端没有数据要发给你了“，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还准备好，请继续你等我的消息“，这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文，当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了“。Client收到FIN报文后，”就知道可以关闭连接了，但是它还是不相信网络，怕server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重发。“Server端收到ACK后，”就知道可以断开连接了“。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那Client端也可以正常关闭了。</p><h3 id="2-4-问题"><a href="#2-4-问题" class="headerlink" title="2.4 问题"></a>2.4 问题</h3><p>1、为什么连接时是三次握手，关闭的时候是四次挥手？</p><p>​    三次握手是因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭Socket（因为可能还有消息没处理完），所以只能先回复一个ACK报文，告诉Client端，“你发的FIN报文我收到了“。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步挥手。</p><p>​    2、为什么TIME_WAIT状态需要经过2MSL（最大报文段生存时间）才能返回到CLOSE状态？</p><p>​    虽然按道理，四个报文都发送完毕，可以进入CLOSE状态了，但是必须假想网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p><h2 id="3-TCP协议的通信过程"><a href="#3-TCP协议的通信过程" class="headerlink" title="3 TCP协议的通信过程"></a>3 TCP协议的通信过程</h2><p>首先，对于tcp通信来说，每个tcp socket的内核中都有一个发送缓冲区和一个接受缓冲区，tcp的全双工的工作模式及tcp的滑动窗口就是依赖于这两个独立的Buffer和该Buffer的填充状态。</p><p>接收缓冲区把数据缓存到内核，若应用进程一直没有调用Socket的read方法进行读取，那么该数据会一直被缓存在接收缓冲区内。不管进程是否读取Socket，对端发来的数据都会经过内核接收并缓存到socket的内核接收缓存区。</p><p>read所要做的工作，就是把内核接收缓冲区中的数据复制到应用层用户的Buffer中。进程调用Socket的send发送数据的时候，一般情况下是将数据从应用层用户的Buffer中复制到Socket的内核发送缓冲区，然后send就会在上层返沪。换句话说，send返回时。数据不一定会被发送到对端。</p><p><img src="/image/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/1.png"></p><p>前面提到，Socket的接收缓冲区被tcp用来缓存网络上收到的数据，一直保存到应用进程读走为止。如果应用进程一直没有读取，那么Buffer满了以后，出现的情况是：通知对端tcp协议中的窗口关闭，保证tcp接收缓冲区不会移除，保证了tcp是可靠传输的。如果对方无视窗口大小发出了超过窗口大小的数据，那么接收方会把这些数据丢弃。</p><p><a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html">https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html</a> </p><h2 id="4-IO阻塞"><a href="#4-IO阻塞" class="headerlink" title="4 IO阻塞"></a>4 IO阻塞</h2><h3 id="4-1-一个客户端对应一个线程"><a href="#4-1-一个客户端对应一个线程" class="headerlink" title="4.1 一个客户端对应一个线程"></a>4.1 一个客户端对应一个线程</h3><p>为每个客户端创建一个线程实际上会存在一些弊端，因为创建一个线程需要占用CPU的资源和内存资源。另外，随着线程数增加，系统资源将会称为瓶颈最终达到一个不可控的状态，所以还可以通过线程池来实现多个客户端请求的功能，因为线程池是可控的。</p><p><img src="/image/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/2.png"></p><h3 id="4-2-非阻塞模型"><a href="#4-2-非阻塞模型" class="headerlink" title="4.2 非阻塞模型"></a>4.2 非阻塞模型</h3><p>上面这种模型虽然优化了IO的处理方式，但是，不管是线程池还是单个线程，线程本身的处理个数是由限制的，对于操作系统来说，如果线程数太多会造成CPU上下文切换的开销。因此这种方式不能解决根本问题。所以在Java1.4之后，引入了NIO的功能，</p><h4 id="4-2-1-阻塞IO"><a href="#4-2-1-阻塞IO" class="headerlink" title="4.2.1 阻塞IO"></a>4.2.1 阻塞IO</h4><p>当客户端的数据从网卡缓冲区复制到内核缓冲区之前，服务端会一直阻塞。以socket接口为例，进程空间中调用recfrom，进程从调用recvfrom开始到它返回的整段时间内都是被阻塞的，因此被称为阻塞IO模型。</p><p><img src="/image/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3.png"></p><h4 id="4-2-2-非阻塞IO"><a href="#4-2-2-非阻塞IO" class="headerlink" title="4.2.2 非阻塞IO"></a>4.2.2 非阻塞IO</h4><p>非阻塞IO模型的原理很简单，就是进程空间调用recvfrom，如果这个时候内核缓冲区没有数据的话，就直接返回一个EWOULDBLOCK错误，然后应用程序通过不断轮询来检查这个状态，看内核是不是有数据过来。</p><p><img src="/image/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/4.png"></p><h4 id="4-2-3-IO复用模型"><a href="#4-2-3-IO复用模型" class="headerlink" title="4.2.3 IO复用模型"></a>4.2.3 IO复用模型</h4><p>前面讲的非阻塞仍然需要进程不断地轮询重试。能不能实现当数据可读了以后给程序一个通知？所以这里引入了一个IO多路复用模型，IO多路复用的本质是通过一种机制（系统内核缓冲IO数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应地读写操作。</p><p>​    【什么是fd：在linux中，内核吧所有的外部设备都当成是一个文件来操作，对一个文件的读写会调用内核提供的系统命令，返回一个fd（文件描述符），而对于一个socket的读写也会有相应的文件描述符，称为socketfd】</p><p>​    常见的IO多路复用方式有【select、poll、epoll】，都是Linux API提供的IO复用方式，那么接下来重点说一下select和epoll这两个模型</p><p>​    select：进程可以通过把一个或者多个fd传递给select系统调用，进程会阻塞在select操作上，这样select可以检测多个fd是否处于就绪状态。这个模式有两个缺点：</p><p>​    1、由于它能够同时监听多个文件描述符，假如说有1000个，这个时候如果其中一个fd处于就绪状态了，那么当前进程需要线性轮询所有的fd，也就是监听的fd越多，性能开销越大。</p><p>​    2、同时，select在单个进程中能打开的fd是有限制的，默认是1024，对于那些需要支持单机上万的tcp连接来说确实有点少。</p><p>​    epoll：linux还提供了epoll的系统调用，epoll是基于时间驱动方式来代替顺序扫描，因此性能相对来说更高，主要原理是，当被监听的fd中，有fd就绪时，会告知当前进程具体哪一个fd就绪，那么当前进程只需要去从指定的fd上读取数据即可。另外，epoll所能支持的fd上线是操作系统的最大文件句柄，这个数字要远远大于1024.</p><p>​    【由于epoll能够通过事件告知应用进程哪个fd是可读的，所以我们也称这种IO为异步非阻塞IO，当然它是伪异步的，因为它还需要去把数据从内核同步复制到用户空间中，真正的异步非阻塞，应该是数据已经完全准备好了，我只需要从用户空间读就行】</p><p><img src="/image/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/5.png"></p><h3 id="4-3-多路复用的好处"><a href="#4-3-多路复用的好处" class="headerlink" title="4.3 多路复用的好处"></a>4.3 多路复用的好处</h3><p>IO多路复用可以通过把多个IO的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。它的最大优势是系统开销小，并且不需要创建新的进程或者线程，降低了系统的资源开销。</p><h3 id="4-4-一台机器理论能支持的连接数"><a href="#4-4-一台机器理论能支持的连接数" class="headerlink" title="4.4 一台机器理论能支持的连接数"></a>4.4 一台机器理论能支持的连接数</h3><p>首先，在确定最大连接数之前，先了解一下系统如何标识一个tcp连接。系统用一个四元组来唯一标识要给tcp连接：（source_ip, source_port, destination_ip, destination_port）。即（源ip，源端口，目的ip，目的端口）四个元素的组合。只要四个元素的组合中有一个元素不一样，那就可以区别不同的连接。</p><p>​    比如：你的IP地址是11.1.2.3，在8080端口监听，那么当一个来自22.4.5.6，端口为5555的连接到达后，那么建立的这条连接的四元组为：（11.1.2.3，8080，22.4.5.6，5555）,这时，假设上面的那个用户（22.4.5.6）发来第二条连接请求，端口为6666，那么新连接的四元组为（11.1.2.3，8080，22.4.5.6，6666）。那么，你主机的8080端口建立了两条连接。</p><p>​    通常来说，服务端是固定一个监听端口，比如8080，等待客户端的连接请求。在不考虑地址重用的情况下，即使server端口有多个ip，但是本地监听的端口是独立了的。所以对于tcp连接的4元组中，如果destination_ip和destination_port不变。那么只有source_ip和source_port是可变的，因此最大的tcp连接数应该为客户端的ip数乘以客户端的端口数。在IPV4中，不考虑IP分类等因素，最大的ip数为2的32次方；客户端最大的端口数为2的16次方，也就是65536，也就是服务端单机最大的tcp连接数约为2的48次方。</p><p>​    当然，这只是一个理论值，以linux服务器为例，实际的连接数还取决于</p><p>​    1、内存大小（因为tcp连接都要占用一定的内存）</p><p>​    2、文件句柄限制，每一个tcp连接都需要占一个文件描述符，一旦这个文件描述符使用完了，新来的连接会返回一个“Can`t open so many files“的异常。如果大家知道对于操作系统最大可以打开的文件数限制，就知道怎么去调整这个限制</p><p>​    a）可以执行【ulimit -n】得到当前一个进程最大能打开1024个文件，所以你要采用此默认配置最多也就可以并发上千个tcp连接</p><p>​    b）可以通过【vim/etc/security/limits/conf】去修改系统最大文件打开数的限制</p><p>​    * soft nofile 2048</p><p>​    * hard nofile 2048</p><p>​    * 表示修改所有用户限制、soft/hard表示软限制还是硬限制，2048表示修改以后的值</p><p>​    c）可以通过【cat/proc/sys/fs/file-max】查看linux系统级最大打开文件数限制，表示当前这个服务器最多能同时打开多少个文件</p><p>​    当然，这块还有很多其他的优化的点</p><p>​    3、带宽资源的限制</p>]]></content>
    
    
    <categories>
      
      <category>通信协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>通信协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sentinel适配开源框架</title>
    <link href="/2023/03/21/spring%E6%A1%86%E6%9E%B6/springcloud/sentinel/sentinel%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    <url>/2023/03/21/spring%E6%A1%86%E6%9E%B6/springcloud/sentinel/sentinel%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>官网：<a href="https://sentinelguard.io/zh-cn/docs/open-source-framework-integrations.html">https://sentinelguard.io/zh-cn/docs/open-source-framework-integrations.html</a></p><h2 id="1-开源生态"><a href="#1-开源生态" class="headerlink" title="1 开源生态"></a>1 开源生态</h2><p><a href="https://github.com/alibaba/Sentinel/wiki/Roadmap">https://github.com/alibaba/Sentinel/wiki/Roadmap</a></p><p><img src="/image/springcloud/sentinel/%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/2.png"></p><h2 id="2-适配RestTemplate"><a href="#2-适配RestTemplate" class="headerlink" title="2 适配RestTemplate"></a>2 适配RestTemplate</h2><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel#resttemplate-%E6%94%AF%E6%8C%81">https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel#resttemplate-%E6%94%AF%E6%8C%81</a></p><p>（1）创建RestTemplate的Bean，并添加@SentinelRestTemplate注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@SentinelRestTemplate</span><br><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplateSentinel</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）开启Sentinel对RestTemplate的支持</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">resttemplate:</span><br>  <span class="hljs-attr">sentinel:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>（3）在UserController中定义RestTemplate访问的资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RestTemplate restTemplateSentinel;<br><br><span class="hljs-meta">@RequestMapping(&quot;/resttemplate-sentinel&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">restTemplateSentinel</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:9091/order/query&quot;</span>,String.class);<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）重启Spring Boot项目，访问：<a href="http://localhost:8081/flow/resttemplate-sentine">http://localhost:8081/flow/resttemplate-sentine</a></p><p>（4）在sentinel dashboard上设置流控规则</p><p><img src="/image/springcloud/sentinel/%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/1.png"></p><p>（5）访问：<a href="http://localhost:8081/user/resttemplate-sentinel%EF%BC%8C%E6%B5%8B%E8%AF%95restTemplate%E7%9A%84%E6%B5%81%E6%8E%A7%E6%95%88%E6%9E%9C">http://localhost:8081/user/resttemplate-sentinel，测试restTemplate的流控效果</a></p><p>（6）核心源码，使用拦截器。RestTemplate发起请求：SentinelProtectInterceptor#intercept</p><h2 id="3-适配OpenFeign"><a href="#3-适配OpenFeign" class="headerlink" title="3 适配OpenFeign"></a>3 适配OpenFeign</h2><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel#feign-%E6%94%AF%E6%8C%81">https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel#feign-%E6%94%AF%E6%8C%81</a></p><p>（1）引入starter-feign依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）开启Sentinel对OpenFeign的支持</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">sentinel:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>（4）定义OpenFeign接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderFeignClient</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/order/query&quot;)</span><br>    String <span class="hljs-title function_">query</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）在UserController中定义OpenFeign访问的资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> OrderFeignClient orderFeignClient;<br><br><span class="hljs-meta">@RequestMapping(&quot;/openfeign-sentinel&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">openFeignSentinel</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.orderFeignClient.query();<br>&#125;<br></code></pre></td></tr></table></figure><p>（6）重启Spring Boot项目，访问：<a href="http://localhost:8081/user/openfeign-sentinel">http://localhost:8081/user/openfeign-sentinel</a></p><p>（7）在sentinel dashboard上设置流控规则</p><p><img src="/image/springcloud/sentinel/%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/3.png"></p><p>（8）访问：<a href="http://localhost:8081/user/openfeign-sentinel%EF%BC%8C%E6%B5%8B%E8%AF%95OpenFeign%E7%9A%84%E6%B5%81%E6%8E%A7%E6%95%88%E6%9E%9C">http://localhost:8081/user/openfeign-sentinel，测试OpenFeign的流控效果</a></p><p>（9）处理异常，定义异常处理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderFeignClientFallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderFeignClient</span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">query</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;流控或降级了...&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在OrderFeignClient的注解@FeignClient上添加属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;order&quot;,fallback = OrderFeignClientFallback.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderFeignClient</span> &#123;<br><span class="hljs-meta">@RequestMapping(&quot;/order/query&quot;)</span><br>String <span class="hljs-title function_">query</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（10）核心源码，代理类： SentinelInvocationHandler#invoke</p><h2 id="4-适配网关Gateway"><a href="#4-适配网关Gateway" class="headerlink" title="4 适配网关Gateway"></a>4 适配网关Gateway</h2><p><a href="https://github.com/alibaba/Sentinel/wiki/%E7%BD%91%E5%85%B3%E9%99%90%E6%B5%81">https://github.com/alibaba/Sentinel/wiki/%E7%BD%91%E5%85%B3%E9%99%90%E6%B5%81</a></p><p>（1）重新编辑sentinel dashboard启动命令，使其支持网关配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-Dcsp.sentinel.app.<span class="hljs-attribute">type</span>=1 -Dcsp.sentinel.dashboard.<span class="hljs-attribute">server</span>=localhost:8080 -Dproject.<span class="hljs-attribute">name</span>=sentinel-dashboard<br></code></pre></td></tr></table></figure><p><img src="/image/springcloud/sentinel/%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/4.png"></p><p>（2）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--sentinel starter--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--sentinel和gateway的整合包--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-sentinel-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（3）写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8090</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>       <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-comment"># 自定义路由规则</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-comment"># 路由匹配</span><br>        <span class="hljs-comment"># localhost:8090/jack-&gt;localhost:9091[9092/9093]</span><br>        <span class="hljs-comment"># localhost:8090/jack/order/query-&gt;localhost:9091[9092/9093]/order/query</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">jack_path_route</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://order</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/jack/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">reactor.netty:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><p>（4）修改order服务，增加一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;username&quot;,required = false)</span> String username)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;hello: &quot;</span>+username);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello: &quot;</span>+username;<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）重启服务</p><p><img src="/image/springcloud/sentinel/%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/5.png"></p><p>（6）route id微服务级别</p><p>就是相当于对jack_path_route这个route id对应的微服务进行限流，不管访问lb://order的哪个资 源，都会使用该限流规则</p><p><img src="/image/springcloud/sentinel/%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/6.png"></p><p>（7）API级别</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">精准匹配：<br>表示会对<span class="hljs-regexp">/jack/</span>order/query这个指定的路径生效<br></code></pre></td></tr></table></figure><p><img src="/image/springcloud/sentinel/%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/7.png"></p><p><img src="/image/springcloud/sentinel/%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/8.png"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">前缀匹配<br></code></pre></td></tr></table></figure><p><img src="/image/springcloud/sentinel/%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/9.png"></p><p>（8）URL参数：表示访问的url中必须有username才会生效</p><p><img src="/image/springcloud/sentinel/%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/10.png"></p><p>（9）自定义异常消息：使用yaml文件配置的方式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span><br>      <span class="hljs-attr">scg:</span><br>        <span class="hljs-attr">fallback:</span><br>          <span class="hljs-attr">mode:</span> <span class="hljs-string">response</span><br>          <span class="hljs-attr">response-status:</span> <span class="hljs-number">200</span><br>          <span class="hljs-attr">response-body:</span> <span class="hljs-string">&#x27;&#123;&quot;code&quot;:200,&quot;msg&quot;:&quot;请求太多，一会再试试.&quot;&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="5-集群限流"><a href="#5-集群限流" class="headerlink" title="5 集群限流"></a>5 集群限流</h2><p><a href="https://sentinelguard.io/zh-cn/docs/cluster-flow-control.html">https://sentinelguard.io/zh-cn/docs/cluster-flow-control.html</a></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sentinel规则详解</title>
    <link href="/2023/03/20/spring%E6%A1%86%E6%9E%B6/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/03/20/spring%E6%A1%86%E6%9E%B6/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>面向分布式、多语言异构化服务架构的流量治理组件</p><h2 id="1-Sentinel入门小结"><a href="#1-Sentinel入门小结" class="headerlink" title="1 Sentinel入门小结"></a>1 Sentinel入门小结</h2><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/sentinel%E5%88%9D%E8%AF%86.jpg"></p><h2 id="2-实时监控"><a href="#2-实时监控" class="headerlink" title="2 实时监控"></a>2 实时监控</h2><p>实时监控仅存储 5 分钟以内的数据，如果需要持久化，需要通过调用实时监控接口来定制。 </p><p>注意：请确保 Sentinel 控制台所在的机器时间与自己应用的机器时间保持一致，否则会导致拉不到实时的监控数据。</p><h2 id="3-簇点链路"><a href="#3-簇点链路" class="headerlink" title="3 簇点链路"></a>3 簇点链路</h2><p>簇点链路（单机调用链路）页面实时的去拉取指定客户端资源的运行情况。它一共提供两种展示模式：一种用树状结构展示资源的调用链路，另外一种则不区分调用链路展示资源的运行情况。 </p><p>注意：簇点监控是内存态的信息，它仅展示启动后调用过的资源</p><h2 id="4-流控规则"><a href="#4-流控规则" class="headerlink" title="4 流控规则"></a>4 流控规则</h2><p>资源名：相当于代码中的rule.setResource(“/user/hello”)-&gt;这个名称需要与Spring Web MVC端点的名称一致，只有这样限流时才能匹配得上</p><p>针对来源：可以根据不同的来源对/user/hello接口进行限流，比如针对来源a设置/user/hello的QPS为500，针对来源b设置/user/hello的QPS为1000 </p><p>阈值类型：QPS or 并发线程数</p><p>单机阈值：比如设置阈值类型为QPS，单机阈值为2，则表示该资源/user/hello最大能接受每秒2个查询请求 </p><p>是否集群：暂时先不关注</p><p>流控模式：直接、关联和链路 </p><p>流控效果：快速失败、Warm Up和排队等待</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/1.png"></p><h3 id="4-1-流控模式之直接"><a href="#4-1-流控模式之直接" class="headerlink" title="4.1 流控模式之直接"></a>4.1 流控模式之直接</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">资源名：<span class="hljs-regexp">/user/</span>hello<br>针对来源：default<br>阈值类型：QPS<br>单机阈值：<span class="hljs-number">2</span><br>是否集群：否<br>流控模式：直接 <span class="hljs-comment"># 表示对当前资源进行QPS为2的限流</span><br>流控效果：快速失败 <span class="hljs-comment"># 如果达到QPS阈值，则直接抛出BlockingException异常</span><br></code></pre></td></tr></table></figure><h3 id="4-2-流控模式之关联"><a href="#4-2-流控模式之关联" class="headerlink" title="4.2 流控模式之关联"></a>4.2 流控模式之关联</h3><p>（1）在UserController中添加write和read两个api接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/write&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">write</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;write ...&quot;</span>;<br>&#125;<br><span class="hljs-meta">@RequestMapping(&quot;/read&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">read</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;read ...&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）重启Spring Boot项目，分别访问write和read接口，观察sentinel dashboard的展示</p><p>（3）理解关联模式业务场景：比如在高并发的场景下，如果修改用户信息的请求达到一定的阈值，则对读取用户的接口进行限流，相当于保护了修改用户的接口</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/2.png"></p><p>（4）写一段代码访问write接口，使其QPS阈值超过2，然后访问read接口，看是否有限流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteQPS</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">RestTemplate</span> <span class="hljs-variable">restTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8081/user/write&quot;</span>, String.class);<br>            System.out.printLn(result);<br>            Thread.sleep(<span class="hljs-number">300</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）关联模式的使用条件 a. 两个资源具有竞争关系 b. 一个资源的优先级高，另外一个资源的优先级低</p><h3 id="4-3-流控模式之链路"><a href="#4-3-流控模式之链路" class="headerlink" title="4.3 流控模式之链路"></a>4.3 流控模式之链路</h3><p>（1）创建OrderService，其中有一个query方法，并使用@SentinelResource注解保护起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span>&#123;<br>    <span class="hljs-meta">@SentinelReesource(value = &quot;orderQuery&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">query</span><span class="hljs-params">()</span>&#123;<br>        System.out.printLn(<span class="hljs-string">&quot;query orders....&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;query orders....&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）创建OrderController，其实有两个接口，一个query一个update，并且这两个接口都需要调用 OrderService#query</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span>&#123;<br>    <span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> OrderService orderService;<br>    <br><span class="hljs-meta">@RequestMapping(&quot;/query&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">query</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;query: &quot;</span>+<span class="hljs-built_in">this</span>.orderService.query();<br>&#125;<br><span class="hljs-meta">@RequestMapping(&quot;/update&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;do sth.&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;update: &quot;</span>+<span class="hljs-built_in">this</span>.orderService.query();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）重启Spring Boot项目，分别访问<a href="http://localhost:8081/order/query%E5%92%8Chttp://localhost:8081/ord">http://localhost:8081/order/query和http://localhost:8081/ord</a> er/update，观察sentinel dashboard，发现update簇点链路下并没有显示orderQuery，这个问题先不管，直接进行配置 </p><p>（4）链路模式</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/3.png"></p><p>（5）配置好了之后，快速访问<a href="http://localhost:8081/order/query%E5%8F%91%E7%8E%B0%E6%98%AF%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%EF%BC%8C%E5%8E%9F%E5%9B%A0%E8%B7%9Fsentinel%E7%9A%84">http://localhost:8081/order/query发现是不生效的，原因跟sentinel的</a> 版本有关，具体可以参考<a href="https://github.com/alibaba/Sentinel/issues/1213%E8%BF%9B%E8%A1%8C%E8%A7%A3%E5%86%B3">https://github.com/alibaba/Sentinel/issues/1213进行解决</a></p><p>（6）如何解决？</p><p>添加sentinel-web-servlet依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-web-servlet<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>设置sentinel.filter.enable为false</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span><br>      <span class="hljs-attr">filter:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>新增Filter配置类，开放全部链路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterCOnfiguration</span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title function_">registrationBean</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">FilterRegistrationBean</span> <span class="hljs-variable">registrationBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterRegistrationBean</span>();<br>        registrationBean.setFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonFilter</span>());<br>        registrationBean.addUrlPatterns(<span class="hljs-string">&quot;/*&quot;</span>);<br>        registrationBean.addInitParameter(CommonFilter.WEB_CONTEXT_UNIFY, <span class="hljs-string">&quot;false&quot;</span>);<br>        registrationBean.setName(<span class="hljs-string">&quot;sentinelFilter&quot;</span>);<br>        <span class="hljs-keyword">return</span> registrationBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启Spring Boot项目，按照上述步骤进行重新测试</p><p>（7）流控异常如何处理？其实还是回到了@SentinelResource流控异常的处理</p><p>定义一个SentinelResource流控异常处理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SentinelResourceFlowExceptionHandler</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">handleBlock</span><span class="hljs-params">(BlockException e)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;流控异常: &quot;</span>+e);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;QPS超过阈值，流控了.&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改orderService#query的异常处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br><span class="hljs-meta">@SentinelResource(value = &quot;orderQuery&quot;,blockHandler = &quot;handleBlock&quot;,blockHandlerClass = SentinelResourceFlowExceptionHandler.class)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">query</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;query orders...&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;query orders...&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-流控效果"><a href="#5-流控效果" class="headerlink" title="5 流控效果"></a>5 流控效果</h2><h3 id="5-1-流控效果之快速失败"><a href="#5-1-流控效果之快速失败" class="headerlink" title="5.1 流控效果之快速失败"></a>5.1 流控效果之快速失败</h3><p>抛出异常</p><h3 id="5-2-流控效果之Warm-up"><a href="#5-2-流控效果之Warm-up" class="headerlink" title="5.2 流控效果之Warm up"></a>5.2 流控效果之Warm up</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">冷启动<br>基于令牌桶算法实现<br>适用于服务器刚启动或秒杀的场景<br></code></pre></td></tr></table></figure><p>（1）令牌桶算法</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95.jpg"></p><p>（2）配置</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/4.png"></p><p>（3）jmeter配置</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/5.png"></p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/6.png"></p><h3 id="5-3-流控效果之排队等待"><a href="#5-3-流控效果之排队等待" class="headerlink" title="5.3 流控效果之排队等待"></a>5.3 流控效果之排队等待</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">基于漏桶算法实现<br>可以用作流量整形：对于突发流量被整形以后能提供一个稳定的流量<br></code></pre></td></tr></table></figure><p>（1）漏桶算法</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95.jpg"></p><p>（2）配置</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/7.png"></p><p>（3）代码与图解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-type">RestTemplate</span> <span class="hljs-variable">restTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8081/user/hello&quot;</span>, String.class);<br>System.out.println(result);<br>Thread.sleep(<span class="hljs-number">500</span>);<br>System.out.println(<span class="hljs-string">&quot;--------------&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/8.png"></p><p>（4）增加排队等待超时时长，比如将300ms修改成600ms，再次运行代码，发现调用正常</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/9.png"></p><h2 id="6-熔断规则"><a href="#6-熔断规则" class="headerlink" title="6 熔断规则"></a>6 熔断规则</h2><h3 id="6-1-慢调用比例"><a href="#6-1-慢调用比例" class="headerlink" title="6.1 慢调用比例"></a>6.1 慢调用比例</h3><p>（1）定义一个DegradeController类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/degrade&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DegradeController</span> &#123;<br><span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>Thread.sleep(<span class="hljs-number">500</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello sentinel degrade.&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）重启Spring Boot项目，访问<a href="http://localhost:8081/degrade/hello">http://localhost:8081/degrade/hello</a> </p><p>（3）查看sentinel dashboard，可以看到该资源 </p><p>（4）配置/degrade/hello的熔断规则</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">理解慢调用比例<br>在1s秒内，最少要有10个请求，如果有10*0.1=1个请求的请求响应时间超过100ms，断路器则从<span class="hljs-keyword">Closed</span>变<br>成<span class="hljs-keyword">Open</span>状态<br>10s之后，断路器从<span class="hljs-keyword">Open</span>变成Half-<span class="hljs-keyword">Open</span>状态，会放一个请求尝试调用一下<br>如果这个请求成功响应时间&lt;100ms，则断路器从Half-<span class="hljs-keyword">Open</span>变成<span class="hljs-keyword">Closed</span><br>如果这个请求成功响应时间&gt;100ms，则断路器从Half-<span class="hljs-keyword">Open</span>变成<span class="hljs-keyword">Open</span><br></code></pre></td></tr></table></figure><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/10.png"></p><p>（5）使用jmeter进行测试</p><h3 id="6-2-异常比例"><a href="#6-2-异常比例" class="headerlink" title="6.2 异常比例"></a>6.2 异常比例</h3><p>理解异常比例：在1s之内，请求数量大于10，并且至少有1次请求有异常，接下来10s内会被熔断，10s之后，会尝试放 一个请求，若请求没有异常则断路器状态关闭，若请求有异常则断路器状态打开</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/11.png"></p><h3 id="6-3-异常数"><a href="#6-3-异常数" class="headerlink" title="6.3 异常数"></a>6.3 异常数</h3><p>理解异常数： 在1s之内，请求数量大于10，并且至少有1次请求有异常，接下来10s内会被熔断，10s之后，会尝试放 一个请求，若请求没有异常则断路器状态关闭，若请求有异常则断路器状态打开</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/12.png"></p><h3 id="6-4-热点规则"><a href="#6-4-热点规则" class="headerlink" title="6.4 热点规则"></a>6.4 热点规则</h3><p>（1）在FlowController中定义接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/say-hello&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;name&quot;,required = false)</span> String name,</span><br><span class="hljs-params">   <span class="hljs-meta">@RequestParam(value = &quot;age&quot;,required = false)</span> Integer age)</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;say hello : &quot;</span>+name+<span class="hljs-string">&quot; age: &quot;</span>+age;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）访问<a href="http://localhost:8081/flow/say-hello?name=Jack&amp;age=17%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AE%E7%83%AD%E7%82%B9%E8%A7%84%E5%88%99">http://localhost:8081/flow/say-hello?name=Jack&amp;age=17，并设置热点规则</a></p><p>表示针对say-hello接口的第0个参数进行QPS为1的限流</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/13.png"></p><p>（3）访问：<a href="http://localhost:8081/degrade/say-hello?name=Jack%EF%BC%8C%E5%8F%91%E7%8E%B0%E6%97%A0%E6%95%88">http://localhost:8081/degrade/say-hello?name=Jack，发现无效</a></p><p>（4）使用@SentinelResource注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/say-hello&quot;)</span><br><span class="hljs-meta">@SentinelResource(&quot;hot&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;name&quot;,required = false)</span> String name,</span><br><span class="hljs-params">   <span class="hljs-meta">@RequestParam(value = &quot;age&quot;,required = false)</span> Integer age)</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;say hello : &quot;</span>+name+<span class="hljs-string">&quot; age: &quot;</span>+age;<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）访问并设置热点规则</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/14.png"></p><p>（6）分别访问如下接口进行测试</p><p><a href="http://localhost:8081/degrade/say-hello?name=Jack">http://localhost:8081/degrade/say-hello?name=Jack</a> </p><p><a href="http://localhost:8081/degrade/say-hello?age=17">http://localhost:8081/degrade/say-hello?age=17</a> </p><p><a href="http://localhost:8081/degrade/say-hello?name=Jack&amp;age=17">http://localhost:8081/degrade/say-hello?name=Jack&amp;age=17</a></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>序列化与反序列化</title>
    <link href="/2023/03/18/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2023/03/18/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Java领域的对象如何传输"><a href="#1-Java领域的对象如何传输" class="headerlink" title="1 Java领域的对象如何传输"></a>1 Java领域的对象如何传输</h2><h3 id="1-1-基于socket进行对象传输"><a href="#1-1-基于socket进行对象传输" class="headerlink" title="1.1 基于socket进行对象传输"></a>1.1 基于socket进行对象传输</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//服务端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        serverSocket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(socket.getInputStream());<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) objectInputStream.readObject();<br>        System.out.printLn(user);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span>(in != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                in.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(serverSocket != <span class="hljs-literal">null</span>) &#123;<br>            serverSocket.close();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        out = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(socket.getOutputStream());<br>        out.writeObject(user);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span>(out != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                out.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(socket != <span class="hljs-literal">null</span>) &#123;<br>            socket.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：这段代码运行后，会报错:</p><p><img src="/image/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/1.png"></p><p>对User对象实现一个Serializable接口，再次运行就可以看到对象能够正常传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-序列化的意义"><a href="#1-2-序列化的意义" class="headerlink" title="1.2 序列化的意义"></a>1.2 序列化的意义</h3><p>发现对User这个类增加一个Serializable，就可以解决Java对象的网络传输问题。这就是序列化。</p><p>Java平台允许在内存中创建可复用的java对象，但一般情况下，只有当JVM出于运行时，这些对象才可能存在，即这些对象的生命周期不会比JVM的生命周期长。但在现实应用中，就可能要求在JVM停止运行后能够保存（持久化）指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够实现该功能。</p><p>简单来说：序列化是把对象的状态信息转化为可存储或传输的形式过程，也就是把对象转化为字节序列的过程称为对象的序列化。反序列化是序列化的逆向过程，把字节数组反序列化为对象，把字节序列恢复为对象的过程称为对象的反序列化。</p><h2 id="2-序列化的高阶认识"><a href="#2-序列化的高阶认识" class="headerlink" title="2 序列化的高阶认识"></a>2 序列化的高阶认识</h2><h3 id="2-1-简单认识以下java原生序列化"><a href="#2-1-简单认识以下java原生序列化" class="headerlink" title="2.1 简单认识以下java原生序列化"></a>2.1 简单认识以下java原生序列化</h3><p>前面的代码中演示了，如何通过JDK提供了java对象的序列化方式实现对象序列化传输，主要通过输出流java.io.ObjectOutputStream和对象输入流java.io.ObjectInputStream来实现。</p><p>​    OutputStream：表示对象输出流，它的writeObect(Object obj)方法可以对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</p><p>​    InputStream：表示对象输入流，它的readObject()方法从输入流中读取字节序列，再把他们反序列化为一个对象，并将其返回。</p><p>​    注意，被序列化的对象需要实现java.io.Serializable接口</p><h3 id="2-2-序列化的高阶认识"><a href="#2-2-序列化的高阶认识" class="headerlink" title="2.2 序列化的高阶认识"></a>2.2 序列化的高阶认识</h3><p><strong>serialVersionUID的作用</strong>，在IDEA中通过如下设置可以生成serializeid，字面上的意思是序列化的版本号，凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量。</p><p>java的序列化机制是通过判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是InvalidCastException。</p><p>从结果可以看出，文件流的class和classpath中的class，也就是修改过后的class，不兼容了，出于安全机制考虑，程序抛出了错误，并且拒绝载入。从错误结果来看，如果没有为指定的class配置serialVersionUID，那么java编译器会自动给这个class进行一个摘要算法，类似于指纹算法，只要这个文件有任何改动，得到的UID就会截然不同的，可以保证在这么多类中，这个编号是唯一的。所以，由于没有显示指定serialVersionUID，编译器又生成了一个UID，当然和前面保存在文件中的不一样了，于是出现了2个序列化版本号不一致的错误。因此，只要指定了serialVersionUID，就可以在序列化后，去添加一个字段，或者方法，而不会影响到后期的还原，还原后的对象照样可以使用，而且还多了方法或者属性可以用。</p><p>​    serialVersionUID有两种显示的生成方式：</p><p>​    1、是默认的1L，比如private static final long serialVersionUID = 1L</p><p>​    2、是根据类名，接口名，成员方法及属性等来生成要给64位的哈希字段</p><p>​    当实现java.io.Serializable接口的类没有显示的定义一个serialVersionUID变量的时候，Java序列化机制会根据编译的class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，如果Class文件（类名，方法名等）没有发生变化（增加空格，换行，增加注释等），就算再编译多次，serialVersionUID也不会变化的。</p><h3 id="2-3-Transient关键字"><a href="#2-3-Transient关键字" class="headerlink" title="2.3 Transient关键字"></a>2.3 Transient关键字</h3><p>transient关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列后，transient变量的值被设为初始值，如int型的是0，对象型的是null。</p><p>虽然name被transient修饰，但是通过写的这两个方法依然能够使得name字段正确被序列化和反序列化。</p><p>writeObject和readObject是两个私有的方法，他们是什么时候被调用的呢？从运行结果来看，它确实被调用。而且他们并不存在于java.lang.Object，也没有再Serializable中去声明。唯一的猜想应该还是和ObjectInputStream和ObjectOutputStream有关系，所以基于这个入口去看看在哪个地方有调用。从源码层面来分析可以看到，readObject是通过反射来调用的。其实可以在很多地方看到readObject和writeObject的使用，比如HashMap。</p><h3 id="2-4-java序列化的一些简单总结"><a href="#2-4-java序列化的一些简单总结" class="headerlink" title="2.4 java序列化的一些简单总结"></a>2.4 java序列化的一些简单总结</h3><p>​    1、java序列化只是针对对象的状态进行保存，至于对象中的方法，序列化不关心</p><p>​    2、当一个父类实现了序列化，那么子类会自动实现序列化，不需要显示实现序列化接口</p><p>​    3、当一个对象的实例变量引用了其他对象，序列化这个对象的时候会自动把引用的对象也进行序列化（实现深度克隆）</p><p>​    4、当某个字段被声明位transient后，默认的序列化机制会忽略这个字段</p><p>​    5、被声明为transient的字段，如果需要序列化，可以添加两个私有方法：writeObject和readObject</p><h2 id="3-分布式架构下常见的序列化技术"><a href="#3-分布式架构下常见的序列化技术" class="headerlink" title="3 分布式架构下常见的序列化技术"></a>3 分布式架构下常见的序列化技术</h2><h3 id="3-1-了解序列化的发展"><a href="#3-1-了解序列化的发展" class="headerlink" title="3.1 了解序列化的发展"></a>3.1 了解序列化的发展</h3><p>随着分布式架构、微服务架构的普及。服务与服务之间的通信成了最基本的需求。这个时候，不仅需要考虑通信的性能，也需要考虑到语言多元化的问题。所以，对于序列化来说如何去提升序列化性能以及解决跨语言问题，就成了一个重点考虑的问题。</p><p>​    由于java本身提供的序列化机制存在两个问题：</p><p>​    1、序列化的数据比较大，传输效率低</p><p>​    2、其他语言无法识别和对接</p><p>以致于在后来的很长一段时间，基于XML格式编码的对象序列化机制成为了主流，一方面解决了多语言兼容问题，另一方面比二进制的序列化方式更容易理解。以至于基于XML的SOAP协议及对应的WebService框架在很长一段时间内成为各个主流开发语言的必备的技术。</p><p>再到后来，基于json的简单文本格式编码的HTTP REST接口又基本上取代了复杂的Web Servcice接口，成为分布式架构中远程通信的首要选择。但是json序列化存储占用的空间大，性能低等问题，同时移动客户端应用需要更高效的传输数据来提升用户体验。在这种情况下与语言无关并且高效的二进制编码协议就成为了大家追求的热点技术之一，首先诞生的一个开源的二进制序列化框架-MessagePack。它比google的Prorocol Buffers出现的还要早。</p><h3 id="3-2-简单了解各种序列化技术"><a href="#3-2-简单了解各种序列化技术" class="headerlink" title="3.2 简单了解各种序列化技术"></a>3.2 简单了解各种序列化技术</h3><h4 id="3-2-1-Xml序列化框架介绍"><a href="#3-2-1-Xml序列化框架介绍" class="headerlink" title="3.2.1 Xml序列化框架介绍"></a>3.2.1 Xml序列化框架介绍</h4><p>xml序列化在于可读性好，方便阅读和调试。但是序列化以后的字节码文件比较大，而且效率不高，适用于对性能不高，而且QPS较低的企业级内部系统之间的数据交换的场景，同时XML又具有语言无关性，所以还可以用于异构系统之间的数据交换和协议。比如熟知的webservice，就是采用xml格式对数据进行序列化的。xml序列化/反序列化的实现方式有很多，熟知的方式有Xstream和java自带的xml序列化和反序列化两种。</p><h4 id="3-2-2-JSON序列化框架"><a href="#3-2-2-JSON序列化框架" class="headerlink" title="3.2.2 JSON序列化框架"></a>3.2.2 JSON序列化框架</h4><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，相对于XML来说，json的字节流更小，而且可读性也非常好，现在json数据格式在企业运用是最普遍的，json序列化常用的开源工具有很多：</p><p>​    1、Jackson <a href="https://github.com/FasterXML/jackson">https://github.com/FasterXML/jackson</a></p><p>​    2、阿里开源的fastJSON <a href="https://github.com/alibaba/fastjson">https://github.com/alibaba/fastjson</a></p><p>​    3、Google的GSON <a href="https://github.com/google/gson">https://github.com/google/gson</a></p><p>这几种json序列化工具中，Jackson和FastJson要比GSON的性能要好，但是jackson、GSON的稳定性要比fastjson好。而fastjson的优势在于提供的api非常容易使用。</p><h4 id="3-2-3-Hessian序列化框架"><a href="#3-2-3-Hessian序列化框架" class="headerlink" title="3.2.3 Hessian序列化框架"></a>3.2.3 Hessian序列化框架</h4><p>Hessian是一个支持跨语言传输的二进制序列化协议，相对于java默认的序列化机制来说，Hessian具有更好的性能和易用性，而且支持多种不同的语言，实际上Dubbo采用的就是Hessian序列化来实现，只不过Dubbo对Hessian进行了重构，性能更高。</p><h4 id="3-2-4-Avro序列化"><a href="#3-2-4-Avro序列化" class="headerlink" title="3.2.4 Avro序列化"></a>3.2.4 Avro序列化</h4><p>Avro是一个数据序列化系统，设计用于支持大批量数据交换的应用。它的主要特点有：支持二进制序列化方式，可以便捷，快速地处理大量数据；动态语言友好，Avro提供地机制使得动态语言可以方便地处理Avro数据。</p><h4 id="3-2-5-kyro序列化框架"><a href="#3-2-5-kyro序列化框架" class="headerlink" title="3.2.5 kyro序列化框架"></a>3.2.5 kyro序列化框架</h4><p>Kyro是一种非常成熟地序列化实现，已经在Hive，Storm中使用的比较广泛，不过它不能跨语言，目前dubbo已经在2.6版本中支持kyro的序列化机制。它的性能要优于之前的hessian2</p><h4 id="3-2-6-Protobuf序列化框架"><a href="#3-2-6-Protobuf序列化框架" class="headerlink" title="3.2.6 Protobuf序列化框架"></a>3.2.6 Protobuf序列化框架</h4><p>Protobuf是Google的一种数据交换格式，它独立于语言，独立于平台。Google提供了多种语言来实现，比如java，C，Go，Python，每一种实现都包含了相应语言的编译器和库文件，Protobuf是一个纯粹的表示层协议，可以和各种传输层协议一起使用。</p><p>Protobuf使用比较广泛，主要是空间开销小和性能比较好，非常适合用于公司内部对性能要求高的RPC调用。另外由于解析性能比较高，序列化以后数据量相对较少，所以也可以应用在对象的持久化场景中。但是要使用Protobuf会相对来说麻烦些，因为他有自己的语法，有自己的编译器，如果需要用到的话必须要投入成本在这个技术的学习中。Protobuf有个缺点就是要传输的每一个类的结构都要生成相应的proto文件，如果某个类发生修改，还得重新生成类对应的proto文件。</p><h2 id="4-序列化技术的选型"><a href="#4-序列化技术的选型" class="headerlink" title="4 序列化技术的选型"></a>4 序列化技术的选型</h2><h3 id="4-1-技术层面"><a href="#4-1-技术层面" class="headerlink" title="4.1 技术层面"></a>4.1 技术层面</h3><p>​    1、序列化空间开销，也就是序列化产生的结果大小，这个影响到传输的性能</p><p>​    2、序列化过程中消耗的时长，序列化消耗时间过长影响到业务的响应时间</p><p>​    3、序列化协议是否支持跨平台，跨语言。因为现在的架构更加灵活，如果存在异构系统通信需求，那么这个是必须要考虑的。</p><p>​    4、可扩展性/兼容性，在实际业务开发中，系统往往需要随着需求的快速迭代来实现快速更新，这就要求采用的序列化协议基于良好的可扩展性/兼容性，比如在现有的序列化数据结构中新增一个业务字段，不会影响到现有的服务</p><p>​    5、技术的流行程度，越流行的技术意味着使用的公司多，那么很多坑都已经淌过并且得到了解决，技术解决方案也相对成熟</p><p>​    6、学习难度和易用性</p><h3 id="4-2-选型建议"><a href="#4-2-选型建议" class="headerlink" title="4.2 选型建议"></a>4.2 选型建议</h3><p>​    1、对性能要求不高的场景，可以采用基于XML的SOAP协议</p><p>​    2、对性能和间接性有比较高要求的场景，那么Hessian，Protobuf，Thrift，Avro都可以</p><p>​    3、基于前后端分离，或者独立的对外的api服务，选用json是比较好的，对于调试，可读性都很不错</p><p>​    4、Avro设计理念偏于动态类型语言，那么这类的场景使用Avro是可以的</p><p>​    这个地址有针对不同系列化技术进行性能比较： <a href="https://github.com/eishay/jvm-serializers/wiki">https://github.com/eishay/jvm-serializers/wiki</a></p>]]></content>
    
    
    <categories>
      
      <category>序列化与反序列化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sentinel入门</title>
    <link href="/2023/03/16/spring%E6%A1%86%E6%9E%B6/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/"/>
    <url>/2023/03/16/spring%E6%A1%86%E6%9E%B6/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>面向分布式、多语言异构化服务架构的流量治理组件</p><p><a href="https://sentinelguard.io/zh-cn/">https://sentinelguard.io/zh-cn/</a></p><h2 id="1-常见的容错方案"><a href="#1-常见的容错方案" class="headerlink" title="1 常见的容错方案"></a>1 常见的容错方案</h2><p>就以B调用C服务为例，怎样避免B服务因为C服务的不可用而导致自己不可用</p><ol><li>超时</li></ol><p>​        <img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/1.png"></p><ol start="2"><li><p>限流</p><p> <img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/2.png"></p></li><li><p>舱壁模式</p></li></ol><p><img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/3.png"></p><ol start="4"><li><p>断路器</p><p> <a href="https://martinfowler.com/bliki/CircuitBreaker.html">https://martinfowler.com/bliki/CircuitBreaker.html</a></p></li></ol><p><img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/4.png"></p><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2 快速入门"></a>2 快速入门</h2><p><a href="https://sentinelguard.io/zh-cn/docs/quick-start.html">https://sentinelguard.io/zh-cn/docs/quick-start.html</a></p><h3 id="2-1-原生API"><a href="#2-1-原生API" class="headerlink" title="2.1 原生API"></a>2.1 原生API</h3><p>1.引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.定义资源</p><p>资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。在接下来的文档中，都会用资源来描述代码块。 只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用 方法签名，URL，甚至服务名称作为资源名来标示资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SentinelExample</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">RESOURCE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Test&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//初始化配置规则</span><br>        initFlowRules();<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                entry = SphU.entry(RESOURCE_NAME);<br>                <span class="hljs-comment">//被保护的逻辑</span><br>                System.out.printLn(<span class="hljs-string">&quot;hello sentinel&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (BlockException ex)&#123;<br>                <span class="hljs-comment">//处理被流控的逻辑</span><br>                System.out.printLn(<span class="hljs-string">&quot;blocked!&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span>(entry != <span class="hljs-literal">null</span>)&#123;<br>                    entry.exit();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.定义规则</p><p><a href="https://sentinelguard.io/zh-cn/docs/introduction.html">https://sentinelguard.io/zh-cn/docs/introduction.html</a></p><p>围绕资源的实时状态设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initFlowRules</span><span class="hljs-params">()</span>&#123;<br>List&lt;FlowRule&gt; rules = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">FlowRule</span> <span class="hljs-variable">rule</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowRule</span>();<br>    rule.setResource(RESOURCE_NAME);<br>    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);<br>    <span class="hljs-comment">// Set limit QPS to 20</span><br>    rule.setCount(<span class="hljs-number">20</span>);<br>    rules.add(rule);<br>    FlowRuleManager.loadRules(rules);<br>&#125;<br></code></pre></td></tr></table></figure><p>4.运行方法，观察控制台</p><p>5.理解过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">initFlowRules()<br>-&gt;FlowRuleManager.loadRules(rules)<br>-&gt;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Map&lt;String, List&lt;FlowRule&gt;&gt; flowRules = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>可以理解为名称为HelloWorld的资源，目前拥有一个流控规则FlowRule，流控规则中有具体的一些值</p><p><img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/5.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">SphU.entry(RESOURCE_NAME)<br>-&gt;FlowSlot#entry<br>-&gt;checkFlow(resourceWrapper, context, node, count, prioritized)<br>-&gt;Collection&lt;FlowRule&gt; rules = ruleProvider.apply(resource.getName())<br></code></pre></td></tr></table></figure><p>也就是在SphU#entry方法中，会根据资源名称拿到对应的流控规则FlowRule</p><p><img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/6.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">canPassCheck<br>-&gt;passLocalCheck<br>-&gt;canPass<br></code></pre></td></tr></table></figure><p>最后在canPass方法中，会判断当前的QPS根据流控规则的配置是否能够通过</p><p><img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/7.png"></p><p>6.总结</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs leaf">a.加载规则到内存 FlowRuleManager<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">loadRules</span><span class="hljs-params">(<span class="hljs-variable">rules</span>)</span></span><br>b.定义被保护的资源 SphU#entry<br></code></pre></td></tr></table></figure><h3 id="2-2-原生API-Web-MVC"><a href="#2-2-原生API-Web-MVC" class="headerlink" title="2.2 原生API-Web MVC"></a>2.2 原生API-Web MVC</h3><p>（1）定义FlowRuleController及被保护的资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/flow&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlowRuleController</span> &#123;<br><span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>entry = SphU.entry(<span class="hljs-string">&quot;flow&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;web mvc hello sentinel.&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;web mvc hello sentinel.&quot;</span>;<br>&#125; <span class="hljs-keyword">catch</span> (BlockException ex) &#123;<br><span class="hljs-comment">// 处理被流控的逻辑</span><br>System.out.println(<span class="hljs-string">&quot;web mvc flow limit!&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;web mvc flow limit!&quot;</span>;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (entry != <span class="hljs-literal">null</span>) &#123;<br>entry.exit();<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）加载规则到内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostConstruct</span> <span class="hljs-comment">// Spring Bean实例化之后执行</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flowRules</span><span class="hljs-params">()</span> &#123;<br>List&lt;FlowRule&gt; rules = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">FlowRule</span> <span class="hljs-variable">rule</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowRule</span>();<br>rule.setResource(<span class="hljs-string">&quot;flow&quot;</span>);<br>rule.setGrade(RuleConstant.FLOW_GRADE_QPS);<br>rule.setCount(<span class="hljs-number">2</span>);<br>rules.add(rule);<br>FlowRuleManager.loadRules(rules);<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）启动Spring Boot项目，并调用/flow/hello接口</p><h3 id="2-3-SentinelResource注解"><a href="#2-3-SentinelResource注解" class="headerlink" title="2.3 @SentinelResource注解"></a>2.3 @SentinelResource注解</h3><p>（1）在FlowController中新增一个api接口，并且定义@SentinelResource注解，为value属性指定值， 其实这个属性值就是资源名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-meta">@SentinelResource(value=&quot;flow&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;@Sentinel hello sentinel.&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;@Sentinel hello sentinel.&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-annotation-aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（3）定义配置类，实例化SentinelResourceAspect对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SentinelConfiguration</span> &#123;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> SentinelResourceAspect <span class="hljs-title function_">sentinelResourceAspect</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SentinelResourceAspect</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）重启Spring Boot项目，测试test接口的QPS是否生效</p><p>（5）简单分析一下实现原理</p><p>其实就是通过AOP给目标代码的前后添加上了SphU#entry相关的逻辑</p><p><img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/8.png"></p><p>（6）定义流控异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-meta">@SentinelResource(value=&quot;flow&quot;,blockHandler = &quot;handleBlock&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;@Sentinel hello sentinel.&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;@Sentinel hello sentinel.&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">handleBlock</span><span class="hljs-params">(BlockException e)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;流控异常: &quot;</span>+e);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;QPS超过阈值，流控了.&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-客户端整合Sentinel控制台"><a href="#2-4-客户端整合Sentinel控制台" class="headerlink" title="2.4 客户端整合Sentinel控制台"></a>2.4 客户端整合Sentinel控制台</h3><p><a href="https://sentinelguard.io/zh-cn/docs/dashboard.html">https://sentinelguard.io/zh-cn/docs/dashboard.html</a></p><p>（1）下载控制台</p><p><a href="https://github.com/alibaba/Sentinel/releases">https://github.com/alibaba/Sentinel/releases</a></p><p>（2）启动控制台</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.8.5.jar<br></code></pre></td></tr></table></figure><p>（3）访问控制台：<a href="http://localhost:8080/">http://localhost:8080</a></p><p>（4）客户端引入与sentinel dashboard通信的jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-transport-simple-http<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（5）配置启动参数</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">Dcsp.sentinel.dashboard.server</span>=<span class="hljs-string">localhost:8080</span><br></code></pre></td></tr></table></figure><p><img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/9.png"></p><h2 id="3-整合Spring-Cloud-Alibaba-Sentinel"><a href="#3-整合Spring-Cloud-Alibaba-Sentinel" class="headerlink" title="3 整合Spring Cloud Alibaba Sentinel"></a>3 整合Spring Cloud Alibaba Sentinel</h2><p>可以注释掉sentinel-core、sentinel-annotation-aspectj、sentinel-transport-simple-http，因为 在sentinel starter中都包含了</p><p>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span><br></code></pre></td></tr></table></figure><p>（3）重启user服务，访问：<a href="http://localhost:8081/user/hello">http://localhost:8081/user/hello</a></p><p>（4）打开sentinel dashboard，配置流控规则</p><p><img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/10.png"></p><p>（5）原理</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ada">a-SphU#<span class="hljs-keyword">entry</span>核心代码在哪 <br>SentinelWebInterceptor#preHandle<br>... <br><span class="hljs-keyword">Entry</span> <span class="hljs-keyword">entry</span> = SphU.<span class="hljs-keyword">entry</span>(resourceName, ResourceTypeConstants.COMMON_WEB, EntryType.<span class="hljs-keyword">IN</span>)<br>b-规则什么时候保存到客户端的内存中的？<br>a-dashboard点击保存按钮<br>b-微服务收到dashboard推送过来的规则<br>c-微服务将规则保存到内存中<br></code></pre></td></tr></table></figure><p>（6）如何自定义流控之后的异常处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">SentinelWebInterceptor#preHandle<br>-&gt;<span class="hljs-keyword">catch</span>(Exception e)<br>-&gt;handleBlockException<br>-&gt;DefaultBlockExceptionHandler#handle<br></code></pre></td></tr></table></figure><p>（7）可以替换掉DefaultBlockExceptionHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JackWebMvcBlockExceptionHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockExceptionHandler</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, BlockException e)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">// Return 429 (Too Many Requests) by default.</span><br>response.setStatus(<span class="hljs-number">429</span>);<br><span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getWriter();<br><span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> FlowException)&#123;<br>out.print(<span class="hljs-string">&quot;Jack flow limit.&quot;</span>);<br>out.flush();<br>out.close();<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> DegradeException)&#123;<br>out.print(<span class="hljs-string">&quot;Jack degrade.&quot;</span>);<br>out.flush();<br>out.close();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-Sentinel客户端与服务端通信原理"><a href="#4-Sentinel客户端与服务端通信原理" class="headerlink" title="4 Sentinel客户端与服务端通信原理"></a>4 Sentinel客户端与服务端通信原理</h2><p><img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/11.png"></p><p>（1）服务注册+心跳机制：心跳时间间隔默认为10s，可以通过heartbeat-interval-ms进行修改</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">SimpleHttpHeartbeatSender<span class="hljs-meta">#sendHeartbeat</span><br></code></pre></td></tr></table></figure><p>（2）访问：<a href="http://localhost:8720/api%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0sentinel%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9Bapi">http://localhost:8720/api，就可以看到sentinel客户端提供了哪些api</a> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">客户端处理接口：CommandHandler<br></code></pre></td></tr></table></figure><p>（3）获取内存中的流控规则：<a href="http://localhost:8720/getRules?type=flow">http://localhost:8720/getRules?type=flow</a> </p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">FetchActiveRuleCommandHandler#handle<br>-&gt; <span class="hljs-string">&quot;flow&quot;</span><br></code></pre></td></tr></table></figure><p>（4）设置内存中的流控规则 </p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">ModifyRulesCommandHandler<span class="hljs-meta">#handle </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jvm调优</title>
    <link href="/2023/03/15/java%E5%9F%BA%E7%A1%80/jvm/jvm%E8%B0%83%E4%BC%98/"/>
    <url>/2023/03/15/java%E5%9F%BA%E7%A1%80/jvm/jvm%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1 常用命令"></a>1 常用命令</h2><p><strong>1. jps—查看java进程</strong></p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/1.png"></p><p><strong>2. jinfo：</strong></p><p>（1）实时查看和调整JVM配置参数</p><p>（2）用法：jinfo -flag name PID    查看某个java进程的name属性的值</p><p>​           例：jinfo -flag MaxHeapSize PID</p><p>​                  jinfo -flag UseG1GC PID</p><p>（3）修改：参数只有被标记为manageable的flags可以被实时修改</p><p>​           例：jinfo -flag [+|-] PID</p><p>​                   jinfo -flag <name>=<value> PID</p><p>（4）查看曾今赋过值的一些参数</p><pre><code class="hljs">               jinfo -flags PID</code></pre><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/2.png"></p><p><strong>3. jstat</strong></p><p>（1）查看虚拟机性能统计信息</p><p>（2）查看类装载信息：</p><p>​    jstat -class PID 1000 10 查看某个java进程的类装载信息，每1000毫秒输出一次，共输出10次</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/3.png"></p><p>（3）查看垃圾收集信息 ：jstat -gc PID 1000 10</p><p><strong>4. jstack</strong></p><p>（1）查看线程堆栈信息</p><p>（2）用法：jstack PID</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/4.png"></p><p>（3）排查死锁案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">DeadLock</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadLock</span>(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">DeadLock</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadLock</span>(<span class="hljs-literal">false</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(d1);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(d2);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLock</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>&#125;<br><span class="hljs-comment">//死锁代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> flag;<br>    DeadLock(<span class="hljs-type">boolean</span> flag)&#123;<br>        <span class="hljs-built_in">this</span>.flag = flag;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(flag)&#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">synchronized</span>(MyLock.obj1)&#123;<br>                    System.out.printLn(Thread.currentThread().getName() + <span class="hljs-string">&quot; -------if获得obj1的锁&quot;</span>)；<br>                    <span class="hljs-keyword">synchronized</span>(MyLock.obj2)&#123;<br>                    System.out.printLn(Thread.currentThread().getName() + <span class="hljs-string">&quot; -------否则获得obj2的锁&quot;</span>)<br>                &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">synchronized</span>(MyLock.obj2)&#123;<br>                    System.out.printLn(Thread.currentThread().getName() + <span class="hljs-string">&quot; -------if获得obj2的锁&quot;</span>)；<br>                    <span class="hljs-keyword">synchronized</span>(MyLock.obj1)&#123;<br>                    System.out.printLn(Thread.currentThread().getName() + <span class="hljs-string">&quot; -------否则获得obj1的锁&quot;</span>)<br>                &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/5.png"></p><p>jstack分析：</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/6.png"></p><p>把打印信息拉到最后发现</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/7.png"></p><p><strong>5. jmap</strong></p><p>（1）生成堆转储快照</p><p>（2）打印出堆内存相关信息</p><p>​    jmap -heap PID</p><p>​    jinfo -flag UsePSAdaptiveSurvivorSizePolicy 35352</p><p>​    -XX:SurvivorRatio=8</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/8.png"></p><p>（3）dump出堆内存相关信息</p><p>​    jmap -dump:format=b,file=heap.hprof PID</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/9.png"></p><p>（4）要是在发生堆内存溢出的时候，能自动dump出该文件就好了</p><p>​    一般在开发中，JVM参数可以加上下面两句，这样内存溢出时，会自动dump出该文件</p><p>​    -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap.hprof</p><p>​    设置堆内存大小: -Xms20M -Xmx20M</p><p>​    启动，然后访问localhost:9090/heap，使得堆内存溢出</p><h2 id="2-执行引擎"><a href="#2-执行引擎" class="headerlink" title="2 执行引擎"></a>2 执行引擎</h2><p>Person.java源码文件是Java这门高级开发语言，对程序员友好，方便我们开发。</p><p>​    javac编译器将Person.java源码文件编译成class文件[我们把这里的编译称为前期编译]，交给JVM运行，因为JVM只能认识class字节码文件。同时在不同的操作系统上安装对应版本的JDK，里面包含了各自屏蔽操作系统底层细节的JVM，这样同一份class文件就能运行在不同的操作系统平台之上，得益于JVM。这也是Write Once，Run Anywhere的原因所在。</p><p>​    最终JVM需要把字节码指令转换为机器码，可以理解为是0101这样的机器语言，这样才能运行在不同的机器上，那么由字节码转变为机器码是谁来做的呢？说白了就是谁来执行这些字节码指令的呢？这就是执行引擎。</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/10.png"></p><p><strong>1. 解释执行</strong></p><p>​    Interpreter，解释器逐条把字节码翻译成机器码并执行，跨平台的保证。 刚开始执行引擎只采用了解释执行的，但是后来发现某些方法或者代码块被调用执行的特别频繁时，就会把这些代码认定为“热点代码”。</p><p><strong>2. 即时编译器</strong></p><p>​    Just-In-Time compilation(JIT)，即时编译器先将字节码编译成对应平台的可执行文件，运行速度快。即时编译器会把这些热点代码编译成与本地平台关联的机器码，并且进行各层次的优化，保存到内存中。</p><p><strong>3. JVM采用哪种方式</strong></p><p>​    JVM采取的是混合模式，也就是解释+编译的方式，对于大部分不常用的代码，不需要浪费时间将其编译成机器码，只需要用到的时候再以解释的方式运行；对于小部分的热点代码，可以采取编译的方式，追求更高的运行效率。</p><p><strong>4. 即时编译器类型</strong></p><p>（1）HotSpot虚拟机里面内置了两个JIT：C1和C2</p><p>​    C1也称为Client Compiler，适用于执行时间短或者对启动性能有要求的程序</p><p>​    C2也称为Server Compiler，适用于执行时间长或者对峰值性能有要求的程序</p><p>（2）Java7开始，HotSpot会使用分层编译的方式</p><p>​    也就是会结合C1的启动性能优势和C2的峰值性能优势，热点方法会先被C1编译，然后热点方法中的热点会被C2再次编译。</p><p><strong>5. AOT和Graal VM</strong></p><p>（1）AOT</p><p>​    在Java9中，引入了AOT(Ahead-Of-Time)编译器，即时编译器是在程序运行过程中，将字节码翻译成机器码。而AOT是在程序运行之前，将字节码转换为机器码。</p><p>​    优势：这样不需要在运行过程中消耗计算机资源来进行即时编译</p><p>​    劣势：AOT 编译无法得知程序运行时的信息，因此也无法进行基于类层次分析的完全虚方法内联，或者基于程序 profile 的投机性优化（并非硬性限制，我们可以通过限制运行范围，或者利用上一次运行的程序 profile 来绕开这两个限制）</p><p>（2）Graal VM</p><p>​    官网：<a href="https://www.oracle.com/tools/graalvm-enterprise-edition.html">https://www.oracle.com/tools/graalvm-enterprise-edition.html</a></p><p>​    在Java10中，新的JIT编译器Graal被引入</p><p>​    它是一个以Java为主要编程语言，面向字节码的编译器。跟C++实现的C1和C2相比，模块化更加明显，也更加容易维护。</p><p>​    Graal既可以作为动态编译器，在运行时编译热点方法；也可以作为静态编译器，实现AOT编译。</p><p>​    除此之外，它还移除了编程语言之间的边界，并且支持通过即时编译技术，将混杂了不同的编程语言的代码编译到同一段二进制码之中，从而实现不同语言之间的无缝切换。</p><h2 id="3-工具"><a href="#3-工具" class="headerlink" title="3 工具"></a>3 工具</h2><h3 id="3-1-jconsole"><a href="#3-1-jconsole" class="headerlink" title="3.1 jconsole"></a>3.1 jconsole</h3><p>jconsole工具是JDK自带的可视化监控工具。查看java应用程序的运行概况、监控堆信息、永久区使用情况、类加载情况等。命令行中输入：jconsole。</p><h3 id="3-2-jvisualvm"><a href="#3-2-jvisualvm" class="headerlink" title="3.2 jvisualvm"></a>3.2 jvisualvm</h3><p>命令行中输入：jvisualvm。Visual GC插件下载地址：<a href="https://visualvm.github.io/pluginscenters.html%E3%80%82">https://visualvm.github.io/pluginscenters.html。</a></p><ol><li><p>监控本地进程：可以监控本地的java进程的CPU，类，线程等</p></li><li><p>监控远端java进程：</p></li></ol><p>​       1）在visualvm中选中“远程”，右击“添加”</p><p>​       2）主机名上写服务器的ip地址，比如39.100.39.63，然后点击“确定”</p><p>​       3）右击该主机”39.100.39.63”，添加“JMX”，就是通过JMX技术具体监控远端服务器哪个Java进程</p><p>​       4）要想让服务器上的tomcat被连接，需要改一下Catalina.sh这个文件。</p><p>​       注意下面的8998不要和服务器上其他端口冲突。</p><p>​        5）在../conf文件中添加两个文件jmxremote.access和jmxremote.password</p><p>​    jmxremote.access：guest readonly</p><p>​                   manager readwrite</p><p>​    jmxremote.password：guest guest</p><p>​                     manager manager</p><p>​    授予权限：chmod 600 jmxremot</p><pre><code class="hljs">    6）将连接服务器地址改为公网ip地址</code></pre><p>​        7）设置上述端口对应的阿里云安全策略和防火墙策略</p><pre><code class="hljs">    8）启动tomcat，来到bin目录：./startup.sh   9）查看tomcat启动日志以及端口监听</code></pre><p>​       tail -f ../logs/catalina.out      lsof -i tcp:8080</p><p>​        10）查看8998监听情况，可以发现多开了几个端口</p><p>​       lsof -i:8998 得到PID         netstat -antup | grep PID</p><pre><code class="hljs">    11）在刚才的JMX中输入8998端口，并且输入用户名和密码则登录成功</code></pre><h3 id="3-3-arthas"><a href="#3-3-arthas" class="headerlink" title="3.3 arthas"></a>3.3 arthas</h3><p><a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></p><p>Arthas 是Alibaba开源的Java诊断工具，采用命令行交互模式，是排查jvm相关问题的利器。</p><p>（1）下载安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl -o https://alibaba.github.io/arthas/arthas-boot.jar<br>java -jar artjas-boot.jar<br>or<br>java -jar arthas-boot.jar -h<br><span class="hljs-comment"># 然后可以选择一个java进程</span><br></code></pre></td></tr></table></figure><p>（2）常用命令</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">version：查看版本号<br>help：查看命名帮助信息<br>cls：清空屏幕<br>session：查看当前会话信息<br><span class="hljs-section">quit：推出客户端</span><br><span class="hljs-section">-----</span><br>dashboard：当前进程的实时数据面板<br>thread：当前JVM的线程堆栈信息<br>jvm：查看当前JVM的信息<br><span class="hljs-section">sysprop：查看JVM的系统属性</span><br><span class="hljs-section">-----</span><br>sc：查看JVM已经加载的类信息<br>dump：dump已经加载类的byte code到指定目录<br><span class="hljs-section">jad：反编译指定已加载类的源码</span><br><span class="hljs-section">-----</span><br>monitor：方法执行监控<br>watch：方法执行数据观测<br>trace：方法内部调用路径，并输出方法路径上的每个节点上耗时<br>stack：输出当前方法被调用的调用路径<br>...<br></code></pre></td></tr></table></figure><h3 id="3-4-内存分析"><a href="#3-4-内存分析" class="headerlink" title="3.4 内存分析"></a>3.4 内存分析</h3><ol><li>MAT</li></ol><p>​    Java堆分析器，用于查找内存泄漏。Heap Dump，称为堆转储文件，是Java进程在某个时间内的快照。它在触发快照的时候保存了很多信息：Java对象和类信息。通常在写Heap Dump文件前会触发一次Full GC。</p><p>下载地址 ：<a href="https://www.eclipse.org/mat/downloads.php">https://www.eclipse.org/mat/downloads.php</a></p><p>1）获取dump文件</p><p>​    手动：jmap -dump:format=b,file=heap.hprof 44808</p><p>​    自动：-XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=heap.hprof</p><p>2）使用</p><p><strong>Histogram</strong>：可以列出内存中的对象，对象的个数及其大小</p><p>​       Class Name:类名称，java类名</p><p>​       Objects:类的对象的数量，这个对象被创建了多少个</p><p>​       Shallow Heap:一个对象内存的消耗大小，不包含对其他对象的引用</p><p>​       Retained Heap:是shallow Heap的总和，即该对象被GC之后所能回收到内存的总和</p><p>​       右击类名—&gt;List Objects—&gt;with incoming references—&gt;列出该类的实例</p><p>​       右击Java对象—&gt;Merge Shortest Paths to GC Roots—&gt;exclude all …—&gt;找到GC Root以及原因</p><p><strong>Leak Suspects</strong>：查找并分析内存泄漏的可能原因</p><p><strong>Top Consumers</strong>：列出大对象</p><h3 id="3-5-GC日志分析"><a href="#3-5-GC日志分析" class="headerlink" title="3.5 GC日志分析"></a>3.5 GC日志分析</h3><p>要想分析日志的信息，得先拿到GC日志文件才行。比如打开windows中的catalina.bat，在第一行加上</p><p>​    XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps</p><p>​    -Xloggc:$CATALINA_HOME/logs/gc.log</p><p>1.不同收集器的日志</p><p>​    这样使用startup.bat启动tomcat的时候就能够在当前目录下拿到gc.log文件，可以看到默认使用的是ParallelGC。</p><p>​    （1）Parallel GC 吞吐量优先</p><p>​       【2019-06-10T23:21:53.305+0800: 1.303: [GC (Allocation Failure) [PSYoungGen:65536K[Young区回  收前]-&gt;10748K[Young区回收后]76288K[Young区总大小]] 65536K[整个堆回收前]-&gt;15039K[整个堆回    收后]251392K[整个堆总大小], 0.0113277 secs] [Times:user=0.00 sys=0.00, real=0.01 secs]】</p><p>​       注意如果回收的差值中间有出入，说明这部分空间是Old区释放出来的。</p><p>（2）CMS 停顿时间优先</p><p>​    参数设置：-XX:+UseConcMarkSweepGC -Xloggc:cms-gc.log</p><p>​    重启tomcat获取gc日志，这里的日志格式和上面差不多，不作分析。</p><p>​    （3）G1 停顿时间优先</p><p>​    G1日志格式参考链接：<a href="https://blogs.oracle.com/poonam/understanding-g1-gc-logs%E3%80%82">https://blogs.oracle.com/poonam/understanding-g1-gc-logs。</a></p><p>​    参数设置：-XX:+UseG1GC -Xloggc:g1-gc.log</p><p>-XX:+UseG1GC # 使用了G1垃圾收集器</p><p>​    # 什么时候发生的GC，相对的时间刻，GC发生的区域young，总共花费的时间，0.00478s，</p><p>​    # It is a stop-the-world activity and all</p><p>​    # the application threads are stopped at a safepoint during this time.</p><p>​    2019-12-18T16:06:46.508+0800: 0.458: [GC pause (G1 Evacuation Pause)(young), 0.0047804 secs]</p><p>​    # 多少个垃圾回收线程，并行的时间</p><p>​    [Parallel Time: 3.0 ms, GC Workers: 4]</p><p>​    # GC线程开始相对于上面的0.458的时间刻</p><p>​    [GC Worker Start (ms): Min: 458.5, Avg: 458.5, Max: 458.5, Diff: 0.0]</p><p>​    # This gives us the time spent by each worker thread scanning the roots</p><p>​    # (globals, registers, thread stacks and VM data structures).</p><p>​    [Ext Root Scanning (ms): Min: 0.2, Avg: 0.4, Max: 0.7, Diff: 0.5, Sum: 1.7]</p><p>​    # Update RS gives us the time each thread spent in updating the RememberedSets.</p><p>​    [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</p><p>​    …</p><p>​    # 主要是Eden区变大了，进行了调整</p><p>​    [Eden: 14.0M(14.0M)-&gt;0.0B(16.0M) Survivors: 0.0B-&gt;2048.0K Heap: 14.0M(256.0M)-&gt;3752.5K(256.0M)]</p><ol start="2"><li>GCViewer</li></ol><p>​    java -jar gcviewer-1.36-SNAPSHOT.jar</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/11.png"></p><ol start="3"><li><p>gceasy ： <a href="http://gceasy.io/">http://gceasy.io</a></p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/12.png"></p></li><li><p>gcplot  <a href="https://it.gcplot.com/">https://it.gcplot.com/</a></p></li></ol><h2 id="4-性能优化"><a href="#4-性能优化" class="headerlink" title="4 性能优化"></a>4 性能优化</h2><h3 id="4-1-内存"><a href="#4-1-内存" class="headerlink" title="4.1 内存"></a>4.1 内存</h3><ol><li>内存分配</li></ol><p>​    正常情况下不需要设置，那如果是促销或者秒杀的场景呢？</p><p>​    每台机器配置2c4G，以每秒3000笔订单为例，整个过程持续60秒</p><ol start="2"><li>内存溢出，一般会有两个原因：</li></ol><p>​    （1）大并发情况下</p><p>​    （2）内存泄露导致内存溢出</p><p>​    3. 大并发【秒杀】</p><p>​        浏览器缓存、本地缓存、验证码</p><p>​        CDN静态资源服务器</p><p>​        集群+负载均衡</p><p>​        动静态资源分离、限流[基于令牌桶、漏桶算法]</p><p>​        应用级别缓存、接口防刷限流、队列、Tomcat性能优化</p><p>​        异步消息中间件</p><p>​        Redis热点数据对象缓存</p><p>​        分布式锁、数据库锁</p><p>​        5分钟之内没有支付，取消订单、恢复库存等</p><p>​    4. 内存泄漏导致内存溢出</p><p>​    ThreadLocal引起的内存泄露，最终导致内存溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TLController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/tl&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">tl</span><span class="hljs-params">(HttpServletRequest request)</span>&#123;<br>        ThreadLocal&lt;Byte[]&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>        tl.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    （1）上传到阿里云服务器</p><p>​       jvm-case-0.0.1-SNAPSHOT.jar</p><p>​    （2）启动</p><p>​       java -jar -Xms1000M -Xmx1000M -XX:+HeapDumpOnOutOfMemoryError -</p><p>​       XX:HeapDumpPath=jvm.hprof jvm-case-0.0.1-SNAPSHOT.jar</p><p>​    （3）使用jmeter模拟10000次并发</p><p>​       39.100.39.63:8080/tl</p><p>​    （4）top命令查看</p><p>​       top</p><p>​       top -Hp PID</p><p>​    （5）jstack查看线程情况，发现没有死锁或者IO阻塞的情况</p><p>​       jstack PID</p><p>​       java -jar arthas.jar —&gt; thread</p><p>​    （6）查看堆内存的使用，发现堆内存的使用率已经高达88.95%</p><p>​       jmap -heap PID</p><p>​       java -jar arthas.jar —&gt; dashboard</p><p>​    （7）此时可以大体判断出来，发生了内存泄露从而导致的内存溢出，那怎么排查呢？</p><p>​       jmap -histo:live PID | more</p><p>​       获取到jvm.hprof文件，上传到指定的工具分析，比如heaphero.io</p><h3 id="4-2-GC（这里以G1垃圾收集器调优为例）"><a href="#4-2-GC（这里以G1垃圾收集器调优为例）" class="headerlink" title="4.2 GC（这里以G1垃圾收集器调优为例）"></a>4.2 GC（这里以G1垃圾收集器调优为例）</h3><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/G1.html#use_cases">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/G1.html#use_cases</a></p><p>​    （1）50%以上的堆被存活对象占用</p><p>​    （2）对象分配和晋升的速度变化非常大</p><p>​    （3）垃圾回收时间比较长</p><p><strong>G1调优</strong></p><p>（1）使用G1GC垃圾收集器: -XX:+UseG1GC</p><p>修改配置参数，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/13.png"></p><p>（2）调整内存大小再获取gc日志分析</p><p>​       -XX:MetaspaceSize=100M</p><p>​       -Xms300M</p><p>​       -Xmx300M</p><p>​       比如设置堆内存的大小，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/14.png"></p><p>（3）调整最大停顿时间</p><p>​    -XX:MaxGCPauseMillis=200 设置最大GC停顿时间指标</p><p>​    比如设置最大停顿时间，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/15.png"></p><p>（4）启动并发GC时堆内存占用百分比</p><p>​       -XX:InitiatingHeapOccupancyPercent=45</p><p>​       G1用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比例。值为 0 则表示 “一直执行GC循环)’. 默认值为 45 (例如, 全部的 45% 或者使用了45%).</p><p>​       比如设置该百分比参数，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/16.png"></p><p>​    <strong>G1调优最佳实战</strong></p><p>​    官网：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#recommendations">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#recommendations</a></p><p>（1）不要手动设置新生代和老年代的大小，只要设置整个堆的大小</p><p>​    why：<a href="https://blogs.oracle.com/poonam/increased-heap-usage-with-g1-gc">https://blogs.oracle.com/poonam/increased-heap-usage-with-g1-gc</a></p><p>​    G1收集器在运行过程中，会自己调整新生代和老年代的大小，其实是通过adapt代的大小来调整对象晋升的速度和年龄，从而达到为收集器设置的暂停时间目标，如果手动设置了大小就意味着放弃了G1的自动调优</p><p>​    （2）不断调优暂停时间目标</p><p>​    一般情况下这个值设置到100ms或者200ms都是可以的(不同情况下会不一样)，但如果设置成50ms就不太合理。暂停时间设置的太短，就会导致出现G1跟不上垃圾产生的速度。最终退化成Full GC。所以对这个参数的调优是一个持续的过程，逐步调整到最佳状态。暂停时间只是一个目标，并不能总是得到满足。</p><p>​    （3）使用-XX:ConcGCThreads=n来增加标记线程的数量</p><p>​    IHOP如果阀值设置过高，可能会遇到转移失败的风险，比如对象进行转移时空间不足。如果阀值设置过低，就会使标记周期运行过于频繁，并且有可能混合收集期回收不到空间。IHOP值如果设置合理，但是在并发周期时间过长时，可以尝试增加并发线程数，调高ConcGCThreads。</p><p>​    （4）MixedGC调优</p><p>​    -XX:InitiatingHeapOccupancyPercent</p><p>​    -XX:G1MixedGCLiveThresholdPercent</p><p>​    -XX:G1MixedGCCountTarger</p><p>​    -XX:G1OldCSetRegionThresholdPercent</p><p>​    （5）适当增加堆内存大小</p><p>​    （6）不正常的Full GC</p><p>​    有时候会发现系统刚刚启动的时候，就会发生一次Full GC，但是老年代空间比较充足，一般是由Metaspace区域引起的。可以通过MetaspaceSize适当增加其大家，比如256M。</p><h3 id="4-3-CPU占用率高"><a href="#4-3-CPU占用率高" class="headerlink" title="4.3 CPU占用率高"></a>4.3 CPU占用率高</h3><p>（1）top</p><p>（2）top -Hp PID</p><p>​       查看进程中占用CPU高的线程id，即tid</p><p>（3）jstack PID | grep tid</p><h2 id="5-JVM性能优化指南"><a href="#5-JVM性能优化指南" class="headerlink" title="5 JVM性能优化指南"></a>5 JVM性能优化指南</h2><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/17.png"></p><h2 id="6-常见问题"><a href="#6-常见问题" class="headerlink" title="6 常见问题"></a>6 常见问题</h2><ol><li>内存泄漏与内存溢出的区别</li></ol><p>​    内存泄漏是指不再使用的对象无法得到及时的回收，持续占用内存空间，从而造成内存空间的浪费。</p><p>​    内存泄漏很容易导致内存溢出，但内存溢出不一定是内存泄漏导致的。</p><ol start="2"><li>young gc会有stw吗？</li></ol><p>​    不管什么 GC，都会发送 stop-the-world，区别是发生的时间长短。而这个时间跟垃圾收集器又有关系，Serial、PartNew、Parallel Scavenge 收集器无论是串行还是并行，都会挂起用户线程，而 CMS和 G1 在并发标记时，是不会挂起用户线程的，但其它时候一样会挂起用户线程，stop the world 的时间相对来说就小很多了。</p><ol start="3"><li>major gc和full gc的区别</li></ol><p>​    Major GC在很多参考资料中是等价于 Full GC 的，也可以发现很多性能监测工具中只有 Minor GC和 Full GC。一般情况下，一次 Full GC 将会对年轻代、老年代、元空间以及堆外内存进行垃圾回收。触发 Full GC 的原因有很多：当年轻代晋升到老年代的对象大小，并比目前老年代剩余的空间大小还要大时，会触发 Full GC；当老年代的空间使用率超过某阈值时，会触发 Full GC；当元空间不足时（JDK1.7永久代不足），也会触发 Full GC；当调用 System.gc() 也会安排一次 Full GC。</p><ol start="4"><li>什么是直接内存</li></ol><p>​    Java的NIO库允许Java程序使用直接内存。直接内存是在java堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于Java堆。因此出于性能的考虑，读写频繁的场合可能会考虑使用直接内存。由于直接内存在java堆外，因此它的大小不会直接受限于Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p><ol start="5"><li>垃圾判断的方式</li></ol><p>​    引用计数法：指的是如果某个地方引用了这个对象就+1，如果失效了就-1，当为0就会回收但是JVM没有用这种方式，因为无法判定相互循环引用（A引用B,B引用A）的情况。</p><p>​    引用链法： 通过一种GC ROOT的对象（方法区中静态变量引用的对象等-static变量）来判断，如果有一条链能够到达GC ROOT就说明，不能到达GC ROOT就说明可以回收。</p><ol start="6"><li>不可达的对象一定要被回收吗？</li></ol><p>​    即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><ol start="7"><li>为什么要区分新生代和老年代？</li></ol><p>​    当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><ol start="8"><li>G1与CMS的区别是什么</li></ol><p>​    CMS 主要集中在老年代的回收，而 G1 集中在分代回收，包括了年轻代的 Young GC 以及老年代的 Mix GC；G1 使用了 Region 方式对堆内存进行了划分，且基于标记整理算法实现，整体减少了垃圾碎片的</p><p>产生；在初始化标记阶段，搜索可达对象使用到的 Card Table，其实现方式不一样。</p><ol start="9"><li>方法区中的无用类回收</li></ol><p>  方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>​    判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。</p><p>​    类需要同时满足下面 3 个条件才能算是 “无用的类” :</p><p>​    a-该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</p><p>​    b-加载该类的 ClassLoader 已经被回收。</p><p>​    c-该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gateway</title>
    <link href="/2023/03/13/spring%E6%A1%86%E6%9E%B6/springcloud/gateway/gateway/"/>
    <url>/2023/03/13/spring%E6%A1%86%E6%9E%B6/springcloud/gateway/gateway/</url>
    
    <content type="html"><![CDATA[<h2 id="1-为什么需要网关"><a href="#1-为什么需要网关" class="headerlink" title="1 为什么需要网关"></a>1 为什么需要网关</h2><p>（1）如果没有网关，各个微服务就需要对外暴露很多端口，访问不方便并且不安全 </p><p>（2）如果没有网关，很多微服务都需要单独认证授权，比较麻烦 </p><p>（3）有些微服务使用的是不同的通信协议，如果没有网关，则客户端访问变得很不方便</p><p>等等。。。</p><h2 id="2-常见的网关产品"><a href="#2-常见的网关产品" class="headerlink" title="2 常见的网关产品"></a>2 常见的网关产品</h2><p><a href="https://landscape.cncf.io/">https://landscape.cncf.io/</a></p><p><img src="/image/springcloud/gateway/1.png"></p><h2 id="3-Spring-Cloud-Gateway-Features"><a href="#3-Spring-Cloud-Gateway-Features" class="headerlink" title="3 Spring Cloud Gateway Features"></a>3 Spring Cloud Gateway Features</h2><p>Built on Spring Framework 5, Project Reactor and Spring Boot 2.0 </p><p>Able to match routes on any request attribute. </p><p>Predicates and filters are specific to routes. </p><p>Circuit Breaker integration. </p><p>Spring Cloud DiscoveryClient integration </p><p>Easy to write Predicates and Filters </p><p>Request Rate Limiting </p><p>Path Rewriting</p><p><img src="/image/springcloud/gateway/2.png"></p><h2 id="4-工作流程"><a href="#4-工作流程" class="headerlink" title="4 工作流程"></a>4 工作流程</h2><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-how-it-works">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-how-it-works</a></p><p><img src="/image/springcloud/gateway/3.png"></p><h2 id="5-Glossary-术语"><a href="#5-Glossary-术语" class="headerlink" title="5 Glossary[术语]"></a>5 Glossary[术语]</h2><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#glossary">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#glossary</a></p><h3 id="5-1-Route"><a href="#5-1-Route" class="headerlink" title="5.1 Route"></a>5.1 Route</h3><p>The basic building block of the gateway. It is defined by an ID, a destination URI, a collection of predicates, and a collection of filters. A route is matched if the aggregate predicate is true.</p><h3 id="5-2-Predicate"><a href="#5-2-Predicate" class="headerlink" title="5.2 Predicate"></a>5.2 Predicate</h3><p>This is a Java 8 Function Predicate. The input type is a Spring Framework ServerWebExchange. This lets you match on anything from the HTTP request, such as headers or parameters.</p><h3 id="5-3-Filter"><a href="#5-3-Filter" class="headerlink" title="5.3 Filter"></a>5.3 Filter</h3><p>These are instances of GatewayFilter that have been constructed with a specific factory. Here, you can modify requests and responses before or after sending the downstream request.</p><h3 id="5-4-图解"><a href="#5-4-图解" class="headerlink" title="5.4 图解"></a>5.4 图解</h3><p><img src="/image/springcloud/gateway/4.png"></p><h2 id="6-Gateway初体验"><a href="#6-Gateway初体验" class="headerlink" title="6 Gateway初体验"></a>6 Gateway初体验</h2><h3 id="6-1-基本搭建流程"><a href="#6-1-基本搭建流程" class="headerlink" title="6.1 基本搭建流程"></a>6.1 基本搭建流程</h3><p>（1）创建Spring Boot项目，名称为gateway，选择gateway的依赖，并修改端口号为8090 </p><p>（2）修改Spring Boot和Spring Cloud版本</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Spring</span> Boot: <span class="hljs-number">2</span>.<span class="hljs-number">7</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">Spring</span> Cloud: <span class="hljs-number">2021</span>.<span class="hljs-number">0</span>.<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>（3）添加SCA Dependencies管理和Nacos Discovery</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入spring cloud alibaba 版本管理--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>---<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（4）自定义路由规则和服务发现路由</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8090</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-comment"># nacos注册中心地址</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-attr">service:</span> <span class="hljs-string">gateway</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-comment"># 自定义路由规则</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-comment"># 路由的匹配条件 localhost:8090/jack/user/hello ---&gt;</span><br>      <span class="hljs-comment"># localhost:8081/jack/user/hello [没有 -StripPrefix过滤器的情况]</span><br>      <span class="hljs-comment"># 路由的匹配条件 localhost:8090/jack/user/hello ---&gt;</span><br>      <span class="hljs-comment"># localhost:8081/user/hello [有 -StripPrefix过滤器的情况]</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">jack_path_route</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8081</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/jack/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">locator:</span><br>          <span class="hljs-comment"># 开启网关服务发现的能力</span><br>          <span class="hljs-comment"># localhost:8090/user --[loadbalancer]-&gt; localhost:8081</span><br>          <span class="hljs-comment"># localhost:8090/user/user/hello ---&gt; localhost:8081/user/hello</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>（5）启动gateway</p><p>（6）访问测试 </p><p>自定义路由规则：<a href="http://localhost:8090/jack/user/hello">http://localhost:8090/jack/user/hello</a> </p><p>基于服务发现的路由规则：<a href="http://localhost:8090/user/user/hello">http://localhost:8090/user/user/hello</a>  </p><p>发现基于服务发现的路由规则访问失败，因为没有引入loadbalancer依赖</p><h3 id="6-2-引入loadbalancer依赖解决负载均衡问题"><a href="#6-2-引入loadbalancer依赖解决负载均衡问题" class="headerlink" title="6.2 引入loadbalancer依赖解决负载均衡问题"></a>6.2 引入loadbalancer依赖解决负载均衡问题</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6-3-设置日志级别"><a href="#6-3-设置日志级别" class="headerlink" title="6.3 设置日志级别"></a>6.3 设置日志级别</h3><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#troubleshooting">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#troubleshooting</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">reactor.netty:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h2 id="7-Actuator-API"><a href="#7-Actuator-API" class="headerlink" title="7 Actuator API"></a>7 Actuator API</h2><h3 id="7-1-整合actuator"><a href="#7-1-整合actuator" class="headerlink" title="7.1 整合actuator"></a>7.1 整合actuator</h3><p>（1）引入spring-boot-starter-actuator依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-comment"># 或者指定为gateway</span><br>  <span class="hljs-attr">endpoint:</span><br>    <span class="hljs-attr">health:</span><br>      <span class="hljs-attr">show-details:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></table></figure><p>（3）常见api操作</p><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#recap-the-list-of-all-endpoints">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#recap-the-list-of-all-endpoints</a></p><p><img src="/image/springcloud/gateway/5.png"></p><h3 id="7-2-动态添加路由信息"><a href="#7-2-动态添加路由信息" class="headerlink" title="7.2 动态添加路由信息"></a>7.2 动态添加路由信息</h3><p>（1）创建路由信息：使用<a href="http://localhost:8090/actuator/gateway/routes/jack_dynamic_route%EF%BC%8C%E5%8F%91">http://localhost:8090/actuator/gateway/routes/jack_dynamic_route，发</a> 送POST请求</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jack_dynamic_route&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;predicates&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Path&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_genkey_0&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/dynamic&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;filters&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;StripPrefix&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;parts&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;uri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://www.gupaoedu.com&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;order&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>（2）刷新并查看路由信息</p><p><a href="http://localhost:8090/actuator/gateway/refresh">http://localhost:8090/actuator/gateway/refresh</a></p><p><a href="http://localhost:8090/actuator/gateway/routes">http://localhost:8090/actuator/gateway/routes</a></p><p>（3）访问 <a href="http://localhost:8090/dynamic">http://localhost:8090/dynamic</a></p><h2 id="8-Gateway整合Nacos实现动态路由"><a href="#8-Gateway整合Nacos实现动态路由" class="headerlink" title="8 Gateway整合Nacos实现动态路由"></a>8 Gateway整合Nacos实现动态路由</h2><h3 id="8-1-环境搭建"><a href="#8-1-环境搭建" class="headerlink" title="8.1 环境搭建"></a>8.1 环境搭建</h3><p>（1）在nacos server上创建gateway.yaml文件，用于保存gateway的路由配置信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">nacos_route</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">https://www.baidu.com</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/nacos/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br></code></pre></td></tr></table></figure><p><img src="/image/springcloud/gateway/6.png"></p><p>（2）在gateway工程中引入nacos相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（3）创建bootstrap.yaml文件并配置相关值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span><br>        <span class="hljs-string">shard-config[0]:</span><br>          <span class="hljs-attr">dataId:</span> <span class="hljs-string">gateway.yaml</span><br>          <span class="hljs-attr">refresh:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>（4）重启gateway工程，通过actuator查看路由信息</p><p><a href="http://localhost:8090/actuator/gateway/routes">http://localhost:8090/actuator/gateway/routes</a></p><p>（5）访问：<a href="http://localhost:8090/nacos">http://localhost:8090/nacos</a> </p><p>（6）在nacos server上动态修改uri：比如将<a href="https://www.baidu.com/">https://www.baidu.com</a> -&gt; <a href="https://www.alibaba.com/">https://www.alibaba.com</a> </p><p>（7）重启gateway，再次访问：<a href="http://localhost:8090/nacos">http://localhost:8090/nacos</a></p><h3 id="8-2-Nacos-Gateway动态刷新原理"><a href="#8-2-Nacos-Gateway动态刷新原理" class="headerlink" title="8.2 Nacos Gateway动态刷新原理"></a>8.2 Nacos Gateway动态刷新原理</h3><p>（1）根据之前Nacos配置中心源码，可以知道在Nacos配置修改之后，会push数据给client 端 </p><p>（2）然后在nacos客户端会调用NacosContextRefresher#registerNacosListener </p><p>（3）在这段代码中发布了RefreshEvent事件，该事件由RefreshEventListener监听器监听到了 </p><p>（4）调用this#refresh#refresh()方法 </p><p>（5）调用this#scope#refreshAll()方法 </p><p>（6）发布RefreshScopeRefreshEvent事件：this#context#publishEvent(new RefreshScopeRefreshedEvent()) </p><p>（7）由RouteRefreshListener监听器监听到了，判断事件类型 </p><p>（8）调用reset方法，发布RefreshRoutesEvent事件 </p><p>（9）最终调用CachingRouteLocator#onApplicationEvent完成路由规则的更新</p><h2 id="9-Predicate与Filter的两种配置方式"><a href="#9-Predicate与Filter的两种配置方式" class="headerlink" title="9 Predicate与Filter的两种配置方式"></a>9 Predicate与Filter的两种配置方式</h2><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#configuring-route-predicate-factories-and-gateway-filter-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#configuring-route-predicate-factories-and-gateway-filter-factories</a></p><h3 id="9-1-Short-Configuration"><a href="#9-1-Short-Configuration" class="headerlink" title="9.1 Short Configuration"></a>9.1 Short Configuration</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">after_route</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span><br>        <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Cookie=mycookie,mycookievalue</span><br></code></pre></td></tr></table></figure><h3 id="9-2-Fully-Expaned-Arguments"><a href="#9-2-Fully-Expaned-Arguments" class="headerlink" title="9.2 Fully Expaned Arguments"></a>9.2 Fully Expaned Arguments</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">after_route</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span><br>        <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cookie</span><br>          <span class="hljs-attr">args:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">mycookie</span><br>            <span class="hljs-attr">regexp:</span> <span class="hljs-string">mycookievalue</span><br></code></pre></td></tr></table></figure><h2 id="10-理解Route-Predicate-Factories"><a href="#10-理解Route-Predicate-Factories" class="headerlink" title="10 理解Route Predicate Factories"></a>10 理解Route Predicate Factories</h2><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories</a></p><h3 id="10-1-常见的Predicate"><a href="#10-1-常见的Predicate" class="headerlink" title="10.1 常见的Predicate"></a>10.1 常见的Predicate</h3><p><img src="/image/springcloud/gateway/7.png"></p><h3 id="10-2-Predicate简介"><a href="#10-2-Predicate简介" class="headerlink" title="10.2 Predicate简介"></a>10.2 Predicate简介</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PredicateTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Predicate&lt;String&gt; lenPredicate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;String&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span> &#123;<br><span class="hljs-keyword">return</span> str.length() &gt; <span class="hljs-number">8</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;;<br>List&lt;String&gt; sc = Arrays.asList(<span class="hljs-string">&quot;Nacos&quot;</span>, <span class="hljs-string">&quot;LoadBalancer&quot;</span>, <span class="hljs-string">&quot;OpenFeign&quot;</span>, <span class="hljs-string">&quot;Gateway&quot;</span>, <span class="hljs-string">&quot;Sentinel&quot;</span>, <span class="hljs-string">&quot;Seata&quot;</span>);<br>sc.stream().filter(lenPredicate).forEach(System.out::println);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-3-分析PathRoutePredicateFactory"><a href="#10-3-分析PathRoutePredicateFactory" class="headerlink" title="10.3 分析PathRoutePredicateFactory"></a>10.3 分析PathRoutePredicateFactory</h3><p>（1）Predicate配置</p><p><img src="/image/springcloud/gateway/8.png"></p><p>（2）debug查看</p><p><img src="/image/springcloud/gateway/9.png"></p><h3 id="10-4-分析AfterRoutePredicateFactory"><a href="#10-4-分析AfterRoutePredicateFactory" class="headerlink" title="10.4 分析AfterRoutePredicateFactory"></a>10.4 分析AfterRoutePredicateFactory</h3><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-after-route-predicate-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-after-route-predicate-factory</a></p><p>（1）配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">gateway:</span><br>  <span class="hljs-attr">routes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">path_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8081</span><br>      <span class="hljs-attr">predicates:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/test/**</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">After=2023-01-20T17:42:47.789-07:00[America/Denver]</span><br>      <span class="hljs-attr">filters:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br></code></pre></td></tr></table></figure><p>（2）访问：<a href="http://localhost:8090/jack/user/hello">http://localhost:8090/jack/user/hello</a> </p><p>（3）debug：AfterRoutePredicateFactory#apply</p><h3 id="10-5-体验HeaderRoutePredicateFactory"><a href="#10-5-体验HeaderRoutePredicateFactory" class="headerlink" title="10.5 体验HeaderRoutePredicateFactory"></a>10.5 体验HeaderRoutePredicateFactory</h3><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-header-route-predicate-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-header-route-predicate-factory</a></p><p>（1）添加Header的Predicate</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">gateway:</span><br>  <span class="hljs-attr">routes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">path_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8081</span><br>      <span class="hljs-attr">predicates:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/test/**</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">After=2023-01-20T17:42:47.789-07:00[America/Denver]</span><br>      <span class="hljs-attr">filters:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>       <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">header_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://order</span><br>      <span class="hljs-attr">predicates:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/test2/**</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">Header=X-Request-Id,</span> <span class="hljs-string">\d+</span><br>      <span class="hljs-attr">filters:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br></code></pre></td></tr></table></figure><h3 id="10-6-自定义Predicate"><a href="#10-6-自定义Predicate" class="headerlink" title="10.6 自定义Predicate"></a>10.6 自定义Predicate</h3><p>需求：定义一个断言工厂，实现时间区间的访问功能</p><p>（1）引入lombok依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）创建配置类JackTimeBetweenConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JackTimeBetweenConfig</span> &#123;<br><span class="hljs-keyword">private</span> LocalTime begin;<br><span class="hljs-keyword">private</span> LocalTime end;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）创建断言工厂类JackTimeBetweenRoutePredicateFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JackTimeBetweenRoutePredicateFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRoutePredicateFactory</span>&lt;JackTimeBetweenConfig&gt; &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">JackTimeBetweenRoutePredicateFactory</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>(JackTimeBetweenConfig.class);<br>&#125;<br><span class="hljs-comment">// 定义配置类与配置文件的映射关系</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">shortcutFieldOrder</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">&quot;begin&quot;</span>,<span class="hljs-string">&quot;end&quot;</span>);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Predicate&lt;ServerWebExchange&gt; <span class="hljs-title function_">apply</span><span class="hljs-params">(JackTimeBetweenConfig config)</span> &#123;<br><span class="hljs-comment">// 获取配置文件中的值</span><br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> config.getBegin();<br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> config.getEnd();<br><span class="hljs-comment">// Predicate完整语法</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;ServerWebExchange&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(ServerWebExchange serverWebExchange)</span> &#123;<br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalTime.now();<br><span class="hljs-keyword">return</span> now.isAfter(begin) &amp;&amp; now.isBefore(end);<br>&#125;<br>&#125;;<br><span class="hljs-comment">// lambda表达式写法</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">return serverWebExchange -&gt; &#123;</span><br><span class="hljs-comment">LocalTime now = LocalTime.now();</span><br><span class="hljs-comment">return now.isAfter(begin) &amp;&amp; now.isBefore(end);</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）查看时间格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// DateTimeFormatterRegistrar#getFallbackFormatter#TIME</span><br>System.out.println(DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT).format(LocalTime.now())); <br>    <span class="hljs-comment">// 上午9:00</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（5）配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">gateway:</span><br>  <span class="hljs-attr">routes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">path_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8081</span><br>      <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/test/**</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">JackTimeBetween=上午1:00,下午2:00</span><br>      <span class="hljs-attr">filters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br></code></pre></td></tr></table></figure><h2 id="11-GatewayFilter-Factories-局部"><a href="#11-GatewayFilter-Factories-局部" class="headerlink" title="11 GatewayFilter Factories[局部]"></a>11 GatewayFilter Factories[局部]</h2><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories</a></p><h3 id="11-1-常见的GatewayFilter"><a href="#11-1-常见的GatewayFilter" class="headerlink" title="11.1 常见的GatewayFilter"></a>11.1 常见的GatewayFilter</h3><p>AddRequestHeaderGatewayFilterFactory：为请求添加请求头 </p><p>AddRequestParameterGatewayFilterFactory：为请求添加请求参数 </p><p>AddResponseHeaderGatewayFilterFactory：为响应添加响应头 </p><p>RequestRateLimiterGatewayFilterFactory：请求限流 </p><p>StripPrefixGatewayFilterFactory：表示要从前截取的路径个数</p><h3 id="11-2-分析StripPrefixGatewayFilterFactory"><a href="#11-2-分析StripPrefixGatewayFilterFactory" class="headerlink" title="11.2 分析StripPrefixGatewayFilterFactory"></a>11.2 分析StripPrefixGatewayFilterFactory</h3><p>（1）类关系图</p><p><img src="/image/springcloud/gateway/10.png"></p><p>（2）配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">gateway:</span><br>  <span class="hljs-attr">routes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">path_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8081</span><br>      <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/test/**</span><br>      <span class="hljs-attr">filters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br></code></pre></td></tr></table></figure><h3 id="11-3-体验AddRequestHeaderGatewayFilterFactory"><a href="#11-3-体验AddRequestHeaderGatewayFilterFactory" class="headerlink" title="11.3 体验AddRequestHeaderGatewayFilterFactory"></a>11.3 体验AddRequestHeaderGatewayFilterFactory</h3><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-addrequestheader-gatewayfilter-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-addrequestheader-gatewayfilter-factory</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">gateway:</span><br>  <span class="hljs-attr">routes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">path_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8081</span><br>      <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/test/**</span><br>      <span class="hljs-attr">filters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=X-Request-red,</span> <span class="hljs-string">blue</span><br></code></pre></td></tr></table></figure><h3 id="11-4-体验RequestRateLimiterGatewayFilterFactory"><a href="#11-4-体验RequestRateLimiterGatewayFilterFactory" class="headerlink" title="11.4 体验RequestRateLimiterGatewayFilterFactory"></a>11.4 体验RequestRateLimiterGatewayFilterFactory</h3><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-requestratelimiter-gatewayfilter-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-requestratelimiter-gatewayfilter-factory</a></p><h3 id="11-5-自定义GatewayFilter"><a href="#11-5-自定义GatewayFilter" class="headerlink" title="11.5 自定义GatewayFilter"></a>11.5 自定义GatewayFilter</h3><p>需求：自定义一个局部过滤器，实现日志打印功能 </p><p>（1）创建自定义内置过滤器类LogGatewayFilterFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogPrintGatewayFilterFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractNameValueGatewayFilterFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> GatewayFilter <span class="hljs-title function_">apply</span><span class="hljs-params">(NameValueConfig config)</span>&#123;<br>        <span class="hljs-keyword">return</span> ((exchange, chain) -&gt; &#123;<br>           log.info(<span class="hljs-string">&quot;打印日志...&#123;&#125;, &#123;&#125;&quot;</span>, config.getName(), config.getValue());<br>            <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> exchange.getRequest().mutate().build();<br>            <span class="hljs-keyword">return</span> chain.filter(exchange.mutate().request(request).build());<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">gateway:</span><br>  <span class="hljs-attr">routes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">path_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8081</span><br>      <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/test/**</span><br>      <span class="hljs-attr">filters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ReqeustRateLimiter</span><br>          <span class="hljs-attr">args:</span><br>            <span class="hljs-attr">redis-rate-limiter.replenishRate:</span> <span class="hljs-number">1</span><br>            <span class="hljs-attr">redis-rate-limiter.burstCapacity:</span> <span class="hljs-number">2</span><br>            <span class="hljs-attr">redis-rate-limiter.requestedTokens:</span> <span class="hljs-number">1</span><br>            <span class="hljs-attr">key-resolver:</span> <span class="hljs-string">&quot;#&#123;@pathKeyResolver&#125;&quot;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">LogPrint=test,17</span><br></code></pre></td></tr></table></figure><h2 id="12-Global-Filter-全局"><a href="#12-Global-Filter-全局" class="headerlink" title="12 Global Filter[全局]"></a>12 Global Filter[全局]</h2><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#global-filters">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#global-filters</a></p><h3 id="12-1-常见的全局过滤器"><a href="#12-1-常见的全局过滤器" class="headerlink" title="12.1 常见的全局过滤器"></a>12.1 常见的全局过滤器</h3><p><img src="/image/springcloud/gateway/11.png"></p><h3 id="12-2-分析ReactiveLoadBalancerClientFilter"><a href="#12-2-分析ReactiveLoadBalancerClientFilter" class="headerlink" title="12.2 分析ReactiveLoadBalancerClientFilter"></a>12.2 分析ReactiveLoadBalancerClientFilter</h3><p>类关系图</p><p><img src="/image/springcloud/gateway/12.png"></p><h3 id="12-3-分析NettyRoutingFilter"><a href="#12-3-分析NettyRoutingFilter" class="headerlink" title="12.3 分析NettyRoutingFilter"></a>12.3 分析NettyRoutingFilter</h3><p>类关系图</p><p><img src="/image/springcloud/gateway/13.png"></p><h3 id="12-4-自定义GlobalFilter"><a href="#12-4-自定义GlobalFilter" class="headerlink" title="12.4 自定义GlobalFilter"></a>12.4 自定义GlobalFilter</h3><p>需求：校验请求头中是否携带指定的token值</p><p>创建自定义全局过滤器CheckHeaderTokenGlobalFilter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CheckHeaderTokenGlobalFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> exchange.getRequest().getHeaders().getFirst(<span class="hljs-string">&quot;token&quot;</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;jack&quot;</span>.equals(value))&#123;<br><span class="hljs-keyword">return</span> chain.filter(exchange);<br>&#125;<br>exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);<br><span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// Order值越小，执行的优先级越高</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-Gateway整合Sentinel实现容错"><a href="#13-Gateway整合Sentinel实现容错" class="headerlink" title="13 Gateway整合Sentinel实现容错"></a>13 Gateway整合Sentinel实现容错</h2><p>请查看Sentinel适配开源框架部分</p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>gateway</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>gateway</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾回收(Garbage Collect-GC)</title>
    <link href="/2023/03/10/java%E5%9F%BA%E7%A1%80/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(Garbage%20Collect-GC)/"/>
    <url>/2023/03/10/java%E5%9F%BA%E7%A1%80/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(Garbage%20Collect-GC)/</url>
    
    <content type="html"><![CDATA[<h2 id="1-对象的引用"><a href="#1-对象的引用" class="headerlink" title="1 对象的引用"></a>1 对象的引用</h2><p>Java中的引用的定义：如果reference(引用)类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。 </p><p>希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。 很多系统的缓存功能都符合这样的应用场景。四种引用类型：</p><p><strong>强引用：</strong>在Java中最常见的就是强引用，也是在开发过程中经常会使用到的引用.把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。</p><p><strong>软引用：</strong>软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SoftReferenceDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Worker</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>();<br>        <span class="hljs-comment">//业务代码使用到了a</span><br>        <span class="hljs-comment">//使用完了a，将它设置为soft引用类型，并且释放强引用</span><br>        <span class="hljs-type">SoftReference</span> <span class="hljs-variable">sr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>(a);<br>        a = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//下次使用时</span><br>        <span class="hljs-keyword">if</span>(sr != <span class="hljs-literal">null</span>)&#123;<br>            a = (worker) sr.get();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//GC由于内存资源不足，可能系统已回收了a的软引用</span><br>            <span class="hljs-comment">//因此需要重新装载</span><br>            a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>();<br>            sr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>(a);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>弱引用：</strong>弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeakReferenceDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//100M的缓存数据</span><br>        <span class="hljs-type">byte</span>[] cacheData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">100</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">//将缓存数据用软引用持有</span><br>        WeakReference&lt;<span class="hljs-type">byte</span>[]&gt; cacheRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(cacheData);<br>        System.out.printLn(<span class="hljs-string">&quot;第一次GC前&quot;</span> + cacheData);<br>        System.out.printLn(<span class="hljs-string">&quot;第一次GC前&quot;</span> + cacheRef.get());<br>        <span class="hljs-comment">//进行一次GC后查看对象的回收情况</span><br>        System.gc();<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        System.out.printLn(<span class="hljs-string">&quot;第一次GC后&quot;</span> + cacheData);<br>        System.out.printLn(<span class="hljs-string">&quot;第一次GC后&quot;</span> + cacheRef.get());<br>        <span class="hljs-comment">//将缓存数据的强引用去除</span><br>        cacheData = <span class="hljs-literal">null</span>;<br>        System.gc();<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        System.out.printLn(<span class="hljs-string">&quot;第二次GC后&quot;</span> + cacheData);<br>        System.out.printLn(<span class="hljs-string">&quot;第二次GC后&quot;</span> + cacheRef.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>虚引用：</strong>虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态，用于通知。应用场景：finalize()方法。</p><p><strong>引用队列：</strong>把对象放入引用队列中，可以实现对对象的后续操作。</p><h2 id="2-如何确定一个对象是垃圾"><a href="#2-如何确定一个对象是垃圾" class="headerlink" title="2 如何确定一个对象是垃圾"></a>2 如何确定一个对象是垃圾</h2><h3 id="2-1-算法"><a href="#2-1-算法" class="headerlink" title="2.1 算法"></a>2.1 算法</h3><p>1.引用计数法</p><p>​    对于某个对象而言，只要应用程序中持有该对象的引用，就说明该对象不是垃圾，如果一个对象没有任何指针对其引用，它就是垃圾。</p><p>​    弊端：循环引用如果AB相互持有引用，导致永远不能被回收。</p><p>2.可达性分析(根搜索)</p><p>​    通过GC Root的对象，开始向下寻找，看某个对象是否可达。</p><p>​    能作为GC Root：类加载器，Thread，虚拟机栈的局部变量表，方法区的静态变量和常量，本地方法栈的变量等。</p><h3 id="2-2-对象的生命周期"><a href="#2-2-对象的生命周期" class="headerlink" title="2.2 对象的生命周期"></a>2.2 对象的生命周期</h3><p>1.创建阶段(Created): 为对象分配存储空间 开始构造对象，从超类到子类对static成员进行初始化，超类成员变量按顺序初始化，递归调用超类的构造方法 子类成员变量按顺序初始化，子类构造方法调用，一旦对象被创建，并被分派给某些变量赋值，这个对象的状态就切换到了应用阶段。</p><p>2.应用阶段(In User)：对象至少被一个强引用持有着。</p><p>3.不可见阶段(Invisible)：当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然该这些引用仍然是存在着的。简单说就是程序的执行已经超出了该对象的作用域了。</p><p>4.不可达阶段( Unreachable)：对象处于不可达阶段是指该对象不再被任何强引用所持有。</p><p>与“不可见阶段”相比，“不可见阶段”是指程序不再持有该对象的任何强引用，这种情况下，该对象仍可能被 JVM等系统下的某些已装载的静态变量或线程或 JNI等强引用持有着，这些特殊的强引用被称为” GC root” 存在着这些 GC root会导致对象的内存泄露情况，无法被回收。</p><p>5.收集阶段( Collected)：当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了 finalize()方法，则会去执行该方法的终端操作。</p><p><em>这里要特别说明一下：不要重载ﬁnazlie()方法！原因有两点：</em></p><p>（1）会影响JVM的对象分配与回收速度。在分配该对象时，JVM需要在垃圾回收器上注册该对象，以便在回收时能够执行该重载方法；在该方法的执行时需要消耗CPU时间且在执行完该方法后才会重新执行回收操作，即至少需要垃圾回收器对该对象执行两次GC。</p><p>（2）可能造成该对象的再次“复活”。在ﬁnalize()方法中，如果有其它的强引用再次持有该对象，则会导致对象的状态由“收集阶段”又重新变为“应用阶段”。这个已经破坏了Java对象的生命周期进程，且“复活”的对象不利用后续的代码管理。</p><p>6.终结阶段(Finalized): 当对象执行完ﬁnalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。</p><p>7.对象空间重分配阶段(De-allocated): 垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”。</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg"></p><h3 id="2-3-垃圾回收的时机"><a href="#2-3-垃圾回收的时机" class="headerlink" title="2.3 垃圾回收的时机"></a>2.3 垃圾回收的时机</h3><p>GC是由JVM自动完成的，根据JVM系统环境而定，所以时机是不确定的。当然，可以手动进行垃圾回收，比如调用System.gc()方法通知JVM进行一次垃圾回收，但是具体什么时刻运行也无法控制。也就是说System.gc()只是通知要回收，什么时候回收由JVM决定。但是不建议手动调用该方法，因为GC消耗的资源比较大。</p><p>（1）当Eden区或者S区不够用了</p><p>（2）老年代空间不够用了</p><p>（3）方法区空间不够用了</p><p>（4）System.gc()</p><h2 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3 垃圾收集算法"></a>3 垃圾收集算法</h2><h3 id="3-1-标记-清除-mark-sweep"><a href="#3-1-标记-清除-mark-sweep" class="headerlink" title="3.1 标记-清除(mark-sweep)"></a>3.1 标记-清除(mark-sweep)</h3><p>1.标记：找出内存中需要回收的对象，并且把他们标记出来。此时堆中所有的对象都会被扫描一遍，从而才能确定需要回收的对象，比较耗时。</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/1.png"></p><p>2.清除：清除掉被标记需要回收的对象，释放出对应的内存空间。</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2.png"></p><p>缺点：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><p>​    （1）标记和清除两个过程都比较耗时，效率不高。</p><p>​    （2）会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中分配较大对象时，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。</p><h3 id="3-2-标记-复制-Mark-Copying"><a href="#3-2-标记-复制-Mark-Copying" class="headerlink" title="3.2 标记-复制(Mark-Copying)"></a>3.2 标记-复制(Mark-Copying)</h3><p>将内存划分为两块相等的区域，每次只使用其中一块。</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/3.png"></p><p>当其中一块内存使用完了，就将还存活的对象复制到另外一块上面，然后再把已经使用过的内存空间一次清除掉。</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/4.png"></p><p>缺点：空间利用率低。</p><h3 id="3-3-标记-整理-mark-compact"><a href="#3-3-标记-整理-mark-compact" class="headerlink" title="3.3 标记-整理(mark-compact)"></a>3.3 标记-整理(mark-compact)</h3><p>标记过程仍然和“标记-清除”算法一样，但是后续步骤不是对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清除掉边界外的内存。</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/5.png"></p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/6.png"></p><p>整理方式分为三类：</p><p>1.任意顺序整理：快，只能处理固定大小的对象。双指针算法(两次遍历)，其中快慢指针解决环：第一次遍历First指针从左往右移动直到遇到空位停下，End指针从右往左移动遇到非空位停下，两个位置交换，知道两指针碰撞到一起，此时碰撞位置左边都是非空的，右边都是空的。第二次遍历，更新移动过的内存地址。</p><p>2.线性顺序整理，相关联的在一起，会导致空间碎片，</p><p>3.滑动顺序整理： </p><p>（1）Lisp2算法(三次遍历)，处理大小不同的对象：有三个指针左边两个一起移动，右边一个不动用于判断结束，多出的那个指针会在第一次遍历进行一个记录操作，记录对象应该去哪个位置，第二次遍历修改引用，第三次进行对象移动。缺点：速度慢，浪费空间记录可达对象的预估到达位置.</p><p>（2）单次遍历：会有一张额外的表，会将内存分为很多大小相等的块，表中记录：标记位向量(对象的位置，开始位置和结束位置)，偏移位向量(到达的位置，只记录开头)，内存索引号</p><h2 id="4-JVM参数"><a href="#4-JVM参数" class="headerlink" title="4 JVM参数"></a>4 JVM参数</h2><h3 id="4-1-标准参数"><a href="#4-1-标准参数" class="headerlink" title="4.1 标准参数"></a>4.1 标准参数</h3><p>-version ；-help ；-server ；-cp</p><h3 id="4-2-X参数"><a href="#4-2-X参数" class="headerlink" title="4.2 -X参数"></a>4.2 -X参数</h3><p>非标准参数，也就是在JDK各个版本中可能会变动</p><p>-Xint   解释执行</p><p>-Xcomp   第一次使用就编译成本地代码 </p><p>-Xmixed  混合模式，JVM自己来决定</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/7.png"></p><h3 id="4-3-XX参数"><a href="#4-3-XX参数" class="headerlink" title="4.3 -XX参数"></a>4.3 -XX参数</h3><p>使用得最多的参数类型，非标准化参数，相对不稳定，主要用于JVM调优和Debug</p><ol><li><strong>Boolean类型</strong></li></ol><p>格式：-XX:[+-]<name>      +或-表示启用或者禁用name属性</p><p>比如：-XX:+UseConcMarkSweepGC  表示启用CMS类型的垃圾回收器</p><p>​            -XX:+UseG1GC        表示启用G1类型的垃圾回收器</p><ol start="2"><li><strong>非Boolean类型</strong></li></ol><p>格式：-XX<name>=<value>表示name属性的值是value </p><p>比如：-XX:MaxGCPauseMillis=500</p><h3 id="4-4-其他参数"><a href="#4-4-其他参数" class="headerlink" title="4.4 其他参数"></a>4.4 其他参数</h3><p>-Xms1000M等价于-XX:InitialHeapSize=1000M</p><p>-Xmx1000M等价于-XX:MaxHeapSize=1000M</p><p>-Xss100等价于-XX:ThreadStackSize=100 默认k为单位</p><p>所以这块也相当于是-XX类型的参数。</p><h3 id="4-5-查看参数"><a href="#4-5-查看参数" class="headerlink" title="4.5 查看参数"></a>4.5 查看参数</h3><p>java -XX:+PrintFlagsFinal -version &gt; flags.txt</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/8.png"></p><p>值得注意的是”=”表示默认值，”:=”表示被用户或JVM修改后的值</p><p>要想查看某个进程具体参数的值，可以使用jinfo，这块后面聊</p><p>一般要设置参数，可以先查看一下当前参数是什么，然后进行修改</p><h3 id="4-6-设置参数的常见方式"><a href="#4-6-设置参数的常见方式" class="headerlink" title="4.6 设置参数的常见方式"></a>4.6 设置参数的常见方式</h3><ol><li><p>开发工具中设置比如IDEA，eclipse</p></li><li><p>运行jar包的时候:java -XX:+UseG1GC xxx.jar </p></li><li><p>web容器比如tomcat，可以在脚本中的进行设置</p></li><li><p>通过jinfo实时调整某个java进程的参数(参数只有被标记为manageable的ﬂags可以被实时修改)</p></li></ol><h3 id="4-7-常用参数含义"><a href="#4-7-常用参数含义" class="headerlink" title="4.7 常用参数含义"></a>4.7 常用参数含义</h3><table><thead><tr><th>参数</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>-XX:CICompilerCount=3</td><td>最大并行编译数</td><td>如果设置大于1，虽然编译速度会提高，但是同样影响系统稳定性，会增加JVM奔溃的可能</td></tr><tr><td>-XX:InitialHeapSize=100M</td><td>初始化堆大小</td><td>简写-Xms 100M</td></tr><tr><td>-XX:MaxHeapSize=100M</td><td>最大堆大小</td><td>简写-Xmx 100M</td></tr><tr><td>-XX:NewSize=20M</td><td>设置年轻代大小</td><td></td></tr><tr><td>-XX:MaxNewSize=50M</td><td>设置年轻代最大大小</td><td></td></tr><tr><td>-XX:OldSize=50M</td><td>设置老年代大小</td><td></td></tr><tr><td>-XX:MetaspaceSize=50M</td><td>设置方法区大小</td><td></td></tr><tr><td>-XX:MaxMetaspaceSize=50M</td><td>设置方法区最大大小</td><td></td></tr><tr><td>-XX:UseParallelGC</td><td>使用ParallelGC</td><td>新生代，吞吐量优先</td></tr><tr><td>-XX:UseParallelOldGC</td><td>使用ParallelOldGC</td><td>老年代，吞吐量优先</td></tr><tr><td>-XX:UseConcMarkSweepGC</td><td>使用CMS</td><td>老年代，停顿时间优先</td></tr><tr><td>-XX:+UseG1GC</td><td>使用G1GC</td><td>新生代，老年代，停顿时间优先</td></tr><tr><td>-XX:NewRatio</td><td>新老生代的比值</td><td>比如-XX:Ratio=4，则表示新生代:老年代=1:4，也就是新生代占整个堆内存的1/5</td></tr><tr><td>-XX:SurvivorRatio</td><td>两个S区和Eden区的比值</td><td>比如-XX:SurvivorRatio=8，也就是(S0+S1):Eden=2:8，也就是一个S占整个新生代的1/10</td></tr><tr><td>-XX:+HeapDumpOnOutOfMemoryError</td><td>启动堆内存溢出打印</td><td>当JVM堆内存溢出时，也就是OOM，自动生成dump文件</td></tr><tr><td>-XX:HeapDumpPath=heap.hprof</td><td>指定堆内存溢出打印目录</td><td>表示在当前目录生成一个heap.hprof</td></tr><tr><td>-XX:+PrintGCDetails <br />-XX:+PrintGCTimeStamps <br />-XX:+PrintGCDateStamps <br />-Xloggc:g1-gc.log</td><td>打印出GC日志</td><td>可以使用不同的垃圾收集器，对比查看GC情况</td></tr><tr><td>-Xss128k</td><td>设置每个线程的堆栈大小</td><td>经验值是3000-5000最佳</td></tr><tr><td>-XX:MaxTenuringThreshold=6</td><td>提升老年代的最大临界值</td><td>默认值为15</td></tr><tr><td>-XX:InitiatingHeapOccypancyPercent</td><td>启动并发GC周期时堆内存使用占比</td><td>G1之类的垃圾收集器用它来触发并发GC周期，基于整个堆的使用率，而不是某一代内存的使用比，值为0表示一直执行GC循环，默认值为45</td></tr><tr><td>-XX:G1HeapWastePercent</td><td>允许的浪费堆空间的占比</td><td>默认值为10%，如果并发标记可回收的空间小于10%，则不会触发MixedGC</td></tr><tr><td>-XX:MaxGCPauseMillis=200ms</td><td>G1最大停顿时间</td><td>暂停时间不能太小，太小的话就会导致出现G1跟不上垃圾产生的速度，最终退化成Full GC，所以堆这个参数的调优是一个持续的过程，逐步调整到最佳状态</td></tr><tr><td>-XX:ConcGCThreads=n</td><td>并发垃圾收集器使用的线程数量</td><td>默认值随JVM运行的平台不同而不同</td></tr><tr><td>-XX:G1MixedGCLiveThresholdPercent=65</td><td>混合垃圾回收周期中要包括的旧区域设置占用率阈值</td><td>默认占用率为65%</td></tr><tr><td>-XX:G1MixedGCCountTarget=8</td><td>设置标记周期完成后，对存活数据上限为G1MixedGCLiveThresholdPercent的旧区域执行混合垃圾回收的目标次数</td><td>默认8次混合垃圾回收，混合回收的目标是要控制在次目标次数以内</td></tr><tr><td>-XX:G1OldCSetRegionThresholdPercent=1</td><td>描述Mixed GC时，Old Region被加入到CSet中</td><td>默认情况下，G1只把10%的Old Region加入到CSet中</td></tr></tbody></table><h2 id="5-垃圾收集器"><a href="#5-垃圾收集器" class="headerlink" title="5 垃圾收集器"></a>5 垃圾收集器</h2><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/9.png"></p><h3 id="5-1-Serial收集器"><a href="#5-1-Serial收集器" class="headerlink" title="5.1 Serial收集器"></a>5.1 Serial收集器</h3><p>Serial收集器是最基本，发展历史最悠久的收集器，曾经(在JDK1.3.3之前)是虚拟机新生代收集的唯一选择。它是一种单线程收集器，不仅仅意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是其在进行垃圾收集的时候需要暂停其他的线程。STW</p><p>​    优点：简单高效，拥有很高的单线程收集效率。</p><p>​    缺点：收集过程需要暂停所有线程。</p><p>​    算法：复制算法。</p><p>​    适用范围：新生代。</p><p>​    应用：Client模式下的默认新生代收集器。</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/10.png"></p><h3 id="5-2-Serial-Old收集器"><a href="#5-2-Serial-Old收集器" class="headerlink" title="5.2 Serial Old收集器"></a>5.2 Serial Old收集器</h3><p>Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，不同的是采用“<strong>标记-整理</strong>”算法，运行过程和serial收集器一样。STW</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/11.png"></p><h3 id="5-3-ParNew收集器"><a href="#5-3-ParNew收集器" class="headerlink" title="5.3 ParNew收集器"></a>5.3 ParNew收集器</h3><p>可以把这个收集器理解为Serial收集器的多线程版本。STW</p><p>​    优点：在多CPU时，比Serial效率高。</p><p>​    缺点：收集过程暂停所有应用程序线程，单CPU时比Serial效率差。</p><p>​    算法：复制算法。</p><p>​    适用范围：新生代。</p><p>​    应用：运行在server模式下的虚拟机中首选的新生代收集器。</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/12.png"></p><h3 id="5-4-Parallel-Scavenge收集器"><a href="#5-4-Parallel-Scavenge收集器" class="headerlink" title="5.4 Parallel Scavenge收集器"></a>5.4 Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，看上去和ParNew一样，但是Parallel Scavenge更关注<strong>系统的吞吐量</strong></p><p>​    吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</p><p>​    比如虚拟机总共运行了100分钟，垃圾收集时间用了1分钟，吞吐量=(100-1)/100=99%</p><p>​    若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序的运算任务。</p><p>-xx:MaxGCPauseMills控制最大的垃圾收集停顿时间</p><p>-XX:GCTimeRatio直接设置吞吐量的大小 0-100</p><p>-XX:+UserAdaptiveSizePolicy，设置用户自适应大小的策略，比如根据系统自动设置新生代大小。</p><p>​    它又叫吞吐优先垃圾收集器。</p><h3 id="5-5-Parallel-Old收集器"><a href="#5-5-Parallel-Old收集器" class="headerlink" title="5.5 Parallel Old收集器"></a>5.5 Parallel Old收集器</h3><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法进行垃圾回收。吞吐量优先。</p><h3 id="5-6-CMS收集器"><a href="#5-6-CMS收集器" class="headerlink" title="5.6 CMS收集器"></a>5.6 CMS收集器</h3><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector</a></p><p>CMS(Concurrent Mark Sweep)收集器是一种以获取<strong>最短回收停顿时间</strong>为目标的收集器。</p><p>采用的是“标记-清除”算法，整个过程分为4步：</p><p>1）初始标记：CMS initial mark 标记GC Roots能关联到的对象  stop the world -&gt; 速度很快，1.7之前是串行，1.8之后是并行。有一个参数控制：-XX: +CMSParallelIntialMarkEnablled(1.8默认开启)</p><p>2）并发标记：CMS concurrent mark 进行GC Roots Tracing，后面还有一小步：</p><p>2.5）新生代策略：并发预处理，也是标记工作。和重新标记的工作很像，尽可能的减轻重新标记的负担。</p><p>有一个问题，怎样扫描从young区指old区的对象，所以必须要在扫描新生代，把新生代中的垃圾先清理掉，执行minorGC后再扫描可达的老年代对象。其中有两个参数：CMSScheduleRemarkEdenSizeThreshold(2M)和CMSSchduleRemarkEdenPenetration(50%)意思是在Eden区使用了超过2M的内存后启动可终止的预处理策略等待minorGC，直到内存使用率达到young的50%后或者minorGC完成；或者5秒后不管是否发生了minorGC，之后自动进入重新标记，这个时间5秒由参数CMSMaxAbortPrecleanTime设置。</p><p>老年代策略：在老年代分成很多块(512k)，有一个card table(卡表)结构，为了解决跨代引用的问题。在并发标记中，如果一个对象的引用发生变化，则把该对象所在的card标记为dirty card，在重新标记阶段对其进行标识并清除dirty card标记。卡表是通过一个字节（8位）来标记对象的引用关系是否改变，例如某一位标记该对象是指向新生代的或者该对象的引用被修改过等。</p><p>3）重新标记：CMS remark 修改并发标记因用户程序变动的内容  stop the world</p><p>4）并发清除：CMS concurrent sweep 清除不可达对象回收空间，同时有新垃圾产生，留着下次清理称为浮动垃圾 </p><p>由于整个过程中，并发标记和并发清除，收集器线程可以和用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程和用户线程一起并发地执行的。</p><p>​    优点：并发收集，低停顿</p><p>​    缺点：产生大量的空间碎片，并发阶段是会降低吞吐量</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/13.png"></p><p>CMS分为两种模式：</p><p><strong>1.backgroud模式</strong>为正常模式执行上述的CMS GC流程；</p><p><strong>2.foregroud模式</strong>为Full GC模式，可能会切换到其他的老年代垃圾收集器，比如Serial Old（由并发模式失败引起），会发生MSC算法（压缩），通过两个参数设置（UseCMSCompactAtFullCollection，CMSFullGCsBeforeCompaction）。</p><p>并发模式失败：在并发标记过程中还在产生垃圾，如果快要发生OOM，会stw。如果发生这种情况则说明相关参数设置有问题。可以设置参数（CMSFullGCsBeforeCompaction，CMSInitiatingOccupancyFraction）达到内存的百分之几后进入CMS垃圾回收，该参数有一个计算公式：((100-MinHeapFreeRatio)+(double)(CMSTiggerRadio *MinHeapFreeRatio)/100.0)/100.0</p><p><strong>相关参数：</strong></p><p>-XX:+UseConcMarkSweepGC    //开启CMS垃圾收集器</p><p>-XX:+UseCMSCompactAtFullCollection     //默认开启，与-XX:CMSFullGCsBeforeCompaction配合使用 </p><p>-XX:CMSFullGCsBeforeCompaction=0    //默认0 几次Full GC后开始整理</p><p>-XX:+UseCMSInitiatingOccupancyOnly    //辅助CMSInitiatingOccupancyFraction的参数，不然CMSInitiatingOccupancyFraction只会使用一次就恢复自动调整，也就是开启手动调整。</p><p>-XX:CMSInitiatingOccupancyFraction     //取值0-100，按百分比回收，默认-1，当它默认为-1时，它=((100-MinHeapFreeRatio)+(double)(80*MinHeapFreeRatio)/100.0)/100.0</p><p><strong>CMS的缺陷：</strong></p><ol><li><p>单线程效率很低。</p></li><li><p>可能会发生并发失败，进入forgoud模式，发生full GC；可终止的预处理（默认停5秒）非常耗时。建议在晚上没人的时候进行手动full GC，手动整理，通过调整参数（UseCMSCompactAtFullCollection，CMSFullGCsBeforeCompaction），只能做为技术方案。</p></li></ol><h3 id="5-7-G1收集器"><a href="#5-7-G1收集器" class="headerlink" title="5.7 G1收集器"></a>5.7 G1收集器</h3><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection</a></p><p>使用G1（拷贝复制算法）收集器时，Java堆的内存布局与就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region(不需要连续)的集合，Region内部内存连续。每个Region大小都是一样的，可以是1M到32M之间的数值，但是必须保证是2的n次幂，默认内存中有2048个Region。如果对象太大，一个Region放不下[超过Region大小的50%]，那么就会直接放到H中，默认开启TLAB</p><p>设置Region大小：-XX:G1HeapRegionSize=M</p><p>所谓Garbage-Frist，其实就是优先回收垃圾最多的Region区域</p><p>Region的功能: 在某种程度上为了解决空间碎片会有角色转换，比如将old附近的eden转为old使得old连续，其实还是会存在空间碎片，它会有价值分析。Region分类（4大类）：1.FreeTag，空Region。2.Young分为EdenTag和SurvTag。3.HumMask分为HumStartsTag（头部区分）和HumContTag（连续区分）。4.OldTag</p><p><strong>特点：</strong></p><p>​    1. 并发和并行</p><p>​    2. 分代收集（仍然保留了分代的概念）</p><p>​    3. 空间整合（整体上属于“标记-整理”算法，不会导致空间碎片）</p><p>​    4. 可预测的停顿（比CMS更先进的地方在于能让使用者明确地指定一个长度为M毫秒地时间片段内，消耗在垃圾收集上的时间不得超过N毫秒）。</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/14.png"></p><p>工作过程分为以下几步：</p><p>​    1.初始标记（Initial Marking）：标记一下GC Roots能够关联的对象，并且修改TAMS的值，需要暂停用户线程。</p><p>​    2.并发标记（Concurrent Marking）：从GC Roots进行可达性分析，找出存活的对象，与用户线程并发执行。</p><p>​    3.最终标记（Final Marking）：修正在并发标记阶段因为用户程序的并发执行导致标动的数据，需要暂停用户线程。</p><p>​    4.筛选回收（Live Data Counting and Evacuation）：堆各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制定回收计划。</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/15.png"></p><p>G1中有三种GC：</p><p>young GC（初始标记阶段）：stw-&gt;选择新生代的region-&gt;根扫描-&gt;更新rset，记录引用变化-&gt;进行对象的复制到survivor-&gt;重构Rset-&gt;释放内存-&gt;进行大对象的回收-&gt;动态的扩展内存-&gt;动态调整Region数量-&gt;启动并发标记。</p><p>mixed GC：执行youngGC + 回收收益高的若干个old区。触发时机就是看时间够不够。</p><p>full GC：没有足够的region</p><p>可以看出三种GC都要回收young区。年轻代指向老年代的问题在G1中基本不会发生，但是相反的话就有问题了，这时引入了Rset（引用集）是卡表的升级版，是异步的，引入DCQS（Dirty Card Queue Set）的队列，当对象的引用发生变化且引用的对象位于老年代时会将数据放入队列中，当队列满了后才放入set中。两种引用关系：Point out和Point in。例如obj1 = obj2，那么Point out就是在obj1中记录obj2而Point In就是在obj2中记录obj1。G1使用的是Point in，而CMS使用的是Point out。为什么G1不适用Point out，因为它会造成扫描浪费。</p><p>Rset（大概消耗5%~10%的空间）用了三种数据结构：</p><ol><li><p>稀疏表（针对卡页），本质是hash表，它的key是Region的起始地址， Value是一个数组，数组中存储的比如说是卡页数据的索引号，其实它就是一个字典。每个Region都会划分成多个512k的card page，而card page的位置（索引号）记录在稀疏表中。</p></li><li><p>细粒度位图（针对卡页），是C语言实现的位图，记录卡页中有对新生代引用的对象。当一个卡页中有对象会引用到年轻代，则位图中相应修改该卡页的记录位脏数据，那么在minorGC扫描时只需要通过位图和稀疏表就可以找到引用到年轻代的对象，在minorGC时就只需要扫描GC root和对年轻代有引用的对象即可。</p></li><li><p>粗粒度位图，当位图的数量达到一个阈值后而且内存足够，使用粗粒度位图后一位指定一个Region。来减少位图的数量。</p></li></ol><p>因为是并发的垃圾收集器，所以Rset中会有写入乱序的问题，G1用写屏障来解决，但是会有额外的开销，很容易带来内存的伪共享。这时会有一个参数控制：-XX:+UseCondCardMark,意思是在写屏障阶段，如果一个卡页被标识了，那就不再标识了。</p><p><strong>三色标记算法</strong>：它的颜色是一种逻辑，其实是三种状态，将垃圾收集器未扫描过的标为白色，扫描完安全存在的标为黑色，正在扫描的标为灰色。CMS处理当对象引用增加时，会将引用改变的对象都标记为灰色进行重新扫描，而G1处理当对象引用消失后把它推到栈中。</p><p><strong>相关参数</strong></p><p>-XX: +UseG1GC 开启G1垃圾收集器</p><p>-XX: G1HeapReginSize 设置每个Region的大小，是2的幂次，1MB-32MB之间</p><p>-XX:MaxGCPauseMillis 最大停顿时间</p><p>-XX:ParallelGCThread 并行GC工作的线程数</p><p>-XX:ConcGCThreads 并发标记的线程数</p><p>-XX:InitiatingHeapOcccupancyPercent 默认45%，代表GC堆占用达到多少的时候开始垃圾收集，JDK8中没有</p><h3 id="5-8-ZGC"><a href="#5-8-ZGC" class="headerlink" title="5.8 ZGC"></a>5.8 ZGC</h3><p><a href="https://docs.oracle.com/en/java/javase/11/gctuning/z-garbage-collector1.html#GUID-A5A42691-095E-47BA-B6DC-FB4E5FAA43D0">https://docs.oracle.com/en/java/javase/11/gctuning/z-garbage-collector1.html#GUID-A5A42691-095E-47BA-B6DC-FB4E5FAA43D0</a></p><p>JDK11新引入的ZGC收集器，不管是物理上还是逻辑上，ZGC中已经不存在新老年代的概念了，会分为一个个page，当进行GC操作时会对page进行压缩，因此没有碎片问题只能在64位的linux上使用，目前用得还比较少。</p><p>​    （1）可以达到10ms以内的停顿时间要求</p><p>​    （2）支持TB级别的内存</p><p>​    （3）堆内存变大后停顿时间还是在10ms以内</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/16.png"></p><p>特点：</p><ol><li><p>读屏障</p></li><li><p>指针染色技术</p></li></ol><p>通过读屏障判断指针的颜色，判断对象引用是否被转移，这两特点时并发转移的关键点。ZGC用指针（64为操作系统一共64bit）中的4bit记录对象的引用变化（染色）。ZGC最大支持4TB，Linux中指针前18为不能用，64-18-4=42，2的42次方就是4TB。</p><h3 id="5-9-垃圾收集器的分类"><a href="#5-9-垃圾收集器的分类" class="headerlink" title="5.9 垃圾收集器的分类"></a>5.9 垃圾收集器的分类</h3><ol><li>串行收集器 -&gt; Serial和Serial Old</li></ol><p>​    只能有一个垃圾回收线程执行，用户线程暂停（适用于内存比较小的嵌入式设备）。</p><p>2.并行收集器（吞吐量优先） -&gt; Parallel Scanvenge，Parallel Old</p><p>​    多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态（适用于科学计算，后台处理等弱交互场景）。</p><p>3.并发收集器（停顿时间优先）-&gt; CMS，G1</p><p>​    用户线程和垃圾收集线程同时执行（但并不一定是并行的，可能是交替执行的），垃圾收集线程在执行的时候不会停顿用户线程的运行（适用于相对对时间有要求的场景，比如web）。</p><h3 id="5-10-常见问题"><a href="#5-10-常见问题" class="headerlink" title="5.10 常见问题"></a>5.10 常见问题</h3><p><strong>（1）理解吞吐量和停顿时间</strong></p><p>​    1. 停顿时间 -&gt;垃圾收集器进行垃圾回收终端应用执行响应的时间</p><p>​    2. 吞吐量 -&gt; 运行用户代码时间/(运行用户代码时间+垃圾收集时间)</p><p>​    停顿时间越短越适合需要和用户交互的程序，良好的响应速度能提升用户体验，高吞吐量则可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>​    小结：这两个指标也是评价垃圾回收期好处的标准，其实调优也是在观察这两个变量。</p><p><strong>（2）如何选择合适和垃圾收集器</strong></p><p>  <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28</a></p><p>​    1.优先调整堆的大小让服务器自己来选择</p><p>​    2.如果内存小于100M，使用串行收集器</p><p>​    3.如果是单核，并且没有停顿时间要求，使用串行或JVM自己选</p><p>​    4.如果允许停顿时间超过1秒，选择并行或JVM自己选</p><p>​    5.如果响应时间最重要，并且不能超过1秒，使用并发收集器</p><p><strong>（3）对于G1收集器：</strong></p><p>JDK7开始使用，JDK8非常成熟，JDK9默认的垃圾收集器，适用于新老年代。</p><p>判断是否需要使用G1收集器？（1）50%以上的堆被存活对象占用（2）对象分配和晋升的速度变化非常大（3）垃圾回收时间比较长</p><p><strong>（4）G1中的RSet</strong></p><p>​    全称Remembered Set，记录维护Region中对象的引用关系。试想，在G1垃圾收集器进行新生代的垃圾收集时，也就是Minor GC，假如该对象被老年代的Region中所引用，这时候新生代的该对象就不能被回收，怎么记录呢？不妨这样，用一个类似于hash的结构，key记录region的地址，value表示引用该对象的集合，这样就能知道该对象被哪些老年代的对象所引用，从而不能回收。</p><p><strong>（5）如何开启需要的垃圾收集器</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby">(<span class="hljs-number">1</span>)串行<br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+UseSerialGC</span><br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+UseSerialOldGC</span><br>(<span class="hljs-number">2</span>)并行(吞吐量优先)<br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+UseParallelGC</span><br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+UseParallelOldGC</span><br>(<span class="hljs-number">3</span>)并发收集器(响应时间优先)<br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:UseConcMarkSweepGC</span><br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:UseG1GC</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存模型</title>
    <link href="/2023/03/09/java%E5%9F%BA%E7%A1%80/jvm/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/03/09/java%E5%9F%BA%E7%A1%80/jvm/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-图解"><a href="#1-图解" class="headerlink" title="1 图解"></a>1 图解</h2><p>一块是非堆区，一块是堆区。堆分为两大区，old区和young区。young区分为两大快，一个是Survivor区（s0+s1），一块是Eden区。 Eden:s0:s1=8:1:1。s0和s1一样大，也可以叫做From和To。</p><p><img src="/image/jvm/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1.png"></p><h2 id="2-对象创建所在区域"><a href="#2-对象创建所在区域" class="headerlink" title="2 对象创建所在区域"></a>2 对象创建所在区域</h2><p>一般情况下，新创建的对象都会被分配到Eden区，一些特殊大的对象会直接分配到Old区。</p><p><img src="/image/jvm/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/2.png"></p><p>比如有对象A，B，C等创建在Eden区，但是Eden区的内存空间肯定有限，比如有100M，假如已经用了100M或者达到一个设定的阈值，这时就需要对Eden区内存空间进行清理，即垃圾回收（Garbage Collect），这样的GC称为Minor GC，Minor GC指的是Young区的GC。经过GC后，有些对象就会被清理掉，有些对象可能还活着，对于存活着的对象需要将其复制到Survivor区，然后再清空Eden区中的这些对象。</p><h2 id="3-Survivor区详解"><a href="#3-Survivor区详解" class="headerlink" title="3 Survivor区详解"></a>3 Survivor区详解</h2><p>由图解可知，Survivor区分为两块s0和s1，也可以叫做From和To。在同一时间点上，s0和s1只能有一个存有数据，另外一个是空的。</p><p>接着上面的GC来说，比如一开始只有Eden区和From中有对象，To中是空的。此时进行一次GC操作，From区中对象的年龄就会+1，Eden区中所有存活的对象会被复制到To区，From区中还能存活的对象会有两个去处。若对象达到之前设置好的年龄阈值，此时对象会被移动到Old区，如果Eden区和From区没有达到阈值的对象会被复制到To区。此时Eden区和From区已经被清空（被GC的对象肯定没了，没有被GC的对象都有了各自的去处）。这时候From和to交换角色，之前的from变成了to，之前的to变成了from。也就是说无论如何都要保证名为to的survivor区域是空的。Minor GC会一直重复这样的过程，直到to区被填满，然后将所有对象复制到老年代中。</p><h2 id="4-old区详解"><a href="#4-old区详解" class="headerlink" title="4 old区详解"></a>4 old区详解</h2><p>从上面的分析可以看出，一般old区都是年龄比较大的对象，或者相对超过了某个阈值的对象。在old区也会有GC的操作。</p><h2 id="5-对象的一辈子理解"><a href="#5-对象的一辈子理解" class="headerlink" title="5 对象的一辈子理解"></a>5 对象的一辈子理解</h2><p>我是一个普通的java对象，我出生在Eden区，在Eden区我还看到和我长得很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区的人实在是太多了，我被迫去了survivor区的from区，自动去了survivor区，我就开始漂了，有时候在from区，有时候在to区，居无定所，直到我18岁的时候，我成人了，于是我去了old区，old区人很多，并且年龄都比较大，我在这里认识了很多人。在old区中，我生活了20年（每次GC加一岁），然后被回收。</p><h2 id="6-常见问题"><a href="#6-常见问题" class="headerlink" title="6 常见问题"></a>6 常见问题</h2><ol><li>为什么需要survivor区？只有Eden区不行吗？</li></ol><p>​    如果没有survivor，eden区每进行一次Minor GC，并且没有年龄限制的话，存活的对象就会被送到老年代。这样依赖，老年代很快被填满，触发full GC。老年代的内存空间远大于新生代，进行一次GC消耗的时间比新生代长的多。频发的full gc消耗的时间很长，会影响大型程序的执行和响应速度。</p><p>​    那就对老年代的空间进行增加或者减少咯。假如增加老年代的空间，更多存活对象才能填满老年代。虽然减少full gc的频率，但是随着老年代的空间变大，一旦发生full gc，执行所需时间会更长。假如减少老年代的空间，虽然full gc所需要的时间减少，但是老年代很快被存活对象填满，Full gc频率增减。</p><p>​    所以survivor的存在意义，就是减少被送到老年代的对象，进而减少full gc的发生，survivor的预筛选保证，只有经历16次minor gc还能再新生代中存活的对象，才会被送到老年代中。</p><ol start="2"><li>为什么要有两个survivor区？</li></ol><p>​    最大的好处是解决了碎片化，也就是说为什么一个survivor区不行？第一问题中，知道了必须设置survivor区。假设现在只有一个survivor区，模拟一下流程：刚刚新建的对象再eden中。一旦eden满了，触发一次minor gc，eden中的存活对象就会被移动到survivor区。这样继续循环下去，下一次eden满了的时候，问题来了，此时进行minor gc，eden和survivor各有一些存活对象，如果此时把eden区的存活对象硬放到survivor，很明显这两部分对象所占有的内存是不连续的，也就导致了内存碎片化。</p><ol start="3"><li>新生代eden:s1:s2为什么是8:1:1?</li></ol><p>​    新生代中的可用内存：复制算法用来担保的内存是9:1，可用内存中eden:s1为8:1，即新生代中eden:s1:s2是8:1:1。</p><ol start="4"><li>如何理解各种GC</li></ol><p>​    Partial GC：其实也就是部分的意思。那么翻译过来也就是回收部分GC堆的模式，他并不会回收整个堆。而young GC以及Old GC都属于这种模式，young GC 只回收young区，old GC只回收Old区。</p><p>​    full GC：实际上就是对于整体回收。</p><ol start="5"><li>堆内存中都是线程共享的区域吗？</li></ol><p>JVM默认为每个线程在Eden上开辟一个buffer区域，用来加速对象的分配，称之为<strong>TLAB</strong>，全称:Thread Local Allocation Buffer。对象优先会在TLAB上分配，但是TLAB空间通常会比较小，如果对象比较大，那么还是在共享区域分配。</p><p><img src="/image/jvm/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/3.png"></p><ol start="6"><li>各种GC的触发条件</li></ol><p>Young GC：空间不够，fullGC会先触发young gc，在某些垃圾收集器在进行oldGC前会触发young GC。</p><p>Full GC：（1）悲观策略：a.之前每次晋升对象的平均大小比Old区的剩余空间大；b.minor GC后存活的对象比Old区的剩余空间大（2）常规策略：metaspace空间不足(一般是内存泄漏)；System.gc();</p><h2 id="7-体验与验证"><a href="#7-体验与验证" class="headerlink" title="7 体验与验证"></a>7 体验与验证</h2><p>使用visualvm，其中下载插件：visualgc插件下载链接：<a href="https://visualvm.github.io/pluginscenters.html">https://visualvm.github.io/pluginscenters.html</a></p><p>选择对应JDK版本链接—&gt;Tools—&gt;Visual GC。</p><h3 id="7-1-堆内存溢出"><a href="#7-1-堆内存溢出" class="headerlink" title="7.1 堆内存溢出"></a>7.1 堆内存溢出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapController</span>&#123;<br>    List&lt;Person&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-meta">@GetMapping(&quot;/heap&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">heap</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>记得设置参数比如：-Xmx20M -Xms20M</p><p><img src="/image/jvm/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/4.png"></p><h3 id="7-2-方法区内存溢出"><a href="#7-2-方法区内存溢出" class="headerlink" title="7.2 方法区内存溢出"></a>7.2 方法区内存溢出</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>asm<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>asm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//向方法区中添加Class信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMetaspace</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Class&lt;?&gt;&gt; createClasses() &#123;<br>        List&lt;Class&lt;?&gt;&gt; classes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10000000</span> ; ++i)&#123;<br>            <span class="hljs-type">CLassWriter</span> <span class="hljs-variable">cw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(<span class="hljs-number">0</span>);<br>            cw.visit(Opcodes.v1_1, Opcodes.ACC_PUBLIC, <span class="hljs-string">&quot;CLass&quot;</span> + i, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-literal">null</span>);<br>            <span class="hljs-type">MethodVisitor</span> <span class="hljs-variable">mw</span> <span class="hljs-operator">=</span> cw.visitMethod(Opcodes.ACC_PUBLIC, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>            mw.visitVarInsn(Opcodes.ALOAD, <span class="hljs-number">0</span>);<br>            mw.visitMethodInsn(Opcodes.INVOKESPECIAL, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>);<br>            mw.visitInsn(Opcodes.RETURN);<br>            mw.visitMaxs(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>            mw.visitEnd();<br>            <span class="hljs-type">Metaspace</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Metaspace</span>();<br>            <span class="hljs-type">byte</span>[] code = cw.toByteArray();<br>            Class&lt;?&gt; exampleClass = test.defineClass(<span class="hljs-string">&quot;Class&quot;</span> + i, code, <span class="hljs-number">0</span>, code.length);<br>            classes.add(exampleClass);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> classs NonHeapController&#123;<br>    List&lt;Class&lt;?&gt;&gt; list - <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-meta">@GetMapping(&quot;/nonheap&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">nonheap</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            list.addAll(MyMetaspace.createClasses());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置Metaspace的大小，比如-XX:MetaspaceSize=50M -XX:MaxMetaspaceSize=50M</p><p><img src="/image/jvm/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/5.png"></p><h3 id="7-3-虚拟机栈"><a href="#7-3-虚拟机栈" class="headerlink" title="7.3 虚拟机栈"></a>7.3 虚拟机栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">stackDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">long</span> i)</span>&#123;<br>        System.out.printLn(count++);<br>        method(i);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        method(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/jvm/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/6.png"></p><p>Stack Space用来做方法的递归调用时压入Stack Frame(栈帧)。所以当递归调用太深的时候，就有可能耗尽Stack Space，爆出StackOverflow的错误。</p><p>-Xss128k：设置每个线程的堆栈大小。JDK 5以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。 根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对 一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p><p>线程栈的大小是个双刃剑，如果设置过小，可能会出现栈溢出，特别是在该线程内有递归、大的循环时出现溢 出的可能性更大，如果该值设置过大，就有影响到创建栈的数量，如果是多线程的应用，就会出现内存溢出的 错误。</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运行时数据区</title>
    <link href="/2023/03/08/java%E5%9F%BA%E7%A1%80/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    <url>/2023/03/08/java%E5%9F%BA%E7%A1%80/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<p>在加载阶段的第二三步可以发现由运行时数据，堆，方法区等名词。第二步将这个字节流所代表的静态存储机构转化为方法区的运行时数据结构。第三步在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区中这些数据的访问入口。说白了就是类文件被类加载器加载进来之后，类中的内容（比如变量，常量，方法，对象等这些数据得要有个去处，也就是要存起来，存储的位置肯定是JVM中有对应的空间）</p><h2 id="1-官网概括"><a href="#1-官网概括" class="headerlink" title="1 官网概括"></a>1 官网概括</h2><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p><h2 id="2-图解"><a href="#2-图解" class="headerlink" title="2 图解"></a>2 图解</h2><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/1.png"></p><h2 id="3-常规理解"><a href="#3-常规理解" class="headerlink" title="3 常规理解"></a>3 常规理解</h2><h3 id="3-1-常量池"><a href="#3-1-常量池" class="headerlink" title="3.1 常量池"></a>3.1 常量池</h3><p>常量池分为静态常量池，运行时常量池，还有字符串常量池。</p><p><strong>静态常量池：</strong>其实储存的就是字面量以及符号引用。</p><p><strong>运行时常量池：</strong>运行时常量池就是每个类以及每个接口在JVM进行run的过程中所在内存中开辟出来 的一块用来储存静态常量池部分数据的一块特殊区域。</p><p><strong>字符串常量池：</strong>包含在动态常量池中。</p><p><strong>Jdk8中各常量池在内存中的划分：</strong></p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/2.png"></p><h3 id="3-2-方法区-Method-Area"><a href="#3-2-方法区-Method-Area" class="headerlink" title="3.2 方法区(Method Area)"></a>3.2 方法区(Method Area)</h3><p>方法区是各个线程共享的内存区域，在虚拟机启动时创建。用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译后的代码等数据。虽然java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做Non-Heap（非堆），目的是与java堆区分开。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><p>此时回看加载阶段的第二步：将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。如果这时候把从class文件到装载的第一二步合并起来理解的话，可以画个图：</p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/3.png"></p><p>方法区在JDK8中就是Metaspace（直接内存，也就是系统内存），在JDK6或7中就是Perm Space。JVM在使用类加载器时会为其分配一个内存列表，会进行线性分配，内存列表的大小取决与类加载器。在GC时1.7之前会对内存列表进行线性卸载，而1.8会对类加载器和其所属的内存列表整个卸载。</p><h3 id="3-3-堆-Heap"><a href="#3-3-堆-Heap" class="headerlink" title="3.3 堆(Heap)"></a>3.3 堆(Heap)</h3><p>java堆是java虚拟机所管理内存中最大的一块，在虚拟机启动时创建，被所有线程共享。java对象实例以及数组都在堆上分配。此时回看装载阶段的第三步：在java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/4.png"></p><h3 id="3-4-虚拟机栈-Java-Virtual-Machine-Stacks"><a href="#3-4-虚拟机栈-Java-Virtual-Machine-Stacks" class="headerlink" title="3.4 虚拟机栈(Java Virtual Machine Stacks)"></a>3.4 虚拟机栈(Java Virtual Machine Stacks)</h3><p>虚拟机栈是一个线程执行的区域，保存着一个线程中方法的调用状态。换句话说，一个java线程的运行状态，由一个虚拟机栈来保存，所以虚拟机栈肯定是线程私有的，独有的，随着线程的创建而创建。每一个被线程执行的方法，为该栈中的栈帧，即每个方法对应一个栈帧。调用一个方法，就会向栈中压入一个栈帧；一个方法调用完成，就会把该栈帧从栈中弹出。</p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/5.png"></p><p>官网：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6</a></p><p><strong>栈帧</strong>：每个栈帧对应一个被调用的方法，可以理解为一个方法的运行空间</p><p>每个栈帧中包括局部变量表，操作数栈，指向运行时常量池的引用，方法返回地址和附加信息。</p><p>（1）局部变量表 Local Variables：方法中定义的局部变量以及方法的参数存放在这张表中，局部变量表中的变量不可直接使用，如需要使用的话，必须通过相关指令将其加载到操作数栈中作为操作数使用。</p><p>（2）操作数栈 Operand Stack：以压栈和出栈的方法存储操作数的。</p><p>（3）动态链接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)。可能发生符号引用转为直接引用。</p><p>（4）方法返回地址：当一个方法开始执行后，只有两种方式可以退出，一种是遇到方法返回的字节码指令；一种是遇到异常，并且这个异常没有在方法体内得到处理。</p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/6.png"></p><h3 id="3-5-程序计数器-The-PC-Register"><a href="#3-5-程序计数器-The-PC-Register" class="headerlink" title="3.5 程序计数器(The PC Register)"></a>3.5 程序计数器(The PC Register)</h3><p>一个JVM进程中有多个线程在执行，而线程中的内容是否能够拥有执行权，是根据CPU调度来的。加入线程A正在执行到某个地方，突然失去了CPU的执行权，切换到线程B了，然后当线程A再获得CPU执行权的时候，怎么能继续执行？这就是需要在线程中维护一个变量，记录线程执行到的位置。</p><p>程序计数器占用的内存空间很小，由于java虚拟机的多线程是通过线程轮流切换，并分配处理器执行时间的方式来实现的。在任意时刻，一个处理器只会执行一条线程中的指令。因此，为了线程切换后能够恢复到正确的执行位置，每条线程需要有一个独立的程序计数器(线程私有)。</p><p>如果线程正在执行java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，则这个计数器为空。</p><h3 id="3-6-本地方法栈-Native-Method-Stacks"><a href="#3-6-本地方法栈-Native-Method-Stacks" class="headerlink" title="3.6 本地方法栈(Native Method Stacks)"></a>3.6 本地方法栈(Native Method Stacks)</h3><p>​    如果当前线程执行的方法是Native类型的，这些方法就会在本地方法栈中执行。</p><h3 id="3-7-另外"><a href="#3-7-另外" class="headerlink" title="3.7 另外"></a>3.7 另外</h3><p>除了上面五块内存之外,其实JVM还会使用到其他两块内存：</p><p><strong>直接内存(Direct Memory)：</strong></p><p>并不是虚拟机运行时数据区的一部分，也不是JVM规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现。在JDK 1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buﬀer)的I/O 方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java 堆里面的DirectByteBuﬀer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能， 因为避免了在Java堆和Native堆中来回复制数据。本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存的大小及处理器寻址空间的限制。因此在分配JVM空间的时候应该考虑直接内存所带来的影响，特别是应用到NIO的场景。</p><p><strong>其他内存:</strong></p><p>Code Cache：JVM本身是个本地程序，还需要其他的内存去完成各种基本任务，比如，JIT 编译器在运行时对热点方法进行编译，就会将编译后的方法储存在Code Cache里面；GC等功能。需要运行在本地线程之中，类似部分都需要占用内存空间。这些是实现JVM的JIT等功能的需要，但规范中并不涉及。</p><h2 id="4-运行时数据区各种元素的引用"><a href="#4-运行时数据区各种元素的引用" class="headerlink" title="4 运行时数据区各种元素的引用"></a>4 运行时数据区各种元素的引用</h2><h3 id="4-1-栈指向谁"><a href="#4-1-栈指向谁" class="headerlink" title="4.1 栈指向谁"></a>4.1 栈指向谁</h3><p>如果在栈帧中有一个变量，类型为引用类型，比如Object obj=new Object()，这时候就是典型的栈中元素指向堆中的对象。</p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/7.png"></p><h3 id="4-2-方法区指向谁"><a href="#4-2-方法区指向谁" class="headerlink" title="4.2 方法区指向谁"></a>4.2 方法区指向谁</h3><p>方法区中会存放静态变量，常量等数据。如果是这种情况，就是典型的方法区中元素指向堆中的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><h3 id="4-3-堆指向方法区"><a href="#4-3-堆指向方法区" class="headerlink" title="4.3 堆指向方法区"></a>4.3 堆指向方法区</h3><p>方法区中会包含类的信息，堆中会有对象，对象与类进行联系即堆指向方法区</p><h3 id="4-4-Java对象内存模型"><a href="#4-4-Java对象内存模型" class="headerlink" title="4.4 Java对象内存模型"></a>4.4 Java对象内存模型</h3><p>一个Java对象在内存中包括3个部分：对象头、实例数据和对齐填充。</p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/8.png"></p><h3 id="4-5-验证hashcode的存储方式"><a href="#4-5-验证hashcode的存储方式" class="headerlink" title="4.5 验证hashcode的存储方式"></a>4.5 验证hashcode的存储方式</h3><p>使用到jol工具。依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jol<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jol-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>    <br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getId</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPassword</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> password;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> username;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUsername</span><span class="hljs-params">(String username)</span>&#123;<br>        <span class="hljs-built_in">this</span>.username = username;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPassword</span><span class="hljs-params">(String password)</span>&#123;<br>        <span class="hljs-built_in">this</span>.password = password;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Integer id)</span>&#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.toString();<br>    &#125;<br>    <span class="hljs-comment">//查看对象的整体结构信息，JOL工具类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(Worker p)</span>&#123;<br>        System.out.printLn(ClassLayout.parseInstance(p).toPrintalbe());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>();<br>        System.out.printLn(work);<br>        Worker.printf(work);<br>        System.out.printLn(work.hashCode());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果：</p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/9.png"></p><p>1791741888这个数字是HashCode值，转换成16进制可得6a cb cf c0，经过对比，由此可得哈希码使用的大端储存。</p><p>例如：十进制数9877，如果用小端存储表示则为： </p><p>高地址  &lt;- - - - - - - - 低地址 10010101<code>[高序字节]</code> 00100110<code>[低序字节]</code> </p><p>用大端存储表示则为：</p><p>低地址  &lt;- - - - - - - - 高地址 00100110<code>[低序字节]</code> 10010101<code>[高序字节]</code></p><p><strong>小端存储：便于数据之间的类型转换，例如：long类型转换为int类型时，高地址部分的数据可以直接截掉。</strong></p><p><strong>大端存储：便于数据类型的符号判断，因为最低地址位数据即为符号位，可以直接判断数据的正负号。</strong></p><h3 id="4-6-Class-Pointer"><a href="#4-6-Class-Pointer" class="headerlink" title="4.6 Class Pointer"></a>4.6 Class Pointer</h3><p>引用定位到对象的方式有两种，一种叫句柄池访问，一种叫直接访问。</p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/10.png"></p><p><strong>句柄池：</strong></p><p>使用句柄访问对象，会在堆中开辟一块内存作为句柄池，句柄中储存了对象实例数据(属性值结构体)的内存地址，访问类型数据的内存地址(类信息，方法类型信息)，对象实例数据一般也在heap中开辟，类型数据一般储存在方法区中。</p><p>优点：reference存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要改变。</p><p>缺点：增加了一次指针定位的时间开销。</p><p><strong>直接访问：</strong></p><p>直接指针访问方式指reference中直接储存对象在heap中的内存地址，但对应的类型数据访问地址需要在实例中存储。</p><p>优点：节省了一次指针定位的开销。</p><p>缺点：在对象被移动时(如进行GC后的内存重新排列)，reference本身需要被修改。</p><p><strong>指针压缩：</strong>在32位系统中，类型指针为4字节32位，在64位系统中类型指针为8字节64位，<em>但是JVM会默认的进行指针压缩</em>，所以上图输出结果中类型指针也是4字节32位。如果关闭指针压缩的话，就可以看到64位的类型指针了，所以通常在部署服务时，JVM内存不要超过32G，因为超过32G就无法开启指针压缩了。</p><p>关闭指针压缩 ： -XX:+UseCompressedOops</p><p>对齐填充，没有对齐填充就可能会存在数据跨内存地址区域存储的情况，在没有对齐填充的情况下，内存地址存放情况如下：</p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/11.png"></p><p>因为处理器只能0x00-0x07，0x08-0x0F这样读取数据，所以想获取这个long型的数据时，处理器必须要读两次内存，第一次(0x00-0x07)，第二次(0x08-0x0F)，然后将两次的结果才能获得真正的数值。</p><p>那么在有对齐填充的情况下，内存地址存放情况是这样的：</p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/12.png"></p><p>现在处理器只需要直接一次读取(0x08-0x0F)的内存地址就可以获得想要的数据了。</p><p>对齐填充存在的意义就是为了提高CPU访问数据的效率，这是一种以空间换时间的做法；虽然访问效率提高了(减少了内存访问次数)，但是在0x07处产生了1bit的空间浪费。<strong>但是有一种情况，父类对象的变量是不会加入到子类对象对齐填充的中间去。</strong></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载器(ClassLoader)</title>
    <link href="/2023/03/08/java%E5%9F%BA%E7%A1%80/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <url>/2023/03/08/java%E5%9F%BA%E7%A1%80/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>负责读取Java字节代码，并转换成java.lang.Class 类的一个实例的代码模块。类加载器除了用于加载类外，还可用于确定类在Java虚拟机中的唯一性。一个类在同一个类加载器中具有唯一性(Uniqueness)，而不同类加载器中是允许同名类存在的，这里的同名是指全限定名相同。但是在整个JVM里，纵然全限定名相同，若类加载器不同，则仍然不算作是同一个类，无法通过 instanceOf 、equals 等方式的校验。</p><h2 id="1-分类"><a href="#1-分类" class="headerlink" title="1 分类"></a>1 分类</h2><p>1） Bootstrap ClassLoader 负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class或Xbootclassoath选项指定的jar，由C++实现，不是ClassLoader子类。</p><p>2） Extension ClassLoader 负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。</p><p>3） App ClassLoader 负责加载classpath中指定的jar包以及Djava.class.path所指定目录下的类和jar包。</p><p>4） Custom ClassLoader 通过java.lang.ClassLoader的子类自定义加载class，属于应用程序根据自身需要定义的ClassLoader，如tomcat，jboss都会根据j2ee规范自行实现ClassLoader。</p><h2 id="2-图解"><a href="#2-图解" class="headerlink" title="2 图解"></a>2 图解</h2><p><img src="/image/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/1.png"></p><p>为什么类加载器要分层？</p><p>​    1.2版本的JVM中，只有一个类加载器，就是现在的“Bootstrap”类加载器。也就是根类加载器。但是这样会出现一个问题。假如用户调用他编写的java.lang.String类。理论上该类可以访问和改变java.lang包下其他类的默认访问修饰符的属性和方法的能力。也就是说，其他的类使用String时也会调用这个类，因为只有一个类加载器，无法判定到底加载哪个。因为Java语言本身并没有阻止这种行为，所以会出现问题。</p><p>这个时候就想到，可不可以使用不同级别的类加载器来对信任级别做一个区分？比如用三种基础的类加载器做为三种不同的信任级别。最可信的级别是java核心API类。然后是安装的拓展类，最后才是在类路径中的类（属于本机的类）。所以，三种基础的类加载器由此生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//App ClassLoader</span><br>        System.out.printLn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>().getClass().getClassLoader());<br>        <span class="hljs-comment">//Ext ClassLoader</span><br>        System.out.printLn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>().getClass().getClassLoader().getParent());<br>        <span class="hljs-comment">//Bootstrap ClassLoader</span><br>        System.out.printLn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>().getClass().getClassLoader().getParent().getParent());<br>        <br>        System.out.printLn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>().getClass().getClassLoader());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/2.png"></p><h2 id="3-JVM类加载机制的三种方式"><a href="#3-JVM类加载机制的三种方式" class="headerlink" title="3 JVM类加载机制的三种方式"></a>3 JVM类加载机制的三种方式</h2><ol><li><p>全盘负责：当一个类加载器负责加载某个class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</p><p> 例如：系统类加载器AppClassLoader加载入口类（含有main方法的类）时，会把main方法所依赖的类及引用的类也载入，依此类推。“全盘负责”机制也可称为当前类加载器负责机制。显然，入口类所依赖的类及引用的类的当前类加载器就是入口类的类加载器。以上步骤只是调用了CLassLoader.loadClass(name)方法，并没有真正定义类。真正加载class字节码文件生成Class对象由“双亲委派”机制完成。</p></li><li><p>父类委托：“双亲委派”是指子类加载器如果没有加载过该目标类，就先委托父类加载器加载该目标类，只有在父类加载器找不到字节码文件的情况下才从自己的类路径中查找并装载目标类。父类委托别名就叫双亲委派机制。</p><p> “双亲委派”机制加载Class的具体过程是：</p></li></ol><p>​    （1）ClassLoader先判断该Class是否已加载，如果已加载，则返回Class对象；如果没有则委托给父类加载器。</p><p>​    （2）父类加载器判断是否加载过该Class，如果已加载，则返回Class对象；如果没有则委托给祖父类加载器。</p><p>​    （3）依此类推，直到始祖类加载器（引用类加载器）。</p><p>​    （4）始祖类加载器判断是否加载过该Class，如果已加载，则返回Class对象；如果没有则尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，则委托给始祖类加载器的子类加载器。</p><p>​    （5）始祖类加载器的子类加载器尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，则委托给始祖类加载器的孙类加载器。</p><p>​    （6）依此类推，直到源ClassLoader。</p><p>​    （7）源ClassLoader尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，源ClassLoader不会再委托其子类加载器，而是抛出异常。</p><p>​    “双亲委派”机制只是Java推荐的机制，并不是强制的机制。可以继承java.lang.ClassLoader类，实现自己的类加载器。如果想保持双亲委派模型，就应该重写findClass(name)方法；如果想破坏双亲委派模型，可以重写loadClass(name)方法。</p><ol start="3"><li>缓存机制：缓存机制将会保证所有加载过的Class都将在内存中缓存，当程序中需要使用某个Class时，类加载器先从内存的缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效.对于一个类加载器实例来说，相同全名的类只加载一次，即 loadClass方法不会被重复调用。而这里我们JDK8使用的是直接内存，所以我们会用到直接内存进行缓存。这也就是我们的类变量为什么只会被初始化一次的由来。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">//1.在虚拟机内存中查找是否已经加载过此类。。。类缓存的主要问题所在</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span>(parent != <span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-comment">//先让上一层加载器进行加载</span><br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e)&#123;<br>                <span class="hljs-comment">//ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">//from the non-null parneet class loader</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">//调用此类加载器所实现的findClass方法进行加载</span><br>                c = findClass(name);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(resolve)&#123;<br>            <span class="hljs-comment">//resolverClass方法是当字节码加载到内存后进行链接操作，对文件格式和字节码校验，并为static字段分配空间并初始化，符号引用转为直接引用，访问控制，方法覆盖等</span><br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-打破双亲委派"><a href="#4-打破双亲委派" class="headerlink" title="4 打破双亲委派"></a>4 打破双亲委派</h2><p>双亲委派这个模型并不是强制模型，而且会带来一些的问题。就比如java.sql.Driver这个东西。JDK只能提供一个规范接口，而不能提供实现。提供实现的是实际的数据库提供商。提供商的库总不能放JDK目录里。所以java想到了几种办法可以用来打破双亲委派。</p><p>（1）<strong>SPI</strong> :比如Java从1.6搞出了SPI就是为了优雅的解决这类问题——JDK提供接口，供应商提供服务。编程人员编码时面向接口编程，然后JDK能够自动找到合适的实现。Java 在核心类库中定义了许多接口，并且还给出了针对这些接口的调用逻辑，然而并未给出实现。开发者要做的就是定制一个实现类，在 META-INF/services 中注册实现类信息，以供核心类库使用。比如JDBC中的DriverManager</p><p>（2）<strong>OSGI</strong>:比如我们更加追求程序的动态性，比如代码热部署，代码热替换。也就是就是机器不用重启，只要部署上就能用。OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块都有一个自己的类加载器，当需要更换一个程序模块时，就把程序模块连同类加载器一起换掉以实现代码的热替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>    <span class="hljs-keyword">private</span> String root;<br>    <br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-type">byte</span>[] classData = loadClassData(name);<br>        <span class="hljs-keyword">if</span>(classData == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> defineClass(name, classData, <span class="hljs-number">0</span>, classData.length);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] loadClassData(String className)&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> root + File.separatorChar + className.replace(<span class="hljs-string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="hljs-string">&quot;.class&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">ins</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(fileName);<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">bufferSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span>;<br>            <span class="hljs-type">byte</span>[] buff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[bufferSize];<br>            <br>            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>((length = ins.read(buffer)) != -<span class="hljs-number">1</span>)&#123;<br>                baos.write(buffer, <span class="hljs-number">0</span>, length);<br>            &#125;<br>            <span class="hljs-keyword">return</span> baos.toByteArray();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRoot</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRoot</span><span class="hljs-params">(String root)</span>&#123;<br>        <span class="hljs-built_in">this</span>.root = root;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">MyclassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClassLoader</span>();<br>        classLoader.setRoot(<span class="hljs-string">&quot;E:\\temp&quot;</span>);<br>        <br>        Class&lt;?&gt; testClass = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            testClass = classLoader.loadClass(<span class="hljs-string">&quot;com.neo.classloader.Test2&quot;</span>);<br>            <br>            <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> testClass.newInstance();<br>            System.out.printLn(object.getClass().getClassLoader());<br>        &#125; <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/3.png"></p><p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意：</p><p>​    1、这里传递的文件名需要是类的全限定性名称，即 Test 格式的，因为 defineClass 方法是按这种格式进行处理的。如果没有全限定名，那么需要做的事情就是将类的全路径加载进去，而setRoot就是前缀地址 setRoot + loadClass的路径就是文件的绝对路径。</p><p>​    2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</p><p>​    3、这类Test 类本身可以被 AppClassLoader 类加载，因此不能把 Test.class 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader 加载，而不会通过自定义类加载器来加载。</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载机制</title>
    <link href="/2023/03/08/java%E5%9F%BA%E7%A1%80/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/03/08/java%E5%9F%BA%E7%A1%80/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>类加载机制是指将类的字节码文件所包含的数据读入内存，同时会生成数据的访问入口的一种特殊机制。那么可以得知，类加载的最终产品是数据访问入口。</p><p><img src="/image/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/1.png"></p><p>加载.class文件的方式：</p><p>​    1.从本地系统中直接加载：最常使用</p><p>​    2.通过网络下载class文件：Web Applet，也就是小程序应用</p><p>​    3.从zip，jar等归档文件中加载class文件：后续演变成jar，war格式</p><p>​    4.从专有数据库中提取class文件：JSP应用从专有数据库中提取class文件，极为少见</p><p>​    5.将java源文件动态编译为class文件，也就是运行时计算而成：动态代理技术</p><p>​    6.从加密文件中获取：典型的防class文件被反编译的保护措施。</p><p><img src="/image/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/2.png"></p><h2 id="1-加载-Load"><a href="#1-加载-Load" class="headerlink" title="1  加载(Load)"></a>1  加载(Load)</h2><p>查找和导入class文件</p><p>（1）   通过一个类的全限定名获取定义此类的二进制字节流（由上可知，不一定从字节码文件中获得，还有很多方法）。那么这个时候需要一个工具来寻找获取类二进制字节流。而java中正好有这么一段代码模块，可以实现通过类全名来获取此类的二进制字节流这个动作，并且将这个动作放到java虚拟机外部去实现，以便让应用程序决定如何获取所需要的类，实现这个动作的代码就是“类加载器“</p><p>（2）   将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p><p>（3）   在java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口</p><p> 注：获取类的二进制字节流的阶段是java程序员最关注的阶段，也是操控性最强的一个阶段。因为这个阶段可以对于类加载器进行操作，比如想自定义类加载器进行操作用以完成加载，又或者想通过java agent来完成字节码增强操作。</p><p>​    在装载完成之后，这时在内存中，运行时数据区的方法区以及堆就已经有数据了。即时编译之后的热点代码并不在这个阶段进入方法区。</p><p>​    方法区：类信息、静态常量、常量</p><p>​    堆：代表被加载类的java.lang.Class对象</p><h2 id="2-链接-Link"><a href="#2-链接-Link" class="headerlink" title="2 链接(Link)"></a>2 链接(Link)</h2><h3 id="2-1-验证-Verify"><a href="#2-1-验证-Verify" class="headerlink" title="2.1 验证(Verify)"></a>2.1 验证(Verify)</h3><p>验证只是为了确保Class文件中的字节流包含的信息完全符合当前虚拟机的要求，并且还要求文件中的信息不会危害虚拟机自身的安全，导致虚拟机的奔溃。</p><p>1） 文件格式验证：验证字节流是否符合class文件格式的规范，并且能够被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确的解析并存储于方法区之内。这阶段的验证是基于二进制字节流进行的，只有经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面验证都是基于方法区的存储结构进行的。</p><p>举例：是否以16进制cafebabe开头；版本号是否正确。</p><p>2） 元数据验证：对类的元数据信息进行语义校验(其实就是对java语法校验)，保证不存在不符合java语法规范的元数据信息。</p><p>举例：是否有父类；是否继承了final类；一个非抽象类是否实现了所有的抽象方法。</p><p>3） 字节码验证：进行数据流和控制流分析，确定程序语义是合法的,符合逻辑的。对类的方法体进行校验分析，保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。字节码的验证相对来说较为复杂。</p><p>举例：运行检查；栈数据类型和操作码参数吻合(比如栈空间只有4个字节，但是实际需要的远远大于4个字节，那么这时字节码就是有问题的)；跳转指令指向合理的位置。</p><p>4） 符号引用验证：这时最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候(解析阶段)，可以看作是对类自身以外的信息(常量池中的各种符号引用)进行匹配性的校验。符号引用验证的目的是确保解析动作能正常执行。</p><p>举例：常量池中描述类是否存在；访问的方法或者字段是否存在且具有足够的权限。</p><p>但是，很多情况下可能认为代码肯定是没有问题的，验证过程完全没必要，那么其实可以添加参数取消验证：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">-Xverify: <span class="hljs-built_in">none</span><br></code></pre></td></tr></table></figure><h3 id="2-2-准备-Prepare"><a href="#2-2-准备-Prepare" class="headerlink" title="2.2 准备(Prepare)"></a>2.2 准备(Prepare)</h3><p>为类的静态变量分配内存，并将其初始化为默认值。</p><table><thead><tr><th>数据类型</th><th>零值</th></tr></thead><tbody><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>short</td><td>(short)0</td></tr><tr><td>char</td><td>‘\u0000’</td></tr><tr><td>byte</td><td>(byte)0</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0d</td></tr><tr><td>reference</td><td>null</td></tr></tbody></table><p>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化。这个不会为实例变量(也就是没加static)分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//正常打印0，因为静态变量i在准备阶段会有默认值0</span><br>        System.out.printLn(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//编译不通过，因为局部变量没有赋值不能被使用</span><br>        <span class="hljs-type">int</span> <span class="hljs-number">1</span>;<br>        System.out.printLn(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进行分配内存的只是包括类变量(静态变量)，而不包括实例变量，实例变量是在对象实例化时随着对象一起分配在java堆中的。通常情况下，初始值为零值，假设public static int a = 1；那么a在准备阶段过后的初始值为0，不为1，这时只是开辟了内存空间，并没有运行java代码，a赋值为1的指令是程序被编译后，存放于类构造器(方法)中，所以a被赋值为1是在初始化阶段才会执行。</p><p>​    对于一些特殊情况,如果类字段属性表中存在ConstantValue属性，那在准备阶段变量a就会被初始化为ConstantValue属性所指的值。</p><p>​    <em>1.ConstantValue属性到底是干什么的?</em></p><p>​    Constant Value属性的作用是通知虚拟机自动为静态变量赋值，只有被static修饰的变量才可以使用这项属性，非static类型的变量的赋值是在实例构造器方法中进行的；static类型变量赋值分两种，在类构造器中赋值，或使用ConstantValue属性赋值。</p><p>​    <em>2.在实际的程序中，什么时候才会用到ConstantValue属性?</em></p><p>​    在实际的程序中，只有同时被final和static修饰的字段才有ConstantValue属性，且限于基本类型和String。编译时javac将会为该变量生成ConstantValue属性，在类加载的准备阶段虚拟机便根据ConstantValue为常量设置相应的值，如果该变量没有被final修饰，或者并非基本类型即字符串，则选择在类构造器中进行初始化。</p><p>​    <em>3.为什么ConstantValue的属性值只限于基本类型和String?</em></p><p>因为常量池中只能引用到基本类型和String类型的字面量。</p><h3 id="2-3-解析-Resolve"><a href="#2-3-解析-Resolve" class="headerlink" title="2.3 解析(Resolve)"></a>2.3 解析(Resolve)</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p><p>​    符号引用就是一组符号来描述目标。可以是任何字面量。引用的目标并不一定已经加载到内存中。</p><p>​    直接引用就是直接指向目标的指针，相对偏移量或一个间接定位到目标的句柄。</p><p>​    直接引用是与虚拟机内存布局实现相关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定存在内存中。</p><p>​    <strong>对解析结果进行缓存:</strong></p><p>​    同一符号引用进行多次解析请求是很常见的，除invokedynamic指令以外，虚拟机实现可以对第一次解析结果进行缓存，来避免解析动作重复进行。无论是否真正执行了多次解析动作，虚拟机需要保证的是在同一个实体中，如果一个引用符号之前已经被成功解析过，那么后续的引用解析请求就应当一直成功；同样的，如果第一次解析失败，那么其他指令对这个符号的解析请求也应该收到相同的异常。</p><p>inDy（invokedynamic）是 java 7 引入的一条新的虚拟机指令，这是自 1.0 以来第一次引入新的虚拟机指令。到了 java 8 这条指令才第一次在 java 应用，用在 lambda 表达式中。 indy 与其他 invoke 指令不同的是它允许由应用级的代码来决定方法解析。</p><h2 id="3-初始化-Initialize"><a href="#3-初始化-Initialize" class="headerlink" title="3 初始化(Initialize)"></a>3 初始化(Initialize)</h2><p>初始化阶段是执行类执行器方法的过程。或者讲的通俗易懂些，在准备阶段，类变量已赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，比如赋值。</p><p>​    在java中对类变量进行初始值设定由两种方式：1.声明类变量时指定初始值。2.使用静态代码块为类变量指定初始值。</p><p>​    按照程序员的逻辑，必须把静态变量定义在静态代码块的前面。因为两个的执行是会根据代码编写的顺序来决定的，顺序搞错了可能会影响业务代码。</p><p>​    JVM初始化步骤：1.假如这个类还没有被加载和连接，则程序先加载并连接该类。2.假如该类的直接父类还没有被初始化，则先初始化其直接父类。3.假如类中有初始化语句，则系统一次执行这些初始化语句。  </p><h2 id="4-使用"><a href="#4-使用" class="headerlink" title="4 使用"></a>4 使用</h2><ol><li>主动引用：只有当对类的主动引用的时候才会导致类的初始化，类的主动使用有6种：</li></ol><p>​    （1）创建类的实例，也就是new的方式。</p><p>​    （2）访问某个类或接口的静态变量，或者对该静态变量赋值</p><p>​    （3）调用类的静态方法</p><p>​    （4）反射，如Class.fonName(“com.carl.Test”)</p><p>​    （5）初始化某个类的子类，则其父类也会被初始化</p><p>​    （6）java虚拟机启动时被标明为启动类的类(JvmCaseApplication)，直接使用java.exe命令来运行某个主类。</p><p>​    2. 被动引用：</p><p>​    （1）引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。</p><p>​    （2）定义类数组，不会引起类的初始化。</p><p>​    （3）引用类的static final常量，不会引起类的初始化，如果只有static修饰，还是会引起类的初始化。</p><h2 id="5-卸载"><a href="#5-卸载" class="headerlink" title="5 卸载"></a>5 卸载</h2><p>在类使用完之后，如果满足下面的情况，类就会被卸载：</p><p>​    （1）该类的所有实例都已经被回收，也就是java堆中不存在该类的任何实例</p><p>​    （2）加载该类的ClassLoader已经被回收。</p><p>​    （3）该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</p><p>​    java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用他们所加载的类的Class对象，因此这些Class对象始终是可触及的。如果以上三个条件全部满足，JVM就会在方法区垃圾回收时堆类进行卸载，类的卸载过程其实就是在方法区种清空类信息，java类的整个声明周期就结束了。但是一般情况下启动类加载器加载的类不会被卸载，而其他两种基础类型的类加载器只有在极少数情况下才会被卸载。</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jvm初识</title>
    <link href="/2023/03/08/java%E5%9F%BA%E7%A1%80/jvm/jvm%E5%88%9D%E8%AF%86/"/>
    <url>/2023/03/08/java%E5%9F%BA%E7%A1%80/jvm/jvm%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-官网"><a href="#1-官网" class="headerlink" title="1  官网"></a>1  官网</h2><h3 id="1-1-JDK-8"><a href="#1-1-JDK-8" class="headerlink" title="1.1 JDK 8"></a>1.1 JDK 8</h3><p><a href="https://docs.oracle.com/javase/8/">https://docs.oracle.com/javase/8/</a></p><h3 id="1-2-The-relation-of-JDK-JRE-JVM"><a href="#1-2-The-relation-of-JDK-JRE-JVM" class="headerlink" title="1.2  The relation of JDK/JRE/JVM"></a>1.2  The relation of JDK/JRE/JVM</h3><p>Reference -&gt; Developer Guides -&gt; 定位到：<a href="https://docs.oracle.com/javase/8/docs/index.html">https://docs.oracle.com/javase/8/docs/index.html</a></p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/1.png"></p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/2.png"></p><h3 id="1-3-源码到类文件"><a href="#1-3-源码到类文件" class="headerlink" title="1.3 源码到类文件"></a>1.3 源码到类文件</h3><h4 id="1-3-1-源码"><a href="#1-3-1-源码" class="headerlink" title="1.3.1 源码"></a>1.3.1 源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String address;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">hobby</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Programming&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span>&#123;<br>        System.out.printLn(<span class="hljs-string">&quot;person say .....&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> op1, <span class="hljs-type">int</span> op2)</span>&#123;<br>        <span class="hljs-keyword">return</span> op1 + op2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译：javac Person.java -&gt; Person.class</p><h4 id="1-3-2-编译过程"><a href="#1-3-2-编译过程" class="headerlink" title="1.3.2 编译过程"></a>1.3.2 编译过程</h4><p>Person.java -&gt; 词法分析器 -&gt; tokens流 -&gt; 语法分析器 -&gt; 语法树/抽象语法树 -&gt; 语义分析器 -&gt; 注解抽象语法树 -&gt; 字节码生成器 -&gt; Person.class文件</p><p>​    由上可知：编译器其实做的事情就是“对等信息转换”。java文件中的信息其实跟class文件中的信息是一样的。</p><h4 id="1-3-3-类文件-class文件"><a href="#1-3-3-类文件-class文件" class="headerlink" title="1.3.3 类文件(class文件)"></a>1.3.3 类文件(class文件)</h4><p>官网: <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/3.png"></p><ol><li><p>magic（魔数）：The magic item supplies the magic number identifying the file format; it has the value 0xCAFEBABE：café babe.</p></li><li><p>minor_version, major_version：0000 0034 对应十进制的52，代表JDK8中的一个版本</p></li><li><p>constant_pool_count：003f 对应十进制63代表常量池中62个常量</p></li></ol><p><strong>常量池中主要存储两方面的内容：字面量和符号引用。</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">字面量：文本字符串，<span class="hljs-keyword">final</span>修饰等<br>符号引用：类和接口的全限定名、字段名称和描述符、方法名称和描述符<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassFile&#123;<br>u4magic;<br>    u2minor_version;<br>    u2major_version;<br>    u2constant_pool_count;<br>    cp_info constant_pool[constant_pool_count-<span class="hljs-number">1</span>];<br>    u2access_flags;<br>    u2this_class;<br>    u2super_class;<br>    u2interfaces_count;<br>    u2interfaces[interfaces_count];<br>    u2fields_count;<br>    field_infofields[fields_count];<br>    u2methods_count;<br>    method_info methods[methods_count];<br>    u2attributes_count;<br>    attribute_infoattributes[attributes_count];<br>&#125;<br></code></pre></td></tr></table></figure><p>.class字节码文件</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">魔术和<span class="hljs-keyword">class</span>文件版本<br>常量池<br>访问标志<br>类索引、父类索引、接口索引<br>字段表集合<br>方法表集合<br>属性表集合<br></code></pre></td></tr></table></figure><h4 id="1-3-4-反编译验证"><a href="#1-3-4-反编译验证" class="headerlink" title="1.3.4  反编译验证"></a>1.3.4  反编译验证</h4><p>用javap指令验证上述猜想正确性。编译指令：javap -v -p Person.class</p><p>进行反编译之后，查看字节码信息和指令等信息。JVM相对class文件来说可以理解为是操作系统；class文件相对JVM来说可以理解是汇编语言或者机器语言。</p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/4.png"></p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/5.png"></p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/6.png"></p><p>上面分析到常量池中常量的数量是62，接下来来具体分析一下这62个常量，也就是这块包含的信息：cp_info constant_pool[constant_pool_count-1]，cp其实就是一个表格的形式。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">cp_info</span> &#123;<br><span class="hljs-attribute">u1</span> tag;<br><span class="hljs-attribute">u1</span> <span class="hljs-literal">info</span>[];<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4</a></p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/7.png"></p><p>（1）往下数一个u1，即0a-&gt;10：代表的是CONSTANT_Methodref，表示这是一个方法引用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">CONSTANT_Fieldref_info&#123;<br>u1 tag<span class="hljs-comment">;</span><br>u2 class_index<span class="hljs-comment">;</span><br>u2 name_and_type_index<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>往下数两个u2：</p><p>​    第一个u2，即00 0a-&gt;10：代表的是class_index，表示该方法所属的类在常量池中的索引</p><p>​    第二个u2，即00 2b-&gt;43：代表的是name_and_type_index，表示该方法的名称和类型的索引。</p><p>（2）往下数u1，即08-&gt;8：表示的是CONSTANT_String，表示字符串类型</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">CONSTANT_String_info &#123;<br>u1 tag<span class="hljs-comment">;</span><br>u2 string_index<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>往下数u2，即00 2c-&gt;44：代表的是string_index</p><p>（3）往下数u1，即09 -&gt;9：表示CONSTANT_Fieldref，表示字段类型</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">CONSTANT_Fieldref_info&#123;<br>u1 tag<span class="hljs-comment">;</span><br>u2 class_index<span class="hljs-comment">;</span><br>u2 name_and_type_index<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>往下数两个u2：</p><p>​    第一个u2：即00 0d -&gt;13：代表的是class_index</p><p>​    第二个u2：即00 2d -&gt;45：代表的是name_and_type_index</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nacos配置中心</title>
    <link href="/2023/03/07/spring%E6%A1%86%E6%9E%B6/springcloud/nacos/nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <url>/2023/03/07/spring%E6%A1%86%E6%9E%B6/springcloud/nacos/nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p><em>Nacos版本：2.0.4  nacos2.x已不支持ribbon，使用nacos2.x需要手动引入LoadBalancer</em></p><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1 基本使用"></a>1 基本使用</h2><p>使用外部数据源</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.platform</span>=<span class="hljs-string">mysql</span><br><span class="hljs-attr">db.num</span>=<span class="hljs-string">1</span><br><span class="hljs-attr">db.url.0</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/mynacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span><br><span class="hljs-attr">db.user</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">db.password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure><h3 id="1-1-本地配置"><a href="#1-1-本地配置" class="headerlink" title="1.1 本地配置"></a>1.1 本地配置</h3><h4 id="1-1-1-实现"><a href="#1-1-1-实现" class="headerlink" title="1.1.1 实现"></a>1.1.1 实现</h4><p>（1）application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">lecturer:</span> <span class="hljs-string">Test</span><br></code></pre></td></tr></table></figure><p>（2）UserController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @Value</span><br><span class="hljs-meta">@Value(&quot;$&#123;lecturer&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String lecturer;<br><br><span class="hljs-meta">@RequestMapping(&quot;/local-config-value&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">localConfigValue</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;lecturer: &quot;</span>+<span class="hljs-built_in">this</span>.lecturer;<br>&#125;<br><br><span class="hljs-comment">// env</span><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> Environment environment;<br><br><span class="hljs-meta">@RequestMapping(&quot;/local-config-env&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">localConfigEnv</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;environment lecturer: &quot;</span>+<span class="hljs-built_in">this</span>.environment.getProperty(<span class="hljs-string">&quot;lecturer&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-1-2-实现原理"><a href="#1-1-2-实现原理" class="headerlink" title="1.1.2 实现原理"></a>1.1.2 实现原理</h4><p><a href="https://docs.spring.io/spring-boot/docs/2.7.6/reference/htmlsingle/#features.external-config">https://docs.spring.io/spring-boot/docs/2.7.6/reference/htmlsingle/#features.external-config</a></p><p>（1）加载application.yml文件中的配置</p><p>PropertySourceLoader#load() -&gt; YamlPropertySourceLoader#load() -&gt; OriginTrackedMapPropertySource</p><p>（2）查看Environment的属性配置源</p><p>SpringApplication#run()  –&gt;debug: configureIgnoreBeanInfo(environment)</p><p>（3）比如在Program arguments中配置timeout=1000，</p><p>观察environment中的 SimpleCommandLinePropertySource</p><p>（4）@Value实现原理</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">（<span class="hljs-number">1</span>）使用BeanPostProcessor解析类上的<span class="hljs-meta">@Value</span>字段<br>（<span class="hljs-number">2</span>）获取到字段上的<span class="hljs-meta">@Value</span>字段<br>（<span class="hljs-number">3</span>）解析<span class="hljs-meta">@Value</span>字段的value属性值，比如age<br>（<span class="hljs-number">4</span>）从environment中的属性配置源OriginTrackedMapPropertySource中寻找age的key<br>（<span class="hljs-number">5</span>）根据key获取到对应的value值<br>（<span class="hljs-number">6</span>）通过field反射的方式设置value值<br></code></pre></td></tr></table></figure><h3 id="1-2-在nacos上创建配置文件"><a href="#1-2-在nacos上创建配置文件" class="headerlink" title="1.2 在nacos上创建配置文件"></a>1.2 在nacos上创建配置文件</h3><p>（1）创建user-dev.yaml文件</p><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/1.png"></p><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/2.png"></p><p>（2）文件存储位置</p><p>mysql     nacos库     config_info表</p><p>nacos home</p><h3 id="1-3-基于HTTP的配置管理"><a href="#1-3-基于HTTP的配置管理" class="headerlink" title="1.3 基于HTTP的配置管理"></a>1.3 基于HTTP的配置管理</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 发布配置</span><br>curl -X POST <span class="hljs-string">&quot;http://127.0.0.1:8848/nacos/v1/cs/configs?</span><br><span class="hljs-string">dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld&quot;</span><br><br><span class="hljs-comment">#获取配置</span><br>curl -X POST <span class="hljs-string">&quot;http://127.0.0.1:8848/nacos/v1/cs/configs?</span><br><span class="hljs-string">dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld&quot;</span><br></code></pre></td></tr></table></figure><h3 id="1-4-基于Java-SDK的配置管理"><a href="#1-4-基于Java-SDK的配置管理" class="headerlink" title="1.4 基于Java SDK的配置管理"></a>1.4 基于Java SDK的配置管理</h3><p><a href="https://nacos.io/zh-cn/docs/sdk.html">https://nacos.io/zh-cn/docs/sdk.html</a></p><p>（1）引入nacos-client包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.nacos<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>nacos-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）编写Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">COnfigExample</span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">serverAddr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;localhost&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">dataId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;redis.yaml&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;DEFAULT_GROUP&quot;</span>;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        properties.put(PropertyKeyConst.SERVER_ADDR, serverAddr);<br>        <span class="hljs-type">ConfigService</span> <span class="hljs-variable">configService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosFactory</span>.createConfigService(properties);<br>        <br>        <span class="hljs-comment">//添加监听</span><br>        configService.addListencer(dataId, group, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Listence</span>()&#123;<br>           <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveConfigInfo</span><span class="hljs-params">(String configInfo)</span>&#123;<br>                System.out.printLn(<span class="hljs-string">&quot;receive: &quot;</span> + configInfo);<br>            &#125;<br>            <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">getExecutor</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;);<br>        <br>        <span class="hljs-comment">//发布配置</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isPublishOK</span> <span class="hljs-operator">=</span> configService.publishConfig(dataId, group, <span class="hljs-string">&quot;redis.host: 120.0.0.1:6379&quot;</span>);<br>        System.out.printLn(isPublishOK);<br>        <br>        Threan.sleep(<span class="hljs-number">3000</span>);<br>        <span class="hljs-comment">//获取配置</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> configService.getConfig(dataId, group, <span class="hljs-number">5000</span>);<br>        System.out.printLn(content);<br>        <br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）通过dashboard修改redis.yaml文件中的配置内容，观察监听器的回调打印信息</p><h3 id="1-5-user服务基于SC的配置管理"><a href="#1-5-user服务基于SC的配置管理" class="headerlink" title="1.5 user服务基于SC的配置管理"></a>1.5 user服务基于SC的配置管理</h3><p>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）在resources目录下创建bootstrap.yaml文件，并写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">user</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/3.png"></p><p>（3）启动user服务，如若报错如下信息，则在pom文件中添加bootstrap starter，并重新启动user服 务</p><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/4.png"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（4）创建访问接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Value的方式获取</span><br><span class="hljs-meta">@Value(&quot;$&#123;age&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String age;<br><br><span class="hljs-meta">@RequestMapping(&quot;/nacos-config-value&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">nacosConfigValue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> age;<br>&#125;<br><br><span class="hljs-comment">//Env的方式获取</span><br><span class="hljs-meta">@RequestMapping(&quot;/nacos-config-env&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">nacosConfigEnv</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.environment.getProperty(<span class="hljs-string">&quot;age&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）访问/user/nacos-config-value和/user/nacos-config-env </p><p>（6）通过dashboard修改age的值，不重启项目的情况下 访问/user/nacos-config-env，发现已经更新 访问/user/nacos-config-value，发现没有更新，在UserController上添加@RefreshScope注解后再尝试</p><h3 id="1-6-当前服务的通用配置"><a href="#1-6-当前服务的通用配置" class="headerlink" title="1.6 当前服务的通用配置"></a>1.6 当前服务的通用配置</h3><p>创建user.yaml文件，nacos会自动加载user、user-dev.yaml、user.yaml三个配置文件</p><h3 id="1-7-不同服务的公共配置"><a href="#1-7-不同服务的公共配置" class="headerlink" title="1.7 不同服务的公共配置"></a>1.7 不同服务的公共配置</h3><p>（1）创建公共配置文件mysql.yaml和es.yaml</p><p>（2）在bootstrap.yaml文件中添加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span><br>        <span class="hljs-string">shared-configs[0]:</span><br>          <span class="hljs-attr">data-id:</span> <span class="hljs-string">mysql.yaml</span><br>          <span class="hljs-attr">refresh:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-string">extension-configs[0]:</span><br>          <span class="hljs-attr">data-id:</span> <span class="hljs-string">es.yaml</span><br>          <span class="hljs-attr">refresh:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">user</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><p>（3）启动user服务观察日志并访问</p><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/5.png"></p><h2 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2 源码解析"></a>2 源码解析</h2><h3 id="2-1-nacos发布配置"><a href="#2-1-nacos发布配置" class="headerlink" title="2.1 nacos发布配置"></a>2.1 nacos发布配置</h3><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/%E5%8F%91%E5%B8%83%E9%85%8D%E7%BD%AE.jpg"></p><h3 id="2-2-Spring-Boot启动调用Nacos-API"><a href="#2-2-Spring-Boot启动调用Nacos-API" class="headerlink" title="2.2 Spring Boot启动调用Nacos API"></a>2.2 Spring Boot启动调用Nacos API</h3><p>启动服务时，会从nacos server上获取配置信息[bootstrap.yaml中配置的]，然后保存到environment中的属性配置源PropertySource中。具体使用的是Spring生态中的扩展点：ApplicationContextInitializer。在Spring Cloud提供的初始化器就是PropertySourceBootstrapConfiguration#initialize方法。</p><h3 id="2-3-获取配置"><a href="#2-3-获取配置" class="headerlink" title="2.3 获取配置"></a>2.3 获取配置</h3><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE.jpg"></p><h3 id="2-4-添加监听与配置变更图"><a href="#2-4-添加监听与配置变更图" class="headerlink" title="2.4 添加监听与配置变更图"></a>2.4 添加监听与配置变更图</h3><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/nacos%E6%B7%BB%E5%8A%A0%E7%9B%91%E5%90%AC%E4%B8%8E%E9%85%8D%E7%BD%AE%E5%8F%98%E6%9B%B4.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>nacos</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
      <tag>nacos</tag>
      
      <tag>配置中心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenFeign</title>
    <link href="/2023/03/07/spring%E6%A1%86%E6%9E%B6/springcloud/openfegin/openfegin/"/>
    <url>/2023/03/07/spring%E6%A1%86%E6%9E%B6/springcloud/openfegin/openfegin/</url>
    
    <content type="html"><![CDATA[<p><em>新版本的OpenFeign把ribbon移除了，正常使用应该引入LoadBalancer依赖</em></p><h2 id="1-OpenFeign使用"><a href="#1-OpenFeign使用" class="headerlink" title="1 OpenFeign使用"></a>1 OpenFeign使用</h2><p>(1) 整合openfeign依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）写注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserApplication</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）编写FeignClient接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderFeignClient</span> &#123;<br><span class="hljs-meta">@RequestMapping(&quot;/order/query&quot;)</span><br>String <span class="hljs-title function_">query</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）在Controller中使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> OrderFeignClient orderFeignClient;<br><br><span class="hljs-meta">@RequestMapping(&quot;/openfeign&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">openfeign</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.orderFeignClient.query();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Feign单独请求url"><a href="#2-Feign单独请求url" class="headerlink" title="2 Feign单独请求url"></a>2 Feign单独请求url</h2><p>（1）定义FeignClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;jack&quot;,url = &quot;https://ke.gupaoedu.cn/&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">JackFeignClient</span> &#123;<br><span class="hljs-meta">@RequestMapping(&quot;/gupao&quot;)</span><br>String <span class="hljs-title function_">gupao</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> JackFeignClient jackFeignClient;<br><br><span class="hljs-meta">@RequestMapping(&quot;/openfeign-url&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">openfeignUrl</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.jackFeignClient.gupao();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-配置OpenFeign的日志级别"><a href="#3-配置OpenFeign的日志级别" class="headerlink" title="3 配置OpenFeign的日志级别"></a>3 配置OpenFeign的日志级别</h2><p><a href="https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/#feign-logging">https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/#feign-logging</a></p><h3 id="3-1-OrderFeignClient-Java代码方式"><a href="#3-1-OrderFeignClient-Java代码方式" class="headerlink" title="3.1 OrderFeignClient-Java代码方式"></a>3.1 OrderFeignClient-Java代码方式</h3><p>（1）为注解@FeignClient配置configuration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;order&quot;, configuration = OrderFeignClientConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderFeignClient</span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/order/query&quot;)</span><br>    String <span class="hljs-title function_">query</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）新建配置类，并配置日志级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里不需要添加@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderFeignClientConfiguration</span> &#123;<br><span class="hljs-meta">@Bean</span><br>Logger.Level <span class="hljs-title function_">feignLoggerLevel</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">// 将feign的日志级别设置为FULL</span><br><span class="hljs-keyword">return</span> Logger.Level.FULL;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）在application.yml文件中将OrderFeignClient的日志级别设置为debug</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.test.openfeign.OrderFeignClient:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h3 id="3-2-OrderFeignClient-yml文件方式"><a href="#3-2-OrderFeignClient-yml文件方式" class="headerlink" title="3.2 OrderFeignClient-yml文件方式"></a>3.2 OrderFeignClient-yml文件方式</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.test.openfeign.OrderFeignClient:</span> <span class="hljs-string">debug</span><br><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-comment">#目标服务名称</span><br>      <span class="hljs-attr">order:</span><br>       <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">full</span><br></code></pre></td></tr></table></figure><h3 id="3-3-全局配置-Java代码方式"><a href="#3-3-全局配置-Java代码方式" class="headerlink" title="3.3 全局配置-Java代码方式"></a>3.3 全局配置-Java代码方式</h3><p>（1）找到Spring Boot的启动入口类，在@EnableFeignClients注解中配置defaultConfiguration属性， 为其指定全局配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableFeignClients(defaultConfiguration = GlobalFeignConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserApplication</span> immplements ApplicationRunner&#123;&#125;<br></code></pre></td></tr></table></figure><p>（2）新建配置类，并配置日志级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalFeignConfiguration</span> &#123;<br><span class="hljs-meta">@Bean</span><br>Logger.Level <span class="hljs-title function_">feignLoggerLevel</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">// 将feign的日志级别设置为FULL</span><br><span class="hljs-keyword">return</span> Logger.Level.FULL;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）在application.yml文件中将UserFeignClient的日志级别设置为debug</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>   <span class="hljs-attr">com.test.opennfeign.OrderFeignClient:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h3 id="3-4-全局配置-yml文件方式"><a href="#3-4-全局配置-yml文件方式" class="headerlink" title="3.4 全局配置-yml文件方式"></a>3.4 全局配置-yml文件方式</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.jack.user.openfeign.OrderFeignClient:</span> <span class="hljs-string">debug</span><br><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-comment"># 全局配置</span><br>      <span class="hljs-attr">default:</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">full</span><br></code></pre></td></tr></table></figure><h2 id="4-更改OpenFeign调用方式"><a href="#4-更改OpenFeign调用方式" class="headerlink" title="4 更改OpenFeign调用方式"></a>4 更改OpenFeign调用方式</h2><p>将OpenFeign默认使用的HttpURLConnection更改为httpclient</p><p>（1）查看当前http调用方式</p><p>SynchronousMethodHandler#invoke-&gt;executeAndDecode-&gt;client#execute-&gt;Default#execute- &gt;HttpURLConnection</p><p>（2）引入httpclient依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（3）写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-comment"># 全局配置</span><br>      <span class="hljs-attr">default:</span> <br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">full</span><br>  <span class="hljs-attr">httpclient:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">max-connections:</span> <span class="hljs-number">200</span><br>    <span class="hljs-attr">max-connections-per-route:</span> <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><h2 id="5-OpenFeign架构"><a href="#5-OpenFeign架构" class="headerlink" title="5 OpenFeign架构"></a>5 OpenFeign架构</h2><p><img src="/image/springcloud/openFegin/openfeign%E6%9E%B6%E6%9E%84.jpg"></p><h2 id="6-核心源码分析"><a href="#6-核心源码分析" class="headerlink" title="6 核心源码分析"></a>6 核心源码分析</h2><p>Spring Boot启动的时候，会扫描指定的包路径，然后判断接口上有没有添加@FeignClient，通过Spring提供的扩展FactoryBean接口，实现getObject方法实现自定义动态代理类，OrderFeignClient=Proxy#newInstance，将动态代理实现类放到ioc容器中。</p><p>调用接口时orderFeignClient#query() –&gt; Proxy#XXXHandler#invoke() ：通过loadbalancer根据order进行服务发现和负载均衡，然后得到一个localhost:9091/order/query ，调用uri进行结果返回。</p><p><img src="/image/springcloud/openFegin/openfeign%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>OpenFeign</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>OpenFeign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>负载均衡LoadBalancer</title>
    <link href="/2023/03/06/spring%E6%A1%86%E6%9E%B6/springcloud/LoadBalancer/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1LoadBalancer/"/>
    <url>/2023/03/06/spring%E6%A1%86%E6%9E%B6/springcloud/LoadBalancer/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1LoadBalancer/</url>
    
    <content type="html"><![CDATA[<p>nacos2.x已不支持ribbon，使用nacos2.x需要手动引入LoadBalancer</p><h2 id="1-手写随机负载均衡算法"><a href="#1-手写随机负载均衡算法" class="headerlink" title="1 手写随机负载均衡算法"></a>1 手写随机负载均衡算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br><span class="hljs-comment">//通过restTemplate访问随机一个url地址</span><br><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">loadbalance</span><span class="hljs-params">()</span>&#123;<br>    List&lt;ServiceInstance&gt; instances = discoveryClient.getInstance(<span class="hljs-string">&quot;order&quot;</span>);<br>    List&lt;String&gt; uris = instances.stream().map(instance -&gt; instance.getUri().toString() + <span class="hljs-string">&quot;/order/query&quot;</span>).collect(Collections.toList());<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> ThreadLocalRandom.current().nextInt(uris.size());<br>    <span class="hljs-type">String</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> uris.get(i);<br>    System.out.printLn(<span class="hljs-string">&quot;访问地址为&quot;</span> + uri);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.restTemplate.getForObject(uri, String.calss);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-LoadBalancerClient-API"><a href="#2-LoadBalancerClient-API" class="headerlink" title="2 LoadBalancerClient API"></a>2 LoadBalancerClient API</h2><p><a href="https://spring.io/guides/gs/spring-cloud-loadbalancer/">https://spring.io/guides/gs/spring-cloud-loadbalancer/</a></p><p>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> LoadBalancerClient loadBalancerClient;<br><br><span class="hljs-meta">@RequestMapping(&quot;/loadbalancerclient-api&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">loadbalancerclientApi</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">ServiceInstance</span> <span class="hljs-variable">serviceInstance</span> <span class="hljs-operator">=</span> loadBalancerClient.choose(<span class="hljs-string">&quot;order&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> serviceInstance.getUri().toString()+<span class="hljs-string">&quot;/order/query&quot;</span>;<br><span class="hljs-keyword">return</span> restTemplate.getForObject(url,String.class);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-LoadBalanced注解方式"><a href="#3-LoadBalanced注解方式" class="headerlink" title="3 @LoadBalanced注解方式"></a>3 @LoadBalanced注解方式</h2><p>（1）引入loadbalancer starter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）自定义一个@LoadBalanced注解的RestTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span> <span class="hljs-comment">// 相当于为restTemplate整合了lb的能力</span><br><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplateLoadBalancer</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RestTemplate restTemplateLoadBalancer;<br><br><span class="hljs-meta">@RequestMapping(&quot;/loadbalancerclient-annotation&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">loadbalancerclientAnnotation</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.restTemplateLoadBalancer.getForObject(<span class="hljs-string">&quot;http://order/order/query&quot;</span>, String.class);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-更改默认负载均衡方式"><a href="#4-更改默认负载均衡方式" class="headerlink" title="4 更改默认负载均衡方式"></a>4 更改默认负载均衡方式</h2><p><a href="https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#switching-between-the-load-balancing-algorithms">https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#switching-between-the-load-balancing-algorithms</a></p><p>默认的负载均衡为轮询</p><p>（1）定义配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomLoadBalancerConfiguration</span> &#123;<br><span class="hljs-meta">@Bean</span><br>ReactorLoadBalancer&lt;ServiceInstance&gt; <span class="hljs-title function_">randomLoadBalancer</span><span class="hljs-params">(Environment environment, LoadBalancerClientFactory loadBalancerClientFactory)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomLoadBalancer</span>(loadBalancerClientFactory.getLazyProvider(name,ServiceInstanceListSupplier.class), name);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）在启动类上通过@LoadBalancerClients注解使用自定义的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@LoadBalancerClients(defaultConfiguration = CustomLoadBalancerConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserApplication</span> &#123;<br></code></pre></td></tr></table></figure><h2 id="5-核心源码分析"><a href="#5-核心源码分析" class="headerlink" title="5 核心源码分析"></a>5 核心源码分析</h2><p>实际上，loadbalancer注解就是给RestTemplate添加了一个拦截器，调用过程简单来说，就是RestTemplate加上loadbalancer注解后，在创建请求之前添加了一个拦截器，在拦截器中通过服务名称调用LoadBalancer的choose方法，获取到真实的ip:port然后再拼接上具体的接口，替换原有uri，再通过RestTemplate进行远程调用。</p><h3 id="5-1-LoadBalancerClient-choose"><a href="#5-1-LoadBalancerClient-choose" class="headerlink" title="5.1 LoadBalancerClient#choose"></a>5.1 LoadBalancerClient#choose</h3><p>（1）LoadBalancerClient的自动装配</p><p><em>BlockingLoadBalancerClientAutoConfiguration</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnBean(LoadBalancerClientFactory.class)</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> LoadBalancerClient <span class="hljs-title function_">blockingLoadBalancerClient</span><span class="hljs-params">(LoadBalancerClientFactory loadBalancerClientFactory)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingLoadBalancerClient</span>(loadBalancerClientFactory);<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）LoadBalancerClient-choose源码分析</p><p><img src="/image/springcloud/loadbalancer/LoadBalancer-choose%E6%BA%90%E7%A0%81.jpg"></p><h3 id="5-2-LoadBalanced和RestTemplate"><a href="#5-2-LoadBalanced和RestTemplate" class="headerlink" title="5.2 @LoadBalanced和RestTemplate"></a>5.2 @LoadBalanced和RestTemplate</h3><h4 id="5-2-1-RestTamplate调用过程"><a href="#5-2-1-RestTamplate调用过程" class="headerlink" title="5.2.1 RestTamplate调用过程"></a>5.2.1 RestTamplate调用过程</h4><p><img src="/image/springcloud/loadbalancer/1.png"></p><h4 id="5-2-2-RestTemplate使用-LoadBalanced"><a href="#5-2-2-RestTemplate使用-LoadBalanced" class="headerlink" title="5.2.2 RestTemplate使用@LoadBalanced"></a>5.2.2 RestTemplate使用@LoadBalanced</h4><p>（1）向Spring IoC容器中注入RestTemplate的Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span> <span class="hljs-comment">// 相当于为RestTemplate整合了LoadBalancer的功能</span><br><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplateLoadBalancer</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）依赖注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(RestTemplate.class)</span><br><span class="hljs-meta">@ConditionalOnBean(LoadBalancerClient.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(LoadBalancerRetryProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoadBalancerAutoConfiguration</span> &#123;<br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-meta">@Autowired(required = false)</span> <span class="hljs-comment">// 获取到restTemplateLoadBalancer，然后给其添加拦截器</span><br><span class="hljs-keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();<br></code></pre></td></tr></table></figure><p>（3）创建拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> LoadBalancerInterceptor <span class="hljs-title function_">loadBalancerInterceptor</span><span class="hljs-params">(LoadBalancerClient loadBalancerClient,</span><br><span class="hljs-params">                                                       LoadBalancerRequestFactory requestFactory)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoadBalancerInterceptor</span>(loadBalancerClient, requestFactory);<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）给指定的restTemplate添加拦截器属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> RestTemplateCustomizer <span class="hljs-title function_">restTemplateCustomizer</span><span class="hljs-params">(<span class="hljs-keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> &#123;<br><span class="hljs-keyword">return</span> restTemplate -&gt; &#123;<br>        List&lt;ClientHttpRequestInterceptor&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(restTemplate.getInterceptors());<br>list.add(loadBalancerInterceptor);<br>restTemplate.setInterceptors(list);<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）拥有了拦截器能力的RestTemplate</p><p><img src="/image/springcloud/loadbalancer/2.png"></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>LoadBalancer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>LoadBalancer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis常见问题</title>
    <link href="/2023/03/03/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/03/03/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1-数据一致性问题"><a href="#1-数据一致性问题" class="headerlink" title="1   数据一致性问题"></a>1   数据一致性问题</h2><h3 id="1-1-缓存使用场景"><a href="#1-1-缓存使用场景" class="headerlink" title="1.1  缓存使用场景"></a>1.1  缓存使用场景</h3><p>针对读多写少的高并发场景，可以使用缓存来提升查询速度。使用redis作为缓存的时候，一般流程是这样的：</p><ol><li>如果数据在redis存在，应用就可以直接从redis拿到数据，不用访问数据库。</li></ol><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/1.png"></p><ol start="2"><li>应用新增了数据，只保存在数据库中，这个时候redis没有这条数据。如果redis里面没有，先到数据库查询，然后写入到redis，再返回给应用。</li></ol><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/2.png"></p><h3 id="1-2-一致性问题的定义"><a href="#1-2-一致性问题的定义" class="headerlink" title="1.2  一致性问题的定义"></a>1.2  一致性问题的定义</h3><p>因为数据最终是以数据库为准的（这是原则），如果redis没有数据，就不存在这个问题。当redis和数据库都有同一条记录，而这条记录发生变化的时候，就可能出现一致性问题。一旦被缓存的数据发生变化（比如修改，删除）的时候，既要操作数据库的数据，也要操作redis的数据，才能让redis和数据库保持一致。所以问题来了。现在有两种选择：</p><p>​    1.先操作redis的数据再操作数据库的数据</p><p>​    2.先操作数据库的数据再操作redis的数据</p><p>​    首先需要明确的是，不管选择哪一种方案，肯定是希望两个操作要么都成功，要么都不成功。但是，redis的数据和数据库是不可能通过事务达到统一的，只能根据相应的场景和所需要付出的代价来采取一些措施降低数据不一致的问题出现的概率，在数据一致性和性能之间取得一个权衡。</p><p>​    比如，对于数据库的实时性一致性要求不是特别高的场合，比如T+1的报表，可以采用定时任务查询数据库数据同步到redis的方案。由于是以数据库的数据为准的，所以给缓存设置一个过期时间，删除redis的数据，也能保证最终一致性。既然提到了Redis和数据库一致性的问题，一般是希望尽可能靠近实时一致性，操作延迟带来的不一致的时间越少越好。</p><h3 id="1-3-方案选择"><a href="#1-3-方案选择" class="headerlink" title="1.3  方案选择"></a>1.3  方案选择</h3><h4 id="1-3-1-redis：删除还是更新？"><a href="#1-3-1-redis：删除还是更新？" class="headerlink" title="1.3.1 redis：删除还是更新？"></a>1.3.1 redis：删除还是更新？</h4><p>这里补充一点：当存储的数据发生变化，redis的数据也要更新的时候，有两种方案，一种就是直接更新redis数据，调用set；还有一种是直接删除redis数据，让应用在下次查询的时候重新写入。</p><p>​    更新缓存之前，是不是要经过其他表的查询，接口调用，计算才能得到最新的数据，而不是直接从数据库拿到的值。如果是的话，建议直接删除，这种方案更加简单，而且避免了数据库的数据和缓存不一致的情况。在一般情况下，也推荐使用删除的方案。所以，更新操作和删除操作，只要数据变化，都用删除。</p><h4 id="1-3-2-先更新数据库，再删除缓存"><a href="#1-3-2-先更新数据库，再删除缓存" class="headerlink" title="1.3.2 先更新数据库，再删除缓存"></a>1.3.2 先更新数据库，再删除缓存</h4><p>正常情况：更新数据库成功，删除缓存成功。</p><p>异常情况：</p><p>​    1. 更新数据库失败，程序捕获异常，不会走到下一步，数据不会出现不一致。</p><p>​    2. 更新数据成功，删除缓存失败。数据库是新数据，缓存是旧数据，发生了不一致的情况。</p><p>​    对于这个问题，可以提供一个重试机制。比如：如果删除缓存失败，捕获这个异常，把需要删除的key发送到消息队列。然后自己创建一个消费者消费，尝试再次删除这个key。这种方式有个缺点，会对业务代码造成入侵。</p><p>​    所以有了第二种方案(异步更新缓存)：因为更新数据库时会往binlog写入日志，所以可以通过一个服务来监听binlog的变化(比如阿里的canal)，然后在客户端完成删除key的操作。如果删除失败的话，在发送到消息队列。<a href="https://gper.club/articles/7e7e7f7ff3g59gc6g6d">https://gper.club/articles/7e7e7f7ff3g59gc6g6d</a> (canal)。总之，对于后删除缓存失败的情况，我们的做法是不断地重试删除，直到成功。无论是重试还是异步删除，都是最终一致性地思想。</p><h4 id="1-3-3-先删除缓存，再更新数据库"><a href="#1-3-3-先删除缓存，再更新数据库" class="headerlink" title="1.3.3 先删除缓存，再更新数据库"></a>1.3.3 先删除缓存，再更新数据库</h4><p>正常情况：删除缓存成功，更新数据库成功。</p><p>异常情况：</p><p>​    1.删除缓存，程序捕获异常，不会走到下一步，数据不会出现不一致。</p><p>​    2.删除缓存成功，更新数据库失败。因为以数据库的数据为准，所以不存在数据不一致的情况。</p><p>​    看起来好像没有问题，但是如果有程序并发操作的情况下：</p><p>​    1）线程A需要更新数据，首先删除了redis缓存</p><p>​    2）线程B查询数据，发现缓存不存在，到数据库查询旧值，写入redis，返回</p><p>​    3）线程A更新了数据库</p><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/3.png"></p><p>这个时候，redis 是旧值，数据库是新的值，发生了数据不一致的情况。</p><p>​    这个是由线程并发造成的问题，能不能让对同一条数据的访问串行化呢？代码肯定保证不了，因为有多个线程，即使做了任务队列也可能有多个应用实例（应用做了集群部署）。数据库也保证不了，因为会有多个数据库的连接。只有一个数据库只提供一个连接的情况下，才能保证读写的操作的串行的，或者我们把所有的读写请求放到同一个内存队列当中，但是强制串行操作，吞吐量太低了。</p><p>​    所以有一种延时双删的策略，在写入数据之后，再删除一次缓存。</p><p>​    A线程：1）删除缓存。 2）更新数据库。 3）休眠500ms（这个时间，依据读取数据的耗时而定）。 4）再次删除缓存。 伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String key, Object data)</span>&#123;<br>    redis.delKey(key);<br>    db.updateData(data);<br>    Thread.sleep(<span class="hljs-number">500</span>);<br>    redis.delKey(key);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-高并发问题"><a href="#2-高并发问题" class="headerlink" title="2  高并发问题"></a>2  高并发问题</h2><p>在redis存储的所有数据中，有一部分是被频繁访问的。有两种情况可能会导致热点问题的产生，一个是用户集中访问的数据，比如抢购商品，明星结婚和明星出轨的微博。还有一种就是在数据进行分片的情况下，负载不均衡，超过了单个服务器的承受能力。热点问题可能引起缓存服务的不可用，最终造成压力堆积到数据库。出于存储和流量优化的角度，必须要找到这些热点数据。</p><h3 id="2-1-热点数据发现"><a href="#2-1-热点数据发现" class="headerlink" title="2.1  热点数据发现"></a>2.1  热点数据发现</h3><h4 id="2-1-1-客户端"><a href="#2-1-1-客户端" class="headerlink" title="2.1.1 客户端"></a>2.1.1 客户端</h4><p>比如可不可以在所有调用了get，set方法的地方，加上key的计数。但是这样的话，每一个地方都要修改，重复代码也多。如果用的是Jedis的客户端，可以修改Jedis的源码，在jedis的connection类的sendCommand()里面，用一个HashMap进行key的计数。但是这种方式有几个问题：</p><p>​    1.会对客户端的代码造成入侵</p><p>​    2.不知道要存多少个key，可能发生内存泄漏的问题。</p><p>​    3.只能统计当前客户端的热点key。</p><h4 id="2-1-2-代理层"><a href="#2-1-2-代理层" class="headerlink" title="2.1.2 代理层"></a>2.1.2 代理层</h4><p>第二种方式就是在代理层实现，比如TwemProxy或者Codis，但是不是所有的项目都使用了代理的架构。</p><h4 id="2-1-3-服务端"><a href="#2-1-3-服务端" class="headerlink" title="2.1.3 服务端"></a>2.1.3 服务端</h4><p>第三种就是在服务端统计，redis有一个monitor的命令，可以监控到所有redis执行的命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.monitor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisMonitor</span>()&#123;<br>   <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCommand</span><span class="hljs-params">(String command)</span>&#123;<br>        System.out.printLn(<span class="hljs-string">&quot;#monitor&quot;</span> + command);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>Facebook的开源项目redis-faina就是基于这个原理实现的。它是一个python脚本，可以分析monitor的数据。</p><p><a href="https://github.com/facebookarchive/redis-faina.git">https://github.com/facebookarchive/redis-faina.git</a></p><p>这种方法也会有两个问题：1）monitor命令在高并发的场景下，会影响性能，所以不适合长时间使用。2）只能统计一个redis节点的热点key。</p><h4 id="2-1-4-机器层面"><a href="#2-1-4-机器层面" class="headerlink" title="2.1.4 机器层面"></a>2.1.4 机器层面</h4><p>还有一种方法就是机器层面的，通过对TCP协议进行抓包，也有一些开源的方案，比如ELK的packetbeat插件。发现了热点key之后，来看下热点数据在高并发的场景下可能会出现的问题，以及怎么去解决。</p><h3 id="2-2-缓存雪崩"><a href="#2-2-缓存雪崩" class="headerlink" title="2.2  缓存雪崩"></a>2.2  缓存雪崩</h3><h4 id="2-2-1-什么是缓存雪崩"><a href="#2-2-1-什么是缓存雪崩" class="headerlink" title="2.2.1 什么是缓存雪崩"></a>2.2.1 什么是缓存雪崩</h4><p>缓存雪崩就是Redis的大量热点数据同时过期（失效），因为设置了相同的过期时间，刚好这个时候redis请求的并发量又很大，就会导致所有的请求落到数据库。</p><h4 id="2-2-2-缓存雪崩的解决方案"><a href="#2-2-2-缓存雪崩的解决方案" class="headerlink" title="2.2.2 缓存雪崩的解决方案"></a>2.2.2 缓存雪崩的解决方案</h4><p>​    1）加互斥锁或者使用队列，针对同一个key只允许一个线程到数据库查询</p><p>​    2）缓存定时预先更新，避免同时失效</p><p>​    3）通过加随机数，使得key在不同的时间过期</p><p>​    4）缓存永不过期</p><h3 id="2-3-缓存穿透"><a href="#2-3-缓存穿透" class="headerlink" title="2.3  缓存穿透"></a>2.3  缓存穿透</h3><h4 id="2-3-1-缓存穿透何时发生"><a href="#2-3-1-缓存穿透何时发生" class="headerlink" title="2.3.1 缓存穿透何时发生"></a>2.3.1 缓存穿透何时发生</h4><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/4.png"></p><p>在这里redis起到了提升查询速度和保护数据库的作用。还有一种情况，数据在数据库和redis里面都不存在，可能是一次条件错误的查询。在这种情况下，因为数据库值不存在，所以肯定不会写入redis，那么下一次查询相同的key的时候，肯定还是会再到数据库查一次。那么这种循环查询数据库中不存在的值，并且每次使用的是相同的key的情况，该怎么避免应用到数据库查询？</p><p>​    （1）缓存空数据 （2）缓存特殊字符串，比如&amp;&amp;</p><p>​    可以在数据库缓存一个空字符串，或者缓存一个特殊的字符串。那么在应用里面拿到这个特殊字符串的时候，就知道数据库没有值了，也没有必要再到数据库查询了。但是这里需要设置一个过期时间，不然的话数据库已经新增了这一条记录，应用也还是拿不到值。</p><p>​    这个是应用重复查询同一个不存在的值的情况，如果应用每一次查询的不存在的值是不一样的？即使每次都缓存特殊字符串也没用，因为它的值不一样，比如我们的用户系统登陆的场景，如果是恶意的请求，它每次都生成了一个符合ID规则的账号，但是这个账号在数据库是不存在的，那redis就完全失去了作用。这种因为每次查询的值都不存在导致的redis失效的情况，应该怎么去解决？</p><h4 id="2-3-2-经典面试题"><a href="#2-3-2-经典面试题" class="headerlink" title="2.3.2 经典面试题"></a>2.3.2 经典面试题</h4><p>其实它也是一个通用的问题，关键就在于怎么知道请求的key在数据库中是否存在，如果数据量特别大的话，怎么去快速判断。</p><p>​    这也是一个非常经典的面试题：如何在海量元素中（例如10亿无序，不定长，不重复）快速判断一个元素是否存在？</p><p>​    如果是缓存穿透的这个问题，要避免到数据库查询不存在的数据，肯定要把这10亿放在别的地方。为了加快检索速度，要把数据放到内存里面来判断，问题来了：如果直接把这些元素的值放到基本的数据结构（List，Map，Tree）里面，比如一个元素一字节的字段，10亿的数据大概需要900G的内存空间，这个对于普通的服务器来说是承受不了的。所以，存储着几十亿个元素，不能直接存值，应该找到一种最简单的最节省空间的数据结构，用来标记这个元素有没有出现。（比如签到表顺序打勾）</p><p>​    这个东西叫做位图，它是一个有序的数组，只有两个值，0和1：0代表不存在，1代表存在。</p><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/5.png"></p><p>对于这个映射方法，有几个基本的要求：</p><p>​    1）因为值长度是不固定的，希望不同长度的输入，可以得到固定长度的输出。</p><p>​    2）转换成下标的时候，希望他在我的这个有序数组里面是分布均匀的，不然的话全部挤到一对去了，也没办法判断哪个元素存了，哪个元素没存。</p><p>​    这个就是哈希函数，比如MD5，SHA-1等等这些都是常见的哈希算法。</p><p>比如这6个元素，经过哈希函数和位运算，得到了相应的下标。</p><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/6.png"></p><h4 id="2-3-3-哈希碰撞"><a href="#2-3-3-哈希碰撞" class="headerlink" title="2.3.3 哈希碰撞"></a>2.3.3 哈希碰撞</h4><p>这个时候，Tom和Mic经过计算得到的哈希值是一样的，那么再经过位运算得到的下标肯定是一样的，把这种情况叫做哈希冲突或者哈希碰撞。如果发生过了哈希碰撞，这个时候对于容器存值肯定是由影响的，从数据结构和映射方法这两个角度来分析，可以通过哪些方式去降低哈希碰撞的概率呢？</p><p>第一种是扩大数组的长度或者说位图容量。因为函数是分布均匀的，所以，位图容量越大，再同一位置发生哈希碰撞的概率越小。是不是位图的容量越大越好？不管存多少个元素，都创建一个几万亿大小的位图，可以吗？当然不行，因为越大的位图容量，意味着越多的内存消耗，所以要建立一个合适大小的位图容量。</p><p>除了扩大位图容量，还有第二种方法，只用一个哈希函数，现在对于每一个要存储的元素都用多个哈希函数计算，这样每次计算出来的下标都相同的概率就小很多了。</p><p>同样的，可以引入很多个哈希函数，也会有问题，第一个就是它会填满位图的更多空间，第二个是计算是需要消耗时间的。</p><p>所以总的来说，既要节省空间，又要很高的计算效率，就必须在位图容量和函数个数之间找到一个最佳的平衡。</p><h4 id="2-3-4-布隆过滤器-BF-原理"><a href="#2-3-4-布隆过滤器-BF-原理" class="headerlink" title="2.3.4 布隆过滤器(BF)原理"></a>2.3.4 布隆过滤器(BF)原理</h4><p>当然，这个事情早就有人研究过了，在1970年的时候，有一个叫做布隆的前辈对于判断海量元素中元素是否存在的问题进行了研究，也就是到底需要多大的位图容量和多少个哈希函数，提出的这个容器就叫做布隆过滤器。</p><p>布隆过滤器的工作原理：首先，布隆过滤器的本质就是刚才分析的，一个位数组码和若干个哈希函数。</p><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/7.png"></p><p>集合中有三个元素，要把它存到布隆过滤器中去，怎么做？首先是a元素，这里用3次计算。b，c元素也一样。元素已经存进去之后，现在要来判断一个元素在这个容器里面是否存在，就要使用同样的三个函数进行计算。比如d元素，用第一个函数f1计算，发现这个位置上是1，没问题。第二个位置也是1，第三个位置也是1.如果经过三次计算得到的下标位置都是1，这种情况下，能不能确定d元素一定在这个容器中呢？实际上是不能的。比如这张图里面，这三个位置分别是把abc存进去的时候置成1的，所以即使d元素之前没有存进去，也会得到1，判断返回true。</p><p>​    所以，这个是布隆过滤器的一个很重要的特性，因为哈希碰撞不可避免，所以它会存在一定的误判率。这种把本来不存在布隆过滤器中的元素误判为存在的情况，把它叫做假阳性(False Positive Probability，FPP)。</p><p>​    再来看另一个元素，e元素。要判断它在容器中是否存在，一样的要用这三个函数去计算。第一个位置是1，第二个位置是1，第三个位置是0。E元素是不是一定不在这个容器中呢？可以确定一定不存在，如果说但是已经把e元素存到布隆过滤器中去了，那么这三个位置肯定是1，不会出现0.</p><p>​    总结，布隆过滤器的特点；</p><p>​    从容器的角度来说：</p><ol><li><p>如果布隆过滤器判断元素在集合中存在，不一定存在</p></li><li><p>如果布隆过滤器判断不存在，一定不存在</p></li></ol><p>从元素的角度来说：</p><ol start="3"><li><p>如果元素实际存在，布隆过滤器一定判断存在</p></li><li><p>如果元素实际不存在，布隆过滤器可能判断存在</p></li></ol><h4 id="2-3-5-Guava-BF实现"><a href="#2-3-5-Guava-BF实现" class="headerlink" title="2.3.5 Guava BF实现"></a>2.3.5 Guava BF实现</h4><p>谷歌的Guava中就提供了一个现成的布隆过滤器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>21.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>创建布隆过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">BloomFilter&lt;String&gt; bf = BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), insertions);<br></code></pre></td></tr></table></figure><p>布隆过滤器提供的存放元素的方法是put()。布隆过滤器提供的判断元素是否存在的方法是mightContain().</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(bf.mightContain(data))&#123;<br>    <span class="hljs-keyword">if</span>(sets.contains(data))&#123;<br>        <span class="hljs-comment">//判断存在实际存在的时候，命中</span><br>        right++;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-comment">//判断存在但实际不存在的时候，错误</span><br>    wrong++;<br>&#125;<br></code></pre></td></tr></table></figure><p>布隆过滤器把误判率默认设置位0.03，也可以在创建的时候指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; BloomFilter&lt;T&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(Funnel&lt;? <span class="hljs-built_in">super</span> T&gt;funnel, <span class="hljs-type">long</span> expectedInsertions)</span>&#123;<br>    <span class="hljs-keyword">return</span> create(funnel, expectedInsertions, <span class="hljs-number">0.03D</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>位图的容量是基于元素个数和误判率计算出来的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">long numBits = optimal<span class="hljs-constructor">NumOfBits(<span class="hljs-params">expectedInsertions</span>, <span class="hljs-params">fpp</span>)</span>;<br></code></pre></td></tr></table></figure><p>根据位图数组的大小，进一步计算出了哈希函数的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">numHashFunctions</span> <span class="hljs-operator">=</span> optimalNumOfHashFunctions(expectedInsertions, numBits);<br></code></pre></td></tr></table></figure><p>存储100万个元素只占用了0.87M的内存，生成了5个哈希函数。</p><h4 id="2-3-6-bf在项目中的使用"><a href="#2-3-6-bf在项目中的使用" class="headerlink" title="2.3.6 bf在项目中的使用"></a>2.3.6 bf在项目中的使用</h4><p>布隆过滤器的工作位置</p><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/8.png"></p><p>因为要判断数据库的值是否存在，所以第一步是加载数据库所有的数据。在去redis查询之前，现在布隆过滤器查询，如果bf说没有，那数据库肯定没有，也不用去查了。如果bf说有，才走之前的流程。</p><h4 id="2-3-7-布隆过滤器的不足与变种"><a href="#2-3-7-布隆过滤器的不足与变种" class="headerlink" title="2.3.7 布隆过滤器的不足与变种"></a>2.3.7 布隆过滤器的不足与变种</h4><p>如果数据库删除了，布隆过滤器的数据也要删除。但是布隆过滤器里面没有提供删除的方法。为什么布隆过滤器不提供删除的方法呢？或者说，如果删除了布隆过滤器的元素，会发生什么问题？</p><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/9.png"></p><p>比如把a删除了，那么三个位置都要改成0，但是再来判断b元素是否存在的时候，因为有一个位置变成了0，所以b元素也判断不存在。就是因为存在哈希碰撞，所以元素只能存入，不能删除。</p><p>那如果要实现删除的功能，怎么做？类似于HashMap的链地址法，可以在每个下标位置上增加一个计数器。比如这个位置命中了两次，计数器就是2。当删除a元素的时候，先把计数器改成1，删除b元素的时候，计数器变成0，这个时候下标对应的位才置成0。</p><p>实际上在布隆过滤器提出来的几十年中，出现了很多布隆过滤器的变种，这种通过计数器提供删除功能的bf叫做Counting Bloom Filter</p><h4 id="2-3-8-布隆过滤器的其他应用场景"><a href="#2-3-8-布隆过滤器的其他应用场景" class="headerlink" title="2.3.8 布隆过滤器的其他应用场景"></a>2.3.8 布隆过滤器的其他应用场景</h4><p>布隆过滤器解决的问题是如何在海量元素中快速判断一个元素是否存在。所以除了解决缓存穿透的问题之外，还有很多其他的用途。</p><p>比如爬虫，爬过的url不需要重复爬，那么在几十亿的url中，怎么判断一个url是不是已经爬过了？还有邮箱服务器，发送垃圾邮件的账号把它们叫做spamer，在这么多的邮箱账号中，怎么判断一个账号是不是spamer？等等一些场景，都可以使用到布隆过滤器。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis客户端</title>
    <link href="/2023/03/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <url>/2023/03/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="1-通信协议"><a href="#1-通信协议" class="headerlink" title="1  通信协议"></a>1  通信协议</h2><p>Redis监听默认6379的端口号，可以通过TCP方式建立连接。服务端约定了一种特殊的消息格式，每个命令都是以\r\n（CRLF回车+换行）结尾。这种编码格式之前在AOF文件中见到了，叫做Redis Serialization Protocol（RESP，redis序列化协议），发消息或者相应消息需要按这种格式编码，接受消息需要按这种格式解码，redis设计这种格式的原因：容易实现，解析快，可读性强。Redis6.0新特性里面说得RESP协议升级到了3.0版本，其实就是对于服务端和客户端可以接受的消息进行了升级扩展，比如客户端缓存的功能就是在这个版本中实现的。自己实现一个Redis的java客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClient</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">private</span> OutputStream write;<br>    <span class="hljs-keyword">private</span> InputStream read;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClient</span><span class="hljs-params">(String host, <span class="hljs-type">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(host, port);<br>        write = socket.getOutputStream();<br>        read = socket.getInputStream();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(String key, String val)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-comment">// 代表3个参数</span><br>        sb.append(<span class="hljs-string">&quot;*3&quot;</span>).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第一个参数(set)的长度</span><br>        sb.append(<span class="hljs-string">&quot;#3&quot;</span>).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第一个参数的内容</span><br>        sb.append(<span class="hljs-string">&quot;SET&quot;</span>).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第二个参数key的长度，(不定，动态获取)</span><br>        sb.append(<span class="hljs-string">&quot;$&quot;</span>).append(key.getBytes().length).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第二个参数key的内容</span><br>        sb.append(key).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第三个参数value的长度，(不定，动态获取)</span><br>        sb.append(<span class="hljs-string">&quot;$&quot;</span>).append(val.getBytes().length).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第三个参数val的内容</span><br>        sb.append(val).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <br>        <span class="hljs-comment">//发送命令</span><br>        write.write(sb.toString().getBytes());<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">//接受响应</span><br>        read.read(bytes);<br>        System.out.printLn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-comment">// 代表2个参数</span><br>        sb.append(<span class="hljs-string">&quot;*2&quot;</span>).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第一个参数(get)的长度</span><br>        sb.append(<span class="hljs-string">&quot;#3&quot;</span>).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第一个参数的内容</span><br>        sb.append(<span class="hljs-string">&quot;GET&quot;</span>).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第二个参数key的长度，(不定，动态获取)</span><br>        sb.append(<span class="hljs-string">&quot;$&quot;</span>).append(key.getBytes().length).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第二个参数key的内容</span><br>        sb.append(key).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <br>        <span class="hljs-comment">//发送命令</span><br>        write.write(sb.toString().getBytes());<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">//接受响应</span><br>        read.read(bytes);<br>        System.out.printLn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-type">MyClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClient</span>(<span class="hljs-string">&quot;192.168.44.181&quot;</span>, <span class="hljs-number">6379</span>);<br>        client.set(<span class="hljs-string">&quot;qs&quot;</span>, <span class="hljs-string">&quot;2673&quot;</span>);<br>        client.get(<span class="hljs-string">&quot;qs&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用这种协议，可以用java实现所有的redis操作命令。</p><h2 id="2-常用客户端"><a href="#2-常用客户端" class="headerlink" title="2  常用客户端"></a>2  常用客户端</h2><p><a href="https://redis.io/resources/clients/#java%EF%BC%8C%E5%AE%98%E7%BD%91%E6%8E%A8%E8%8D%90%E7%9A%84java%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%89%E4%B8%89%E4%B8%AA%EF%BC%9AJedis%EF%BC%8CRedisson%E5%92%8CLuttce">https://redis.io/resources/clients/#java，官网推荐的java客户端有三个：Jedis，Redisson和Luttce</a></p><table><thead><tr><th>客户端</th><th>作用</th></tr></thead><tbody><tr><td>Jedis</td><td>体系非常小，但是功能很完善</td></tr><tr><td>Lettuce</td><td>高级客户端，支持线程安全，异步，反应式编程，支持集群，哨兵，pipeline，编解码</td></tr><tr><td>Redisson</td><td>基于Redis服务实现的java分布式可扩展的数据结构</td></tr></tbody></table><p>Spring操作redis提供了一个模板方法，RedisTemplate。实际上这个并不是spring官方开发的一个客户端呢。Spring定义了一个连接工厂接口：redisConnectionFactory。这个接口有很多实现，例如：JedisConnectionFactory，JredisConnectionFactory，LettuceConnectionFactory，SrpConnectionFactory。也就是说，RedisTemplate对其他现成的客户端再进行了一层封装而已。在springboot 2.x版本之前，RedisTemplate默认使用Jedis。2.x版本之后，默认使用Lettuce。</p><h2 id="3-Jedis"><a href="#3-Jedis" class="headerlink" title="3  Jedis"></a>3  Jedis</h2><p><a href="https://github.com/redis/jedis/">https://github.com/redis/jedis/</a></p><h3 id="3-1-Jedis功能特性"><a href="#3-1-Jedis功能特性" class="headerlink" title="3.1 Jedis功能特性"></a>3.1 Jedis功能特性</h3><p>Jedis是最熟悉和最常用的客户端。如果不用RedisTemplate，就可以直接创建Jedis的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>    jedis.set(<span class="hljs-string">&quot;qs&quot;</span>, <span class="hljs-number">6379</span>);<br>    System.out.printLn(jedis.get(<span class="hljs-string">&quot;qs&quot;</span>));<br>    jedis.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>Jedis有一个问题：多个线程使用一个连接的时候线程不安全。</p><p>下面也提供了解决思路：使用连接池，为每个请求创建不同的连接，基于Apache common pool实现。Jedis的连接池有三个实现：JedisPool，ShardedJedisPool。JedisSentinePool。都是用getResource从连接池获取一个连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//普通连接池</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ordinaryPool</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">JedisPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(<span class="hljs-string">&quot;192.168.44.181&quot;</span>, <span class="hljs-number">6379</span>);<br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> pool.getResource();<br>    System.out.printLn(jedis.get(<span class="hljs-string">&quot;qs&quot;</span>));<br>&#125;<br><br><span class="hljs-comment">//分片连接池</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shardedPool</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>    <span class="hljs-type">JedisSjardInfo</span> <span class="hljs-variable">shardInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisShardInfo</span>(<span class="hljs-string">&quot;192.168.44.181&quot;</span>, <span class="hljs-number">6379</span>);<br>    List&lt;JedisShardInfo&gt; infoList = Arrays.asList(shardInfo);<br>    <span class="hljs-type">ShardedJedisPool</span> <span class="hljs-variable">jedisPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShardedJedisPool</span>(poolConfig, infoList);<br>    <br>    <span class="hljs-type">ShardedJedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> jedisPool.getResource();<br>    System.out.printLn(jedis.get(<span class="hljs-string">&quot;qs&quot;</span>));<br>&#125;<br><br><span class="hljs-comment">//哨兵连接池</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sentinelPool</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">masterName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;redis-master&quot;</span>;<br>    Set&lt;String&gt; sentinels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    sentinels.add(<span class="hljs-string">&quot;192.168.44.186:26379&quot;</span>);<br>    sentinels.add(<span class="hljs-string">&quot;192.168.44.187:26379&quot;</span>);<br>    sentinels.add(<span class="hljs-string">&quot;192.168.44.188:26379&quot;</span>);<br>    <br>    <span class="hljs-type">JedisSentinelPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisSentinelPool</span>(masterName, sentinels);<br>    System.out.printLn(pool.getResource().get(<span class="hljs-string">&quot;qs&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>Jedis的功能比较完善，redis官方的特性全部支持，比如发布订阅，事务，Lua脚本，客户端分片，哨兵，集群，pipeline等等。</p><h3 id="3-2-Sentinel获取连接原理"><a href="#3-2-Sentinel获取连接原理" class="headerlink" title="3.2 Sentinel获取连接原理"></a>3.2 Sentinel获取连接原理</h3><p>在构造方法中（JedisSentinelPool）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisSentinelPool</span>(masterName, sentinels);<br></code></pre></td></tr></table></figure><p>调用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HostAndPort</span> <span class="hljs-variable">master</span> <span class="hljs-operator">=</span> initSentinels(sentinels, masterName);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">private</span> HostAndPort <span class="hljs-title function_">initSentinels</span><span class="hljs-params">(Set&lt;String&gt; sentinels, String masterName)</span> &#123;<br>      <span class="hljs-type">HostAndPort</span> <span class="hljs-variable">master</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">sentinelAvailable</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-built_in">this</span>.log.info(<span class="hljs-string">&quot;Trying to find master from available Sentinels...&quot;</span>);<br>      <span class="hljs-type">Iterator</span> <span class="hljs-variable">var5</span> <span class="hljs-operator">=</span> sentinels.iterator();<br><br>      String sentinel;<br>      HostAndPort hap;<br>      <span class="hljs-comment">//有多个sentinels，遍历这些sentinel</span><br>      <span class="hljs-keyword">while</span>(var5.hasNext()) &#123;<br>          sentinel = (String)var5.next();<br>          <span class="hljs-comment">//host:port表示的sentinel地址转化成一个HostAndPort对象</span><br>          hap = HostAndPort.parseString(sentinel);<br>          <span class="hljs-built_in">this</span>.log.debug(<span class="hljs-string">&quot;Connecting to Sentinel &#123;&#125;&quot;</span>, hap);<br>          <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>          <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">//连接到sentinel</span><br>              jedis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(hap.getHost(), hap.getPort(), <span class="hljs-built_in">this</span>.sentinelConnectionTimeout,<br>                                <span class="hljs-built_in">this</span>.sentinelSoTimeout);<br>              <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.sentinelUser != <span class="hljs-literal">null</span>) &#123;<br>                  jedis.auth(<span class="hljs-built_in">this</span>.sentinelUser, <span class="hljs-built_in">this</span>.sentinelPassword);<br>              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.sentinelPassword != <span class="hljs-literal">null</span>) &#123;<br>                  jedis.auth(<span class="hljs-built_in">this</span>.sentinelPassword);<br>              &#125;<br><br>              <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.sentinelClientName != <span class="hljs-literal">null</span>) &#123;<br>                  jedis.clientSetname(<span class="hljs-built_in">this</span>.sentinelClientName);<br>              &#125;<br><span class="hljs-comment">//根据masterName得到master的地址，返回一个list，host=list[0],port=list[1]</span><br>              List&lt;String&gt; masterAddr = jedis.sentinelGetMasterAddrByName(masterName);<br>              sentinelAvailable = <span class="hljs-literal">true</span>;<br>              <span class="hljs-keyword">if</span> (masterAddr != <span class="hljs-literal">null</span> &amp;&amp; masterAddr.size() == <span class="hljs-number">2</span>) &#123;<br>                  <span class="hljs-comment">//如果在任何一个sentinel中找到了master，不再遍历sentinels</span><br>                  master = <span class="hljs-built_in">this</span>.toHostAndPort(masterAddr);<br>                  <span class="hljs-built_in">this</span>.log.debug(<span class="hljs-string">&quot;Found Redis master at &#123;&#125;&quot;</span>, master);<br>                  <span class="hljs-keyword">break</span>;<br>              &#125;<br>              <span class="hljs-built_in">this</span>.log.warn(<span class="hljs-string">&quot;Can not get master addr, master name: &#123;&#125;. Sentinel: &#123;&#125;&quot;</span>, masterName, hap);<br>          &#125; <span class="hljs-keyword">catch</span> (JedisException var13) &#123;<br>              <span class="hljs-built_in">this</span>.log.warn(<span class="hljs-string">&quot;Cannot get master address from sentinel running @ &#123;&#125;.&quot;</span>+<br>                            <span class="hljs-string">&quot; Reason: &#123;&#125;. Trying next one.&quot;</span>, hap, var13);<br>          &#125; <span class="hljs-keyword">finally</span> &#123;<br>              <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) &#123;<br>                  jedis.close();<br>              &#125;<br><br>          &#125;<br>      &#125;<br><span class="hljs-comment">//到这里，如果master为null，则说明两种情况，一种是所有的sentinel节点都down了，一种是master节点没有被存活的sentinel监控到</span><br>      <span class="hljs-keyword">if</span> (master == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">if</span> (sentinelAvailable) &#123;<br>              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisException</span>(<span class="hljs-string">&quot;Can connect to sentinel, but &quot;</span> + masterName <br>                                       + <span class="hljs-string">&quot; seems to be not monitored...&quot;</span>);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisConnectionException</span>(<span class="hljs-string">&quot;All sentinels down, cannot determine where is &quot;</span> <br>                                                 + masterName + <span class="hljs-string">&quot; master is running...&quot;</span>);<br>          &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">//如果走到这里，说明找到了master地址</span><br>          <span class="hljs-built_in">this</span>.log.info(<span class="hljs-string">&quot;Redis master running at &#123;&#125;, starting Sentinel listeners...&quot;</span>, master);<br>          var5 = sentinels.iterator();<br><span class="hljs-comment">//启动对每个sentinels的监听为每个sentinel都启动了一个监听者MasterListener。MasterListener本身是一个线程，它会去订阅sentinel上关于master节点地址改变的信息</span><br>          <span class="hljs-keyword">while</span>(var5.hasNext()) &#123;<br>              sentinel = (String)var5.next();<br>              hap = HostAndPort.parseString(sentinel);<br>              <span class="hljs-type">MasterListener</span> <span class="hljs-variable">masterListener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MasterListener</span>(masterName, hap.getHost(),<br>                                                                 hap.getPort());<br>              masterListener.setDaemon(<span class="hljs-literal">true</span>);<br>              <span class="hljs-built_in">this</span>.masterListeners.add(masterListener);<br>              masterListener.start();<br>          &#125;<br>          <span class="hljs-keyword">return</span> master;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-Cluster获取连接原理"><a href="#3-3-Cluster获取连接原理" class="headerlink" title="3.3 Cluster获取连接原理"></a>3.3 Cluster获取连接原理</h3><p>使用Jedis连接Cluster的时候，我们只需要连接到任意一个或者多个redis group中的实例地址，为了避免get，set的时候发生重定向错误，需要把slot和redis节点的关系保存起来，在本地计算slot，就可以获得redis节点信息。</p><p><img src="/image/redis/redis%E5%AE%A2%E6%88%B7%E7%AB%AF/1.png"></p><p>注意slots的数量是写死的，不能修改。</p><p>第一，在服务端表示16384个位，只需要2kb的大小（每个group维护一个位数组，在16384bit里面把对应下表的值改成1，就代表slot由当前节点负责）。再大的话，获取slots信息有点浪费通信资源。</p><p>第二，一般来说集群的节点数不会特别大，16384个slots够他们分了。</p><p><em>关键问题：在于如何存储slot和redis连接池的关系。</em></p><ol><li>程序启动初始化集群环境，读取配置文件中的节点配置，无论是主从，无论多少个，只拿第一个，获取redis连接实例。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeSlotsCache</span><span class="hljs-params">(Set&lt;HostAndPort&gt; startNodes, GenericObjectPoolConfig poolCOnfig, String password)</span>&#123;<br>    <span class="hljs-keyword">for</span>(HostAndPort hostAndPort : startNodes)&#123;<br>        <span class="hljs-comment">//获取一个Jedis实例</span><br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(hostAndPort.getHost(),hostAndPort.getPort());<br>        <span class="hljs-keyword">if</span>(password != <span class="hljs-literal">null</span>)&#123;<br>            jedis.auth(password);<br>        &#125;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//获取redis节点和Slot虚拟槽</span><br>            cache.discoverClusterNodesAndSlots(jedis);<br>            <span class="hljs-comment">//直接跳出循环</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">catch</span>(JedisConnectionException e)&#123;<br>            <br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span>(jedis != <span class="hljs-literal">null</span>)&#123;<br>                jedis.close();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>discoverClusterNodesAndSlots方法，用获取的redis 连接实例执行clusterSlots()方法，实际执行redis服务端cluster slots命令，获取虚拟槽信息。该集合的基本信息为[long.long,List,List]，第一，第二个元素是该节点负责槽点的其实位置，第三个元素是主节点信息，第四个元素为主节点对应的从节点信息。该list的基本信息为[string,int,string]，第一个为host信息，第二个为port信息，第三个为唯一id。</p></li><li><p>获取有关节点的槽点信息后，调用getAssignedSlotArray(slotinfo)来获取所有的槽点值。</p></li><li><p>再获取主节点的地址信息，调用generateHostAndPort(hostInfo)方法，生成一个hostAndPort对象。</p></li><li><p>再assignSlotsToNode方法中，再根据节点地址信息来设置节点对应的JedisPool，即设置Map&lt;Srting, JedisPool&gt; nodes的值。</p></li></ol><p>接下来判断若此时节点信息为主节点信息时，则调用assignSlotsToNodes方法，设置每个槽点对应的连接池（slave不需要连接），即设置Map&lt;Integer, JedisPool&gt; slots的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">discoverClusterNodesSlots</span><span class="hljs-params">(Jedis jedis)</span>&#123;<br>    w.lock();<br>    <span class="hljs-keyword">try</span>&#123;<br>        reset();<br>        <span class="hljs-comment">//获取节点集合</span><br>        List&lt;Object&gt; slots = jedis.clusterSlots();<br>        <span class="hljs-comment">//遍历3个master节点</span><br>        <span class="hljs-keyword">for</span>(Object slotInfoObj : slots)&#123;<br>            List&lt;object&gt; slotInfo = (List&lt;Object&gt;) slotInfoObj;<br>            <span class="hljs-comment">//如果&lt;=2，代表没有分配slot</span><br>            <span class="hljs-keyword">if</span>(slotInfo.size() &lt;= MASTER_NODE_INDEX)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//获取分配到当前master节点的数据槽</span><br>            List&lt;Integer&gt; slotNums = getAssignedSlotArray(slotInfo);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> slotInfo.size();<br>            <span class="hljs-comment">//第3位和第4位是主从端口的信息</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> MASTER_NODE_INDEX ; i &lt; size ; i++)&#123;<br>                List&lt;Object&gt; hostInfos = (List&lt;Object&gt;) slotInfo.get(i);<br>                <span class="hljs-keyword">if</span>(hostInfos.size() &lt;= <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">//根据IP端口生成HostAndPort实例</span><br>                <span class="hljs-type">HostAndPort</span> <span class="hljs-variable">targetNode</span> <span class="hljs-operator">=</span> generateHostAndPort(hostInfos);<br>                <span class="hljs-comment">//根据HostAndPort解析出ip:port的key值，再根据key从缓存中查询对应的jedisPool实例。如果没有jedisPool实例，就创建JedisPool实例，最后放入缓存中，nodeKey和nodePool的关系</span><br>                setupNodeIfNotExist(targetNode);<br>                <span class="hljs-keyword">if</span>(i == MASTER_NODE_INDEX)&#123;<br>                    assignSlotsToNode(slotNums, targetNode);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        w.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显，这个Map有16384个key，key对应的value是一个连接池信息。有几个Redis Group（或者说有几个master），就有几个不同的连接池。获取slot和redis实例的对应关系之后，接下来就是从集群环境获取值。Jedis集群模式下所有的命令都要调用这个方法：核心代码JedisClusterCommand#runWithRetries</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">connection = connectionHandler.getConnectionFromSlot(JedisClusterCRC16.getSlot(key));<br></code></pre></td></tr></table></figure><ol><li><p>把key作为参数，执行CRC16算法，获取key对应的slot值。</p></li><li><p>通过该slot值，去slots的map集合中获取jedisPool实例。</p></li><li><p>通过jedisPool实例获取jedis实例，最终完成redis数据存取工作。</p></li></ol><h3 id="3-4-Jedis实现分布式锁"><a href="#3-4-Jedis实现分布式锁" class="headerlink" title="3.4 Jedis实现分布式锁"></a>3.4 Jedis实现分布式锁</h3><p>分布式锁的基本需求：</p><p>​    1. 互斥性：只有一个客户端能够持有锁</p><p>​    2. 不会产生死锁：即使持有锁的客户端奔溃，也能保证后续其他客户端可以获取锁。</p><p>​    3. 只有持有这把锁的客户端才能解锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryGetDistributedLock</span><span class="hljs-params">(Jedis jedis, String lockKey, String requestId, <span class="hljs-type">int</span> expireTime)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);<br>    <span class="hljs-keyword">if</span>(LOCK_SUCCESS.equals(result))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    1. lockKey是redis key的名称，谁添加成功这个key，就代表谁获取锁成功。比如有一把修改1001账户余额的锁。</p><p>​    2. requestId是客户端的ID（设置成value），如果我们要保证只有加锁的客户端才能释放锁，就必须获取客户端的ID（保证第三点，自己才能解锁）。</p><p>​    3. SET_IF_NOT_EXIST是我们的命令中加上NX（保证第一点，互斥）。</p><p>​    4. SET_WITH_EXPIRE_TIME，PX代表以毫秒为单位设置key的过期时间（保证第二点，不会死锁）。expireTime是自动释放锁的时间，比如5000代表5秒。</p><p>如果在释放锁的时候，这把锁已经不属于这个客户端（例如已经过期，并且被别的客户端获取锁成功了），那就会出现释放了其他客户端的锁的情况。所以，要先判断是不是自己加的锁，才能释放，为了保证原子性，我们把判断客户端是否相等和删除key的操作放在Lua脚本中执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseDistributedLock</span><span class="hljs-params">(Jedis jedis, String lockKey, String requestId)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1])==ARGV[1] then return redis.call(&#x27;del&#x27;,KEY[1]) else return 0 end&quot;</span>;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.eval(script, Collections.singletonList(lockKey), CollectionssingletonList(requestId));<br>    <span class="hljs-keyword">if</span>(RELEASE_SUCCESS.equals(result))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-Pipline"><a href="#3-5-Pipline" class="headerlink" title="3.5 Pipline"></a>3.5 Pipline</h3><p>平时说redis是单线程的，说的是redis的请求是单线程处理的，只有上一个命令的结果响应以后，下一个命令才会处理。如果要一次操作10万个key，客户端跟服务端就要交互10万次，排队的时间加上网络通信的时间，就会很慢。举个例子，假设一次交互的网络延迟的1毫秒，客户端1秒钟最多只能发送1000个命令。这个就太浪费服务端的性能了。</p><p>​    能不能像把一组命令组装在一起发送给redis服务端执行，然后一次性获得返回结果呢？这个就是Pipeline的作用。Pipeline通过一个队列把所有的命令缓存起来，然后把多个命令在一次连接中发送给服务器。</p><p>​    要是按Pipeline，既要服务端的支持，也要客户端的支持。对于服务端来说，需要能够处理客户端通过一个TCP连接发来的多个命令，并且逐个地执行命令一起返回。对于客户端来说，要把多个命令缓存起来，达到一定地条件就发送出去，最后才处理redis地应答（这里要注意对客户端内存地消耗）。jedis-pipeline的client0buffer限制：8192bytes，客户端堆积的命令超过8M时，会发送给服务端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisOutputStream</span><span class="hljs-params">(<span class="hljs-keyword">final</span> OutputStream out)</span>&#123;<br>    <span class="hljs-built_in">this</span>(out, <span class="hljs-number">8192</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>pipeline对于命令条数没有限制，但是命令可能会受限于TCP包大小。需要注意的是，并不是所有业务场景都要用pipeline。如果某些操作需要马上得到redis操作是否成功的结果，这种场景就不合适。有些场景，例如批量写入数据，对于结果的实时性和成功性要求不高，就可以用Pipeline。</p><h2 id="4-Lettuce"><a href="#4-Lettuce" class="headerlink" title="4  Lettuce"></a>4  Lettuce</h2><p>与Jedis相比，Lettuce则完全克服了其线程不安全的缺点：Lettuce是一个可伸缩的线程安全的redis客户端，支持同步，异步和响应式模式（Reactive）。多个线程可以共享一个连接实例，而不必担心多线程并发问题。</p><p>Lettuce基于Netty框架构建，支持Redis的全部高级功能，如发布订阅，事务，Lua脚本，Sentinel，集群，pipeline支持连接池。Lettuce是springboot 2.x默认的客户端，替换了jedis。集成之后我们不需要单独使用它，直接调用spring的redisTemplate操作，连接和创建和关闭也不需要我们操心。</p><h2 id="5-Redisson"><a href="#5-Redisson" class="headerlink" title="5  Redisson"></a>5  Redisson</h2><p>Redisson是一个在redis的基础上实现的java内存数据网格（In-Memory Data Grid），提供了分布式和可扩展的java数据结构，比如分布式的Map，List，Queue，Set，不需要自己去运行一个服务实现。</p><h3 id="5-1-特点"><a href="#5-1-特点" class="headerlink" title="5.1 特点"></a>5.1 特点</h3><p>基于Netty实现，采用非阻塞IO，性能高；支持异步请求。支持连接池，pipeline，Lua脚本，redis Sentinel， redis cluster。不支持事务，官方建议以lua脚本代替事务。主从，哨兵，集群都支持。Spring也可以配置和注入RedissonClient。</p><h3 id="5-2-实现分布式锁"><a href="#5-2-实现分布式锁" class="headerlink" title="5.2 实现分布式锁"></a>5.2 实现分布式锁</h3><p>在Redisson里面提供了更见简单的分布式锁的实现。</p><p><img src="/image/redis/redis%E5%AE%A2%E6%88%B7%E7%AB%AF/2.png"></p><p>加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">rLock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;updateAccount&quot;</span>);<br>    <span class="hljs-comment">//最多等待100秒，上锁10后自动解锁</span><br>    <span class="hljs-keyword">if</span>(rLock.tryLock(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS))&#123;<br>        System.out.printLn(<span class="hljs-string">&quot;获取锁成功&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">//do something</span><br>    rLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>在获得锁之后，只需要一个tryLock方法，里面有三个参数：</p><p>​    1.waitTime：获取锁的最大等待时间，超过这个时间不再尝试获取锁。</p><p>​    2.leaseTime：如果没有调用unlock，超过了这个时间会自动释放锁。</p><p>​    3.TimeUnit：释放时间的单位</p><p>Redisson的分布式锁的实现原理，在加锁的时候，在redis写入了一个HASH，key是锁名称，field是线程名称，value是1（表示锁的重入次数）。</p><p><img src="/image/redis/redis%E5%AE%A2%E6%88%B7%E7%AB%AF/3.png"></p><p>trylock() -&gt;tryAcquire() -&gt; tryAcquireAsync()-&gt; trylockInnerAsync()，最终也是调用了一段lua脚本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//KEYS[1]锁名称 updateAccount</span><br><span class="hljs-comment">//ARGV[1]key过期时间10000ms</span><br><span class="hljs-comment">//ARGV[2]线程名称</span><br><span class="hljs-comment">//锁名称不存在</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;exists&#x27;</span>,KEYS[<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>)) then<br>    <span class="hljs-comment">//创建一个hash，key=锁名称，field=线程名，value=1</span><br>    redis.call(<span class="hljs-string">&#x27;hset&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">2</span>],<span class="hljs-number">1</span>);<br><span class="hljs-comment">//设置hash的过期时间</span><br>redis.call(<span class="hljs-string">&#x27;prxpire&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> nil;<br>end;<br><span class="hljs-comment">//锁名称存在，判断是否当前线程持有的锁</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">2</span>])==<span class="hljs-number">1</span>) then<br>    <span class="hljs-comment">//如果是，value+1，代表重入次数+1</span><br>    redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">2</span>],<span class="hljs-number">1</span>);<br><span class="hljs-comment">//重新获得锁，需要重新设置key的过期时间</span><br>redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> nil;<br>end;<br><span class="hljs-comment">//锁存在，但是不是当前线程持有，返回过期时间(毫秒)</span><br><span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;pttl&#x27;</span>,KEYS[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><p>释放锁:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//KEYS[1]锁名称 updateAccount</span><br><span class="hljs-comment">//KEYS[2]频道名称rredisson_lock_channel:&#123;updateAccount&#125;</span><br><span class="hljs-comment">//ARGV[1]释放锁的消息 0</span><br><span class="hljs-comment">//ARGV[2]释放时间 10000</span><br><span class="hljs-comment">//ARGV[3]线程名称</span><br><span class="hljs-comment">//锁不存在，过期或者已经释放</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;exists&#x27;</span>,KEYS[<span class="hljs-number">1</span>])==<span class="hljs-number">0</span>) then<br>    <span class="hljs-comment">//发布锁已经释放的消息</span><br>    redis.call(<span class="hljs-string">&#x27;publish&#x27;</span>,KEYS[<span class="hljs-number">2</span>],ARGV[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>end;<br><span class="hljs-comment">//锁存在，但是不是当前线程加的锁</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">3</span>])==<span class="hljs-number">0</span>) then<br>    <span class="hljs-keyword">return</span> nil;<br>end;<br><span class="hljs-comment">//锁存在，是当前线程加的锁，重入次数-1</span><br>local counter=redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">3</span>],<span class="hljs-number">-1</span>);<br><span class="hljs-comment">//减1后大于0，说明这个线程持有这把锁还有其他的任务需要执行</span><br><span class="hljs-keyword">if</span>(counter&gt;<span class="hljs-number">0</span>) then<br>    <span class="hljs-comment">//重新设置锁的过期时间</span><br>    redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">2</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">//减1后等于0，释放锁</span><br>    redis.call(<span class="hljs-string">&#x27;del&#x27;</span>,KEYS[<span class="hljs-number">1</span>]);<br><span class="hljs-comment">//释放后发布消息</span><br>redis.call(<span class="hljs-string">&#x27;publish&#x27;</span>,KEYS[<span class="hljs-number">2</span>],ARGV[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>end;<br><span class="hljs-comment">//其他情况返回nil</span><br><span class="hljs-keyword">return</span> nil;<br></code></pre></td></tr></table></figure><p>这个是Redisson里面分布式锁的实现，在调用的时候非常简单。</p><p>​    1.业务没执行完，锁到期了怎么办？ watchdog（Redisson github wiki）</p><p>​    2.集群模式下，如果对多个master加锁，导致重复加锁怎么办？  Redisson会自动选择同一个master</p><p>​    3.业务没执行完，redis master挂了怎么办？ redis slave还有这个数据</p><p>​    Redisson跟jedis定位不同，它不是一个单纯的redis客户端，而是基于redis实现的分布式的服务，如果有需要用到一些分布式的数据结构，比如还可以基于Redisson的分布式队列实现分布式事务，就可以引入redisson的依赖实现。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis分布式</title>
    <link href="/2023/03/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <url>/2023/03/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>如果要实现redis数据的分片，有三种方案。</p><p>第一种是在客户端实现相关的逻辑，例如用取模或者一致性哈希对key进行分片，查询和修改都先判断key的路由。</p><p>第二种是把做分片处理的逻辑抽取出来，运行一个独立的代理服务，客户端连接到这个代理服务，代理服务做请求的转发。</p><p>第三种就是基于服务端实现。</p><h2 id="1-客户端Sharding-ShardedJedis"><a href="#1-客户端Sharding-ShardedJedis" class="headerlink" title="1  客户端Sharding-ShardedJedis"></a>1  客户端Sharding-ShardedJedis</h2><p>RedisTemplate就是对jedis的封装。</p><p>Jedis有几种连接池。比如这里一个连接到186，一个连接到windows的redis服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShardingTest</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>        <span class="hljs-comment">//Redis服务器</span><br>        <span class="hljs-type">JedisShardInfo</span> <span class="hljs-variable">shardInfo1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisShardInfo</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>        <span class="hljs-type">JedisShardInfo</span> <span class="hljs-variable">shardInfo2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisShardInfo</span>(<span class="hljs-string">&quot;192.168.44.186&quot;</span>, <span class="hljs-number">6379</span>);<br>        <span class="hljs-comment">//连接池</span><br>        List&lt;JedisShardInfo&gt; infoList = Arrays.asList(shardInfo1, shardInfo2);<br>        <span class="hljs-type">ShardedJedisPool</span> <span class="hljs-variable">jedisPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShardedJedisPool</span>(poolConfig, infoList);<br>        <br>        <span class="hljs-type">ShardedJedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            jedis = jedisPool.getResource();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">100</span> i++)&#123;<br>                jedis.set(<span class="hljs-string">&quot;k&quot;</span>+i, <span class="hljs-string">&quot;&quot;</span>+i);<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">100</span> ; i++)&#123;<br>                System.out.printLn(jedis.get(<span class="hljs-string">&quot;k&quot;</span>+i));<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span>(jedis != <span class="hljs-literal">null</span>)&#123;<br>                jedis.close();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过dbsize命令发现，一台服务器有44个key，一台服务器有56个key。如果是希望数据分布相对均匀的话，首先可以考虑哈希后取模(因为key不一定是整数，所以先计算哈希)。</p><p><strong>哈希后取模</strong></p><p>例如，hash(key)%N，根据余数，决定映射到哪个节点。这种方式比较简单，属于静态的分片规则，但是一旦节点数量变化，由于取模的N发生变化，数据需要重新分布。为了解决这个问题，又有了一致性哈希算法。ShardedJedis实际上用的就是一致性哈希算法。</p><p><strong>一致性哈希</strong></p><p>原理：把所有的哈希值空间组织成一个虚拟的圆环(哈希环)，整个空间按顺时针方向组织。因为是环形空间，0和2^32-1是重叠的。假如有四台机器要哈希环来实现映射(分布数据)，先根据机器的名称或者ip计算哈希值，然乎分布到哈希环中(红色圆圈)。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/1.png"></p><p>现在有4条数据或者4个访问请求，对key计算后，得到哈希环中的位置（绿色圆圈）。沿哈希环顺时针找到的第一个node，就是数据存储的节点。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/2.png"></p><p>在这种情况下，新增了一个node5节点，只影响一部分数据的分布。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/3.png"></p><p>删除了一个节点node4，只影响相邻的一个节点。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/4.png"></p><p>一致性哈希解决了动态增减节点时，所有数据都需要重新分布的问题，它只会影响到下一个相邻的系欸但，对其他节点没有影响。但是这样的一致性算法有一个缺点，因为节点不一定是均匀分布的，特别是在节点数比较少的情况下，所以数据不能得到均匀分布。解决这个问题的办法是引入虚拟节点(Virtual node)。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/5.png"></p><p>Node1设置了两个虚拟节点，node2也设置了两个虚拟节点（虚线圆圈）。这时候有3条数据分布到了node1，1条数据分布到了node2。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/6.png"></p><p>一致性哈希在分布式系统中，负载均衡，分库分表等场景中都有应用，跟LRU一样，是一个基础的算法。</p><p><strong>java源码</strong></p><p>Redis.client.util.Sharded.initialze()，jedis实例被放到了一棵红黑树TreeMap中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(List&lt;S&gt; shards)</span> &#123;<br>      <span class="hljs-comment">//创建一个红黑树</span><br>      <span class="hljs-built_in">this</span>.nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>();<br><span class="hljs-comment">//把所有节点放入红黑树中</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i != shards.size(); ++i) &#123;<br>          <span class="hljs-type">S</span> <span class="hljs-variable">shardInfo</span> <span class="hljs-operator">=</span> (ShardInfo)shards.get(i);<br>          <span class="hljs-comment">//为每个Redis节点创建160个虚拟节点，放到红黑树中</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">160</span> * shardInfo.getWeight();<br>          <span class="hljs-type">int</span> n;<br>          <span class="hljs-keyword">if</span> (shardInfo.getName() == <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span>; n &lt; N; ++n) &#123;<br>                  <span class="hljs-built_in">this</span>.nodes.put(<span class="hljs-built_in">this</span>.algo.hash(<span class="hljs-string">&quot;SHARD-&quot;</span> + i + <span class="hljs-string">&quot;-NODE-&quot;</span> + n), shardInfo);<br>              &#125;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span>; n &lt; N; ++n) &#123;<br>                  <span class="hljs-comment">//对名字计算哈希(MurmurHash)</span><br>                  <span class="hljs-built_in">this</span>.nodes.put(<span class="hljs-built_in">this</span>.algo.hash(shardInfo.getName() + <span class="hljs-string">&quot;*&quot;</span> + n), shardInfo);<br>              &#125;<br>          &#125;<br><span class="hljs-comment">//添加到map中，键为ShardInfo，值为redis实例</span><br>          <span class="hljs-built_in">this</span>.resources.put(shardInfo, shardInfo.createResource());<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>当存取键值对时，计算键的哈希值，然后从红黑树上摘下比该值大的第一个节点上的JedisShardInfo，随后从resources去除jedis。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> R <span class="hljs-title function_">getShard</span><span class="hljs-params">(String key)</span>&#123;<br>    <span class="hljs-keyword">return</span> resources.get(getShardInfo(key));<br>&#125;<br></code></pre></td></tr></table></figure><p>获取红黑树子集，找出比它大的第一个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> S <span class="hljs-title function_">getShardInfo</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] key)</span> &#123;<br>    <span class="hljs-comment">//获取比当前key的哈希值要大的红黑树的子集</span><br>    SortedMap&lt;Long, S&gt; tail = <span class="hljs-built_in">this</span>.nodes.tailMap(<span class="hljs-built_in">this</span>.algo.hash(key));<br>    <span class="hljs-keyword">return</span> tail.isEmpty() ? <br>        <span class="hljs-comment">//没有比它大的了，直接从nodes中取出</span><br>        (ShardInfo)<span class="hljs-built_in">this</span>.nodes.get(<span class="hljs-built_in">this</span>.nodes.firstKey()) : <br>    <span class="hljs-comment">//返回第一个比它大的JedisShardInfo</span><br>    (ShardInfo)tail.get(tail.firstKey());<br>&#125;<br></code></pre></td></tr></table></figure><p>使用ShardedJedis之类的客户端分片代码的优势是配置简单，不依赖于其他中间件，分区的逻辑可以自定义，比较灵活。但是基于客户端的方案，不能实现动态的服务增减，每个客户端需要自行维护分片则略，存在重复代码。</p><h2 id="2-代理Proxy"><a href="#2-代理Proxy" class="headerlink" title="2  代理Proxy"></a>2  代理Proxy</h2><p>典型的代理分区方案有Twitter开源的Twemproxy和国内的豌豆荚开源的Codis。</p><h3 id="2-1-Twemproxy"><a href="#2-1-Twemproxy" class="headerlink" title="2.1 Twemproxy"></a>2.1 Twemproxy</h3><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/7.png"></p><p>Twemproxy的优点：比较稳定，可用性高。</p><p>不足：</p><ol><li><p>出现故障不能自动转移，架构复杂，需要借助其他组件（LVS/HAProxy+Keepalived）实现HA</p></li><li><p>扩缩容需要修改配置，不能实现平滑地扩缩容（需要重新分布数据）。</p></li></ol><h3 id="2-2-Codis"><a href="#2-2-Codis" class="headerlink" title="2.2 Codis"></a>2.2 Codis</h3><p>Codis是一个代理中间件，豌豆荚公司用Go语言开发的（快三年时间没有更新了）。跟数据库分库分表中间件的Mycat的工作层次是一样的。功能：客户端连接Codis跟连接redis没有区别。</p><table><thead><tr><th>功能特性</th><th>Codis</th><th>Tewmproxy</th><th>Redis Cluster</th></tr></thead><tbody><tr><td>重新分片不需要重启</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>pipeline</td><td>yes</td><td>yes</td><td>–</td></tr><tr><td>多key操作的hash tags {}</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>重新分片时的多key操作</td><td>yes</td><td>–</td><td>no</td></tr><tr><td>客户端支持</td><td>所有</td><td>所有</td><td>支持cluster协议的客户端</td></tr></tbody></table><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/8.png"></p><p>分片原理：Codis把所有的key分成了N个槽（例如1024），每个槽对应一个分组，一个分组对应于一个或者一组Redis实例。Codis对key进行CRC32运算，得到一个32位的数字，然后模拟N（槽的个数），得到余数，这个就是key对应的槽，槽后面就是redis实例（跟Mycat的先哈希后范围的算法思想类似）。比如4个槽：</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/9.png"></p><p>Codis的槽位映射关系是保存在proxy中的，如果要解决单点的问题，Codis也要做集群部署，多个Codis节点同步槽和实例的关系需要运行一个Zookeeper（或者etcd/本地文件）。</p><p>在新增节点的时候，可以为节点指定特定的槽位。Coids也提供了自动均衡策略。Codis不支持事务，其他的一些命令也不支持。获取数据原理（mget）在redis中的各个实例里获取到符合的key，然后再汇总到Codis中。Codis是第三方提供的分布式解决方案，再官网的集群功能稳定之前，Coids也得到了大量的应用。</p><h2 id="3-Redis-Cluster"><a href="#3-Redis-Cluster" class="headerlink" title="3  Redis Cluster"></a>3  Redis Cluster</h2><p>Redis Cluster是在Redis3.0版本正式推出的，用来解决分布式的需求，同时也可以实现高可用。跟Codis不一样，它是去中心化的，客户端可以连接到任意一个可用节点。数据分片有几个关键的问题需要解决：</p><ol><li><p>数据怎么相对均匀的分片</p></li><li><p>客户端怎么访问到相应的节点和数据</p></li><li><p>重新分片的过程，怎么保证正常服务</p></li></ol><h3 id="3-1-架构"><a href="#3-1-架构" class="headerlink" title="3.1 架构"></a>3.1 架构</h3><p>Redis Cluster可以看成是由多个Redis实例组成的数据集合。客户端不需要关注数据到底存储在哪个节点，只需要关注这个集合整体。以3主3从为例，节点之间两两交互，共享数据分片，节点状态等信息。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/10.png"></p><h3 id="3-2-搭建"><a href="#3-2-搭建" class="headerlink" title="3.2 搭建"></a>3.2 搭建</h3><table><thead><tr><th>类型</th><th>命令</th></tr></thead><tbody><tr><td>集群</td><td>cluster info：打印集群的信息<br />cluster nodes：列出集群当前已知的所有节点，以及这些节点的相关信息</td></tr><tr><td>节点</td><td>cluster meet &lt;ip<ip>&gt;&lt;port<port>&gt; : 将ip与port所指定的节点添加到集群当中，让它成为集群的一份子<br />cluster forget&lt;node_id<node_id>&gt; : 从集群中移除node_id指定的节点(保证空槽道)<br />cluster replicate&lt;node_id<node_id>&gt; : 将当前节点设置为node_id指定节点的从节点 <br />cluster saveconfig：将节点的配置文件保存到硬盘中</td></tr><tr><td>槽(slot)</td><td>cluster addslots&lt;slot<slot>&gt;[slot …]：将一个或多个槽指派给当前节点<br />cluster delslots&lt;slot<slot>&gt;[slot …]：移除一个或多个槽对当前节点的指派 <br />cluster flushslots：移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点<br />cluster setslot&lt;slot<slot>&gt; node&lt;node_id<node_id>&gt;：将槽slot指派给node_id指定的节点，如果槽已经指派给另一个节点，那么先让另一个节点删除该槽，然后再进行指派<br />cluster setslot&lt;slot<slot>&gt; migrating<node_id>&gt;：将本节点的槽迁移到node_id指定的节点中<br />cluster setslot&lt;slot<slot>&gt; importing<node_id>&gt;：从node_id指定的节点中导入槽到本节点<br />cluster setslot&lt;slot<slot>&gt; stable：取消对槽的导入或者迁移</td></tr><tr><td>键</td><td>cluster keyslot &lt;key<key>&gt;：计算键key应该被放置在哪个槽上<br />cluster countkeysinslot &lt;slot<slot>&gt;：返回槽目前包含的键值对数量<br />cluster getkeysinslot&lt;slot<slot>&gt; &lt;count<count>&gt;：返回count个槽中的键</td></tr></tbody></table><h3 id="3-3-数据分布"><a href="#3-3-数据分布" class="headerlink" title="3.3 数据分布"></a>3.3 数据分布</h3><p>Redis既没有用哈希取模，也没有用一致性哈希，而是用虚拟槽来实现的。Redis创建了16384个槽（slot），每个节点负责一定区间的slot。比如Node1负责0-5460，Node2负责5461-10922，Node3负责10923-163838.</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/11.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli -p 7291<br>redis-cli -p 7292<br>redis-cli -p 7293<br></code></pre></td></tr></table></figure><p>对象分布到Redis节点上时，对key用CRC16算法计算再%16384，得到一个slot的值，数据落到负责这个slot的redis节点上。Redis的每个master节点都会维护自己负责的slot。用一个bit序列实现，比如：序列的第0位是1，就代表第一个slot是它负责；序列的第1位是0，就代表第二个slot不归它负责。查看key属于哪个slot：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">redis&gt; <span class="hljs-keyword">cluster</span> keyslot qs<br></code></pre></td></tr></table></figure><p>注意：key与slot的关系是永远不会变的，汇编的只有slot和redis节点的关系。</p><p><em>问题：怎么让相关的数据落到同一个节点上？</em></p><p>比如有些multi key操作是不能跨节点的，例如用户2673的基本信息和金融信息？</p><p>在key里面加入{hash tag}即可。Redis在计算槽编号的时候只会获取{}之间的字符串进行槽便哈计算，这样由于上面两个不同的键。{}里面的字符串是相同的，因此他们可以被计算出相同的槽。</p><h3 id="3-4-客户端重定向"><a href="#3-4-客户端重定向" class="headerlink" title="3.4 客户端重定向"></a>3.4 客户端重定向</h3><p>比如在7291端口的redis的redis-cli客户端操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">127.0.0.1:7291&gt; <span class="hljs-built_in">set</span> qs 1<br>(error)MOVED 13724 127.0.0.1:7293<br></code></pre></td></tr></table></figure><p>服务器返回MOVED，也就是根据key计算出来的slot不归7291端口管理，而是归7293端口管理，服务器返回MOVED告诉客户端去7293端口操作。这个时候更换端口，用redis-cli-p 7293操作，才会返回OK。或者用./redis-cli-c -o port的命令。Jedis等客户端会在本地维护一份slot——node的映射关系，大部分时候不需要重定向，所以叫做smart jedis（需要客户端支持）。</p><h3 id="3-5-数据迁移"><a href="#3-5-数据迁移" class="headerlink" title="3.5 数据迁移"></a>3.5 数据迁移</h3><p>因为key和slot的关系是永远不会变的，当新增了节点的时候，需要把原有的slot分配给新的节点负责，并且把相关的数据迁移过来。</p><p>添加新节点（新增一个7297）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli --cluster add-node 127.0.0.1:7291 127.0.0.1:7297<br></code></pre></td></tr></table></figure><p>新增的节点没有哈希槽，不能分布数据，在原来的任意一个节点上执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli --cluster reshard 127.0.0.1:7291<br></code></pre></td></tr></table></figure><p>输入需要分配的哈希槽的数量（比如500），和哈希槽的来源节点（可以输入all或者id）。</p><h3 id="3-6-高可用和主从切换原理"><a href="#3-6-高可用和主从切换原理" class="headerlink" title="3.6 高可用和主从切换原理"></a>3.6 高可用和主从切换原理</h3><p>当slave发现自己的master变成FAIL状态时，便尝试进行Failover，成为新的master。由于挂掉的master可能会有多个slave，从而存在多个slave竞争成为master节点的过程，其过程如下：</p><ol><li><p>slave发现自己的master变成Fail</p></li><li><p>将自己记录的集群currentEpoch加1，并广播FAILOVER_AUTH_REQUEST信息</p></li><li><p>其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack。</p></li><li><p>尝试failover的slave收集FAILOVER_AUTH_ACK</p></li><li><p>超过半数后变成新master</p></li><li><p>广播pong通知其他集群节点</p></li></ol><p>总结：Redis Cluster既能够实现主从的角色分配，又能够实现主从切换，相当于集成了Replication和Sentinel的功能。</p><h3 id="3-7-总结"><a href="#3-7-总结" class="headerlink" title="3.7 总结"></a>3.7 总结</h3><p>Redis Cluster特点：</p><ol><li><p>无中心架构</p></li><li><p>数据按照slot存储分布在多个节点，节点间数据共享，可动态调整数据分布。</p></li><li><p>可扩展性，可线性扩展到1000个节点（官方推荐不超过1000个），节点可动态添加或删除。</p></li><li><p>高可用性，部分节点不可用时，集群仍可用。通过增加Slave做standby数据副本，能够实现故障自动failover，节点之间通过gossip协议交换状态信息，用投票机制完成slave到master的角色提升。</p></li><li><p>降低运维成本，提高系统的扩展性和可用性。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis主从复制</title>
    <link href="/2023/03/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <url>/2023/03/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>redis支持集群的架构。集群的节点有主节点和从节点之分，主节点叫master，从节点叫slave。slave会通过复制的技术，自动同步master的数据。</p><h2 id="1-主从复制配置"><a href="#1-主从复制配置" class="headerlink" title="1  主从复制配置"></a>1  主从复制配置</h2><p>Redis的主从配置非常的简单，只需要在配置文件里面添加一行配置就可以了。例如一主多从，186是主节点，在每个slave节点的redis.conf配置文件增加一行:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">replicaof</span> <span class="hljs-string">192.168.44.186 6379</span><br></code></pre></td></tr></table></figure><p>从节点启动之后，就会自动连接到master节点，开始同步数据。如果master节点变了，比如原来的master宕机，选举出了新的master，这个配置会被重写。还有一种方式，就是在启动服务器时通过参数直接指定master节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">./redis-server --slaveof <span class="hljs-number">192.168</span><span class="hljs-number">.44</span><span class="hljs-number">.186</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><p>一个正在运行的节点，可以改变其他节点的从节点，这就是第三种方式，在客户端直接执行slaveof IP port，使该redis实例成为从节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">slaveof <span class="hljs-number">192.168</span><span class="hljs-number">.44</span><span class="hljs-number">.186</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><p>一个从节点也可以是其他节点的主节点，形成级联复制的关系。查看集群状态:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">redis&gt; info replication<br></code></pre></td></tr></table></figure><p>从节点是只读的，不能执行写操作。执行命令会报错。在主节点写入后，slave会自动从master同步数据。把配置文件里面的replica of去掉重启，或者直接断开复制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">redis&gt; slaveof no one<br></code></pre></td></tr></table></figure><p>此时从节点会变成自己的主节点，不再复制数据。MySQL的主从复制原理是依赖binlog，然后还有几个线程。</p><h2 id="2-主从复制原理"><a href="#2-主从复制原理" class="headerlink" title="2 主从复制原理"></a>2 主从复制原理</h2><p>Redis的主从复制分为两类，一种叫全量复制，就是一个节点第一次连接到master节点，需要全部的数据。第二种叫做增量复制，比如之前已经连接到master节点，但是中间网络断开，或者slave节点宕机了，缺失了一部分的数据。</p><h3 id="2-1-连接阶段"><a href="#2-1-连接阶段" class="headerlink" title="2.1 连接阶段"></a>2.1 连接阶段</h3><ol><li><p>  slave节点启动时（或者执行slaveof命令时），会在自己本地保存master节点的消息，包括master node的host和ip。</p></li><li><p>slave节点内部有个定时任务replicationCron，每个一秒检查是否有新的master node要连接和复制。</p></li></ol><p>如果发现有master节点，就跟master节点建立连接。如果连接成功，从节点就会连接建立一个专门处理复制工作的文件事件处理器负责后续的复制工作。为了让主节点感知到slave节点的存在，slave节点定时会给主节点发送ping请求。</p><h3 id="2-2-数据同步阶段"><a href="#2-2-数据同步阶段" class="headerlink" title="2.2 数据同步阶段"></a>2.2 数据同步阶段</h3><p>如果是新加入的slave节点，那就需要全量复制。Master通过bgsave命令再本地生成一份RDB快照，将RDB快文件发给slave节点（如果超时会重连，可以调大repl-timeout的值）。</p><p>如果slave自己本来有数据，Slave节点首先需要清除自己的旧数据，然后用RDB文件加载数据。</p><p>master节点生成RDB期间，如果接收到写命令，开始生成RDB文件时，master会把所有新的写命令缓存在内存中，在slave节点保存了RDB之后，再将新的写命令复制给slave节点。（跟AOF重写rewrite期间接收到的命令的处理思路是一样的）。</p><p>第一次全量同步完了，主从已经保持一致了，后面就是持续把接收到的命令发送给slave节点。</p><h3 id="2-3-命令传播阶段"><a href="#2-3-命令传播阶段" class="headerlink" title="2.3 命令传播阶段"></a>2.3 命令传播阶段</h3><p>master节点持续把写命令，异步复制给slave节点。总结起来非常的简单，前面同RDB文件，后面把命令发给slave节点，就实现了主从复制。注意，一般情况下不会用redis做读写分离，因为redis的吞吐量已经够高了，做集群分片之后并发的问题更少，所以不需要考虑主从延迟的问题。跟MySQL一样主从之间复制延迟是不可避免的，只能通过优化网络来改善。</p><p>第二种情况就是增量复制了。slave通过master_repl_offset记录偏移量。Redis的一个新特性，就是主从复制的无盘复制（从2.8.18版本开始支持无盘复制）。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">repl-diskless-sync</span>=<span class="hljs-string">no</span><br></code></pre></td></tr></table></figure><p>为了降低主节点的磁盘开销，redis支持无盘复制，master生成的RDB文件并不保存到磁盘而是直接通过网络发送给从节点。无盘复制适用于主节点所在机器磁盘性能较差但网络带宽较充裕的场景。</p><h2 id="3-主从复制不足"><a href="#3-主从复制不足" class="headerlink" title="3  主从复制不足"></a>3  主从复制不足</h2><p>Redis的主从复制解决了数据备份和一部分性能的问题，但是没有解决高可用的问题。在一主一从或者多主多从的情况下，如果主服务器挂了，对外提供的服务就不可用了，单点问题没有得到解决。跟mysql一样。如果每次都是手动把之前的从服务器切换到主服务器，然后再把剩余节点设置为它的从节点，这个比较费时费力，还会造成一定时间的服务不可用。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis哨兵(Sentinel)</title>
    <link href="/2023/03/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%93%A8%E5%85%B5(Sentinel)/"/>
    <url>/2023/03/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%93%A8%E5%85%B5(Sentinel)/</url>
    
    <content type="html"><![CDATA[<h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1  原理"></a>1  原理</h2><p>怎么实现高可用？第一个对于服务器来说，能够实现主从自动切换；第二个，对于客户端来说，如果发生了主从切换，它需要获取最新的master节点。这个怎么实现呢？这里面应该要有一个管理redis节点状态的角色，而且具备路由功能。比如RocketMQ是通过nameserver来实现的。思路：创建一台监控服务器来监控所有redis服务节点的状态，比如，master节点超过一定时间没有给监控服务器发送心跳报文，就把master标记为下线，之后把某一个slave变成master，应用每一次都是从这个监控服务器拿到master的地址。</p><p>Redis的高可用是通过哨兵Sentinel来保证的。它的思路就是通过运行监控服务器来保证服务的可用性。从redis2.8版本起，提供了一个稳定版本的哨兵，用来解决高可用的问题。我们会启动奇数个的哨兵服务（通过src/redis-sentinel）。可以同sentinel的脚本启动，也可以用redis-server的脚本加sentinel参数启动。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">./redis-sentinel ../sentinel.conf<br># 或者<br>./redis-server ../sentinel.conf --sentinel<br></code></pre></td></tr></table></figure><p>它的本质上只是一个运行在特殊模式之下的redis。Sentinel通过info命令得到被监听redis机器的master，slave信息。</p><p><img src="/image/redis/redis%E5%93%A8%E5%85%B5/1.png"></p><p>为保证监控服务器的可用性，会对Sentinel做集群的部署。Sentinel既监控所有的redis服务，Sentinel相互之间也监控。注意：Sentinel本身没有主从之分，地位是平等的，只有redis服务节点有主从之分。sentinel唯一的联系，就是监控相同的master，sentinel节点是怎么知道其他的Sentinel节点的存在的？因为Sentinel是一个特殊状态的redis节点，它也有发布订阅的功能。哨兵上线时，给所有的redis节点的名字为_sentinel_:hello的channle发送消息。每个哨兵都订阅了所有redis节点为_sentinel_:helo的channle，所以能相互感知对方的存在，而进行监控。</p><h3 id="1-1-服务下线"><a href="#1-1-服务下线" class="headerlink" title="1.1 服务下线"></a>1.1 服务下线</h3><p>sentinel默认以每秒钟1次的频率向redis服务节点发送ping命令。如果在指定时间内没有收到有效回复，sentinel会将该服务器标记为下线（主观下线）。由这个参数控制：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># sentiel.conf</span><br><span class="hljs-attr">sentiel</span> <span class="hljs-string">down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br></code></pre></td></tr></table></figure><p>默认是30秒。但是，只有发现master下线，并不代表master真的下线了。也有可能是网络出问题了。所以，这个时候第一个发现master下线的sentinel节点会继续询问其他的sentinel节点，确认这个节点是否下线，如果多数sentinel节点都认为master下线，master才真正被确认下线（客观下线）。确定master下线后，就需要重新选举master。Kafka有会在Broke里面选一个Controller出来。RocketMQ用Dledger技术选举（基于Raft协议）。</p><h3 id="1-2-故障转移"><a href="#1-2-故障转移" class="headerlink" title="1.2 故障转移"></a>1.2 故障转移</h3><p>Redis的选举和故障转移都是由sentinel完成的，故障转移流程的第一步就是在sentinel集群选择一个leader，由leader完成故障转移流程。Sentinel通过Raft算法，实现sentinel选举。</p><p><strong>Raft算法</strong></p><p>只要有了多个副本，就必然要面对副本一致性的问题。如果要所有的节点达成一致，必然要通过复制的方式实现。所以数据保持一致需要两个步骤：领导选举，数据复制。数据复制在redis主从复制中说过了，这里关注一下选举的实现。</p><p>Raft算法是一个共识算法(consensus algorith)。Spring cloud的注册中心解决方案Consul也用到了Raft协议。Raft的核心思想：先到先得，少数服从多数。sentinel的raft实现跟原生的算法有所区别，但是大体思想一致。</p><ol><li><p>分布式环境中的节点有三个状态: Follower,Candidate,Leader.</p></li><li><p>一开始所有的节点都是Follower状态.如果follower连接不到leader(leader挂了),它就会成为candidate。candidate请求其他节点的投票，其他的节点会投给它，如果它得到了大多数节点的投票，它就成为了主节点.这个过程就叫做leader election。</p></li><li><p>现在所有的写操作需要在leader节点上发生。leader会记录操作日志，没有同步到其他follower节点的日志，状态是uncommitted。等到超过半数的follower同步了这条记录，日志状态就会变成committed。leader会通知所有的follower日志已经committed，这个时候所有的节点就达成了一致，这个过程叫log replication。</p></li><li><p>在raft协议中，选举的时候有两个超时时间。第一个叫election timeout，也就是说，为了防止同一时间大量节点参与选举，每个节点在变成candidate之前需要随机等待一段时间，时间范围是150ms and 300ms之间。第一个变成candidate的节点会先发起投票，它会先投给自己，然后请求其他节点投票(request vote)。</p></li><li><p>如果还没有收到投票结果，又到了超时时间，需要重置超时时间，只要有大部分节点投给了一个节点，他就会变成leader。</p></li><li><p>成为leader之后，它会发消息来同步数据(append entries)，发消息的间隔是由heartbeat timeout的计时。</p></li><li><p>只要follower收到了同步数据的信息，代表leader没挂，他们就会清除heartbeat timeout的计时。</p></li><li><p>但是一旦followers在heartbeat timeout时间之内没有收到append entries消息，它就会认为leader挂了，开始让其他节点投票，成为新的leader。</p></li><li><p>必须超过半数以上节点投票，保证只有一个leader被选出来。</p></li><li><p>如果两个follower同时变成了candidate，就会出现分割投票，比如有两个节点同时变成candidate，而且各自有一个投票请求先达到了其他的节点。加上他们给自己的投票，每个candidate手上有两票。但是，因为他们的election timeout不同，在发起新的一轮选举的时候，有一个节点收到了更多的投票，所以它变成了leader。</p></li></ol><p>总结:sentinel的raft算法和raft论文略有不同.</p><ol><li><p>master客观下线触发选举，而不是过了election timeout时间开始选举。</p></li><li><p>leader并不会把自己成为leader的消息发送给其他sentinel。其他sentinel等待leader从slave选出master后，检测到新的master正常工作后，就会去掉客观下线的标识，从而不需要进入故障转移流程。</p></li></ol><p>到达这里，从所有的sentinel节点里面选出来一个leader，也就是所谓选举委员会主席，下面才是真正的选举。</p><p><strong>故障转移</strong></p><p>对于所有的slave节点，一共有四个因素影响选举的结果，分别是断开连接时长、优先级排序、复制数量、进程id。</p><ol><li><p>如果与哨兵连接断开的比较久，超过了某个阈值，就直接失去了选举权。</p></li><li><p>如果拥有选举权，那就看谁的优先级高，这个在配置文件里可以设置(replica-priority 100)，数值越小优先级越高。</p></li><li><p>如果优先级相同，那就看谁从master中复制的数据最多(复制偏移量最大)，选最多的那个。</p></li><li><p>如果复制量也相同，就选进程id最小的那个。</p></li></ol><p>Master节点确定之后，让其他的节点变成它的从节点：</p><ol><li><p>选出sentinel leader之后，由sentinel leader向某个节点发送slaveof no one命令，让他成为独立节点。</p></li><li><p>然后向其他节点发送slaveof x.x.x.x xxxx(本机ip端口)，让它们成为这个节点的从节点，故障转移完成。</p></li></ol><h2 id="2-功能总结"><a href="#2-功能总结" class="headerlink" title="2  功能总结"></a>2  功能总结</h2><p>监控：sentinel会不断检查主服务器和从服务器是否正常运行。</p><p>通知：如果某一个被监控的实例出现问题，sentinel可以通过命令发出通知。</p><p>自动故障转移(failover)：如果主服务器发生故障，sentinel可以启动故障转移过程，把某台服务器升级为主服务器，并发出通知。</p><p>配置管理：客户端连接到sentinel，获取当前的redis主服务器的地址。</p><h2 id="3-实战"><a href="#3-实战" class="headerlink" title="3  实战"></a>3  实战</h2><h3 id="3-1-Sentinel配置"><a href="#3-1-Sentinel配置" class="headerlink" title="3.1 Sentinel配置"></a>3.1 Sentinel配置</h3><p>为了保证sentinel的高可用,sentinel也需要做集群部署,集群中至少需要三个sentinel实例(推荐奇数个,防止脑裂).</p><table><thead><tr><th>hostname</th><th>ip地址</th><th>节点角色&amp;端口</th></tr></thead><tbody><tr><td>master</td><td>192.168.44.186</td><td>Master: 6379 / Sentinel: 26379</td></tr><tr><td>slave1</td><td>192.168.44.187</td><td>Slave: 6379 / Sentinel: 26379</td></tr><tr><td>slave2</td><td>192.168.44.188</td><td>Slave: 6379 / Sentinel: 26379</td></tr></tbody></table><p>以redis的安装路径/user/local/soft/redis-6.0.9/为例，在187和188的src/redis.conf配置文件中添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">replicaof <span class="hljs-number">192.168</span><span class="hljs-number">.44</span><span class="hljs-number">.186</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><p>在186,187,188创建sentinel配置文件(安装后根目录下默认有sentinel.conf)，三台服务器内容相同：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">daemonize</span> <span class="hljs-string">yes</span><br><span class="hljs-attr">port</span> <span class="hljs-string">26739</span><br><span class="hljs-attr">protected-mode</span> <span class="hljs-string">no</span><br><span class="hljs-attr">dir</span> <span class="hljs-string">&quot;/usr/local/soft/redis-6.0.9/sentinel-tmp&quot;</span><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">monitor redis-master 192.168.44.186 6379 2</span><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">down-after-milliseconds redis-master 30000</span><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">failover-timeout redis-master 180000</span><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">parallel-syncs redis-master 1</span><br></code></pre></td></tr></table></figure><p>上面出现了4个’redis-master’,这个名称要统一,并且使用客户端(比如jedis)连接的时候要使用这个名字。</p><table><thead><tr><th>配置</th><th>作用</th></tr></thead><tbody><tr><td>protected-mode</td><td>是否允许外部网络访问，yes不允许</td></tr><tr><td>dir</td><td>sentinel的工作目录</td></tr><tr><td>sentinel monitor</td><td>sentinel监控的redis主节点</td></tr><tr><td>sentinel down-after-milliseconds（毫秒）</td><td>master宕机多久，才会被sentinel主观认为下线</td></tr><tr><td>sentinel failover-timeout（毫秒）</td><td>1.同一个sentinel对同一个master两次failover之间的间隔时间<br />2.当一个slave从一个错误的master那里同步数据开始计算时间，知道slave被纠正为向正确的master那里同步的数据时间。<br />3.当想要取消一个正进行的failover所需要的时间。<br />4.当进行failover时，配置所有slaves指向新的master所需的最大时间</td></tr><tr><td>sentinel parallel-syncs</td><td>这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成failover所需的时间就越长，但是这个数字越大，就意味着越多的slave因为replication而不可用，可以通过将这个值设为1来保证每次只有一个slave处于不能处理命令请求的状态</td></tr></tbody></table><h3 id="3-2-Sentinel验证"><a href="#3-2-Sentinel验证" class="headerlink" title="3.2 Sentinel验证"></a>3.2 Sentinel验证</h3><p>启动redis服务和sentinel，查看集群状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">redis&gt; info replication<br></code></pre></td></tr></table></figure><p>模拟宕机,在主节点执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">redis&gt; shutdown<br></code></pre></td></tr></table></figure><p>某个节点会被选为新的master，只有一个slave节点。注意看sentinel.conf里面的redis-master被修改了！模拟原master恢复，启动redis-server。master又有两个slave了。</p><h3 id="3-3-Sentinel连接使用"><a href="#3-3-Sentinel连接使用" class="headerlink" title="3.3 Sentinel连接使用"></a>3.3 Sentinel连接使用</h3><p>Jedis连接sentinel，master name来自于sentinel.conf的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisSentinelPool <span class="hljs-title function_">createJedisPool</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">masterName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;redis-master&quot;</span>;<br>    Set&lt;String&gt; sentinels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    sentinels.add(<span class="hljs-string">&quot;192.168.44.186:26379&quot;</span>);<br>    sentinels.add(<span class="hljs-string">&quot;192.168.44.187:26379&quot;</span>);<br>    sentinels.add(<span class="hljs-string">&quot;192.168.44.188:26379&quot;</span>);<br>    pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisSentinelPool</span>(masterName, sentinels);<br>    <span class="hljs-keyword">return</span> pool;<br>&#125;<br></code></pre></td></tr></table></figure><p>Springboot连接sentinel:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.redis.sentinel.master</span>=<span class="hljs-string">redis-master</span><br><span class="hljs-attr">spring.redis.sentinel.nodes</span>=<span class="hljs-string">192.168.44.186:26379,192.168.44.187:26379,192.168.44.188:26379</span><br></code></pre></td></tr></table></figure><p>无论是jedis还是springbot(2.x版本默认是Lettuce)，都只需要配置全部哨兵的地址，由哨兵返回当前的master节点地址。</p><h2 id="4-不足"><a href="#4-不足" class="headerlink" title="4 不足"></a>4 不足</h2><p>主从切换的过程中会丢失数据，因为只有一个master。只能单点写，没有解决水平扩容的问题。如果数据量非常大，这个时候就要对redis的数据进行分片了。这个时候需要多个master-slave的group，把数据分布到不同的group中。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis持久化机制</title>
    <link href="/2023/02/28/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/02/28/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>Redis速度快，很大一部分原因是因为它所有的数据都存储在内存中。如果断电或者宕机，都会导致内存的数据丢失。为了实现重启后数据不丢失，redis提供了两种持久化的方案，一种是RDB快照（Redis Database），一种是AOF（Append Only File）。持久化是redis跟memcache的主要区别之一。</p><h2 id="1-RDB"><a href="#1-RDB" class="headerlink" title="1. RDB"></a>1. RDB</h2><p>RDB是redis默认的持久化方案（注意如果开启了AOF，优先用AOF）。当满足一定条件的时候，会把当前内存中的数据写入磁盘，生成一个快照文件dump.rdb。redis重启会通过加载dump.rdb文件恢复数据。</p><h3 id="1-1-Rdb触发"><a href="#1-1-Rdb触发" class="headerlink" title="1.1 Rdb触发"></a>1.1 Rdb触发</h3><p><strong>1 自动触发</strong></p><p>a） 配置规则触发。</p><p>redis.conf，SNAPSHOTTING，其中定义了触发把数据保存到磁盘的触发频率。如果不需要rdb方案，注释save或者配置成空字符串“”。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span>     #<span class="hljs-number">900</span>秒内至少有一个key被修改（包括添加）<br><span class="hljs-attribute">save</span> <span class="hljs-number">400</span> <span class="hljs-number">10</span>    #<span class="hljs-number">400</span>秒内至少有<span class="hljs-number">10</span>个key被修改<br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span>  #<span class="hljs-number">60</span>秒内至少有<span class="hljs-number">10000</span>个key被修改<br></code></pre></td></tr></table></figure><p>注意上面的配置是不冲突的，只要满足任意一个都会触发。用lastsave命令可以查看最近一次成功生成快照的时间。Rdb文件位置和目录（默认在安装根目录下）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">dir</span> ./  <span class="hljs-comment">#文件路径</span><br>dbfilename dump.rdb  <span class="hljs-comment">#文件名称</span><br>rdbcompression <span class="hljs-built_in">yes</span>  <span class="hljs-comment">#是否以LZF压缩rdb文件</span><br>rdbchechsum <span class="hljs-built_in">yes</span>  <span class="hljs-comment">#开启数据校验</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>dir</td><td>rdb文件默认在启动目录下（相对路径） config get dir获取</td></tr><tr><td>dbfilename</td><td>文件名称</td></tr><tr><td>rdbcompression</td><td>开启压缩可以节省存储空间，但是会消耗一些CPU的计算时间，默认开启</td></tr><tr><td>rdbchecksum</td><td>使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</td></tr></tbody></table><p>b） shutdown触发，保证服务器正常关闭。</p><p>c） flushall，rdb文件是空的，没什么意义。</p><p><strong>2 手动触发</strong></p><p>如果我们需要重启服务或者迁移数据，这个时候就需要手动触发快照保存。Redis提供了两条命令：</p><p>a） save，在生成快照的时候会阻塞当前redis服务器，redis不能处理其他命令。如果内存中的数据比较多，会造成redis长时间的阻塞。生产环境下不建议使用这个命令。</p><p>b） 执行bgsave，执行bgsave时，redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体操作是redis进程执行fork操作创建子线程（copy-on-write），rdb持久化过程由子进程负责，完成后自动结束。它不会记录fork之后产生的数据。阻塞只发生在fork阶段，一般时间很短。</p><h3 id="1-2-RDB数据恢复"><a href="#1-2-RDB数据恢复" class="headerlink" title="1.2 RDB数据恢复"></a>1.2 RDB数据恢复</h3><ol><li> shutdown持久化</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#添加键值</span><br>redis&gt; <span class="hljs-built_in">set</span> k1 1<br>redis&gt; <span class="hljs-built_in">set</span> k2 2<br>redis&gt; <span class="hljs-built_in">set</span> k3 3<br>redis&gt; <span class="hljs-built_in">set</span> k4 4<br>redis&gt; <span class="hljs-built_in">set</span> k5 5<br><span class="hljs-comment">#停止服务器，触发save</span><br>redis&gt; shutdown<br><span class="hljs-comment">#备份dump.rdb文件</span><br><span class="hljs-built_in">cp</span> dump.rdb dump.rdb.bak<br><span class="hljs-comment">#启动服务器，数据都在</span><br>redis&gt; redis-server redis.conf<br></code></pre></td></tr></table></figure><ol start="2"><li>模拟数据丢失</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#模拟数据丢失，触发save</span><br>redis&gt; shutdown<br><span class="hljs-comment">#停止服务器</span><br>redis&gt; shutdown<br><span class="hljs-comment">#启动服务器</span><br>redis&gt; redis-server redis.conf<br><span class="hljs-comment">#数据丢失</span><br></code></pre></td></tr></table></figure><ol start="3"><li> 通过该备份文件恢复数据</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#停止服务器</span><br>redis&gt; shutdown<br><span class="hljs-comment">#重命名备份文件</span><br><span class="hljs-built_in">mv</span> dump.rdb.bak dump.rdb<br><span class="hljs-comment">#启动服务器</span><br>redis&gt; redis-server redis.conf<br><span class="hljs-comment">#数据找回</span><br></code></pre></td></tr></table></figure><h3 id="1-3-RDB文件的优劣"><a href="#1-3-RDB文件的优劣" class="headerlink" title="1.3 RDB文件的优劣"></a>1.3 RDB文件的优劣</h3><p>一、 优势</p><p>1． Rdb是一个非常紧凑（compact）的文件，它保存了redis在某个时间点上的数据集。这种文件非常适合用于进行备份和灾难恢复。</p><p>2． 生成rdb文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘io操作。</p><p>3． Rdb在恢复大数据集时的速度比aof的恢复速度快。</p><p>二．劣势</p><p>1.rdb方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，频繁执行成本过高。</p><p>2.在一定间隔时间做一次备份，所以如果redis意外当掉的话，就会丢失最后一次快照之后的所有修改（数据又丢失）。</p><p>​    如果数据相对来说比较重要，希望将损失降到最小，则可以使用aof方式进行持久化。</p><h2 id="2-AOF"><a href="#2-AOF" class="headerlink" title="2. AOF"></a>2. AOF</h2><p>Redis默认不开启。aof采用日志的形式来记录每个写操作，并追加文件中。开启后，执行更改redis数据的命令时，就会把命令写入到aof文件中。Redis重启时会根据日志文件的内容把写指令从前到后执行一次以完成数据的恢复工作。</p><h3 id="2-1-aof配置"><a href="#2-1-aof配置" class="headerlink" title="2.1 aof配置"></a>2.1 aof配置</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 开关</span><br><span class="hljs-attr">appendonly</span> <span class="hljs-string">no</span><br><span class="hljs-comment"># 文件名</span><br><span class="hljs-attr">appendfilename</span> <span class="hljs-string">&quot;appendonly.aof&quot;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>appendonly</td><td>Redis默认只开启RDB持久化，开启AOF需要修改为yes</td></tr><tr><td>appendfilename</td><td>路径也是通过dir参数配置，config get dir</td></tr></tbody></table><p>由于操作系统的缓存机制，aof数据并没有真正地写入磁盘，而是进入了系统的硬盘缓存。什么时候把缓冲区的内容写入到aof文件？</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>appendfsync everysec</td><td>AOF持久化策略(硬盘缓存到磁盘)，默认everysec <br />no—-表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快，但是不安全<br />always—-表示每次写入都执行fsync，以保证数据同步到磁盘，效率很低<br />everysec—-表示每秒执行一次fsync，可能会导致丢失这1s的数据，通常选择everysec，兼顾安全和效率</td></tr></tbody></table><p>由于aof持久化是redis不断将写命令记录到aof文件中，随着redis不断的进行，aof文件会越来越大，文件越大，占用服务器内存越大以及aof恢复要求时间越长。例如计数器增加100万次，100万个命令都记录进去了，但是结果只有一个。为了解决这个问题，redis新增了重写机制，当aof文件的大小超过锁设定的阈值时，redis就会启动aof文件的内容压缩，值保留可以恢复数据的最小指令集。可以使用命令bgrewriteaof来重写。Aof文件重写并不是对原文件进行重新整理，而是读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令，生成一个新的文件后去替换原来的aof文件。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 重写触发机制</span><br><span class="hljs-attr">auto-aof-rewrite-percentage</span> <span class="hljs-string">100</span><br><span class="hljs-attr">auto-aof-rewrite-min-size</span> <span class="hljs-string">64mb</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>auto-aof-rewrite-percentage</td><td>默认值是100，aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写，当前AOF文件大小是上次日志重写得到aof文件大小的二倍(设置为100)时，自动启动新的日志重写过程。</td></tr><tr><td>auto-aof-rewrite-min-size</td><td>默认64M。设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写</td></tr></tbody></table><p><em>问题：重写过程中，AOF文件被更改了怎么办？</em></p><p>当子进程执行aof重写时，主进程需要执行以下三个工作：</p><p>（1）处理命令请求；（2）将写命令追加到现有的aof文件中；（3）将写命令追加到aof重写缓存中</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>no-appendfsync-on-rewrite</td><td>在aof重写或者写入rdb文件时，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成过长时间的阻塞，no-appendfsync-on-rewrite字段设置为默认no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。设置为yes表示rewrite期间对新写操作不fsync，暂时存在内存中，等rewrite完成后再写入，默认为no，建议修改为yes。Linux默认fsync策略是30秒。可能丢失30秒数据。</td></tr><tr><td>aof-load-truncated</td><td>aof文件可能在尾部是不完整的，当redis启动时，aof文件的数据被载入内存中。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项，出现这种现象。redis宕机或者异常终止不会造成尾部不完整现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复aof文件才可以。默认为yes。</td></tr></tbody></table><h3 id="2-2-AOF数据恢复"><a href="#2-2-AOF数据恢复" class="headerlink" title="2.2 AOF数据恢复"></a>2.2 AOF数据恢复</h3><p>重启redis后就会进行aof文件的恢复</p><h3 id="2-3-AOF的优劣势"><a href="#2-3-AOF的优劣势" class="headerlink" title="2.3 AOF的优劣势"></a>2.3 AOF的优劣势</h3><p>一、 优点：</p><p>​    1． Aof持久化的方法提供了多种的同步频率，即使用默认的同步频率每秒同步一次，redis最多也就丢失1秒的数据而已。</p><p>二、缺点</p><p>​    1.对于具有相同数据的redis，aof文件通常会比RDB文件体积更大（rdb存的是数据快照）</p><p>​    2.虽然aof提供了多种同步的频率，默认情况下，每秒同步一次的频率也具有较高的性能，在高并发的情况下，rdb比aof具有更好的性能保证。</p><h2 id="3-两种方案比较"><a href="#3-两种方案比较" class="headerlink" title="3.  两种方案比较"></a>3.  两种方案比较</h2><p>如果可以忍受一小段时间内数据的丢失，毫无疑问使用rdb是最好的，定时生成rdb快照（snapshot）非常便于进行数据库备份，并且rdb恢复数据集的速度也要比aof恢复的速度要快。否则就是用AOF重写。但是一般情况下建议不要单独使用某一种持久化机制，而是应该两种一起用，在这种情况下，当redis重启的时候会优先加载aof文件来恢复原始的数据，因为在通常情况下aof文件保存的数据集要比RDB文件保存的数据集要完整。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis内存回收</title>
    <link href="/2023/02/27/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    <url>/2023/02/27/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="1-过期策略"><a href="#1-过期策略" class="headerlink" title="1. 过期策略"></a>1. 过期策略</h2><h3 id="1-1-立即过期-主动淘汰"><a href="#1-1-立即过期-主动淘汰" class="headerlink" title="1.1 立即过期(主动淘汰)"></a>1.1 立即过期(主动淘汰)</h3><p>每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好，但是会占用大量CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p><h3 id="1-2-惰性过期-被动淘汰"><a href="#1-2-惰性过期-被动淘汰" class="headerlink" title="1.2 惰性过期(被动淘汰)"></a>1.2 惰性过期(被动淘汰)</h3><p>只有当访问一个key时，才会判断该key是否已经过期，过期则清除。该策略可以最大化的节省CPU资源，却对内存非常不友好。极端情况下可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p><p>第一种情况，所有的查询都会调用expireIfNeeded判断是否过期：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">expireIfNeeded(redisDb *db, robj *key)<br></code></pre></td></tr></table></figure><p>第二种情况，每次写入key时，发现内存不够，吊桶activeExpireCycle释放一部分内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">activeExpireCycle(<span class="hljs-type">int</span> type)<br></code></pre></td></tr></table></figure><h3 id="1-3-定期过期"><a href="#1-3-定期过期" class="headerlink" title="1.3 定期过期"></a>1.3 定期过期</h3><p>每隔一定的时间，会扫描一定数量的数据库的expire字典中一定数量的key，并清除其中已经过期的key。该策略是前两者的一个折中方案，通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以再不同情况下使得Cpu和内存资源达到最优的平衡效果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span>&#123;</span><br>    dict *dict;<br>    dict *expires;<br>    dict *blocking_keys;<br>    dict *ready_keys;<br>    dict *watched_keys;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> avg_ttl;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> expires_cursor;<br>    <span class="hljs-built_in">list</span> *defrag_later;<br>&#125; redisDb;<br></code></pre></td></tr></table></figure><p>总结: Redis中同时使用了惰性过期和定期过期两种过期策略，并不是实时的清除过期的key。</p><h2 id="2-淘汰策略"><a href="#2-淘汰策略" class="headerlink" title="2. 淘汰策略"></a>2. 淘汰策略</h2><p>Redis的内存淘汰策略，是指当内存使用达到最大内存极限时，需要使用淘汰算法来决定清理掉哪些数据，以保证新数据的存入。</p><h3 id="2-1-最大内存设置"><a href="#2-1-最大内存设置" class="headerlink" title="2.1 最大内存设置"></a>2.1 最大内存设置</h3><p>Redis.conf参数配置  #maxmemory <bytes></p><p>如果不设置maxmemory或者设置为0，32位系统最多使用3GB内存，64位系统不限制内存。</p><p>动态修改（先get一下）：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">redis&gt;<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> maxmemory 2GB<br></code></pre></td></tr></table></figure><h3 id="2-2-淘汰策略"><a href="#2-2-淘汰策略" class="headerlink" title="2.2 淘汰策略"></a>2.2 淘汰策略</h3><p><a href="https://redis.io/docs/reference/eviction/">https://redis.io/docs/reference/eviction/</a></p><p>redis.conf   #maxmemory-policy noeviction</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coq"># volatile-lru -&gt; Evict <span class="hljs-built_in">using</span> approximated LRU, only keys <span class="hljs-built_in">with</span> an expire <span class="hljs-built_in">set</span><br># allkeys-lru  -&gt; Evict any key <span class="hljs-built_in">using</span> approximated LRU<br># vloatile-lfu -&gt; Evict <span class="hljs-built_in">using</span> approximated LFU, only keys <span class="hljs-built_in">with</span> an expire <span class="hljs-built_in">set</span><br># allkeys-lfu  -&gt; Evict any key <span class="hljs-built_in">using</span> approximated LFU<br># volatile-random -&gt; <span class="hljs-keyword">Remove</span> a random key having an expire <span class="hljs-built_in">set</span><br># allkeys-random  -&gt; <span class="hljs-keyword">Remove</span> a random key, any key<br># volatile-ttl -&gt; <span class="hljs-keyword">Remove</span> the key <span class="hljs-built_in">with</span> the nearest expire <span class="hljs-built_in">time</span>(minor TTL)<br></code></pre></td></tr></table></figure><p>（1）先从后缀的算法名来看：</p><p>LRU，Least Recently Used：最近最少使用。判断最近被使用的时间，目前最远的数据有限被淘汰。</p><p>LFU，Least Frequently Used：最不常用，按照使用频率删除，4.0版本新增。</p><p>Random 随机删除。</p><p>（2）从前缀针对的对象来分：volatile是针对设置了ttl的key，allkeys是针对所有key</p><table><thead><tr><th>策略</th><th>含义</th></tr></thead><tbody><tr><td>volatile-lru</td><td>根据LRU算法删除设置了超时属性(expire)的键，直到腾出足够内存为止。如果没有可删除的对象，回退到noeviction策略</td></tr><tr><td>allkeys-lru</td><td>根据LRU算法删除键，不管数据有没有设置超时属性，知道腾出足够的内存为止</td></tr><tr><td>volatile-lfu</td><td>在带有过期时间的键中选择最不常用的</td></tr><tr><td>allkeys-lfu</td><td>在所有键中选择最不常用的，不管数据有没有设置超时属性</td></tr><tr><td>volatile-random</td><td>在带有过期时间的键中随机选择</td></tr><tr><td>allkeys-random</td><td>随机删除所有键，知道腾出足够内存为止</td></tr><tr><td>volatile-ttl</td><td>根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noevitcion策略</td></tr><tr><td>noeviction</td><td>默认策略，不会删除任何数据，拒绝所有写入操作并返回客户端错误信息(error)OOM command not allowed when used memory, 此时Redis只响应读操作</td></tr></tbody></table><p>如果没有设置ttl或者没有符合前提条件的key被淘汰，那么volatile-lru，volatile-random，volatile-ttl相当于noeviction（不做内存回收）。动态修改淘汰策略（先get一下）</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">redis&gt; config set maxmemory-policy <span class="hljs-keyword">volatile</span>-lru<br></code></pre></td></tr></table></figure><p>建议使用volatile-lru，在保证正常服务的情况下，有限删除最近最少使用的key。</p><h3 id="2-3-LRU淘汰原理"><a href="#2-3-LRU淘汰原理" class="headerlink" title="2.3 LRU淘汰原理"></a>2.3 LRU淘汰原理</h3><p>LRU是一个很常见的算法，比如InnoDB的Buffer Pool也用到了LRU。传统LRU：通过链表+HashMap实现，设置链表长度，如果新增或者被访问，就移动到头节点，超过链表长度，末尾的节点被删除。</p><p><img src="/image/redis/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/1.png"></p><p>如果基于传统LRU算法实现redis LRU的话，需要额外的数据结构存储，消耗内存。所以Redis LRU对传统的LRU算法进行了改良，通过随机采样来调整算法的精度。如果淘汰策略是LRU，则根据篇日志的采样值maxmemory_samples（默认是5个），随机从数据库中选择m个key，淘汰其中热度最低的key对应的缓存数据。所以采样参数m配置的数值越大，就越能精确的查找到待淘汰的缓存数据，但是也消耗更多的CPU计算，执行效率降低。</p><p>Redis中所有对象结构都有一个lru字段，且使用了unsigned的低24位，这个字段用来记录对象的热度。对象被创建时会记录lru值。在被访问的时候也会更新lru的值。但并不是获取系统当前的时间戳，而是设置位全局变量server.lruclock的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span>&#123;</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS;<br>    <span class="hljs-type">int</span> refcount;<br>    <span class="hljs-type">void</span> *ptr;<br>&#125; robj;<br></code></pre></td></tr></table></figure><p>Redis中有个定时处理的函数serverCron，默认每100毫秒调用函数updateCachedTime更新一次全局变量的server.lruclock的值，它记录的是当前unix时间戳。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">updateCachedTime</span><span class="hljs-params">(<span class="hljs-type">int</span> update_daylight_info)</span>&#123;<br>    server.ustime = ustime();<br>    server.mstime = server.ustime / <span class="hljs-number">1000</span>;<br>    server.unixtime = server.mstime / <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">if</span>(update_daylight_info)&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> <span class="hljs-title">tm</span>;</span><br>        <span class="hljs-type">time_t</span> ut = server.unixtime;<br>        localtime_r(&amp;ut,&amp;tm);<br>        server.daylight_active = tm.tm_isdst;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>问题：为什么不获取精确的时间而是放在全局变量中？不会有延迟的问题吗？</em></p><p>这样函数查询key调用lookupKey中更新数据的lru热度值时，就不用换每次调用系统函数time，可以提高执行效率。</p><p>当对象里面已经有了LRU字段的值，就可以评估对象的热度了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">estimeteObjectIdleTime</span><span class="hljs-params">(robj *o)</span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> lrulock = LRU_CLOCK();<br>    <span class="hljs-keyword">if</span>(lruclock &gt;= o-&gt;lru)&#123;<br>        <span class="hljs-keyword">return</span> (lruclock - o-&gt;lru) * LRU_CLOCK_RESOLUTION;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> (lruclock + (LRU_CLOCK_MAX - o-&gt;lru)) * LRU_CLOCK_RESOLUTION;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数estimateObjectIdleTime评估指定对象的lru热度，方法就是对象的lru值和全局的server.lruclock的差值越大（越久没有得到更新）,该对象热度越低。server.lruclock 只有24位，按秒位单位来标识才能存储194天。但超过24bit能表示的最大时间的时候，他会从头开始计算。在这种情况下，可能会出现对象的lru大于server.lruclocl的情况，如果这种情况出现那么就两个相加而不是相减来求最久的key。</p><p>Redis LRU算法在sample为10的情况下，已经能接近传统LRU算法了。</p><h3 id="2-4-LFU"><a href="#2-4-LFU" class="headerlink" title="2.4 LFU"></a>2.4 LFU</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span>&#123;</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-type">unsigned</span> enncoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS;<br>    <span class="hljs-type">int</span> refcount;<br>    <span class="hljs-type">void</span> *ptr;<br>&#125; robj;<br></code></pre></td></tr></table></figure><p>当这24bits 用作LFU时，其被分为两部分：高16位用来记录访问时间（单位为分钟，Idt-last decrement time）低8位用来记录访问频率，简称counter（logc-logistic counter）</p><p>counter是用基于概率的对数计数器来实现的，8位可以标识百万次的访问频率。对象被读写的时候，lfu的值会被更新。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">updateLFU</span><span class="hljs-params">(robj *val)</span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counter = LFUDecrAndReturn(val);<br>    counter = LFULogIncr(counter);<br>    val-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="hljs-number">8</span>) | counter;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然这里并不是访问一次，技术就加1。增长的速率由一个参数决定，lfu-log-factor越大，counter增长的越慢，redis.conf配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># lfu-log-factor 10</span><br></code></pre></td></tr></table></figure><p>如果一段时间热点高，就一直保持这个热度，肯定也是不行的，体现不了整体频率。所以，没有被访问的时候，计数器还要递减。减少的值由衰减因子lfu-decay-time(分钟)来控制，如果值是1的话，N分钟没有访问，计数器就要减少N。lfu-decay-time越大，衰减越慢。Redis.conf配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># lfu-decay-time 1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nacos注册中心</title>
    <link href="/2023/02/27/spring%E6%A1%86%E6%9E%B6/springcloud/nacos/nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <url>/2023/02/27/spring%E6%A1%86%E6%9E%B6/springcloud/nacos/nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p><em>Nacos版本：2.0.4   nacos2.x已不支持ribbon，使用nacos2.x需要手动引入LoadBalancer</em></p><p><a href="https://nacos.io/zh-cn/docs/sdk.html">https://nacos.io/zh-cn/docs/sdk.html</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#服务注册</span><br>curl -X POST <span class="hljs-string">&#x27;http://localhost:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=8080&#x27;</span><br><br><span class="hljs-comment">#服务发现</span><br>curl -X GET <span class="hljs-string">&#x27;http://localhost:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h2><h3 id="1-1-基于Java-SDK的服务注册与发现"><a href="#1-1-基于Java-SDK的服务注册与发现" class="headerlink" title="1.1 基于Java SDK的服务注册与发现"></a>1.1 基于Java SDK的服务注册与发现</h3><p><a href="https://nacos.io/zh-cn/docs/sdk.html">https://nacos.io/zh-cn/docs/sdk.html</a></p><p>（1）引入nacos-client包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.nacos<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>nacos-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）编写Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceRegisterAndDiscovery</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NacosException, IOException&#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        properties.setProperty(<span class="hljs-string">&quot;serverAddr&quot;</span>, <span class="hljs-string">&quot;192.168.0.108:8848&quot;</span>); <span class="hljs-comment">//集群地址用逗号隔开</span><br>        <span class="hljs-type">NamingService</span> <span class="hljs-variable">naming</span> <span class="hljs-operator">=</span> NamingFactory.createNamingService(properties);<br>        <span class="hljs-comment">// 服务注册</span><br>System.out.println(<span class="hljs-string">&quot;-----服务注册-----&quot;</span>);<br>naming.registerInstance(<span class="hljs-string">&quot;nacos.test.3&quot;</span>, <span class="hljs-string">&quot;11.11.11.11&quot;</span>, <span class="hljs-number">8888</span>, <span class="hljs-string">&quot;TEST1&quot;</span>);<br><span class="hljs-comment">// 服务发现</span><br>System.out.println(<span class="hljs-string">&quot;-----服务发现-----&quot;</span>);<br>System.out.println(naming.getAllInstances(<span class="hljs-string">&quot;nacos.test.3&quot;</span>));<br>System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-基于SC的服务注册"><a href="#1-2-基于SC的服务注册" class="headerlink" title="1.2 基于SC的服务注册"></a>1.2 基于SC的服务注册</h3><p>（1）引入版本管理依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入spring cloud 版本管理 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入spring cloud alibaba 版本管理 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--引入spring cloud netflix 版本管理--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-netflix-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）引入nacos discovery依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（3）在application.yml文件中编写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-comment"># nacos server地址</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-comment"># 服务名称</span><br>        <span class="hljs-attr">service:</span> <span class="hljs-string">order</span><br></code></pre></td></tr></table></figure><p>（4）启动order-9091、9092、9093，观察nacos dashboard的服务情况</p><h3 id="1-3-SC的服务发现"><a href="#1-3-SC的服务发现" class="headerlink" title="1.3 SC的服务发现"></a>1.3 SC的服务发现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义服务发现接口，使用DiscoveryClient测试</span><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;<br><span class="hljs-meta">@RequestMapping(&quot;/instances&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;ServiceInstance&gt; <span class="hljs-title function_">instances</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;serviceId&quot;)</span>String serviceId)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.discoveryClient.getInstances(serviceId);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-Nacos领域模型"><a href="#1-4-Nacos领域模型" class="headerlink" title="1.4 Nacos领域模型"></a>1.4 Nacos领域模型</h3><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/1.png"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 创建一个命名空间，名称为dev，并获取到其id：9c52616a-48c0-4f78-a256-573b6fb5a152</span><br><span class="hljs-comment"># 查看dev命名空间下的服务，发现没有任何服务</span><br><span class="hljs-comment"># 修改user服务的application.yml文件，主要配置体验一下namespace、group和cluster</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-comment"># nacos server地址</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-comment"># 服务名称</span><br>        <span class="hljs-attr">service:</span> <span class="hljs-string">user</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">9c52616a-48c0-4f78-a256-573b6fb5a152</span><br>        <span class="hljs-attr">group:</span> <span class="hljs-string">shop-group</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">BJ</span><br><span class="hljs-comment"># 启动user服务，观察nacos dashboard dev命名空间下的数据</span><br><span class="hljs-comment"># 调用user服务中UserController提供的服务发现代码，发现调用失败，说明不同名命名空间下的服务是隔离的</span><br><span class="hljs-comment"># http://localhost:8081/user/instances?serviceId=order</span><br></code></pre></td></tr></table></figure><h3 id="1-5-Nacos元信息-Metadata"><a href="#1-5-Nacos元信息-Metadata" class="headerlink" title="1.5 Nacos元信息(Metadata)"></a>1.5 Nacos元信息(Metadata)</h3><p>Nacos数据（如配置和服务）描述信息，如服务版本、权重、容灾策略、负载均衡策略、鉴权配置、 各种自定义标签 (label)，从作用范围来看，分为服务级别的元信息、集群的元信息及实例的元信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 配置元信息</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">Jack</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/2.png"></p><h3 id="2-1-Nacos-Server启动"><a href="#2-1-Nacos-Server启动" class="headerlink" title="2.1 Nacos Server启动"></a>2.1 Nacos Server启动</h3><ol><li>Nacos 2.x</li></ol><p>（1）http方式，以Spring Boot的方式启动内置的Tomcat容器，并且实例化很多Controller提供Http请求的访问形式，比如InstanceController。启动方式和正常springboot启动相同。用于持久节点注册</p><p>（2）在Nacos2.X中新增了gRPC的通信方式，所以会在Server端提供gRPC的监听，用于处理客户端的连接。用于临时节点注册。</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos-grpc-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.jpg"></p><ol start="2"><li><p>Nacos 1.x</p><p> 只有http方式</p></li></ol><h3 id="2-2-Spring-Boot启动调用Nacos-API"><a href="#2-2-Spring-Boot启动调用Nacos-API" class="headerlink" title="2.2 Spring Boot启动调用Nacos API"></a>2.2 Spring Boot启动调用Nacos API</h3><p>（1）Spring Boot项目启动 </p><p>（2）Spring Boot发布ServletWebServerInitializedEvent事件 </p><p>（3）Spring Cloud监听器AbstractAutoServiceRegistration 监听感兴趣事件 WebServerInitializedEvent </p><p>（4）回调AbstractAutoServiceRegistration#onApplicationEvent</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/3.png"></p><h3 id="2-3-Nacos客户端向服务端发起服务注册"><a href="#2-3-Nacos客户端向服务端发起服务注册" class="headerlink" title="2.3 Nacos客户端向服务端发起服务注册"></a>2.3 Nacos客户端向服务端发起服务注册</h3><p>（1）Nacos 2.x</p><ul><li>入口：NacosNamingService#registerInstance(serviceName,groupName,Instance instance)</li></ul><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos2.x-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.jpg"></p><p>（2）Nacos 1.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos1.x-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.jpg"></p><h3 id="2-4-Nacos服务端处理服务注册"><a href="#2-4-Nacos服务端处理服务注册" class="headerlink" title="2.4 Nacos服务端处理服务注册"></a>2.4 Nacos服务端处理服务注册</h3><p>（1）Nacos 2.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos2.x-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C.jpg"></p><p>（2）Nacos 1.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos1.x-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C.jpg"></p><h3 id="2-5-心跳机制与健康检查"><a href="#2-5-心跳机制与健康检查" class="headerlink" title="2.5 心跳机制与健康检查"></a>2.5 心跳机制与健康检查</h3><p>（1）Nacos 2.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos2.x-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5.jpg"></p><p>（2）Nacos 1.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos1.x-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5.jpg"></p><h3 id="2-6-服务发现与订阅及通知客户端"><a href="#2-6-服务发现与订阅及通知客户端" class="headerlink" title="2.6 服务发现与订阅及通知客户端"></a>2.6 服务发现与订阅及通知客户端</h3><p>（1）Nacos 2.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos2.x-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0.jpg"></p><p>（2）Nacos 1.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos1.x-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0.jpg"></p><h3 id="2-7-分布式架构"><a href="#2-7-分布式架构" class="headerlink" title="2.7 分布式架构"></a>2.7 分布式架构</h3><p>如果注册Nacos的client节点注册时ephemeral=true，那么Nacos集群对这个client节点的效果就是AP，采用distro协议实现；而注册Nacos的client节点注册时ephemeral=false，那么Nacos集群对这个节点的效果就是CP的，采用raft协议实现。根据client注册时的属性，AP，CP同时混合存在，只是对不同的client节点效果不同。Nacos可以很好的解决不同场景的业务需求。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#false为永久实例，true表示临时实例开启，注册为临时实例，默认是true</span><br><span class="hljs-attr">spring.cloud.nacos.discovery.ephemeral</span> = <span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><h4 id="2-7-1-AP架构-distro"><a href="#2-7-1-AP架构-distro" class="headerlink" title="2.7.1 AP架构-distro"></a>2.7.1 AP架构-distro</h4><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos2.x-%E5%88%86%E5%B8%83%E5%BC%8FAP%E6%9E%B6%E6%9E%84.jpg"></p><h4 id="2-7-2-CP架构-raft"><a href="#2-7-2-CP架构-raft" class="headerlink" title="2.7.2 CP架构-raft"></a>2.7.2 CP架构-raft</h4><p><a href="https://raft.github.io/">https://raft.github.io/</a></p><p><a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p><p><a href="https://raft.github.io/#implementations/">https://raft.github.io/#implementations/</a></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>nacos</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
      <tag>nacos</tag>
      
      <tag>服务注册中心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nacos安装与配置</title>
    <link href="/2023/02/27/spring%E6%A1%86%E6%9E%B6/springcloud/nacos/nacos%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/02/27/spring%E6%A1%86%E6%9E%B6/springcloud/nacos/nacos%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p><em>Nacos版本：2.0.4   nacos2.x已不支持ribbon，使用nacos2.x需要手动引入LoadBalancer</em></p><h2 id="1-单机版"><a href="#1-单机版" class="headerlink" title="1. 单机版"></a>1. 单机版</h2><h3 id="1-1-package-基于CentOS"><a href="#1-1-package-基于CentOS" class="headerlink" title="1.1 package(基于CentOS)"></a>1.1 package(基于CentOS)</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#（1）下载nacos-server的二进制包，比如：nacos-server-2.0.4.tar.gz</span><br><span class="hljs-comment">#（2）解压并进入bin目录</span><br>unzip nacos-server-<span class="hljs-variable">$version</span>.zip OR tar -xvf nacos-server-<span class="hljs-variable">$version</span>.tar.gz<br><span class="hljs-built_in">cd</span> nacos/bin<br><span class="hljs-comment">#（3）打开startup.sh文件，寻找MODE的默认方式，发现是&quot;cluster&quot;</span><br>vim startup.sh<br><span class="hljs-comment">#（4）查看nacos的启动配置文件，可以发现默认端口是8848，默认访问路径是/nacos</span><br>vim ../conf/application.properties<br><span class="hljs-comment">#（5）以单机模式启动nacos server</span><br>sh startup.sh -m standalone<br><span class="hljs-comment">#（6）查看启动日志</span><br><span class="hljs-built_in">tail</span> -f /root/nacos/logs/start.out<br><span class="hljs-built_in">tail</span> -f ../logs/start.out<br><span class="hljs-comment">#（7）关闭nacos server</span><br>sh shutdown.sh<br><span class="hljs-comment">#（8）打开浏览器访问，输入默认用户名:nacos和密码:nacos</span><br>centosip:8848/nacos<br></code></pre></td></tr></table></figure><h3 id="1-2-source"><a href="#1-2-source" class="headerlink" title="1.2 source"></a>1.2 source</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">（<span class="hljs-number">1</span>）下载nacos-<span class="hljs-keyword">server</span>的源码，比如：nacos<span class="hljs-number">-2.0</span><span class="hljs-number">.4</span>.zip<br>（<span class="hljs-number">2</span>）解压并进入nacos目录<br>（<span class="hljs-number">3</span>）maven构建<br>mvn -Prelease-nacos -Dmaven.test.skip=<span class="hljs-keyword">true</span> clean install -U<br>（<span class="hljs-number">4</span>）使用idea打开nacos工程<br>（<span class="hljs-number">5</span>）配置启动信息<br>Spring Boot<br><span class="hljs-type">Name</span>: nacos-<span class="hljs-keyword">server</span>-standalone<br>Main <span class="hljs-keyword">Class</span>: com.alibaba.nacos.Nacos<br>VM <span class="hljs-keyword">options</span>: -Dnacos.standalone=<span class="hljs-keyword">true</span> -Dnacos.home=nacos-home-standalone<br>classpath <span class="hljs-keyword">of</span> module: nacos-console<br></code></pre></td></tr></table></figure><h2 id="2-集群版"><a href="#2-集群版" class="headerlink" title="2. 集群版"></a>2. 集群版</h2><p><a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html</a></p><h3 id="2-1-package"><a href="#2-1-package" class="headerlink" title="2.1 package"></a>2.1 package</h3><p>（1）准备3台centos机器，把对应的nacos二进制包上传到3台机器中并解压</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.1.81</span><br><span class="hljs-number">192.168.1.82</span><br><span class="hljs-number">192.168.1.83</span><br></code></pre></td></tr></table></figure><p>（2）复制并编辑nacos/conf目录下的cluster.conf文件：cp cluster.conf.example cluster.conf</p><p>（3）选择其中一台机器作为MySQL的安装机器，比如81，生产使用建议至少主备模式，或者采用高可用数据库，并执行提供好的sql文件，用于创建数据库表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p<br><span class="hljs-keyword">create</span> database nacos;<br>use nacos;<br>source <span class="hljs-operator">/</span>root<span class="hljs-operator">/</span>nacos<span class="hljs-operator">/</span>conf<span class="hljs-operator">/</span>nacos<span class="hljs-operator">-</span>mysql.sql;<br><span class="hljs-keyword">show</span> tables;<br></code></pre></td></tr></table></figure><p>（4）将derby的配置切换成MySQL</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#（1）打开conf/application.properties文件</span><br><span class="hljs-comment"># vim application.properties</span><br><span class="hljs-comment">#（2）根据自己MySQL的安装情况修改如下配置信息</span><br><span class="hljs-comment">#*************** Config Module Related Configurations ***************#</span><br><span class="hljs-comment">### If use MySQL as datasource:</span><br><span class="hljs-attr">spring.datasource.platform</span>=<span class="hljs-string">mysql</span><br><span class="hljs-comment">### Count of DB:</span><br><span class="hljs-attr">db.num</span>=<span class="hljs-string">1</span><br><span class="hljs-comment">### Connect URL of DB:</span><br><span class="hljs-attr">db.url.0</span>=<span class="hljs-string">jdbc:mysql://192.168.1.81:3306/nacos?</span><br><span class="hljs-attr">characterEncoding</span>=<span class="hljs-string">utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span><br><span class="hljs-attr">&amp;useUnicode</span>=<span class="hljs-string">true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="hljs-attr">db.user.0</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">db.password.0</span>=<span class="hljs-string">root123</span><br></code></pre></td></tr></table></figure><p>（5）来到nacos/bin目录，直接启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sh startup.sh<br></code></pre></td></tr></table></figure><p>（6）访问任意一台机器的8848端口，看看dashboard中的内容</p><h3 id="2-2-source"><a href="#2-2-source" class="headerlink" title="2.2 source"></a>2.2 source</h3><p>​    nacos2.x的版本使用到了grpc进行通信，而grpc的端口会相对于server.port端口做的偏移 比如nacos server的http端口为8848，则grpc的会使用8848+1000，即9848作为和客户端的通信端口，同时grpc会使用8848+1001，即9849作为nacos集群间的数据同步端口，所以在源码搭建的时候，要避免端口冲突</p><p>（1）前置准备</p><p>​    下载nacos-server的源码，比如：nacos-2.0.4.zip ；解压并进入nacos目录 ；maven构建 mvn -Prelease-nacos -Dmaven.test.skip=true clean install -U ；使用idea打开nacos工程</p><p>（2）准备好MySQL数据库</p><p>（3）在nacos源码根目录创建3个文件夹，作为集群的nacos home。同时在3个nacos home下新建 conf目录，并创建cluster.conf文件，配置内容如下</p><p><img src="/image/springcloud/nacos/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/1.png"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:8841</span><br><span class="hljs-number">127.0.0.1:8843</span><br><span class="hljs-number">127.0.0.1:8845</span><br></code></pre></td></tr></table></figure><p>4）将derby修改成mysql，配置文件：nacos2.0.4\console\src\main\resources\application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#*************** Config Module Related Configurations ***************#</span><br><span class="hljs-comment">### If use MySQL as datasource:</span><br><span class="hljs-attr">spring.datasource.platform</span>=<span class="hljs-string">mysql</span><br><span class="hljs-comment">### Count of DB:</span><br><span class="hljs-attr">db.num</span>=<span class="hljs-string">1</span><br><span class="hljs-comment">### Connect URL of DB:</span><br><span class="hljs-attr">db.url.0</span>=<span class="hljs-string">jdbc:mysql://192.168.0.81:3306/nacos?</span><br><span class="hljs-attr">characterEncoding</span>=<span class="hljs-string">utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span><br><span class="hljs-attr">&amp;useUnicode</span>=<span class="hljs-string">true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="hljs-attr">db.user.0</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">db.password.0</span>=<span class="hljs-string">root123</span><br></code></pre></td></tr></table></figure><p>（5）配置集群的启动参数</p><ul><li><p>8841</p><p>  <img src="/image/springcloud/nacos/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/2.png"></p></li><li><p>8843</p><p>  <img src="/image/springcloud/nacos/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/3.png"></p></li><li><p>8845</p><p>  <img src="/image/springcloud/nacos/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/4.png"></p></li></ul><p>（6）分别启动集群的3个server</p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>nacos</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>架构演进以及版本更迭</title>
    <link href="/2023/02/27/spring%E6%A1%86%E6%9E%B6/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/"/>
    <url>/2023/02/27/spring%E6%A1%86%E6%9E%B6/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="1-架构演进"><a href="#1-架构演进" class="headerlink" title="1. 架构演进"></a>1. 架构演进</h2><h3 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1 单体架构"></a>1.1 单体架构</h3><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/1.png"></p><h3 id="1-2-垂直化拆分"><a href="#1-2-垂直化拆分" class="headerlink" title="1.2 垂直化拆分"></a>1.2 垂直化拆分</h3><p>按功能模块进行垂直化拆分</p><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/2.png"></p><h3 id="1-3-集群-负载均衡"><a href="#1-3-集群-负载均衡" class="headerlink" title="1.3 集群+负载均衡"></a>1.3 集群+负载均衡</h3><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/3.png"></p><h3 id="1-4-SOA"><a href="#1-4-SOA" class="headerlink" title="1.4 SOA"></a>1.4 SOA</h3><p>SOA：Service Oriented Architecture </p><p>ESB：Enterprise Service Bus 企业服务总线。ESB就相当于是一根管道，主要是为了集成不同协议的服务，使得不同服务之间能够彼此调用</p><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/4.png"></p><h3 id="1-5-微服务"><a href="#1-5-微服务" class="headerlink" title="1.5 微服务"></a>1.5 微服务</h3><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/5.png"></p><h2 id="2-微服务架构下问题的解决方案"><a href="#2-微服务架构下问题的解决方案" class="headerlink" title="2. 微服务架构下问题的解决方案"></a>2. 微服务架构下问题的解决方案</h2><p><a href="https://landscape.cncf.io/">Cloud Native Landscape (cncf.io)</a></p><p>（1）服务注册与发现：eureka、zookeeper、nacos、consul、etcd等 </p><p>（2）负载均衡：ribbon、nginx等 </p><p>（3）服务调用：dubbo、thrift、feign等 </p><p>（4）熔断：hystrix、sentinel等 </p><p>（5）网关：zuul、gateway、kong等 </p><p>（6）配置中心：config、nacos、apoll等 </p><p>（7）分布式消息：rocketmq、kafka、pulsar、rabbitmq等 </p><p>（8）分布式锁：redis、zookeeper等 </p><p>（9）分布式事务：seata、tx-lcn等</p><h2 id="3-Spring-Cloud生态"><a href="#3-Spring-Cloud生态" class="headerlink" title="3. Spring Cloud生态"></a>3. Spring Cloud生态</h2><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/6.png"></p><h2 id="4-版本对比"><a href="#4-版本对比" class="headerlink" title="4. 版本对比"></a>4. 版本对比</h2><h3 id="4-1-Spring-Cloud和Spring-Boot"><a href="#4-1-Spring-Cloud和Spring-Boot" class="headerlink" title="4.1 Spring Cloud和Spring Boot"></a>4.1 Spring Cloud和Spring Boot</h3><p><a href="https://spring.io/projects/spring-cloud#overview">https://spring.io/projects/spring-cloud#overview</a></p><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/7.png"></p><h3 id="4-2-Spring-Cloud和SCA"><a href="#4-2-Spring-Cloud和SCA" class="headerlink" title="4.2 Spring Cloud和SCA"></a>4.2 Spring Cloud和SCA</h3><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E</a></p><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/8.png"></p><h3 id="4-3-Spring-Cloud和SCN"><a href="#4-3-Spring-Cloud和SCN" class="headerlink" title="4.3 Spring Cloud和SCN"></a>4.3 Spring Cloud和SCN</h3><p><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2021.0-Release-Notes#202104">https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2021.0-Release-Notes#202104</a></p><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/9.png"></p><h3 id="4-4-SCA与具体组件版本"><a href="#4-4-SCA与具体组件版本" class="headerlink" title="4.4 SCA与具体组件版本"></a>4.4 SCA与具体组件版本</h3><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E#%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E#%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB</a></p><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/10.png"></p><h3 id="4-5-最终版本"><a href="#4-5-最终版本" class="headerlink" title="4.5 最终版本"></a>4.5 最终版本</h3><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/11.png"></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lua脚本-redis</title>
    <link href="/2023/02/22/lua/Lua-redis/"/>
    <url>/2023/02/22/lua/Lua-redis/</url>
    
    <content type="html"><![CDATA[<h2 id="1-在redis中调用lua脚本"><a href="#1-在redis中调用lua脚本" class="headerlink" title="1  在redis中调用lua脚本"></a>1  在redis中调用lua脚本</h2><p>使用eval方法，语法格式：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">eval</span> lua-script <span class="hljs-built_in">key</span>-<span class="hljs-built_in">num</span> [key1 key2 key3 ...] [value1 value2 value3 ...]<br><br>//<span class="hljs-built_in">eval</span> 代表执行Lua语言的命令<br>//lua-script 代表Lua语言脚本内容<br>//<span class="hljs-built_in">key</span>-<span class="hljs-built_in">num</span> 表示参数中有多少个<span class="hljs-built_in">key</span>，需要注意的是Redis中的<span class="hljs-built_in">key</span>是从<span class="hljs-number">1</span>开始的，如果没有<span class="hljs-built_in">key</span>的参数，那么写<span class="hljs-number">0</span><br>//[key1 key2 key3 ...]是<span class="hljs-built_in">key</span>作为参数传递给Lua语言，也可以不写，但是需要和<span class="hljs-built_in">key</span>-<span class="hljs-built_in">num</span>的个数对应起来<br>//[value1 value2 value3 ...]参数的value值，一一对应，可填可不填<br></code></pre></td></tr></table></figure><p>示例：返回一个字符串，0个参数：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">eval</span> <span class="hljs-string">&quot;return &#x27;Hello World&#x27;&quot;</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>实际上，Lua脚本在Redis里面真正的用途是用来执行redis命令。</p><h2 id="2-在Lua脚本中调用redis命令"><a href="#2-在Lua脚本中调用redis命令" class="headerlink" title="2  在Lua脚本中调用redis命令"></a>2  在Lua脚本中调用redis命令</h2><h3 id="2-1-命令格式"><a href="#2-1-命令格式" class="headerlink" title="2.1 命令格式"></a>2.1 命令格式</h3><p>使用redis.call(command, key, [param1, param2 ……])进行操作。语法格式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">redis.call(command, key [param1, param2, ...])<br><span class="hljs-comment">-- command是命令，包括set、get、del等</span><br><span class="hljs-comment">-- key是被操作的键</span><br><span class="hljs-comment">-- param1， param2 ...代表给key的参数</span><br></code></pre></td></tr></table></figure><p>一个简单的案例，让Lua脚本执行set qingshan 2673</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">eval <span class="hljs-string">&quot;return redis.call(&#x27;set&#x27;,&#x27;qingshan&#x27;,&#x27;2673&#x27;)&quot;</span>  <span class="hljs-regexp">//</span>写死值<br>eval <span class="hljs-string">&quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[1])&quot;</span> <span class="hljs-number">1</span> qingshan <span class="hljs-number">2673</span> <span class="hljs-regexp">//</span>参数传递<br></code></pre></td></tr></table></figure><p>在redis-cli中直接写Lua脚本不够方便，也不能实现编辑和复用，通常我们会把lua脚本凡在文件中，然后执行这个文件。</p><h3 id="2-2-Lua脚本文件"><a href="#2-2-Lua脚本文件" class="headerlink" title="2.2 Lua脚本文件"></a>2.2 Lua脚本文件</h3><p>创建脚本文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft/redis-6.0.9/src<br>vim test.lua<br></code></pre></td></tr></table></figure><p>Lua脚本内容，先赋值，再取值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">redis.call(<span class="hljs-string">&#x27;set&#x27;</span>,<span class="hljs-string">&#x27;qingshan&#x27;</span>,<span class="hljs-string">&#x27;lua666&#x27;</span>)<br><span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;get&#x27;</span>,<span class="hljs-string">&#x27;qingshan&#x27;</span>)<br></code></pre></td></tr></table></figure><p>调用脚本文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft/redis-6.0.9/src<br>redis-cli --<span class="hljs-built_in">eval</span> test.lua 0<br></code></pre></td></tr></table></figure><h3 id="2-3-案例：对IP进行限流"><a href="#2-3-案例：对IP进行限流" class="headerlink" title="2.3 案例：对IP进行限流"></a>2.3 案例：对IP进行限流</h3><p>需求：每个用户再X秒内只能访问Y次。设计思路：</p><p>首先是数据类型。用String的key记录IP，用value记录访问的次数。几秒钟和几次哟啊用参数动态传进去。拿到IP以后，对IP+1。如果是第一次访问，对key设置国企时间（参数1）.否则判断次数，超过限定次数（参数2），返回0。如果没有超过次数返回1。超过时间，key国企之后，可以再次访问。</p><p>KEY[1]是IP，ARGV[1]是过期时间X，ARGV[2]是限制访问的次数Y。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- ip_limit.lua</span><br><span class="hljs-comment">-- IP限流，对某个IP频率进行校址，6秒钟访问10次</span><br><span class="hljs-keyword">local</span> num=redis.call(<span class="hljs-string">&#x27;incr&#x27;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">tonumber</span>(num)==<span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>   <span class="hljs-keyword">elseif</span> <span class="hljs-built_in">tonumber</span>(num)&gt;<span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">2</span>]) <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>   <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>6秒钟内限制访问10次，调用测试（连续调用10次）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli --<span class="hljs-built_in">eval</span> ip_limit.lua app:ip:<span class="hljs-built_in">limit</span>:192.168.8.111 , 6 10<br></code></pre></td></tr></table></figure><p>Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LuaTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> getJedisUtil();<br>        jedis.eval(<span class="hljs-string">&quot;return redis.call(&#x27;set&#x27;,KEYS[1],ARGV[1])&quot;</span>, <span class="hljs-number">1</span>,<span class="hljs-string">&quot;test:lua:key&quot;</span>,<span class="hljs-string">&quot;qingshan2673lua&quot;</span>);<br>        System.out.println(jedis.get(<span class="hljs-string">&quot;test:lua:key&quot;</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>            limit();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 10秒内限制访问5次</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">limit</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> getJedisUtil();<br>        <span class="hljs-comment">// 只在第一次对key设置过期时间</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">lua</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;local num = redis.call(&#x27;incr&#x27;, KEYS[1]) \n&quot;</span> +<br>                <span class="hljs-string">&quot;if tonumber(num) == 1 then\n&quot;</span> +<br>                <span class="hljs-string">&quot;\t redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[1]) \n&quot;</span> +<br>                <span class="hljs-string">&quot;\t return 1 \n&quot;</span> +<br>                <span class="hljs-string">&quot;elseif tonumber(num) &gt; tonumber(ARGV[2]) then \n&quot;</span> +<br>                <span class="hljs-string">&quot;\t return 0 \n&quot;</span> +<br>                <span class="hljs-string">&quot;else \n&quot;</span> +<br>                <span class="hljs-string">&quot;\t return 1 \n&quot;</span> +<br>                <span class="hljs-string">&quot;end \n&quot;</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.evalsha(jedis.scriptLoad(lua), Arrays.asList(<span class="hljs-string">&quot;localhost&quot;</span>), Arrays.asList(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>));<br>        System.out.println(result);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedisUtil</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> ResourceUtil.getKey(<span class="hljs-string">&quot;redis.host&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> Integer.valueOf(ResourceUtil.getKey(<span class="hljs-string">&quot;redis.port&quot;</span>));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> ResourceUtil.getKey(<span class="hljs-string">&quot;redis.password&quot;</span>);<br>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">jedisPoolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>        <span class="hljs-type">JedisPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(jedisPoolConfig, ip, port, <span class="hljs-number">10000</span>, password);<br>        <span class="hljs-keyword">return</span> pool.getResource();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-缓存Lua脚本"><a href="#2-4-缓存Lua脚本" class="headerlink" title="2.4 缓存Lua脚本"></a>2.4 缓存Lua脚本</h3><p><strong>为什么要缓存</strong></p><p>​    在Lua脚本比较长的情况下，如果多次调用脚本都需要把整个脚本传给Redis服务端，会产生比较大的网络开销。为了解决这个问题，Redis可以缓存Lua脚本并生成SHA1摘要码，后面可以直接通过摘要码来执行Lua脚本。</p><p><strong>如何缓存</strong></p><p>这里面涉及到两个命令，首先是在服务端缓存lua脚本生成一个摘要码，用script load命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">script load <span class="hljs-string">&quot;return Hello World&quot;</span><br></code></pre></td></tr></table></figure><p>第二个命令是通过摘要码执行缓存的脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">evalsha <span class="hljs-string">&quot;摘要码&quot;</span> 0<br></code></pre></td></tr></table></figure><p><strong>自乘案例</strong></p><p>Redis有incrby这样的自增命令，但是没有自乘。比如乘以3，乘以5</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">set</span> num 2<br></code></pre></td></tr></table></figure><p>写一个自乘的运算，让它乘以后面的参数:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> curVal=redis.call(<span class="hljs-string">&quot;get&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">if</span> curVal==<span class="hljs-literal">false</span> <span class="hljs-keyword">then</span><br>    curVal=<span class="hljs-number">0</span><br>   <span class="hljs-keyword">else</span><br>    curVal=<span class="hljs-built_in">tonumber</span>(curVal)<br><span class="hljs-keyword">end</span><br>curVal=curVal*<span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>])<br>redis.call(<span class="hljs-string">&quot;set&quot;</span>,KEYS[<span class="hljs-number">1</span>],curVal)<br><span class="hljs-keyword">return</span> curVal<br></code></pre></td></tr></table></figure><p>这个命令变成串行，语句之间使用分号隔开，Script load命令（redis客户端执行）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">script locad <span class="hljs-string">&#x27;local curVal=redis.call(&quot;get&quot;,KEYS[1]);if curVal==false then curVal=0 else curVal=tonumber(curVal) end;curVal=curVal*tonumber(ARGV[1]);redis.call(&quot;set&quot;,KEYS[1],curVal);return curVal&#x27;</span><br></code></pre></td></tr></table></figure><p>调用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">evalsha <span class="hljs-string">&quot;摘要码&quot;</span> 1 num 6<br></code></pre></td></tr></table></figure><h3 id="2-5-脚本超时"><a href="#2-5-脚本超时" class="headerlink" title="2.5 脚本超时"></a>2.5 脚本超时</h3><p>Redis的指令执行本身是单线程的，这个线程还要执行客户端的Lua脚本，如果Lua脚本执行超时或者陷入了死循环，是不是没有办法为客户端提供服务了？它会导致其他的命令都会进入等待状态。为了防止这种情况，首先，脚本执行有一个超时时间，默认为5秒钟。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">lua-time-limit</span> <span class="hljs-string">5000</span><br></code></pre></td></tr></table></figure><p>超过5秒钟，其他客户端的命令不会等待，而是直接返回BUSY错误。这样也不行，不能一直拒绝其他客户端的命令执行。在提示中看到有两个命令可以使用，第一个是script kill，终止脚本的执行。但是需要注意:并不是所有的lua脚本执行都可以kill。如果当前执行的lua脚本对Redis的数据进行了修改（set，DEL、等），那么通过script kill命令是不能终止脚本运行的。为什么包含修改的脚本不能中断？因为要保证脚本运行的原子性。如果脚本执行了一部分被终止，那就违背了脚本原子性的目标。遇到这种情况，只能通过shutdown nosave命令，直接把redis服务停掉。正常关机是shutdown。Shutdown nosave和shutdown的区别在于shutdown nosave不会进行持久化操作，意味着发生在上一个快照后的数据库修改都会丢失。</p>]]></content>
    
    
    <categories>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis为什么这么快</title>
    <link href="/2023/02/22/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/"/>
    <url>/2023/02/22/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/</url>
    
    <content type="html"><![CDATA[<p>总结起来主要有三点：1.纯内存结构。2.请求处理单线程。3.多路复用机制</p><h2 id="1-原因"><a href="#1-原因" class="headerlink" title="1  原因"></a>1  原因</h2><h3 id="1-1-内存"><a href="#1-1-内存" class="headerlink" title="1.1 内存"></a>1.1 内存</h3><p>KV结构的内存数据库，时间复杂度是O(1)。</p><h3 id="1-2-单线程"><a href="#1-2-单线程" class="headerlink" title="1.2 单线程"></a>1.2 单线程</h3><p>这里说的单线程其实指的是处理客户端的请求是单线程的，可以把它叫做主线程。从4.0版本之后，还引入了一些线程处理其他的事情，比如清理脏数据，无用连接的释放，大key的删除。</p><p>​    把处理请求的主线程设置成单线程有什么好处呢？</p><p>​    1.没有创建线程，销毁线程带来的消耗</p><p>​    2.避免了上下文切换导致的CPU消耗</p><p>​    3.避免了线程之间带来的竞争关系，例如加锁释放锁死锁等等。</p><p>​    这里有个问题，就算单线程确实有这些好处，但是会不会白白浪费了CPU的资源？也就是说只能用到单核。官方的解释是这样的：在Redis中单线程已经够用了，CPU不是redis的瓶颈。redis的瓶颈最有可能是机器内存或者网络带宽，既然单线程容易实现，又不需要处理线程并发的问题，那就顺理成章的采用单线程的方案了。注意，因为请求处理是单线程的，不要在生产环境运行长命令，比如keys，flushall，flushdb。否则会导致请求被阻塞。</p><h3 id="1-3-同步非阻塞IO"><a href="#1-3-同步非阻塞IO" class="headerlink" title="1.3 同步非阻塞IO"></a>1.3 同步非阻塞IO</h3><p>同步非阻塞IO，多路复用并发连接</p><h2 id="2-单线程为什么这么快？"><a href="#2-单线程为什么这么快？" class="headerlink" title="2  单线程为什么这么快？"></a>2  单线程为什么这么快？</h2><p>因为redis是基于内存的操作，先从内存开始说起</p><h3 id="2-1-虚拟存储器-虚拟内存Virtual-Memory"><a href="#2-1-虚拟存储器-虚拟内存Virtual-Memory" class="headerlink" title="2.1 虚拟存储器(虚拟内存Virtual Memory)"></a>2.1 虚拟存储器(虚拟内存Virtual Memory)</h3><p>计算机里面的内存叫做主存，硬盘叫做辅存。主存可看作一个很长的数组，一个字节一个单元，每个字节有一个唯一的地址，这个地址叫做物理地址（Physical Address）。早期的计算机中，如果CPU需要内存，使用物理寻址，直接访问主存储器。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/1.png"></p><p>这种方式有几个弊端：</p><p>​    1.一般的操作系统都是多用户多任务的，所有的进程共享主存。如果每个进程都独占一块物理地址空间，主存很快就会被用完。我们希望在不同的时刻，不同的进程共用同一块物理地址空间。</p><p>​    2.如果所有进程都是直接访问物理内存，那么一个进程就可以修改其他进程的内存数据，导致物理地址空间被破坏，程序运行就会出现异常。</p><p>​    所以想了一个办法，在CPU和主存之间增加一个中间层。CPU不再使用物理地址访问主存，而是访问一个虚拟地址，由这个中间层把地址转换成物理地址，最终获得数据。这个中间层叫做MMU（Memory Management Unit），内存管理单元。</p><p>​    具体的操作如下所示：</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/2.png"></p><p>访问MMU就跟访问物理内存一样，所以把虚拟出来的地址叫做虚拟内存（Virtual Memory）。</p><p>在每一个进程开始创建的时候，都会分配一段虚拟地址，然后通过虚拟地址和物理地址的映射来获取真实数据，这样进程就不会直接接触到物理地址，甚至不知道自己调用的哪块物理地址的数据。目前，大多数操作系统都使用了虚拟内存，如Windows系统的虚拟内存，Linux系统的交换空间等。Windows的虚拟内存（pagefile.sys）是磁盘空间的一部分。在32位系统上，虚拟地址空间大小是2^32=4G。在64位系统上，最大虚拟地址空间大小是多少？是不是2^64-1024*1024TB?实际上没有用到64位，因为用不到这么大的空间，而且会造成很大的系统开销。linux一般用低48位来表示虚拟地址空间，也就是2^48=256T.</p><p>实际的物理内存可能远远小于虚拟内存的大小。总结：引入虚拟内存的作用：</p><p>​    1.通过把同一块物理内存映射到不同的虚拟地址空间实现内存共享。</p><p>​    2.对物理内存进行隔离，不同的进程操作互不影响</p><p>​    3.虚拟内存可以提供更大的地址空间，并且地址空间是连续的，使得程序编写，连接更加简单。</p><p>​    Linux/GNU的虚拟内存又进一步划分成了两块</p><h3 id="2-2-用户空间和内核空间"><a href="#2-2-用户空间和内核空间" class="headerlink" title="2.2 用户空间和内核空间"></a>2.2 用户空间和内核空间</h3><p>一部分是内核空间（Kernel-space）,一部分是用户空间（User-space）。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/3.png"></p><p>Linux系统中，虚拟地址布局如下：</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/4.png"></p><p>进程的用户空间中存放的是用户程序的代码和数据，内核空间中存放的是内核代码和数据。不管内核空间还是用户空间，它们都处于虚拟内存空间中，都是对物理地址的映射。当进程运行在内核空间时就处于内核态，而进程运行在用户空间时则处于用户态。进程在内核空间可以访问受保护的内存空间，也可以访问底层硬件设备。也就是可以执行任意命令，调用系统的一切资源。在用户空间只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称system call），才能向内核发出指令。所以，这样划分的目的是为了避免用户进程直接操作内核，保证内核安全。</p><h3 id="2-3-进程切换（上下文切换）"><a href="#2-3-进程切换（上下文切换）" class="headerlink" title="2.3 进程切换（上下文切换）"></a>2.3 进程切换（上下文切换）</h3><p>多任务操作系统是怎么实现运行远大于CPU数量的任务个数的?当然，这些任务实际上并不是真的在同时运行，而是因为系统通过时间片算法，在很短的时间内，将CPU轮流分配给它们，造成多任务同时运行的错觉。在这个交替运行的过程中，为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，以及恢复以前挂起的某个进程的执行。这个行为被称为进程切换。</p><p>​    什么叫上下文（Context）？在每个任务运行前，CPU都需要知道任务从哪里加载，又从哪里开始运行，也就是说，需要系统事先帮它设置好CPU寄存器和程序计数器，这个叫做CPU的上下文。</p><p>​    而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p><p>​    在切换上下文的时候，需要完成一系列的工作，这是一个很消耗资源的操作。</p><h3 id="2-4-进程的阻塞"><a href="#2-4-进程的阻塞" class="headerlink" title="2.4 进程的阻塞"></a>2.4 进程的阻塞</h3><p>正在运行的进程由于提出系统服务请求（如IO操作），但因为某种原因未得到操作系统的立即响应，该进程只能把自己变成阻塞状态，等待响应的时间出现后才被唤醒。进程在阻塞状态不占用CPU资源。</p><h3 id="2-5-文件描述符FD"><a href="#2-5-文件描述符FD" class="headerlink" title="2.5 文件描述符FD"></a>2.5 文件描述符FD</h3><p>Linus系统将所有设备都当作文件来处理，而Linux用文件描述符来标识每个文件对象。文件描述符（File Descriptior）是内核为了高效管理已被打开的文件锁创建的索引，用于指向被打开的文件，所有执行IO操作的系统调用都通过文件描述符。</p><p>​    文件描述符是一个简单的非负整数，用以标名每个被进程打开的文件。linux系统里面有三个标准文件描述符：</p><p>​    0：标准输入（键盘）；1：标准输出（显示器）；2：标准错误输出（显示器）。</p><h3 id="2-6-传统IO数据拷贝"><a href="#2-6-传统IO数据拷贝" class="headerlink" title="2.6 传统IO数据拷贝"></a>2.6 传统IO数据拷贝</h3><p>以读操作为例：但应用程序执行read系统调用读取文件描述符（FD）的时候，如果这块数据已经存在于用户进程的页内存中，就直接从内存中读取数据。如果数据不存在，则先将数据从磁盘加载数据到内核缓冲区中，再从内核缓冲器拷贝到用户进程的页内存中。（两个拷贝，两次user和kernel的上下文切换）。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/5.png"></p><h3 id="2-7-Bocking-I-O"><a href="#2-7-Bocking-I-O" class="headerlink" title="2.7 Bocking I/O"></a>2.7 Bocking I/O</h3><p>当使用read或write对某个文件描述符进行过读写时，如果当前FD不可读，系统就不会对其他的操作做出响应，从硬件设备复制数据到内核缓冲区是阻塞的，从内核缓冲区拷贝到用户空间，也是阻塞的，知道copy complete，内核返回结果，用户进程才解除block的状态。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/6.png"></p><p>为了解决阻塞的问题，有几个思路</p><p>​    1.在服务端创建多个线程或者使用线程池，但是在高并发的情况下需要的线程会很多，系统无法承受，而且创建和释放线程都需要消耗资源。</p><p>​    2.由请求方定期轮询，在数据准备完毕后再从内核缓存区复制数据到用户空间（非阻塞IO），这种方式存在一定的延迟。</p><p>​    能不能用一个线程处理多个客户端请求？</p><h3 id="2-8-I-O多路复用-IO-Multiplexing"><a href="#2-8-I-O多路复用-IO-Multiplexing" class="headerlink" title="2.8 I/O多路复用(IO Multiplexing)"></a>2.8 I/O多路复用(IO Multiplexing)</h3><p>​    IO指的是网络IO</p><p>​    多路指的是多个TCP连接（Socket或Channel）。</p><p>​    复用指的是复用一个或多个线程。</p><p>​    它的基本原理就是不再由应用程序自己监视连接，而是由内核替应用程序监视文件描述符。客户端再操作的时候，会产生具有不同事件类型的socket。在服务端，IO多路复用程序（IO Multiplexing Module）会把消息放入队列中，然后通过文件事件分派其（File event Dispatcher），转发到不同的事件处理器中。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/7.png"></p><p>多路复用有很多实现，以select为例，当用户进程调用了多路复用器，进程会被阻塞。内核会监视多路复用器负责的所有socket，当任何一个socket的数据准备好了，多路复用器就会返回。这时候用户进程再调用read操作，把数据从内核缓冲器拷贝到用户空间。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/8.png"></p><p>所以，IO多路复用的特点是通过一种机制让一个进程能同时等待多个文件描述符，而这些文件描述符其中的任意一个进入读就绪(readable)状态，select()函数就可以返回。多路复用需要操作系统的支持。redis的多路复用，提供了select，epoll，evport，kqueue几种选择，在编译的时候来选择一种。</p><p>​    evport是Solaris系统内核提供支持的；</p><p>​    epoll是Linux系统内核提供支持的；</p><p>​    kqueue是Mac系统提供支持的；</p><p>​    select是POSIX提供的，一般操作系统都有支撑(保底方案)</p><p>总结：redis抽象了一套AE事件模型，将IO事件和时间事件融入一起，同时借助多路复用机制的回调特性（Linux上用epoll），使得IO读写都是非阻塞的，实现高性能的网络处理能力。</p><p>​    一直在说的redis新版本多线程的特性，意思并不是服务端接收客户端请求变成多线程了，它还是单线程的。严格意义上来说，redis从4.0之后就引入了多线程用来处理一些耗时长的工作和后台工作，那不然的话，如果真的只有一个线程，那些耗时的操作肯定会导致金额护短请求被阻塞。我们这里说的多线程，确切的说叫做多线程IO</p><h3 id="2-9-多线程IO"><a href="#2-9-多线程IO" class="headerlink" title="2.9 多线程IO"></a>2.9 多线程IO</h3><p>服务端的数据返回给客户端，需要从内核空间copy数据到用户空间，然后会写道socket(write调用)，这个过程是非常耗时的。所以多线程IO指的就是把结果写道socket的这个环节是多线程的。处理请求依然是单线程的，所以不存在线程并发安全问题。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/9.png"></p><p>Redis本质上是一个存储系统。所有的存储系统在数据量过大的情况下都会面临存储瓶颈，包括MySQL，RabbitMQ等等。这里要解决两个问题：首先作为一个内存的KV系统，redis服务肯定不是无限制的使用内存，应该设置一个上限（max_memory）。第二个，数据应该有过期属性，这样就能清除不再使用的key。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis事务</title>
    <link href="/2023/02/22/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E4%BA%8B%E5%8A%A1/"/>
    <url>/2023/02/22/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="1-为什么要用事务"><a href="#1-为什么要用事务" class="headerlink" title="1 为什么要用事务"></a>1 为什么要用事务</h2><p>Redis的单个命令是原子性的（比如get set mget mset），要么成功要么失败，不存在并发干扰的问题。如果涉及到多个命令的时候，需要把多个命令作为一个不可分割的处理序列，就必须要依赖redis的功能特性来实现了。</p><p>Redis提供了事务的功能，可以把一组命令一起执行。Redis的事务有3个特点：</p><ol><li><p>按进入队列的顺序执行。</p></li><li><p>不会受到其他客户端的请求的影响</p></li><li><p>事务不能嵌套，多个multi命令效果一样</p></li></ol><h2 id="2-事务的用法"><a href="#2-事务的用法" class="headerlink" title="2  事务的用法"></a>2  事务的用法</h2><p>Redis的事务涉及到四个命令：multi（开启事务），exec（执行事务），discard（取消事务），watch（监视）</p><p>案例场景：tom和mic各有1000元，tom向mic转账100元。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> tom <span class="hljs-comment">1000</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">mic 1000</span><br>multi<br>decrby <span class="hljs-comment">tom 100</span><br>incrby <span class="hljs-comment">mic 100</span><br>exec<br>get <span class="hljs-comment">tom</span><br>get <span class="hljs-comment">mic</span><br></code></pre></td></tr></table></figure><p>通过multi命令开启事务。Multi执行后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即执行，而是被放到一个队列中。当exec命令被调用时，所有队列中的命令才会被执行。如果没有执行exec，所有的命令都不会被执行。如果中途不想执行事务了，可以调用discard可以清空事务队列，放弃执行。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">multi </span><br>decrby tom <span class="hljs-number">100</span><br><span class="hljs-keyword">discard</span><br><span class="hljs-keyword"></span>get tom<br></code></pre></td></tr></table></figure><h2 id="3-Watch命令"><a href="#3-Watch命令" class="headerlink" title="3  Watch命令"></a>3  Watch命令</h2><p>为了防止事务过程中某个key‘的值被其他客户端请求修改，在Redis中还提供那个了一个watch命令。也就是多个客户端更新变量的时候，会跟原值做比较，只有它没有被其他线程修改的情况下，才更新成新的值。它可以为Redis事务提供CAS乐观锁行为。</p><p>可以一个用watch监视一个或者多个key，如果开启事务之后，至少一个被监视key键在exec执行之前被修改了，那么整个事务都会被取消（key提前过期除外）。可以用unwatch取消。</p><table><thead><tr><th>client 1</th><th>client 2</th></tr></thead><tbody><tr><td>set balance 1000 <br />watch balance <br />multi <br />incrby balance 100</td><td></td></tr><tr><td></td><td>decrby balance 100</td></tr><tr><td>exec [返回null] <br />get balance</td><td></td></tr></tbody></table><h2 id="4-事务可能遇到的问题"><a href="#4-事务可能遇到的问题" class="headerlink" title="4 事务可能遇到的问题"></a>4 事务可能遇到的问题</h2><h3 id="4-1-在执行exec之前发生错误"><a href="#4-1-在执行exec之前发生错误" class="headerlink" title="4.1 在执行exec之前发生错误"></a>4.1 在执行exec之前发生错误</h3><p>比如：入队的命令存在语法错误，包括参数数量，参数名称等等（编译器错误）。事务会被拒绝执行，也就是队列中所有的明林都不会得到执行。</p><h3 id="4-2-在执行exec之后发生错误"><a href="#4-2-在执行exec之后发生错误" class="headerlink" title="4.2 在执行exec之后发生错误"></a>4.2 在执行exec之后发生错误</h3><p>比如String使用了hash的命令，参数个数正确，但是数据类型错误，这是一种运行时错误。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gams">flushall<br>multi<br><span class="hljs-keyword">set</span> k1 <span class="hljs-comment">1</span><br>hset <span class="hljs-comment">k1 a b</span><br>exec<br>1) OK<br>2) (error) WRONGTYPE <span class="hljs-comment">Operation againest a key holding the wrong kind of value</span> <br>get <span class="hljs-comment">k1</span><br></code></pre></td></tr></table></figure><p>最后发现set k1 1的命令是成功的，也就是在这种发生了运行时异常的情况下，只有错误的命令没有被执行，但是其他命令没有收到影响。这个显然不符合对原子性的定义，也就是没办法用redis的这种事务机制来实现原子性，保证数据的一致。</p><h3 id="4-3-为什么不回滚？"><a href="#4-3-为什么不回滚？" class="headerlink" title="4.3 为什么不回滚？"></a>4.3 为什么不回滚？</h3><p>官方的解释是这样的：</p><ol><li><p>redis命令只会因为错误的语法而失败，也就是说，从实用性的角度来说，失败的命令是由代码错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</p></li><li><p>因为不需要对回滚进行支持，所以redis的内部可以保持简单且快速。需要知道的是：回滚不能够解决代码问题。</p></li></ol><p>Redis从2.6版本开始引入了Lua脚本，也就是说redis可以用lua来执行redis命令。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot启动流程</title>
    <link href="/2023/02/21/spring%E6%A1%86%E6%9E%B6/springboot/springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/02/21/spring%E6%A1%86%E6%9E%B6/springboot/springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-启动方式"><a href="#1-启动方式" class="headerlink" title="1. 启动方式"></a>1. 启动方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-comment">//方式一</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Application.class, args);<br>    &#125;<br>    <span class="hljs-comment">//方式二</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SpringApplication</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplication</span>(MySpringConfiguration.class);<br>        app.run(args);<br>    &#125;<br>    <span class="hljs-comment">//方式三</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplicationBuilder</span>()<br>            .sources(Parent.class)<br>            .child(Application.class)<br>            .run(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-启动流程概览"><a href="#2-启动流程概览" class="headerlink" title="2. 启动流程概览"></a>2. 启动流程概览</h2><p><img src="/image/springboot/springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.jpg"></p><h2 id="3-启动流程详解"><a href="#3-启动流程详解" class="headerlink" title="3. 启动流程详解"></a>3. 启动流程详解</h2><h3 id="3-1-new-Application初始化"><a href="#3-1-new-Application初始化" class="headerlink" title="3.1 new Application初始化"></a>3.1 new Application初始化</h3><h4 id="3-1-1-initializers初始化器"><a href="#3-1-1-initializers初始化器" class="headerlink" title="3.1.1 initializers初始化器"></a>3.1.1 initializers初始化器</h4><p>​    SPI方式设置初始化器initializers：this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));</p><p>​    扩展：自定义初始化器，在spring容器启动前执行，实现ApplicationContextInitializer接口，实现方法，在spring.factories中加入org.springframework.context.ApplicationContextInitializer=初始化器类全路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//springboot源码</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApplicationContextInitializer</span>&lt;C <span class="hljs-keyword">extends</span><br><span class="hljs-title class_">ConfigurableApplicationContext</span>&gt; &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Initialize the given application context.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> applicationContext the application to configure</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(C applicationContext)</span>;<br>&#125;<br><br><span class="hljs-comment">//自定义初始化器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextInitializer</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;自定义初始化器执行...&quot;</span>);<br><span class="hljs-type">ConfigurableEnvironment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> applicationContext.getEnvironment();<br><span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;jack&quot;</span>);<br>environment.getPropertySources().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MapPropertySource</span>(<span class="hljs-string">&quot;myInitializer&quot;</span>,map));<br>System.out.println(<span class="hljs-string">&quot;myInitializer execute, and add some property&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//通过SPI机制将自定义初始化器交给list集合initializers</span><br>org.springframework.context.ApplicationContextInitializer=com.intializer.MyInitializer<br></code></pre></td></tr></table></figure><p>初始化器的回调 SpringApplication#run()-&gt;prepareContext(..)–&gt;applyInitializers(context)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">applyInitializers</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> &#123;<br><span class="hljs-keyword">for</span> (ApplicationContextInitializer initializer : getInitializers()) &#123;<br>Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),ApplicationContextInitializer.class);<br>Assert.isInstanceOf(requiredType, context, <span class="hljs-string">&quot;Unable to call initializer.&quot;</span>);<br>initializer.initialize(context);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/springboot/1.png"></p><h4 id="3-1-2-listeners监听器"><a href="#3-1-2-listeners监听器" class="headerlink" title="3.1.2 listeners监听器"></a>3.1.2 listeners监听器</h4><p><img src="/image/springboot/2.png"></p><p>SPI方式设置监听器listeners：this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));</p><p>​    扩展：自定义监听器(starting-servlet启动前执行 or started-servlet启动后执行)，在spring容器启动前(后)执行，实现ApplicationListener接口，实现方法，在spring.factories中加入org.springframework.context.ApplicationListener=初始化器类全路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义监听器</span><br><span class="hljs-comment">//容器启动前调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStartingListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;ApplicationStartingEvent&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ApplicationStartingEvent event)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;myStartingListener 容器正在启动...&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">//容器启动完成调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStartedListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;ApplicationStartedEvent&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ApplicationStartedEvent event)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;myStartedListener 容器启动完成...&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//通过SPI机制将自定义初始化器交给list集合listeners</span><br>org.springframework.context.ApplicationListener=\<br>com.jack.springbootmybatis.listener.MyStartingListener,\<br>com.jack.springbootmybatis.listener.MyStartedListener<br></code></pre></td></tr></table></figure><p><img src="/image/springboot/3.png"></p><h3 id="3-2-run方法"><a href="#3-2-run方法" class="headerlink" title="3.2 run方法"></a>3.2 run方法</h3><ol><li><p>获取监听器，并启动starting类型的监听器</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SpringApplicationRunListeners</span> <span class="hljs-variable">listeners</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getRunListeners(args);<br>listeners.starting(bootstrapContext, <span class="hljs-built_in">this</span>.mainApplicationClass);<br></code></pre></td></tr></table></figure></li><li><p>准备Environment，和配置中心扩展有关</p></li><li><p>打印Banner；自定义Banner，有txt和image两种方式，在resources目录下创建一个banner.txt的文件就可以自定义banner效果</p></li><li><p>确定context类型：context = createApplicationContext()</p></li><li><p>prepareContext，执行初始化器initializers</p></li><li><p><strong>refreshContext(context) -&gt;AbstractApplicationContext#refresh()：创建tomcat容器；创建bean工厂；实例化bean</strong></p></li></ol><p>（1）this.prepareRefresh();上下文刷新前的准备工作：启动日期，设置context的当前状态，初始化属性和环境</p><p>（2）获取beanFantory工厂：obtainFreshFactory</p><p>（3）准备beanFactory工厂，配置一些标准的特性，比如上下文类加载器和后置处理器等</p><p>（4）postProcessBeanFactory(beanFactory)：处理一些web相关的bean以及作用域，比如：request和session等</p><p>（5）invokeBeanFactoryPostProcessors(beanFactory)：执行BeanFactory的后置处理器，解析@Configuration，生成BeanDefinition</p><p>​    扩展：自定义BeanFactoryPostProcessor：实现BeanFactoryPostProcessor，添加@Component注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义BeanFactoryPostProcessor</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JackBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactorybeanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>Arrays.asList(beanFactory.getBeanDefinitionNames()).forEach(beanDefinitionName -&gt;<br>System.out.println(beanDefinitionName));<br>System.out.println(<span class="hljs-string">&quot;JackBeanFactoryPostProcessor...&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>（6）registerBeanPostProcessors(beanFactory)：向BeanFactory中注册bean的postprocessor，用于后续bean创建的拦截操作，应用场景AOP</p><p>​    扩展：自定义BeanPostProcessor：实现BeanPostProcessor，添加@Component</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义BeanPostProcessor</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JackBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><span class="hljs-keyword">if</span>(beanName.equals(<span class="hljs-string">&quot;userController&quot;</span>))&#123;<br>System.out.println(<span class="hljs-string">&quot;找到了userController: &quot;</span>+bean);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（7）initMessageSource国际化</p><p>（8）initApplicationEventMulticaster：初始化一些广播器，用于发布事件</p><p>（9）<strong>onRefresh：初始化context子类上下文中的其他特别bean，创建tomcat容器等</strong></p><p>（10）finishBeanFactoryInitialization(beanFactory)：bean的初始化并加入beanFactory中</p><p>​    1-beanFactory.preInstantiateSingletons() </p><p>​    2-获取到所有BeanDefinition的名称 List beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames) </p><p>​    3-判断当前的bean是否为factorybean if (isFactoryBean(beanName)) </p><p>​    4-来到else部分的getBean(beanName)方法</p><p>​    5-判断是否可以从缓存中获取到bean或者父容器中获取：getSingleton(beanName)以及 getParentBeanFactory()</p><p>​    6-getSingleton(String beanName,Object Factory singleFactory)，调用singleFactory#getObject 方法时，会来到其实现类createBean(beanName,mbd,args)</p><p>​    7-AbstractAutowireCapableBeanFactory#doCreateBean()</p><p>​    8-选择无参构造函数创建Bean：</p><ol start="7"><li><p>执行runners</p><p> 扩展：自定义runner，在spring容器启动前执行，实现ApplicationRunner接口，实现方法，添加通过@Component注解</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义Runner</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplicationRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationRunner</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>System.out.println(<span class="hljs-string">&quot;MyApplicationRunner...&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/springboot/4.png"></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>Springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis入门</title>
    <link href="/2023/02/17/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%85%A5%E9%97%A8/"/>
    <url>/2023/02/17/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-redis定位与特性"><a href="#1-redis定位与特性" class="headerlink" title="1 redis定位与特性"></a>1 redis定位与特性</h2><h3 id="1-1-SQL与NoSQL"><a href="#1-1-SQL与NoSQL" class="headerlink" title="1.1 SQL与NoSQL"></a>1.1 SQL与NoSQL</h3><p>​    大部分时候，我们都会首先考虑用关系型数据库来存储我们的数据，比如SQLServer，Oracle，MySQL 等等。关系型数据库的特点：</p><p>​    1.它以表格的形式，基于行存储数据，是一个二维的模式。</p><p>​    2.它存储的是结构化的数据，数据存储有固定的模式（scheme），数据需要适应表结构。</p><p>​    3.表与表之间存在关联（Reletionship）。</p><p>​    4.大部分关系型数据库都支持SQL（结构化查询语句）的操作，支持复杂的关联查询。</p><p>​    5.通过支持事务（ACID）来提供严格或者实时的数据一致性。</p><p>​    但是使用关系型数据库也存在一些限制，比如：</p><p>​    1.要实现扩容的话，只能向上（垂直）扩展，比如磁盘限制了数据的存储，就要扩大磁盘容量，通过堆硬件的方式，不支持动态的扩缩容。水平扩容需要复杂的技术来实现，比如分库分表。</p><p>​    2.表结构修改困难，因此存储的数据格式也收到限制。</p><p>​    3.在高并发和高数据量的情况下，关系型数据库通常会把数据持久化到磁盘，基于磁盘的读写压力比较大。</p><p>​    为了规避关系型数据库的一系列问题，就有了非关系型的数据库，一般把它叫做“non-relational”或者“Not Only SQL”。NoSQL 最开始是不提供SQL 的数据库的意思，但是后来意思慢慢地发生了变化。</p><p>​    非关系型数据库的特点：</p><p>​    1、存储非结构化的数据，比如文本、图片、音频、视频。</p><p>​    2、表与表之间没有关联，可扩展性强。</p><p>​    3、保证数据的最终一致性。遵循BASE（碱）理论。Basically Available（基本可用）； Soft-state（软状态）； Eventually Consistent（最终一致性）。</p><p>​    4、支持海量数据的存储和高并发的高效读写。</p><p>​    5、支持分布式，能够对数据进行分片存储，扩缩容简单。</p><p>​    对于不同的存储类型，又有各种各样的非关系型数据库，比如有几种常见的类型：</p><p>​    1 、KV 存储， 用Key Value 的形式来存储数据。比较常见的有Redis 和MemcacheDB。</p><p>​    2、文档存储，MongoDB。</p><p>​    3、列存储，HBase。</p><p>​    4、图存储，这个图（Graph）是数据结构，不是文件格式。Neo4j。</p><p>​    5、对象存储。</p><p>​    6、XML 存储等等等等。</p><p>​    这个列举了各种各样的NoSQL 数据库<a href="http://nosql-database.org/">http://nosql-database.org/</a> 。NewSQL 结合了SQL 和NoSQL 的特性（例如PingCAP 的TiDB）。</p><h3 id="1-2Redis特性"><a href="#1-2Redis特性" class="headerlink" title="1.2Redis特性"></a>1.2Redis特性</h3><p>​    官网介绍：<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a></p><p>​    中文网站：<a href="http://www.redis.cn/">http://www.redis.cn</a> </p><p>​    硬件层面有CPU 的缓存；浏览器也有缓存；手机的应用也有缓存。把数据缓存起来的原因就是从原始位置取数据的代价太大了，放在一个临时位置存储起来，取回就可以快一些。</p><p>​    1.为什么要把数据放在内存中？</p><p>​    1）内存的速度快，10w QPS</p><p>​    2）减少计算的时间，减轻数据库的压力</p><p>​    2.如果是用内存的数据结构作为缓存，为什么不用HashMap或者Memcached？</p><p>​    1）更丰富的数据类型</p><p>​    2）进程内与跨进程；单机与分布式</p><p>​    3）功能丰富：持久化机制、内存淘汰策略，事务，发布订阅，pipeline，lua</p><p>​    4）支持多种编程语言</p><p>​    5）高可用，集群</p><p>注：Memcached只能存储KV，没有持久化机制，不支持主从复制，是多线程的。</p><h2 id="2-redis安装启动"><a href="#2-redis安装启动" class="headerlink" title="2 redis安装启动"></a>2 redis安装启动</h2><h3 id="2-1-服务端安装"><a href="#2-1-服务端安装" class="headerlink" title="2.1 服务端安装"></a>2.1 服务端安装</h3><p>1、Linux 安装</p><p>​    CentOS7 安装Redis 单实例<a href="https://gper.club/articles/7e7e7f7ff7g5egc4g6b">https://gper.club/articles/7e7e7f7ff7g5egc4g6b</a></p><p>​    Docker 安装Redis<a href="https://gper.club/articles/7e7e7f7ff7g5egc5g6c">https://gper.club/articles/7e7e7f7ff7g5egc5g6c</a></p><p>  主要是注意配置文件几处关键内容（后台启动、绑定IP、密码）的修改，配置别名</p><p>2、Windows 服务端安装</p><p>​    自行百度</p><h3 id="2-2-服务启动"><a href="#2-2-服务启动" class="headerlink" title="2.2 服务启动"></a>2.2 服务启动</h3><p>​    src 目录下，直接启动   ./redis-server</p><p>​    后台启动（指定配置文件）1、redis.conf -&gt;修改两行配置daemonize yes ；bind 0.0.0.0</p><p>​                         2、启动Redis -&gt; redis-server /usr/local/soft/redis-5.0.5/redis.conf</p><p>​    总结：redis 的参数可以通过三种方式配置，一种是redis.conf，一种是启动时–携带的参数，一种是config set。</p><h3 id="2-3-基本操作"><a href="#2-3-基本操作" class="headerlink" title="2.3 基本操作"></a>2.3 基本操作</h3><p>​    Redist默认有16个库（0-15）.可以在配置文件redis.conf中修改   database 16</p><p>​    因为没有完全隔离，不像数据库的database，不适合把不同的库分配给不同的业务使用。默认使用第一个库db0。在集群中只能使用第一个db。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">select 0;   <span class="hljs-comment">#切换数据库</span><br>flushdb;    <span class="hljs-comment">#清空当前数据库</span><br>flushall;   <span class="hljs-comment">#清空所有数据库</span><br></code></pre></td></tr></table></figure><p>​    Redis的存储叫做key-value存储，或者叫做字典结构。key的最大长度限制是512M，值得限制不同，有的是用长度限制，有的是用个数限制。先从key的基本操作入手。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">set</span> qs 2673   <span class="hljs-comment">#存值</span><br>get qs        <span class="hljs-comment">#取值</span><br>keys *        <span class="hljs-comment">#查看所有键</span><br>dbsize        <span class="hljs-comment">#获取键总数(生产环境数据量大，慎用)</span><br>exists qs     <span class="hljs-comment">#查看键是否存在</span><br>del qs hh     <span class="hljs-comment">#删除键</span><br>rename qs pyy <span class="hljs-comment">#重命名键</span><br><span class="hljs-built_in">type</span> qs       <span class="hljs-comment">#获取数据类型</span><br></code></pre></td></tr></table></figure><h2 id="3-redis基本数据类型"><a href="#3-redis基本数据类型" class="headerlink" title="3 redis基本数据类型"></a>3 redis基本数据类型</h2><h3 id="3-1-String字符串"><a href="#3-1-String字符串" class="headerlink" title="3.1 String字符串"></a>3.1 String字符串</h3><p><strong>存储类型</strong>  </p><p>​    可以用来存储INT（整数），float（单精度浮点数），String（字符串）</p><p><strong>操作命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh">getrange qs 0 1                        <span class="hljs-comment">#获取指定范围的字符</span><br>strlen                                 <span class="hljs-comment">#获取值长度</span><br>append qs good                         <span class="hljs-comment">#字符串追加内容</span><br>mset qs 888 hh 666                     <span class="hljs-comment">#设置多个值(批量操作，原子性)</span><br>mget qs hh                             <span class="hljs-comment">#获取多个值</span><br>setnx qs pyy                           <span class="hljs-comment">#设置值，如果key存在，则不成功</span><br><span class="hljs-comment">#基于此可实现分布式锁，用del key释放锁</span><br><span class="hljs-comment">#但如果释放锁的操作失败了，导致其他节点永远获取不到锁，怎么办？</span><br><span class="hljs-comment">#加过期时间，单独用expire加过期，也失败了。无法保证原子性，怎么办？多参数</span><br><span class="hljs-built_in">set</span> key value [expriation EX seconds|PX milliseconds][NX|XX]<br><span class="hljs-built_in">set</span> k1 v1 EX 10 NX                     <span class="hljs-comment">#使用参数的方式</span><br>incr qs                                <br>incrby qs 100                          <span class="hljs-comment">#(整数)值递增(值不存在会得到1)</span><br>decr qs<br>decrby qs 100                          <span class="hljs-comment">#(整数)值递减</span><br><span class="hljs-built_in">set</span> mf 2.6<br>incrbyfloat mf 7.3                     <span class="hljs-comment">#浮点数增量</span><br></code></pre></td></tr></table></figure><p><strong>存储实现原理</strong></p><p><em>1.数据模型</em></p><p>​    Redis是KV的数据库，Key-value一般会用哈希表来存储它。Redis的最外层是通过hashtable实现的（把这个叫做外层的哈希）。在redis里面。这个哈希表怎样实现呢？看一下C语言的源码（dict.h 47行），每一个键值对都是一个dictEntry（怪不得叫远程字典服务）,通过指针指向key的存储结构和value的存储结构，而且next 存储了指向下一个键值对的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span>&#123;</span><br>    <span class="hljs-type">void</span> *key; <span class="hljs-comment">//key关键字定义</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">void</span> *val; <span class="hljs-comment">//value定义</span><br>        <span class="hljs-type">uint64_t</span> u64;<br>        <span class="hljs-type">int64_t</span> s64;<br>        <span class="hljs-type">double</span> d;<br>    &#125; v;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dicEntry</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">//只向下一个键值对节点</span><br>&#125; dictEntry;<br></code></pre></td></tr></table></figure><p>实际上最外层是redisDb，redisDb里面放的是dict。源码server.h 661行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span>&#123;</span><br>    dict *dict; <span class="hljs-comment">//所有的键值对</span><br>    dict *expires; <span class="hljs-comment">//设置了过期时间的键值对</span><br>    dict *blocking_keys; <span class="hljs-comment">//Keys with clients waiting for data(BLOPOP)</span><br>    dict *ready_keys; <span class="hljs-comment">//Blocked keys that received a PUSH</span><br>    dict *watched_keys; <span class="hljs-comment">//WATCHED keys for MULTI/EXEC CAS</span><br>    <span class="hljs-type">int</span> id; <span class="hljs-comment">//Database ID</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> avg_ttl; <span class="hljs-comment">//Average TTL, just for stats</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> expires_cursor; <span class="hljs-comment">//Cursor of the active expore cycle</span><br>    <span class="hljs-built_in">list</span> *defrag_later; <span class="hljs-comment">// List of key names to attempt to defrag one by one, gradully</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以set hello world为例，因为key是字符串，Redis自己实现了一个字符串类型，叫做SDS，所以hello指向一个SDS的结构。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/1.png"></p><p>​    value是world，同样是一个字符串，当value存储一个字符串时，Redis并没有直接使用SDS存储，而是存储在redisObject中，实际上五种常用的数据类型的任何一种value，都是通过redisObject来存储的。最终redisObject再通过一个指针指向实际的数据结构，比如字符串或者其他。来看一下redisObject怎么定义的：redisObject：源码src/server.h 622行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C">typdef <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span>&#123;</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>; <span class="hljs-comment">//对象的类型，包括：OBJ_STRING,OBJ_LIST,OBJ_HASH,OBJ_SET,OBJ_ZSET</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>; <span class="hljs-comment">//具体的数据结构</span><br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS; <span class="hljs-comment">//24位，对象最后一次被命令程序访问的时间，与内存回收有关</span><br>    <span class="hljs-type">int</span> refcount; <span class="hljs-comment">//引用计数，当refcount为0的时候，表示该对象已经不被任何对象引用，则可以进行回收</span><br>    <span class="hljs-type">void</span> *ptr; <span class="hljs-comment">//只向对象实际的数据结构</span><br>&#125;<br></code></pre></td></tr></table></figure><p>用type命令看到的类型就是type的内容。</p><p>为什么一个value会有一种对外的类型，还有一种实际的编码呢？我们刚才说字符串会用SDS存储，那这个redisObject的value就会指向一个SDS：</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/2.png"></p><p>2.内部编码</p><p>用的String的命令，但是出现了三种不同的编码。这三种编码有什么区别？</p><p>​    （1）int，存储8个字节的长整型（long， 2^63-1）</p><p>​    （2）embstr，代表embstr格式的SDS，存储小于44个字节的字符串</p><p>​    （3）raw，存储大于44个字节的字符串</p><p><em>问题1，SDS是什么？</em></p><p>Redis中字符串的实现，Simple Dynamic String简单动态字符串。源码：sds.h 47行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">attribute_</span> ((_<span class="hljs-title">packed_</span>)) <span class="hljs-title">sdshdr8</span>&#123;</span><br>    <span class="hljs-type">uint8_t</span> len; <span class="hljs-comment">//当前字符数组的长度</span><br>    <span class="hljs-type">uint8_t</span> alloc; <span class="hljs-comment">//当前字符数组总共分配的内存大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">//当前字符数组的属性，用来标识到底是sdshdr8还是sdshdr16等</span><br>    <span class="hljs-type">char</span> buf[]; <span class="hljs-comment">//字符串真正的值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    本质上其实还是字符数组。SDS又有多种结构（sds.h）：sdshdr5，sdshdr8，sdshdr32，sdshdr32，sdshdr64，用于存储不同长度的字符串，分贝代表2^5=32byte，2^8=256byte, 2^16=65536byte=64KB, 2^32byte=4GB。</p><p><em>问题2：为什么Redis要用SDS是实现字符串？</em></p><p>​    因为C语言本身没有字符串类型，只能用字符串数组char[]实现。</p><p>​    （1）使用字符串数组必须先给目标变量分配足够的空间，否则可能会溢出</p><p>​    （2）如果要获取字符长度，必须遍历字符数组，时间复杂度是O(n)</p><p>​    （3）C字符长度的变更会对字符数组做内存重分配</p><p>​    （4）通过从字符串开始到结尾碰到的第一个‘\0’来标记字符串的结束，因此不能保存图片，音频，视频，压缩文件等二进制（bytes）保存的内容，二进制不安全。</p><p>SDS的特点：</p><p>​    1.不用担心内存溢出问题，如果需要会对SDS进行扩容</p><p>​    2.获取字符串长度时间复杂度为O(1)，因为定义了len属性</p><p>​    3.通过“空间预分配”（sdsMakeRoonFor）和“惰性空间释放”，防止多次重分配内存</p><p>​    4.判断是否结束的标志是len属性，可以包含‘\0‘（它同样以’\0’结尾是因为这样就可以使用C语言中函数库操作字符串的函数了）</p><table><thead><tr><th>C字符数组</th><th>SDS</th></tr></thead><tbody><tr><td>获取字符串长度的复杂度为O(N)</td><td>获取字符串长度的复杂度为O(1)</td></tr><tr><td>API是不安全的，可能会造成缓冲区溢出</td><td>API是安全的，不会造成缓冲区溢出</td></tr><tr><td>修改字符串长度N次必然需要执行N次内存重分配</td><td>修改字符串长度N次最多需要执行N次内存重分配</td></tr><tr><td>只能保存文本数据</td><td>可以保存文本或者二进制数据</td></tr><tr><td>可以使用所有&lt;string.h&gt;库中的函数</td><td>可以使用一部分&lt;string.h&gt;库中的函数</td></tr></tbody></table><p><em>问题3：embstr和raw编码的区别？为什么要为不同大小设计不同编码？</em></p><p>​    embstr的使用值分配一次内存空间（因为RedisObject和SDS是连续的），而raw需要分配两次内存空间（分别为RedisObject和SDS分配空间）。embstr的好处在于创建时少分配一次空间，删除时少释放一次空间，以及对象的所有数据连在一起，寻找方便。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/3.png"></p><p>​    而embstr的坏处也很明显，如果字符串的长度增加需要重新分配内存时，整个RedisObject和SDS都需要重新分配空间，因此Redis中的embstr实现为只读（这种编码的内容是不能修改的）。</p><p><em>问题4：int和embstr什么时候转化为raw？</em></p><ol><li><p>int数据不再是整数——raw</p></li><li><p>int大小超过了long的范围(2^63-1)——embstr</p></li><li><p>embstr长度超过了44个字节——raw</p></li></ol><p><em>明明没有超过44个字节，为什么变成raw了？</em></p><p>​    对于embstr，由于它的实现是只读的，因此在对embstr对象进行修改时，都会先转化为raw再进行修改。因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了44个字节。</p><p><em>问题5：当长度小于阈值时，会还原吗？</em></p><p>​    关于Redis内部编码的转换，都符合一下规律：编码转换在Redis写入数据时完成，且转换过程不可逆转，只能从小内存编码向大内存编码转换。</p><p><em>问题6：为什么要对底层的数据结构使用redisObject进行一层包装呢？</em></p><p>​    其实无论是设计redisObject，还是对存储字符设计这么多的SDS，都是为了根据存储的不同内容选择不同的存储方式，这样可以实现尽量地节省内存空间和提升查询速度的目的。</p><p><strong>应用场景</strong></p><p><em>1.缓存</em></p><p>​    String类型，缓存热点数据。例如明星出轨，网站首页，报表数据等等。可以显著提升热点数据的访问速度。</p><p><em>2.分布式数据共享</em></p><p>​    String类型，因为Redis是分布式的独立服务，可以在多个应用之间共享</p><p><em>3.分布式锁</em></p><p>​    String类型的setnx方法，只有不存在时才能添加成功，返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">getLock</span><span class="hljs-params">(Object lockObject)</span>&#123;<br>    jedisUtil = getJedisConnection();<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> jedisUtil.setNx(lockObject, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(flag)&#123;<br>        expire(lockObject, <span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> falg;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseLock</span><span class="hljs-params">(Object lockObject)</span>&#123;<br>    del(lockObject);<br>&#125;<br></code></pre></td></tr></table></figure><p><em>4.全局ID</em></p><p>​    INT类型，INCRBY，利用原子性（分库分表的场景，一次性拿一段）</p><p><em>5.计数器</em></p><p>INT类型，INCR方法。例如：文章的阅读量，微博点赞数，允许一定的延迟，先写入Redis再定时同步到数据库</p><p><em>6. 限流</em></p><p>INT类型，INCR方法。以访问者的IP和其他信息作为key，访问一次再增加一次计数，超过次数则返回false。</p><h3 id="3-2-Hash哈希"><a href="#3-2-Hash哈希" class="headerlink" title="3.2 Hash哈希"></a>3.2 Hash哈希</h3><p><strong>存储类型</strong></p><p>​    Hash用来存储多个无序的键值对。最大存储数量2^32-1（40亿左右）。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/4.png"></p><p>注意：前面说Redis所有的KV本身就是键值对，用dictEntry实现的，叫做外层的哈希，现在我们讲的是内层的哈希。</p><p>注意：Hash的value只能是字符串，不能是嵌套其他类型，比如hash或者list。</p><p>同样是存储字符串，Hash和String的主要区别?</p><ol><li><p>把所有相关的值聚集到一个key中，节省内存空间</p></li><li><p>只使用一个key，减少key中途</p></li><li><p>当需要批量获取值的时候，只需要使用一个命令，减少内存IO/CPU的消耗</p></li></ol><p>Hash不适合的场景：</p><ol><li><p>Field不能单独设置过期时间</p></li><li><p>需要考虑数据量分布的问题（field非常多的时候，无法分布到多个节点）</p></li></ol><p><strong>操作命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">hset h1 f 6;<br>hset h1 e 5;<br>hmset h1 a 1 b 2 c 3 d 4;<br>hget h1 a;<br>hmget h1 a b c;<br>hkeys h1;<br>hvals h1;<br>hgetall h1;<br>hdel h1 a;<br>hlen h1;<br></code></pre></td></tr></table></figure><p><strong>存储（实现）原理</strong></p><p>​    Redis的Hash本身也是一个KV结构，内层哈希底层可以使用两种数据结构实现：</p><p>​       （1）Ziplist: OBJ_ENCODING_ZIPLIST(压缩列表)</p><p>​       （2）Hashtable：OBJ_ENCODING_HT(哈希表)</p><p><em>1.ziplist压缩列表</em></p><p>​    ziplist是一个经过特殊编码的，由连续内存块组成的双向链表。它不存储指向上一个链表节点和指向下一个链表节点的指针，而是存储上一个节点长度和当前节点长度，这样读写可能会慢一些，因为你要去算长度，但是可以节省内存，是一种时间换空间的思想。</p><p>Ziplist的内部结构-源码ziplist.c第16行的注释：</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/5.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zlentry</span>&#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> privrawlensize; <span class="hljs-comment">//存储上一个链表节点的长度数值所需要的字节数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> prevrawlen; <span class="hljs-comment">//上一个链表节点占用的长度</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> lensize; <span class="hljs-comment">//存储当前链表节点长度数值所需要的字节数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len; <span class="hljs-comment">//当前链表节点占用的长度</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> headersize; <span class="hljs-comment">//当前链表节点的头部大小(privrawlensize + lensize)，即非数据域的大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> encoding; <span class="hljs-comment">//编码方式</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p; <span class="hljs-comment">//压缩链表以字符串的形式保存，该指针指向当前节点起始位置</span><br>&#125; zlentry;<br></code></pre></td></tr></table></figure><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/6.png"></p><p>编码类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIP_STR_06B(0&lt;&lt;6) <span class="hljs-comment">//长度小于等于63字节</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIP_STR_14B(1&lt;&lt;6) <span class="hljs-comment">//长度小于等于16383字节</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIP_STR_32B(2&lt;&lt;6) <span class="hljs-comment">//长度小于等于4294967295字节</span></span><br></code></pre></td></tr></table></figure><p><em>问题：什么时候使用ziplist存储？</em></p><p>当哈希对象同时满足一下两个条件的时候，使用ziplist编码：</p><p>1） 哈希对象保存的键值对数量&lt;512个</p><p>2） 所有的键值对的键和值的字符串长度都&lt;64byte（一个英文字母一个字节）</p><p>src/redis.conf配置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">hash-max-ziplist-value <span class="hljs-number">64</span> <span class="hljs-comment">//ziplist中最大能存放的值长度</span><br>hash-max-ziplist-entries <span class="hljs-number">512</span> <span class="hljs-comment">//ziplist中最多能存放的entry节点数量</span><br></code></pre></td></tr></table></figure><p>如果超过这两个阈值的任何一个，存储接后就会转换为hashtable。总结：字段个数少，字段值小，用ziplist。</p><p><em>2.hashtable（dict）</em></p><p>​    在redis中，hashtable被称为字典（dictionary）。前面我们知道了，Redis的KV结构是通过一个dictEntry来实现的。在hashtable中，又对dictEntry进行了多层的封装。源码位置Ldict.h 47行。首先有一个dictEntry：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span>&#123;</span><br>    <span class="hljs-type">void</span> *key; <span class="hljs-comment">//关键字定义</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">void</span> *val; <span class="hljs-comment">//value定义</span><br>        <span class="hljs-type">uint64_t</span> u64;<br>        <span class="hljs-type">int64_t</span> s64;<br>        <span class="hljs-type">double</span> d;<br>    &#125; v;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">//只向下一个键值对节点</span><br>&#125; dictEntry；<br></code></pre></td></tr></table></figure><p>dictEntry放到了dictht（hashtable里面）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span>&#123;</span><br>    dictEntry **table; <span class="hljs-comment">//哈希表数组</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size; <span class="hljs-comment">//哈希表大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask; <span class="hljs-comment">//掩码大小，用于计算索引值，总是等于size-1</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used; <span class="hljs-comment">//已有节点数</span><br>&#125; dictht;<br></code></pre></td></tr></table></figure><p>Ht放到了dict里面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>  &#123;</span><br>    dictType *type; <span class="hljs-comment">//字典类型</span><br>    <span class="hljs-type">void</span> *privdata; <span class="hljs-comment">//私有数据</span><br>    dictht ht[<span class="hljs-number">2</span>]; <span class="hljs-comment">//一个字典有两个哈希表</span><br>    <span class="hljs-type">long</span> rehashidx; <span class="hljs-comment">//rehash索引</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> iterators; <span class="hljs-comment">//当前正在使用的迭代器数量</span><br>&#125; dict;<br></code></pre></td></tr></table></figure><p>从最底层到最高层dictEntry——dictht——dict。它是一个数组+链表的结构，展开一下，哈希的整体存储结构：</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/7.png"></p><p>​    注意：dictht后面是null说明第二个ht还没有用到。DictEntry*后面是Null说明没有hash到这个地址。DictEntry后面是NULL说明没有发生哈希冲突。</p><p><em>问题：为什么要定义两个哈希表，其中一个不同呢？</em></p><p>Redis的哈希默认使用的是ht[0]，ht[1]不会初始化和分配空间。哈希表dictht是用链地址法来解决碰撞问题的。在这种情况下，哈希表的性能取决于它的大小（size属性）和它锁保存的节点的数量（used属性）之间的比率：</p><p>*比率在1：1时（一个哈希表ht只储一个节点entry）哈希表的性能最好。</p><p>*如果节点数量比哈希表的大小要大很多的话（这个比率用ratio表示，5标识平均一个ht存储5个entry），那么哈希表就会退化成多个链表，哈希表本身的性能优势就不再存在。</p><p>如果单个哈希表的节点数量过多，哈希表的大小需要扩容。Redis里面的这种操作叫做rehash。步骤：</p><ol><li><p>为字符ht[1]哈希表分配空间，ht[1]的大小为第一个大于等于ht[0].used*2的2的N次方幂。比如已经使用了10000，那就是16384.</p></li><li><p>将所有的ht[0]上的节点rehash到ht[1]上，重新计算hash值和索引，然后放入指定的位置。</p></li><li><p>当ht[0]全部迁移到了ht[1]之后，释放ht[0]的空间，将ht[1]设置为ht[0]表，并创建新的ht[1]，为下次rehash做准备。</p></li></ol><p><em>问题：什么时候触发扩容？</em></p><p>负载因子（源码dict.c）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> dict_can_resize = <span class="hljs-number">1</span>; <span class="hljs-comment">//是否需要扩容</span><br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> dict_force_resize_ratio = <span class="hljs-number">5</span>; <span class="hljs-comment">//扩容因子</span><br></code></pre></td></tr></table></figure><p>总结一下，Redis的Hash类型，可以用ziplist和hashtables来实现。</p><p><strong>应用场景</strong></p><p><em>1. 跟String一样</em></p><p>String可以做的事情。Hash都可以做</p><p><em>2.存储对象类型的数据</em></p><p>比如对象或者一张表的数据，比String节省了更多key的空间，也更加便于集中管理。</p><h3 id="3-3-List列表"><a href="#3-3-List列表" class="headerlink" title="3.3 List列表"></a>3.3 List列表</h3><p><strong>存储类型</strong></p><p>存储有序的字符串（从左到右），元素可以重复。最大存储数量2^32-1（40亿左右）。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/8.png"></p><p><strong>操作命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#元素增减</span><br>lpush queue a;<br>lpush queue b c;<br>rpush queue d e;<br>lpop queue;<br>rpop queue;<br><span class="hljs-comment">#取值</span><br>lindex queue 0;<br>lrange queue 0 -1;<br></code></pre></td></tr></table></figure><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/9.png"></p><p><strong>存储（实现）原理</strong></p><p>​    在早期的版本中，数据量较小时用ziplist存储（特殊编码的双向链表），达到临界值时转换为linkedlist进行存储，分别对应OBJ_ENCODING_ZIPLIST和OBJ_ENCODING_LINKEDLIST。3.2版本之后，统一用quicklist来存储。quicklist存储了一个双向链表，每个节点都是一个ziplist，所以是ziplist和linkedlist的结合体。</p><p><strong>quicklist：</strong>总体结构：</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/10.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklist</span>&#123;</span><br>    quicklistNode *head; <span class="hljs-comment">//指向双向列表的表头</span><br>    quicklistNode *tail; <span class="hljs-comment">//指向双向列表的表尾</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> count; <span class="hljs-comment">//所有的ziplist中一共存了多少个元素</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len; <span class="hljs-comment">//双向列表的长度，node的数量</span><br>    <span class="hljs-type">int</span> fill : QL_FILL_BITS; <span class="hljs-comment">//ziplist最大大小，对应list-max-ziplist-size</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> compress: QL_COMP_BITS; <span class="hljs-comment">//压缩深度，对应list-compress-depth</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bookmark_count: QL_BM_BITS; <span class="hljs-comment">//4位，bookmarks数组的大小</span><br>    quicklistBookmark bookmarks[]; <span class="hljs-comment">//bookmarks是一个可选字段，quicklist重新分配内存空间时使用，不使用时不占用空间</span><br>&#125; quicklist；<br></code></pre></td></tr></table></figure><p>redis.conf相关参数：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>list-max-ziplist-size (fill)</td><td>正数表示单个ziplist最多所包含的entry个数<br />负数表示单个ziplist的大小，默认8K</td></tr><tr><td>list-compress-depth (compress)</td><td>压缩深度，默认为0。<br />1：首尾的ziplist不压缩；2：首尾第一第二个ziplist不压缩，以此类推</td></tr></tbody></table><p>quicklist.h 46行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">pre</span>;</span> <span class="hljs-comment">//指向前一个节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">//指向后一个节点</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zl; <span class="hljs-comment">//指向实际的ziplist</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz; <span class="hljs-comment">//当前ziplist占用多少字节</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count : <span class="hljs-number">16</span>; <span class="hljs-comment">//当前ziplist中存储了多少个元素，占16bit（下同），最大65536个</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> encoding : <span class="hljs-number">2</span>; <span class="hljs-comment">//是否采用了LZF压缩算法压缩节点，RAW == 1 or LZF == 2</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> container : <span class="hljs-number">2</span>; <span class="hljs-comment">//未来可能支持其他结构存储 NONE==1 or ziplist == 2</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> recompress : <span class="hljs-number">1</span>; <span class="hljs-comment">//当前ziplist是不是已经被解压出来作临时使用</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> attempted_compress: <span class="hljs-number">1</span>; <span class="hljs-comment">//测试用</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> extra : <span class="hljs-number">10</span>; <span class="hljs-comment">//预留给未来用</span><br>&#125; quicklistNode;<br></code></pre></td></tr></table></figure><p><strong>应用场景</strong></p><p>list主要用在存储有序内容的场景。</p><p>​    <em>1.列表</em></p><p>​    例如用户的消息列表，网站的公告列表，活动列表，博客的文章列表，评论列表等等。思路：存储所有字段，LRANGE取出一页，按顺序显示。</p><p><em>2.队列/栈</em></p><p>​    list还可以当作分布式环境的队列/栈使用。list提供了两个阻塞的弹出操作：BLPOP/BRPOP，可以设置超时时间（单位：秒）.</p><p>​    BLPOP：BLPOP key 1 timeout移出并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p><p>​    BRPOP：BRPOP key 1 timeout移出并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/11.png"></p><p>​    队列：先进先出：rpush blpop，左头右尾，有便进入队列，左边出队列。</p><p>​    栈：先进后出：rpush brpop</p><p>​    总结一下：List存储有序的内容，用quicklist实现，本质上是数组——链表。Hashtable也是数组+链表，只是内部编码结构不一样。</p><h3 id="3-4-Set集合"><a href="#3-4-Set集合" class="headerlink" title="3.4 Set集合"></a>3.4 Set集合</h3><p><strong>存储类型</strong></p><p>Set存储String类型的无序集合，最大存储数量2^32-1（40亿左右）。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/12.png"></p><p><strong>操作命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">sadd myset a b c d e f g  <span class="hljs-comment">#添加一个或者多个元素</span><br>smembers myset            <span class="hljs-comment">#获取多个元素</span><br>scard myset               <span class="hljs-comment">#统计元素个数</span><br>srandmember myset         <span class="hljs-comment">#随机获取一个元素</span><br>spop myset                <span class="hljs-comment">#随机弹出一个元素</span><br>srem myset d e f          <span class="hljs-comment">#移除一个或多个元素</span><br>sismember myset a         <span class="hljs-comment">#查看元素是否存在</span><br></code></pre></td></tr></table></figure><p><strong>存储（实现）原理</strong></p><p>Redis用inset或hashtable存储set。如果元素都是整数类型，就用inset存储。inset.h 35行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intset</span>&#123;</span><br>    <span class="hljs-type">uint32_t</span> encoding; <span class="hljs-comment">//编码类型</span><br>    <span class="hljs-type">uint32_t</span> length; <span class="hljs-comment">//长度</span><br>    <span class="hljs-type">int8_t</span> contents[]; <span class="hljs-comment">//用来存储成员的动态数组</span><br>&#125; intset；<br></code></pre></td></tr></table></figure><p>如果不是整数类型，就用hashtable（数组+链表的存储结构），如果元素超过512个，也会用hashtable存储，跟一个配置有关</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">set-max-intset-entries</span> <span class="hljs-string">512</span><br></code></pre></td></tr></table></figure><p>问题：set的key没有value，怎么用hashtable存储？value存null就好了。</p><p><strong>应用场景</strong></p><p>抽奖：随机获取元素：spop myset。点赞，签到，打卡。商品标签。商品筛选。用户关注，推荐模型</p><h3 id="3-5-ZSet有序集合"><a href="#3-5-ZSet有序集合" class="headerlink" title="3.5 ZSet有序集合"></a>3.5 ZSet有序集合</h3><p><strong>存储类型</strong></p><p>sorted set存储有序的元素。每个元素有个score，按照score从小到大排名。score相同时，按照key的ASCII码排序。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/13.png"></p><table><thead><tr><th>数据结构</th><th>是否允许存在重复元素</th><th>是否有序</th><th>与有序实现方式</th></tr></thead><tbody><tr><td>列表list</td><td>是</td><td>是</td><td>索引下标</td></tr><tr><td>集合set</td><td>否</td><td>否</td><td>无</td></tr><tr><td>有序集合zset</td><td>否</td><td>否</td><td>分值score</td></tr></tbody></table><p><strong>操作命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">zadd myzset 10 java 20 php 30 ruby 40 cpp 50 python <span class="hljs-comment">#添加元素</span><br>zrange myzset 0 -1 withscores                       <br>zrevrange myzset 0 -1 withscores                     <span class="hljs-comment">#获取全部元素</span><br>zrangebyscore myzset 20 30                           <span class="hljs-comment">#根据分值区间获取元素</span><br>zrem myzset php cpp                                  <span class="hljs-comment">#移除元素，亦可以根据score rank删除</span><br>zcard myzset                                         <span class="hljs-comment">#统计元素个数</span><br>zincrby myzset 5 python                              <span class="hljs-comment">#分值递增</span><br>zcount myzset 20 60                                  <span class="hljs-comment">#根据分值统计个数</span><br>zrank myzset python                                  <span class="hljs-comment">#获取元素rank</span><br>zscore myzset python                                 <span class="hljs-comment">#获取元素score</span><br></code></pre></td></tr></table></figure><p><strong>存储（实现）原理</strong></p><p>​    默认使用ziplist编码（第三次见到了，hash的小编码，quicklist的Node，都是ziplist）。在ziplist内部，按照score排序递增来存储，插入的时候要移动之后的数据。如果元素数量大于等于128个，或者任一member长度大于等于64字节使用skiplist+dict存储。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">zset-max-ziplist-entries</span> <span class="hljs-string">128</span><br><span class="hljs-attr">zset-max-ziplist-value</span> <span class="hljs-string">64</span><br></code></pre></td></tr></table></figure><p>​    <em>什么是skiplist（跳表）？</em></p><p>​    我们先来看一下有序链表：</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/14.png"></p><p>​    在这样一个链表中，如果我们要查找某个数据，那么需要从头开始逐个进行比较，直到找到包含数据的那个节点，或者找到第一个比给定数据大的节点为止。时间复杂度为O(n)。同样，当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置。二分查找只适用于有序数组，不适用于链表。</p><p>​    假如我们每相邻两个节点增加一个指针，让指针指向下个节点（或者理解为有三个元素进入了第二层）。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/15.png"></p><p>​    这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一般（上图中是7，19，26）</p><p>​    问题：是哪些元素运气这么好，进入到第二层？在插入一个数据的时候，决定要放到哪一层，取决于一个算法，源码：t_zset.c 122行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">zslRandomLevel</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">int</span> level = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>((random()&amp;<span class="hljs-number">0xFFFF</span>) &lt; (ZSKIPLIST_P*<span class="hljs-number">0xFFFF</span>))<br>        level += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL)?level:ZSKIPLIST_MAXLEVEL;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在当我们想查找数据的时候，可以先沿着这个新链表进行查找。当碰到比待查数据大的节点时，再到下一层进行查找。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/16.png"></p><p>​    比如，我们想查找23，查找的路径是沿着标红的指针所指向的方向进行的：</p><p>​    1.23首先和7比较，再和19比较，比它们都大，继续向后比较。</p><p>​    2.但23和26比较的时候，比26要小，因此回到下面的链表（原链表），与19在第一层的下一个节点22比较。</p><p>​    3.23比22要大，沿下面的指针继续向后和26比较。23比26小，说明待查数据23在原链表中不存在。</p><p>​    在这个查找过程中，由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了。需要比较节点数大概只有原来的一般。这就是跳表。为什么不用AVL树或者红黑树？因为skiplist更加简洁。因为level是随机的，得到的skiplist可能是这样的，有些在第四层，有些在第三层，有些在第二层，有些在第一层。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/17.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span>&#123;</span><br>    sds ele;<br>    <span class="hljs-type">double</span> score;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span>&#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> span;<br>    &#125; level[];<br>&#125; zskiplistNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>, *<span class="hljs-title">tail</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br>    <span class="hljs-type">int</span> level;<br>&#125; zskiplist;<br><br>typdef <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zset</span>&#123;</span><br>    dict *dict;<br>    zskiplist *zsl;<br>&#125; zset;<br></code></pre></td></tr></table></figure><p><strong>应用场景</strong></p><p>顺序会动态变化的列表, 比如：排行榜</p><h3 id="3-6-其他数据结构简介"><a href="#3-6-其他数据结构简介" class="headerlink" title="3.6 其他数据结构简介"></a>3.6 其他数据结构简介</h3><h4 id="3-6-1-BitMaps"><a href="#3-6-1-BitMaps" class="headerlink" title="3.6.1 BitMaps"></a>3.6.1 BitMaps</h4><p>bitMaps是在字符串类型上面定义的位操作。一个字节由8个二进制位组成。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/18.png"></p><p>set k1 a</p><p>​    获取value在offset处的值（a对应的ASCII码是97，转换为二进制数据是01100001）</p><p>​    getbit k1 0</p><p>​    修改二进制数据</p><p>​    setbit k1 6 1</p><p>​    setbit k1 7 0</p><p>​    get k1</p><p>​    <em>问题：怎么变成b了？（b对应的ASCII码是98，二进制数是01100010）</em></p><p>​    统计二进制位中1的个数</p><p>​    bitcount k1</p><p>​    获取第一个1或者0的位置</p><p>​    bitpos k1 1</p><p>​    bitpos k1 0</p><p>​    因为bit非常节省空间（1MB=8388608bit），可以用来做大数据量的统计。</p><p>​    应用场景：用户访问统计， 在线用户统计</p><h4 id="3-6-2-Hyperloglogs"><a href="#3-6-2-Hyperloglogs" class="headerlink" title="3.6.2 Hyperloglogs"></a>3.6.2 Hyperloglogs</h4><p>​    Hyperloglogs：提供了一种不太精确的基数统计方法，用来统计以集合中不重复的元素个数，比如统计网站的UV，或者应用的日活，月活，存在一定的误差。在redis中实现HyperLogLog，只需要12K内存就能统计2^54个数据。</p><h4 id="3-6-3-Geo"><a href="#3-6-3-Geo" class="headerlink" title="3.6.3 Geo"></a>3.6.3 Geo</h4><p>​    消费金融，给客户使用的客户端有这么一个需求，要获取半径1公里以内的门店，那么我们就要把门店的经纬度保存起来。那个时候我们是直接把经纬度保存到数据库的，一个字段存经度一个字段存维度。计算距离比较复杂。Redis的GEO直接提供了这个方法。</p><p>操作：增加地址位置信息，获取地址位置信息，计算两个位置的距离，获取指定范围内的地理位置集合等等。</p><h4 id="3-6-4-Streams"><a href="#3-6-4-Streams" class="headerlink" title="3.6.4 Streams"></a>3.6.4 Streams</h4><p>5.0推出的数据类型。支持多播的可持久化的消息队列，用于实现发布订阅功能，借鉴了kafka的设计。</p><h3 id="3-7-总结"><a href="#3-7-总结" class="headerlink" title="3.7 总结"></a>3.7 总结</h3><table><thead><tr><th>对象</th><th>对象type属性值</th><th>type命令输出</th><th>object_encoding</th></tr></thead><tbody><tr><td>字符串对象</td><td>OBJ_STRING</td><td>string</td><td>int  embstr  raw</td></tr><tr><td>列表对象</td><td>OBJ_LIST</td><td>list</td><td>quicklist</td></tr><tr><td>哈希对象</td><td>OBJ_HASH</td><td>hash</td><td>ziplist   hashtable</td></tr><tr><td>集合对象</td><td>OBJ_SET</td><td>set</td><td>intset   hashtable</td></tr><tr><td>有序集合对象</td><td>OBJ_ZSET</td><td>zset</td><td>ziplist  skiplist+hashtable</td></tr></tbody></table><p><strong>应用场景总结</strong></p><p>​    缓存——提升热点数据库的访问速度</p><p>​    共享数据——数据的存储和共享的问题</p><p>​    全局ID——分布式全局ID的生成方案（分库分表）</p><p>​    分布式锁——进程间共享数据的原子操作保证</p><p>​    在线用户统计和计数</p><p>​    队列，栈——跨进程的队列/栈</p><p>​    消息队列——异步解耦的消息队列</p><p>   服务注册与发现——RPC通信机制的服务协调中心（Dubbo支持Redis）</p><p>​    购物车</p><p>​    新浪/Twitter 用户消息时间线</p><p>​    抽奖逻辑（礼物，转发）</p><p>​    点赞，打卡，签到</p><p>​    商品标签</p><p>​    用户（商品）关注（推荐）模型</p><p>​    电商产品筛选</p><p>​    排行榜</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis发布订阅模式</title>
    <link href="/2023/02/17/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/17/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-列表的局限"><a href="#1-列表的局限" class="headerlink" title="1 列表的局限"></a>1 列表的局限</h2><p>通过队列的rpush和blpop可以实现消息队列（队尾进队头出），没有任何元素可以弹出的时候，连接会被阻塞。但是基于list实现的消息队列，不支持一对多的消息分发，相当于只有一个消费者。</p><h2 id="2-发布订阅模式"><a href="#2-发布订阅模式" class="headerlink" title="2 发布订阅模式"></a>2 发布订阅模式</h2><p>除了通过list实现消息队列之外，Redis还提供了发布订阅的功能</p><h3 id="2-1-订阅频道"><a href="#2-1-订阅频道" class="headerlink" title="2.1 订阅频道"></a>2.1 订阅频道</h3><p>消息的生产者和消费者是不同的客户端，连接到同一个redis的服务。通过什么对象把生产者和消费者关联起来？</p><p>在RabbitMQ中叫Queue，在kafka中叫Topic。Redis的模型中这个叫channel（频道）。订阅者可以订阅一个或多个channel。消息的发布者可以给指定的channel发布于消息，只要有消息到达了channel，所有订阅了这个channel的订阅者都会收到这条消息。</p><p><img src="/image/redis/redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/1.png"></p><p>订阅者订阅频道：可以一次订阅多个，比如这个客户端订阅了3个频道，频道不用实现创建。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">subscribe</span> channel-<span class="hljs-number">1</span> channel-<span class="hljs-number">2</span> channel-<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>发布者可以向指定的频道发布消息（并不支持一次向多个频道发送消息）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">publish</span> channel-<span class="hljs-number">1</span> test<br></code></pre></td></tr></table></figure><p>取消订阅（不能在订阅状态下使用）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">unsubscribe</span> channel-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="2-2-按规则-Pattern-订阅频道"><a href="#2-2-按规则-Pattern-订阅频道" class="headerlink" title="2.2 按规则(Pattern)订阅频道"></a>2.2 按规则(Pattern)订阅频道</h3><p>?代表一个字符，*代表0个或多个字符。</p><p>例如，现在有三个新闻频道，运动新闻（news-sport），音乐新闻（news-music），天气新闻（news-weather）。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">psubscribe *sport  <span class="hljs-comment">//消费端1关注运动消息</span><br>psubscribe <span class="hljs-keyword">new</span><span class="hljs-type">s</span>*  <span class="hljs-comment">//消费端2关注所有消息</span><br>psubscribe <span class="hljs-keyword">new</span><span class="hljs-type">s</span>-weather  <span class="hljs-comment">//消费端3关注天气新闻</span><br></code></pre></td></tr></table></figure><p><img src="/image/redis/redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/2.png"></p><p>一般来说，考虑到性能和持久化的因素，不建议使用Redis的发布订阅功能来实现MQ。Redis的一些内部机制用到了发布订阅功能。</p><h3 id="2-3-java伪代码"><a href="#2-3-java伪代码" class="headerlink" title="2.3 java伪代码"></a>2.3 java伪代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PublishTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>        jedis.publish(<span class="hljs-string">&quot;test-123&quot;</span>, <span class="hljs-string">&quot;666&quot;</span>);<br>        jedis.publish(<span class="hljs-string">&quot;test-abc&quot;</span>, <span class="hljs-string">&quot;pengyuyan&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JedisPubSub</span> &#123;<br>    <span class="hljs-comment">// 取得订阅的消息后的处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String channel, String message)</span> &#123;<br>        System.out.println(channel + <span class="hljs-string">&quot;=&quot;</span> + message);<br>    &#125;<br>    <span class="hljs-comment">// 初始化订阅时候的处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSubscribe</span><span class="hljs-params">(String channel, <span class="hljs-type">int</span> subscribedChannels)</span> &#123;<br>        <span class="hljs-comment">// System.out.println(channel + &quot;=&quot; + subscribedChannels);</span><br>    &#125;<br>    <span class="hljs-comment">// 取消订阅时候的处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUnsubscribe</span><span class="hljs-params">(String channel, <span class="hljs-type">int</span> subscribedChannels)</span> &#123;<br>        <span class="hljs-comment">// System.out.println(channel + &quot;=&quot; + subscribedChannels);</span><br>    &#125;<br>    <span class="hljs-comment">// 初始化按表达式的方式订阅时候的处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPSubscribe</span><span class="hljs-params">(String pattern, <span class="hljs-type">int</span> subscribedChannels)</span> &#123;<br>        <span class="hljs-comment">// System.out.println(pattern + &quot;=&quot; + subscribedChannels);</span><br>    &#125;<br>    <span class="hljs-comment">// 取消按表达式的方式订阅时候的处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPUnsubscribe</span><span class="hljs-params">(String pattern, <span class="hljs-type">int</span> subscribedChannels)</span> &#123;<br>        <span class="hljs-comment">// System.out.println(pattern + &quot;=&quot; + subscribedChannels);</span><br>    &#125;<br>    <span class="hljs-comment">// 取得按表达式的方式订阅的消息后的处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPMessage</span><span class="hljs-params">(String pattern, String channel, String message)</span> &#123;<br>        System.out.println(pattern + <span class="hljs-string">&quot;=&quot;</span> + channel + <span class="hljs-string">&quot;=&quot;</span> + message);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListenTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">MyListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyListener</span>();<br>        <span class="hljs-comment">// 使用模式匹配的方式设置频道</span><br>        <span class="hljs-comment">// 会阻塞</span><br>        jedis.psubscribe(listener, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;test-*&quot;</span>&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL性能优化</title>
    <link href="/2023/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2023/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="1-优化思路"><a href="#1-优化思路" class="headerlink" title="1 优化思路"></a>1 优化思路</h2><p>​    说到性能调优，大部分时候想要实现的目标是让查询更快。一个查询的流程又是由很多个环节组成的，每个环节都会消耗时间。要减少查询所消耗的时间，就要从每一个环节入手。</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.png"></p><p>确定环境：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> version();<br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%engine%&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="2-连接-配置优化"><a href="#2-连接-配置优化" class="headerlink" title="2 连接-配置优化"></a>2 连接-配置优化</h2><p>​    第一个环节是客户端连接到服务端，连接这一块有可能出现的问题是服务端连接数不够导致应用程序获取不到连接。比如Mysql：error 1040：Too many connections的错误。这个是超过了服务端设置的最大并发连接数。</p><p>​    可以从两个方面来解决连接数不够的问题：</p><p>​    1.从服务端来说，可以增加服务端的可连接数。如果有多个应用或者很多请求同时访问数据库，连接数不够的时候，可以:</p><p>​    （1）增加可用连接数，修改max_connections的大小：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> varibales <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;max_connections&#x27;</span>; <span class="hljs-comment">--修改最大连接数，当有多个应用连接的时候</span><br></code></pre></td></tr></table></figure><p>​    （2）及时释放不活动的连接。交互式和非交互式的客户端的默认超时时间都是28800秒，8小时，可以把这个值调小。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;wait_timeout&#x27;</span>; <span class="hljs-comment">--及时释放不活动的连接，注意不要释放连接池还在使用的连接</span><br></code></pre></td></tr></table></figure><p>​    2.从客户端来说，可以减少从服务端获取的连接数。如果想要不是每一次执行SQL都要创建一个新的连接，这时可以引入连接池，可以实现连接的重用。常见的连接池有老牌的DBCP和C3P0，阿里的Druid，Hikari（Spring Boot2.X版本默认的连接池）。连接池不是越大越好，只要维护一定数量大小的连接池，其他的客户端排队等待获取连接就可以了。有的时候连接池越大，效率反而越低。</p><p>​    Druid默认最大连接池大小是8。Hikari默认最大连接池大小是10。在Hikari的githuhb文档中，给出了一个PostgreSQL数据库建议的设置连接池小大的公式。它的建议是机器核数乘以2加1.也就是说，4核的机器，连接池维护9个连接就够了。这个公式从一定程度上来说对其他数据库也是适用的。每一个连接，服务端都需要创建一个线程去处理它。连接数越多，服务端创建的线程数就会越多。问题：CPU是怎么同时执行远远超过它的核数大小的任务的？分配时间片。上下文切换。而CPU的核数是有限的，频繁的上下文切换回造成比较大的性能开销。</p><p>​    这里说到了从数据库配置的层面去优化数据库。不管是数据库本身的配置，还是安装这个数据库服务的操作系统的配置，对于配置进行优化，最终的目标都是为了更好的发挥硬件本身的性能，包括CPU，内存，磁盘，网络。在不同的硬件环境下，操作系统和MySQL的参数的配置是不同的，没有标准的配置。 一般修改配置的工作是由专业的DBA完成，也有一些工具可以给出推荐值。</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/2.png"></p><h2 id="3-架构优化"><a href="#3-架构优化" class="headerlink" title="3 架构优化"></a>3 架构优化</h2><h3 id="3-1-缓存"><a href="#3-1-缓存" class="headerlink" title="3.1 缓存"></a>3.1 缓存</h3><p>​    在系统中有一些很慢的查询，要么数据量大，要么关联的表多，要么是计算逻辑非常复杂，这样的查询每次会占用连接很长时间。所以为了减轻数据库的压力，和提升查询效率，把数据放到内存中缓存起来，比如使用redis。</p><p>​    缓存适用于实时性不是很高的业务，比如报表数据，一次查询要2分钟，但是一天只需要更新一次。</p><p>​    独立的缓存服务，属于架构层面的优化。</p><h3 id="3-2-集群，主从复制"><a href="#3-2-集群，主从复制" class="headerlink" title="3.2 集群，主从复制"></a>3.2 集群，主从复制</h3><p>​    在分布式中，有一种提升可用性的手段叫做冗余，也就是创建集群。</p><p>​    集群的话必然会面临一个问题，就是不同的节点之间数据一致性的问题。如果同时读写多台数据库节点，怎么让所有的节点数据保持一致？这个时候需要用到复制技术（replication），被复制的节点称为master，复制的节点称为slave。Slave本身也可以作为其他节点的数据来源，这个叫做级联复制。之前说过，MySQL所有的更新语句都会记录到Server层binlog中。从服务器会不断获取主服务器的binlog文件，然后解析里面的SQL语句，在从服务器上面执行一遍，保持主从的数据一致。</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.png"></p><p>​    这里面涉及到三个线程，连接到master获取binlog，并且解析binlog写入中继日志，这个线程叫做IO线程。Master节点上有一个log dump线程，是用来发送binlog给slave的。从库的SQl线程，是用来读取relay log，把数据写入到数据库的。</p><p>​    做了主从复制配置之后，我们只把数据写入master节点，而读的请求可以分担到slave节点。我们把这种方案叫做读写分离。</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/4.png"></p><p>​    对于读多写少的项目来说，读写分离对于减轻主服务器的访问压力很有用。</p><h3 id="3-3-分库分表"><a href="#3-3-分库分表" class="headerlink" title="3.3 分库分表"></a>3.3 分库分表</h3><p>​    在集群架构中，所有的节点存储的都是相同的数据。如果单张表存储的数据过大的时候，比如一张表有上亿的数据，每天以百万的量级增加，单表的查询性能还是会大幅下降。这时就要用到第二手段，叫做分片。把单个节点的数据分散到多个节点存储，减少存储和访问压力，这个就是分库分表。</p><p>​    分库分表总体上可以分为两类：垂直分库，减少并发压力；水平分表，解决存储瓶颈。</p><p><strong>1.垂直分库</strong>：把一个数据库按照业务拆分成不同的数据库</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/5.png"></p><p><strong>2.水平分库分表</strong>：把单张表的数据按照一定的规则分布到多个数据库</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/6.png"></p><h2 id="4-优化器-SQL优化"><a href="#4-优化器-SQL优化" class="headerlink" title="4  优化器-SQL优化"></a>4  优化器-SQL优化</h2><p>​    优化器的作用是对SQL语句进行优化分析，生成执行计划。首先，要用到服务端的慢查询日志。</p><h3 id="4-1-慢查询日志slow-query-log"><a href="#4-1-慢查询日志slow-query-log" class="headerlink" title="4.1 慢查询日志slow query log"></a>4.1 慢查询日志slow query log</h3><h4 id="4-1-1-打开慢查询开关"><a href="#4-1-1-打开慢查询开关" class="headerlink" title="4.1.1 打开慢查询开关"></a>4.1.1 打开慢查询开关</h4><p>因为开启慢查询日志是有代价的（跟binlog，optimizer-trace一样），所以它默认是关闭的.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;slow_query%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>除了这个开关，还有一个参数，控制执行超过多长时间的SQL才记录到慢日志，默认是10秒。如果改成0秒的话就是记录所有的SQL。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%long_query%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>参数的两种修改方式：</p><p>​    1.set动态修改参数（重启后失效）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> @<span class="hljs-variable">@global</span>.slow_query_log<span class="hljs-operator">=</span><span class="hljs-number">1</span>; <span class="hljs-comment">--1开启，0关闭，重启后失效</span><br><span class="hljs-keyword">set</span> @<span class="hljs-variable">@global</span>.long_query_time<span class="hljs-operator">=</span><span class="hljs-number">3</span>; <span class="hljs-comment">--默认10秒，另开一个窗口后才会查到最新值</span><br></code></pre></td></tr></table></figure><p>​    2.修改配置文件my.cnf，以下配置定义了慢查询日志的开关，慢查询的时间，日志文件的存放路径。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">show_query_log</span>=<span class="hljs-string">ON</span><br><span class="hljs-attr">long_query_time</span>=<span class="hljs-string">2</span><br><span class="hljs-attr">show_query_log_file</span>=<span class="hljs-string">/var/lib/mysql/localhost-slow.log</span><br></code></pre></td></tr></table></figure><h4 id="4-1-2-慢日志分析"><a href="#4-1-2-慢日志分析" class="headerlink" title="4.1.2 慢日志分析"></a>4.1.2 慢日志分析</h4><p>1.日志内容</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/7.png"></p><p>2.mysqldumpslow</p><p>MySQL提供了mysqldumpslow的工具，在Mysql的bin目录下。例如：查询用时最多的10条慢SQL：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mysqldumpslow -s t -t 10 -g <span class="hljs-string">&#x27;select&#x27;</span> /var/lib/mysql/localhost-slow.log<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/8.png"></p><p>​    Count代表这个SQL执行了多少次；Time代表执行的时间，括号中是累计时间；Lock表示锁定的时间，括号是累计；Rows表示返回的记录数，括号是累计。当然，有的时候查询慢，不一定是SQL语句的问题，也有可能是服务器状态的问题。所以也要掌握一些查看服务器和存储引擎状态的命令。</p><h4 id="4-1-3-其他系统命令"><a href="#4-1-3-其他系统命令" class="headerlink" title="4.1.3 其他系统命令"></a>4.1.3 其他系统命令</h4><p>1.Show processlist 运行线程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">full</span> processlist;<br></code></pre></td></tr></table></figure><p>这是一个很重要的命令，用于显示用户运行线程。可以根据id号kill线程。也可以查表，效果一样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> information.processlist<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/9.png"></p><table><thead><tr><th>列</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>线程的唯一标识，可以根据它kill线程</td></tr><tr><td>User</td><td>启动这个线程的用户，普通用户只能看到自己的线程</td></tr><tr><td>Jpst</td><td>哪个端口发起的连接</td></tr><tr><td>db</td><td>操作的数据库</td></tr><tr><td>Command</td><td>线程的命令 <a href="https://dev.mysql.com/doc/refman/5.7/en/thread-commands.html">https://dev.mysql.com/doc/refman/5.7/en/thread-commands.html</a></td></tr><tr><td>Time</td><td>操作持续时间，单位秒</td></tr><tr><td>State</td><td>线程状态，比如查询所有可能有copying to tmp table, Sorting result, Sending data <br /> <a href="https://dev.mysql.com/doc/refman/5.7/en/general-thread-states.html">https://dev.mysql.com/doc/refman/5.7/en/general-thread-states.html</a></td></tr><tr><td>Info</td><td>SQL语句的前100个字符。如果要查看完整的SQL语句，用show full processlist</td></tr></tbody></table><p>2.Show status 服务器运行状态</p><p>Show status用于查看mysql服务器运行状态（重启后会清空）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> status;<br></code></pre></td></tr></table></figure><p>有session和global两种作用域，格式：参数-值。可以通过like带通配符过滤：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">showo <span class="hljs-keyword">global</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;com_select&#x27;</span>; <span class="hljs-comment">--查看select次数</span><br></code></pre></td></tr></table></figure><p>3.show engine 存储引擎运行信息</p><p>​    Show engine用来显示存储引擎的当前运行信息，包括事务持有的表锁，行锁信息；事务锁等待情况；线程信号量等待；文件IO请求；buffer pool统计信息。 例如：show engine innodb status；开启InnoDB监控：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> innodb_status_output<span class="hljs-operator">=</span><span class="hljs-keyword">ON</span>;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> innodb_status_output_locks<span class="hljs-operator">=</span><span class="hljs-keyword">ON</span>;<br></code></pre></td></tr></table></figure><p>​    很多开源的MySQL监控工具，其实他们的原理也都是读取的服务器，操作系统，MYSQL服务的状态和变量。之后，MySQL提供了一个执行计划的工具。通过EXPLAIN可以模拟服务端执行SQL查询语句的过程。通过这种方式可以分析语句或者表的性能瓶颈。</p><p>​    MYSQL5.6.3以前只能分析select，之后可以分析update，delete，insert。</p><h3 id="4-2-EXPLAIN执行计划"><a href="#4-2-EXPLAIN执行计划" class="headerlink" title="4.2 EXPLAIN执行计划"></a>4.2 EXPLAIN执行计划</h3><p>先创建三张表。课程表，老师表，老师联系方式表（没有任何索引）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if_exists course;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;course&#x27;</span> (<br><span class="hljs-string">&#x27;cid&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-string">&#x27;cname&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-string">&#x27;tid&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span><br>) engine<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">default</span> charrest<span class="hljs-operator">=</span>utf8mb4;<br><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if_exists teacher;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;teacher&#x27;</span> (<br><span class="hljs-string">&#x27;tid&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-string">&#x27;tname&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-string">&#x27;tcid&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span><br>) engine<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">default</span> charrest<span class="hljs-operator">=</span>utf8mb4;<br><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if_exists teacher_contact;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;teacher_contact&#x27;</span> (<br><span class="hljs-string">&#x27;tcid&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-string">&#x27;phone&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>) engine<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">default</span> charrest<span class="hljs-operator">=</span>utf8mb4;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;course&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;mysql&#x27;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;course&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;jvm&#x27;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;course&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;juc&#x27;</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;course&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;spring&#x27;</span>, <span class="hljs-number">3</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;teacher&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;qs&#x27;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;teacher&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;hh&#x27;</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;teacher&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;mic&#x27;</span>, <span class="hljs-number">3</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;teacher_contact&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;13688888888&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;teacher_contact&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;13688888889&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;teacher_contact&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;13688888810&#x27;</span>);<br></code></pre></td></tr></table></figure><p>Explain的结果字段有很多，详细分析一下：</p><h4 id="4-2-1-Id"><a href="#4-2-1-Id" class="headerlink" title="4.2.1 Id"></a>4.2.1 Id</h4><p>Id是查询序列编号，每张表都是单独访问的，一个select就会有一个序号。</p><p>（1）Id值不同的时候，先查询id值大的（先大后小）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> tc.phone <br><span class="hljs-keyword">from</span> teacher_contact tc<br><span class="hljs-keyword">where</span> tcid <span class="hljs-operator">=</span> (<br>    <span class="hljs-keyword">select</span> tcid <span class="hljs-keyword">from</span> teacher t <span class="hljs-keyword">where</span> t.tid <span class="hljs-operator">=</span> (<br>        <span class="hljs-keyword">select</span> c.tid <span class="hljs-keyword">from</span> course c <span class="hljs-keyword">where</span> c.cname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;mysql&#x27;</span><br>        )<br>    )<br></code></pre></td></tr></table></figure><p>查询顺序：course c——teacher t——teacher_contact tc</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/10.png"></p><p>先查课程表，再查老师表，最后查老师联系表。子查询只能以这种方式进行，只有拿到内层的结果之后才能进行外层的查询。</p><p>（2）id值相同</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> t.tname, c.name, tc.phone<br><span class="hljs-keyword">from</span> teacher t, course c, teacher_contact tc<br><span class="hljs-keyword">where</span> t.tid <span class="hljs-operator">=</span> c.tid <span class="hljs-keyword">and</span> t.tcid <span class="hljs-operator">=</span> tc.tcid <span class="hljs-keyword">and</span> (c.cid <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> tc.cid <span class="hljs-operator">=</span> <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/11.png"></p><p>Id值相同时，表的查询顺序是从上往下顺序执行。例如这次查询的id都是1（说明子查询被优化器转换成了连接查询），查询的顺序是teacher t（3条）——course c（4条）——teacher_contact tc（3条）。</p><p>​    （3）如果id有相同也有不同，就是id不同的先大后小，相同的从上往下。</p><p>​    在连接查询中，先查询的叫做驱动表，后查询的叫做被驱动表。应该先查小表（得到的结果少），小表驱动大表。</p><h4 id="4-2-2-Select-type-查询类型"><a href="#4-2-2-Select-type-查询类型" class="headerlink" title="4.2.2 Select type 查询类型"></a>4.2.2 Select type 查询类型</h4><p>​    这里并没有列出全部（其他：dependent union，dependent subquery，materialized，uncacheable subquery，uncacheable union）。下面列举了一些常见的查询类型：</p><p>​    1.simple：简单查询，不包含子查询，不包含关联查询union。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/12.png"></p><p>再看一个包含子查询的案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--查询mysql课程老师的手机号</span><br>explain <span class="hljs-keyword">select</span> tc.phone <span class="hljs-keyword">from</span> tescher_contact tc<br><span class="hljs-keyword">where</span> tcid <span class="hljs-operator">=</span> (<br>    <span class="hljs-keyword">select</span> tcid <span class="hljs-keyword">from</span> teacher t <span class="hljs-keyword">where</span> t.tid <span class="hljs-operator">=</span> (<br>        <span class="hljs-keyword">select</span> c.tid <span class="hljs-keyword">from</span> course c <span class="hljs-keyword">where</span> c.cname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;mysql&#x27;</span><br>        )<br>    )<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/13.png"></p><p>​    2.primary：子查询sql语句中的主查询，也就是最外层的查询</p><p>​    3.subquery：子查询中所有的内层查询都是该类型。</p><p>​    4.derived：衍生查询，表示在得到最终查询结果之前会用到的临时表，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> cr.cname <span class="hljs-keyword">from</span> (<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> course <span class="hljs-keyword">where</span> tid<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">union</span><br>    <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> course <span class="hljs-keyword">where</span> tid<span class="hljs-operator">=</span><span class="hljs-number">2</span><br>) cr;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/14.png"></p><p>​    对于关联查询，先执行有便的table（union），再执行左边的table，类型是derived</p><p>​    5.union：同上例</p><p>​    6.union result：主要是显示哪些表之间存在union查询。&lt;union2,3&gt;代表id=2和id=3的查询存在union，同上例。</p><h4 id="4-2-3-Type-连接类型"><a href="#4-2-3-Type-连接类型" class="headerlink" title="4.2.3 Type 连接类型"></a>4.2.3 Type 连接类型</h4><p>​    所有连接类型中，上面的最好，越往下越差。在常用的连接类型中：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;all。这里并没有列举全部（其他: fulltext, ref_or_null, index_merger, unique_subquery, index_subquery）。以上访问类型除了all，都能用到索引。</p><p>​    <strong>1.const</strong>：主键索引或者唯一索引，只能查到一条数据的SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> talbe if_exists single_data;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> single_data(<br>id <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">primary</span> key,<br>    content <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)<br>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> single_data <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>);<br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> single_data a <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">&#x27;;</span><br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/15.png"></p><p><strong>2.system</strong>：system是const的一种特例，只有一行满足条件，对于NyISAM，Memory的表，只查询到一条记录，也是system。比如系统库的这张表（8.0的版本中系统表全部变成InnoDB存储引擎了）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> mysql.proxies_priv;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/16.png"></p><p><strong>3.eq_ref</strong>：通常出现在多表的join查询，被驱动表通过唯一性索引（unique或primary key）进行访问，此时被驱动表的访问方式就是eq_ref。eq_ref是出const之外最好的访问类型。先删除teacher表中多余的数据，teacher_contact有3条数据，teacher表有三条数据。teacher_contact表的tcid（第一个字段）创建主键索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- alert table teacher_contact drop primary key</span><br>alert <span class="hljs-keyword">table</span> teacher_contact <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary</span> key(tcid);<br><br>explain <span class="hljs-keyword">select</span> t.tcid <span class="hljs-keyword">from</span> teacher t, teacher_contact tc <span class="hljs-keyword">where</span> t.tcid<span class="hljs-operator">=</span>tc.tcid<br></code></pre></td></tr></table></figure><p>此时的执行计划（先大后小，从上往下，tc是被驱动表。Tc表是eq_ref）：被驱动表用主键进行访问</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/17.png"></p><p><strong>小结</strong>：以上三种system，const，eq_ref，都是可遇不可求的，基本上很难优化到这个状态。</p><p>​    <strong>4.ref</strong>：查询用到了非唯一性索引，或者关联操作只使用了索引的最左前缀</p><p>​    为teacher表的tcid（第三个字段）创建普通索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- alert table teacher drop primary key</span><br>alert <span class="hljs-keyword">table</span> teacher <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary</span> key(tcid);<br><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">where</span> tcid<span class="hljs-operator">=</span><span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/18.png"></p><p><strong>5.range</strong>：索引范围扫描。如果where后面是between and 或 &lt; 或 &gt; 或 &gt;= 或 &lt;= 或 in这些，type类型就为range。不走索引一定是全表扫描（ALL），所以先加上普通索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- alert table teacher drop index idx_tid</span><br>alert <span class="hljs-keyword">table</span> teacher <span class="hljs-keyword">add</span> index idx_tid(tid)<br><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">where</span> tid<span class="hljs-operator">&lt;</span><span class="hljs-number">3</span>;<br><span class="hljs-comment">-- 或</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">where</span> tid <span class="hljs-keyword">between</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/19.png"></p><p>IN查询也是range（字段上有主键索引）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher_contact <span class="hljs-keyword">where</span> tcid <span class="hljs-keyword">in</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/20.png"></p><p><strong>6.index</strong>：Full Index Scan，查询全部索引中的数据（比不走索引要快）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> tid <span class="hljs-keyword">from</span> teacher;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/21.png"></p><p><strong>7.all：</strong>Full Table Scan，如果没有索引或者没有用到索引，type就是ALL。代表全表扫描。</p><p><strong>8.Null：</strong>不用访问表或者索引就能得到结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> dual <span class="hljs-keyword">where</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>总结：一般来说，需要保证查询的type至少达到range级别，最好能达到ref。all（全表扫描）和index（查询全部索引）都是需要优化的</p><h4 id="4-2-4-Possible-key-key"><a href="#4-2-4-Possible-key-key" class="headerlink" title="4.2.4 Possible_key, key"></a>4.2.4 Possible_key, key</h4><p>​    可能用到的索引和实际用到的索引。如果是null就代表没有用到索引。Possible_key可以有一个个或者多个，可能用到索引不代表一定用到索引。反过来，possible_key为空，key可能有值吗？表上创建联合索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">alert <span class="hljs-keyword">table</span> user_innodb <span class="hljs-keyword">add</span> index name_phone(name, phone);<br>explain <span class="hljs-keyword">select</span> phone <span class="hljs-keyword">from</span> user_innodb <span class="hljs-keyword">where</span> phone <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;126&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/22.png"></p><p>结论：是有可能的（这里是覆盖索引的情况）。如果通过分析发现没有用到索引，就要检查SQL或者创建索引。</p><h4 id="4-2-5-key-len"><a href="#4-2-5-key-len" class="headerlink" title="4.2.5 key_len"></a>4.2.5 key_len</h4><p>​    索引的长度（使用的字节数）。跟索引字段的类型，长度有关。</p><p>​    表上有联合索引：KEY ‘comidx_name_phone’(‘name’, ‘phone’)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_innodb <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;qs&#x27;</span>;<br></code></pre></td></tr></table></figure><p>Key_len = 1023，为什么不是255+11=266呢？这里的索引只用到了name字段，定义长度255.utf8mb4编码一个字符4个字节。所以是255*4=1020.使用变长字段varchar需要额外增加2个字节，允许null需要额外增加1个字节。所以一共1023.</p><h4 id="4-2-6-Rows"><a href="#4-2-6-Rows" class="headerlink" title="4.2.6 Rows"></a>4.2.6 Rows</h4><p>MySQL认为扫描多少行才能返回请求的数据，是一个预估值。一般来说行数越少越好。</p><h4 id="4-2-7-Filtered"><a href="#4-2-7-Filtered" class="headerlink" title="4.2.7 Filtered"></a>4.2.7 Filtered</h4><p>​    这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，它是一个百分比。如果比例很低，说明存储引擎层返回的数据经过大量过滤，这个是会消耗性能的，需要关注。</p><h4 id="4-2-8-Ref"><a href="#4-2-8-Ref" class="headerlink" title="4.2.8 Ref"></a>4.2.8 Ref</h4><p>使用哪个列或者常数和索引一起从表中筛选数据。</p><h4 id="4-2-9-Extra"><a href="#4-2-9-Extra" class="headerlink" title="4.2.9 Extra"></a>4.2.9 Extra</h4><p>执行计划给出额外的信息说明。</p><p>​    1.using index：用到了覆盖索引，不需要回表</p><p>​    2.using where：使用了where过滤，表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤（跟是否使用索引没有关系）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_innodb <span class="hljs-keyword">where</span> phone <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1345353545&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/23.png"></p><p>​    3.using index condition：索引条件下推</p><p>​    4.using filesort：不能使用索引来排序，用到了额外的排序（跟磁盘或文件没有关系）。需要优化。（复合索引的前提）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">alert <span class="hljs-keyword">table</span> user_innodb <span class="hljs-keyword">drop</span> index comidx_name_phone;<br>alert <span class="hljs-keyword">table</span> user_innodb <span class="hljs-keyword">add</span> index comidx_name_phone(name,phone);<br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_innodb <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;qs&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/24.png"></p><p>​    5.using temporary：用到了临时表，例如（以下不是全部情况）</p><p>​       （1）distinct非索引列（确定tid字段是否有索引）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span>(tid) <span class="hljs-keyword">from</span> teacher t;<br></code></pre></td></tr></table></figure><p>​       （2）group by非索引列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> tname <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> tname;<br></code></pre></td></tr></table></figure><p>​       （3）使用join的时候，group任意列（t表的结果）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> t.tid <span class="hljs-keyword">from</span> teacher t <span class="hljs-keyword">join</span> course c <span class="hljs-keyword">on</span> t.tid <span class="hljs-operator">-</span> c.tid <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> t.tid;<br></code></pre></td></tr></table></figure><p>需要优化，比如创建复合索引。</p><p>如果需要具体的cost信息，可以用：EXPLAIN FORMAT = JSON。如果觉得explain还不够细，可以开启optimizer trace。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;optimizer_trace&#x27;</span>;<br><span class="hljs-keyword">set</span> optimizer_trace<span class="hljs-operator">=</span><span class="hljs-string">&#x27;enabled=on&#x27;</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> information_schema.optimizer_trace\G<br></code></pre></td></tr></table></figure><p>总结一下：模拟优化器执行SQL查询语句的过程，来知道MySQL是怎么处理一条SQL语句的，通过这种方式我们可以分析语句或者表的性能瓶颈。分析出问题之后，就是对SQL语句的具体优化。</p><h3 id="4-3-SQL与索引优化"><a href="#4-3-SQL与索引优化" class="headerlink" title="4.3 SQL与索引优化"></a>4.3 SQL与索引优化</h3><p>​    当我们的SQL语句比较复杂，有多个关联和子查询的时候，就要分析SQL语句有没有改写的方法。举个简单的例子，一摸一样的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 大偏移量的limit</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_innodb limit <span class="hljs-number">900000</span>,<span class="hljs-number">10</span>;<br><span class="hljs-comment">-- 改成先过滤ID，再limit</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_innodb <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">900000</span> limit <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>一个sum语句性能提升3倍的优化案例： <a href="https://gper.club/articles/7e7e7f7ff4g5egc2g63">https://gper.club/articles/7e7e7f7ff4g5egc2g63</a>   这一步是SQL语句的优化，目的是让SQL语句的cost更小。</p><h2 id="5-存储引擎与表结构优化"><a href="#5-存储引擎与表结构优化" class="headerlink" title="5  存储引擎与表结构优化"></a>5  存储引擎与表结构优化</h2><p>1.存储引擎的选择</p><p>​       为不同的业务表选择不同的存储引擎，例如：查询插入多的业务表，用MyISAM。临时数据用memory。 常规并发多更新的表用InnoDB。</p><p>​    2.分表或者分区</p><p>​       交易历史表：在年底为下一年度建立12个分区，每个月一个分区</p><p>​       渠道交易表：分成：当日表，当月表，历史表，历史表再做分区</p><p>​    3.字段定义：</p><p>​       原则：使用可以正确存储数据的最小数据类型。为每列选择合适的字段类型：</p><p>​       （1）整数类型：</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/25.png"></p><p>Int有6中类型，不同的类型的最大存储范围是不一样的，占用的存储空间也是不一样的。举       例：存储性别字段？用tinyint，因为enum也是整数存储。</p><p>​       （2）字符类型：变长情况下，varchar更节省空间，但是对于varchar字段，需要一个字节来记录长      度，比如：联系地址。固定长度的用char，不要用varchar，比如：行政区编码。</p><p>​       （3）非空：非空字段尽量定义成not null，提供默认值，或者使用特殊值，空串代替null。NULL类     型的存储，优化，使用都会存在问题。</p><p>​       （4）不要使用外键，触发器，视图：降低了可读性；影响数据库性能，应该把计算的事情交给程序，       数据库专心做存储；数据的完整性应该在程序中检查。</p><p>​       （5）大文件存储：图片和音频，视频怎么存储？不要用数据库村粗图片（比如base64编码）或者      大文件。把文件放在NAS上，数据库只存储URI（相对路径），在应用中配置NAS服务器地址。</p><p>​       （6）表拆分或者字段冗余：</p><p>​           表拆分：将不常用的字段拆分出去，避免列数过多和数据量过大。淘宝的商品表。商户信息表。      比如在业务系统中，要记录所有接收和发送的消息，这个消息是XML格式的，用blob或者text存      储，用来追踪和判断重复，可以建立一张表专门用来存储报文。</p><p>​           字段冗余：合同表的客户姓名。</p><h2 id="6-总结：优化体系"><a href="#6-总结：优化体系" class="headerlink" title="6  总结：优化体系"></a>6  总结：优化体系</h2><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/26.png"></p><p>除了对于代码，SQL语句，表定义，架构，配置优化之外，业务层面的优化也不能忽视，举几个例子：</p><p>​    （1）在某一年的双十一，为什么会做一个充值到余额宝和余额有奖金的活动？现在会推荐大家用花呗支付，而不是银行卡支付？因为使用余额或者余额宝付款是记录本地或者内部数据库中，而使用银行卡付款，需要调用接口，操作内部数据库肯定更快。</p><p>​    （2）在某一年的双十一，为什么在凌晨禁止查询今天之外的账单？为什么小鸡的饲料发放延迟了？这时一种降级措施，用来保证当前最核心的业务。</p><p>​    （3）某银行的叫记录，只能按月份查询。</p><p>​    （4）最近几年的双十一，为什么11月1日就开始了？变成了各种定金红包模式？预售分流。</p><p>​    在应用层面同样有很多其他的方案来优化，达到尽量减轻数据库的压力的目的，比如限流，或者引入MQ削锋，等等。用数据库慢，不代表数据库本身慢，有的时候还要往上层去优化。当然，如果关系型数据库解决不了的问题，我们可能需要用到搜索引擎或者大数据的方案了，并不是所有的数据都要放到关系型数据库存储。</p><h2 id="7-优化案例"><a href="#7-优化案例" class="headerlink" title="7  优化案例"></a>7  优化案例</h2><p>​    服务端状态分析：</p><p>​    如果出现连接变慢，查询被阻塞，无法获取连接的情况。</p><p>​       1.重启！</p><p>​       2.show processlist查看线程状态，连接数数量，连接时间，状态</p><p>​       3.查看锁的状态</p><p>​       4.kill有问题的线程</p><p>​    对于具体的慢SQL：</p><p>​    一，分析查询基本情况</p><p>​       涉及到的表的表结构，字段的索引情况，每张表的数据量，查询的业务含义。这个非常重要，因为    有时候你会发现SQL根本没必要这么写，或者表设计是有问题的。</p><p>​    二，找出慢的原因</p><p>​       1.查看执行计划，分析SQL的执行情况，了解表访问顺序，访问类型，索引，扫描行数等信息</p><p>​       2.如果总体的时间很长，不确定哪一个因素影响最大，通过条件的增减，顺序的调整，找出引起查    询慢的主要原因，不断的尝试验证。找到原因：比如是没有走索引引起的，还是关联查询引起的，还order     by引起的。找到原因后：</p><p>​       3.对症下药，</p><p>​       （1）创建索引或者联合索引</p><p>​       （2）改写SQL，这里需要平时积累经验，例如：a）使用小表驱动大表，b）用join代替子查询，c）         not exist转换为left join is null，d）or改成union，e）如果结果集允许重复的话，使用union         all代替union，f）大偏移的limit，先过滤再排序。</p><p>​       如果sql本身解决不了，就要上升到表结构和架构了。</p><p>​       （3）表结构（冗余，拆分，not all等），架构优化（缓存，读写分离，分表分库）</p><p>​       （4）业务层的优化，必须条件是否必要</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL事务和锁</title>
    <link href="/2023/02/16/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/"/>
    <url>/2023/02/16/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="1-数据库事务"><a href="#1-数据库事务" class="headerlink" title="1. 数据库事务"></a>1. 数据库事务</h2><h3 id="1-1-事务的典型场景"><a href="#1-1-事务的典型场景" class="headerlink" title="1.1 事务的典型场景"></a>1.1 事务的典型场景</h3><p>​    在项目中，什么地方使用事务？是根据业务类型来使用的还是根据数据操作类型来使用的？无论你是在方法上加@Transactional注解，还是在xml文件中配置切面，还是直接用JDBC的方法。很多时候我们需要事务是因为我们希望涉及数据库的多个操作都成功，比如客户下单，会操作订单表，资金表，物流表等等，就需要放在一个事务中执行。</p><p>​    一个非常典型的案例就是银行转账。如果我们把行内转账简化为一个账户余额减少，另一个账户余额增加的情况，那么这两个动作一定是同时成功或同时失败的，否则会造成会计科目不平衡。另一个例子：12306的连续换乘功能，两张票必须同时购买成功，只买到前半程或者只买到后半程是没有意义的。</p><h3 id="1-2事务的定义"><a href="#1-2事务的定义" class="headerlink" title="1.2事务的定义"></a>1.2事务的定义</h3><p>​    事务是数据库管理系统（DBMS）执行过程中的一个逻辑单位，有一个有限的数据库操作序列构成。这里有两个关键点，1.所谓的逻辑单位，意味着它是数据库最小的工作单位，是不可再分的。2.它可能包含了一个或者多个DML语句，包括insert delete update。（单条DDL（create drop）和DCL（grant revoke）也会有事务）。</p><h3 id="1-3-哪些存储引擎支持事务"><a href="#1-3-哪些存储引擎支持事务" class="headerlink" title="1.3 哪些存储引擎支持事务"></a>1.3 哪些存储引擎支持事务</h3><p>​    并不是所有的数据库或者所有的存储引擎都支持事务，它是作为一种特性出现的。在MySQL中除了做集群的NDB之外，只有InnoDB支持事务，这个也是它成为默认的存储引擎的一个重要原因。</p><h3 id="1-4-事务的四大特性-ACID"><a href="#1-4-事务的四大特性-ACID" class="headerlink" title="1.4 事务的四大特性(ACID)"></a>1.4 事务的四大特性(ACID)</h3><p>​    1.原子性，Atomicity，也就是不可再分，因为原子是化学上（参加化学反应）最小单位。也就意味着我们对数据库的一系列操作，要么都成功，要么都失败，不可能出现部分成功的情况。问题是如果前面一个成功了，后面的操作失败了，怎么让它全部失败？这个时候我们必须要回滚。原子性在InnoDB中是通过undo log来实现的，他记录了数据修改之前的值（逻辑日志），一旦发生异常，就可以用undo log来实现回滚操作。</p><p>​    2.隔离性，Isolation，我们有了事务的定义后，在数据库中会有很多的事务同时去操作我们的同一张表或者同一行数据，必然会产生一些并发或者干扰的操作。我们对隔离性的定义，就是这些很多个的事务，对表或者行的并发操作，应该是透明的，互相不干扰的。比如两个人给青山转账100，开启两个事务，都拿到了青山账户的余额1000，然后各自基于1000加100，最后结果是1100，就出现了数据混乱的问题。</p><p>​    3.持久性，Durability，事务的持久性是什么意思？我们对数据库的任意的操作，增删改，是要事务提交成功，那么结果就是永久性的，不可能因为数据库掉电，宕机，意外重启，又能变成原来的状态。这个就是事务的持久性。持久性是通过redo log和double write buffer（双写缓冲）来实现的，我们操作数据的时候，会先写到内存的buffer pool中，同时记录redo log，如果在刷盘之前出现异常，在重启后就可以读取到redo log的内容，写入到磁盘，保证数据的持久性。当然，恢复成功的前提是数据页本身没有损坏，是完整的，这个通过双写缓冲保证。需要注意的是，原子性，隔离性，持久性，最后都是为了实现一致性。</p><p>​    4.一致性，consistent，指的是数据库的完整性约束没有被破坏，事务执行前后都是合法的数据状态。数据库自身提供了一些约束：比如主键必须是唯一的，字段长度符合要求。另外还有用户自定义的完整性，用户自定义的完整性通常要在代码中控制，例如金额不能小于0等。</p><h3 id="1-5数据库什么时候出现事务"><a href="#1-5数据库什么时候出现事务" class="headerlink" title="1.5数据库什么时候出现事务"></a>1.5数据库什么时候出现事务</h3><p>​    当执行一条更新语句，实际上，它不仅自动开启了事务，而且还自动提交了，所以最终写入了磁盘。这个是开启事务的第一种方式，增删改的语句会自动开启事务，当然是一条SQL一个事务。注意每个事务都是有编号的，这个编号是一个整数，有递增的特性。如果把多条SQL放在一个事务中，就要手动开启事务。手动开启事务有两种方式：一种是用begin；一种是用start transaction。结束事务也有两种方式：一种是回滚事务rollback，事务结束；另一种是提交事务commit，事务结束。</p><p>​    InnoDB中有一个autocommit的参数（分为两个级别，session和global级别）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;autocommit&#x27;</span>;<br></code></pre></td></tr></table></figure><p>​    它的默认值是ON。这个参数的意义是是否自动提交。如果它的值是true/ON的话，会自动提交事务。如果设置为false/OFF的话，那么数据库的事务就需要我们手动结束，用rollback或commit。</p><p>​    还有一种情况，客户端的连接断开的时候，事务也会结束。</p><h3 id="1-6事务并发会带来哪些问题？"><a href="#1-6事务并发会带来哪些问题？" class="headerlink" title="1.6事务并发会带来哪些问题？"></a>1.6事务并发会带来哪些问题？</h3><p>​    有两个事务，一个编号2573，另一个是2674。在第一个事务中，它首先通过where id=1的条件查询一条数据，返回name=Ada，age=16的这条数据，然后第二个事务，它通过一个update的语句，把id=1的数据的age改成了18，但是没有提交。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/1.png"></p><p>​    这时，在第一个事务中，它再次执行相同的查询操作，发现数据发生了变化，获取到的数据age变成了18.那么，这种在一个事务中，由于其他的时候修改了数据并且没有提交，而导致了前后两次读取数据不一致的情况，这种事务并发的问题，我们把它定义为<strong>脏读。</strong>如果在转账的案例中，我们第一个事务基于读取到的第二个事务未提交的余额进行了操作，但是第二个事务进行了回滚，这个时候就会导致数据不一致。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/2.png"></p><p>​    同样是两个事务，第一个事务通过id=1查询到了一条数据。然后第二个事务中执行了一个update操作，执行了update以后它通过一个commit提交了修改。然后第一个事务读取到了其他事务已提交的数据导致前后两次读取数据不一致的情况，就像这里，age到底是16还是18，那么这种事务并发带来的问题，把它叫做<strong>不可重复读。</strong></p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/3.png"></p><p>​    在第一个事务中我们执行了一个范围查询，这时满足条件的数据只有一条。在第二个事务中，插入了一行数据，并且提交了。重点：插入了一条数据。在第一个事务再去查询时，它发现多了一行数据。一个事务前后两次读取数据不一致，是由于其他事务插入数据造成的，这种情况叫做<strong>幻读</strong>。</p><p>不可重复读和幻读的区别在哪里？修改或删除造成的读不一致叫做不可重复读，插入造成的读叫做幻读。</p><p>这里有两点需要说明：</p><ol><li><p>一个事务读取到其他事务最新提交的数据，这不是正常的吗？当然是正常的，所以这里讨论的是读一致性。读一致性的意义就是一个事务的select操作跟其他事务没有瓜葛，你不需要修改数据，所以不需要获取最新的数据，这样能够提高并发性能。</p></li><li><p>如果在第一个事务中，select以后，再执行一个update，就能获取到第二个事务的最新数据，这个怎么解释？同样的，这个页脱离了读一致性的讨论范畴。如果要修改数据。必然会读取到最新的数据，也会影响其他的事务。</p></li></ol><p>所以这里要不要修改，要不要读取到最新的数据，是一个区别点。目前我们讨论的都是一个事务中多次重复读取。</p><p>​    小结：无论是脏读，不可重复读，幻读，他们都是数据库的读一致性问题，都是在一个事务中前后两次读取出现了不一致的情况。读一致性的前提，必须要由数据库提供一定的事务隔离机制来解决。就像我们去饭店吃饭，基本的设施和卫生保证都是饭店提供的。那么我们使用的数据库，隔离性的问题页必须由数据库帮助我们解决。</p><h3 id="1-7SQL92标准事务隔离级别定义"><a href="#1-7SQL92标准事务隔离级别定义" class="headerlink" title="1.7SQL92标准事务隔离级别定义"></a>1.7SQL92标准事务隔离级别定义</h3><p>​    美国国家标准协会（ANSI）制定了一个SQL标准，也就是说建议数据库厂商都按照这个标准，提供一定的事务隔离级别，来解决事务并发的问题。这个SQL标准有很多版本，大家最熟悉的是SQL92标准。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/4.png"></p><p>​    这个表格里面定义了四个隔离级别，右边P1 P2 P3计师代表事务并发的3个问题，脏读，不可重复读，幻读。Possible代表在这个隔离级别下，这个问题有可能发生，换句话说就是没有解决这个问题。Not Possiable就是解决了这个问题。</p><p>我们详细的分析这4个隔离级别是怎么定义的。</p><ol><li><p>Read Uncommitted（未提交读），一个事务可以读取到其他事务为提交的数据，会出现脏读，所以叫做RU，没有解决任何问题。</p></li><li><p>Read Commited（已提交读），就是一个事务只能读取到其他事务已提交的数据，不能读取其他事务未提交的数据，解决了脏读的问题，但是会出现不可重复读的问题。</p></li><li><p>Repeatable Read（可重复读），它解决了不可重复读的问题，也就是在同一事务中多次读取的数据结果是一样的，但是没有解决幻读的问题</p></li><li><p>Serializable（串行化），这个隔离级别下，所有的事务都是串行执行的，也就是对数据的操作需要排队，已经不存在事务的并发操作了，所以它解决了所有问题。</p></li></ol><p>事务的隔离级别是可以修改的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level read uncommitted;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level read committed;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level repeatable read;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level serializable;<br></code></pre></td></tr></table></figure><p>​    这个是SQL92的标准，但是不同的数据库厂商或者存储引擎的实现有一定的差异，比如Oracle中就只有两种RC（已提交读）和Serializable（串行化）。</p><h3 id="1-8-InnoDB事务隔离级别的实现"><a href="#1-8-InnoDB事务隔离级别的实现" class="headerlink" title="1.8 InnoDB事务隔离级别的实现"></a>1.8 InnoDB事务隔离级别的实现</h3><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读(Read Uncommitted)</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>已提交读(Read Committed)</td><td><em>不可能</em></td><td>可能</td><td>可能</td></tr><tr><td>可重复读(Repeatable Read)</td><td><em>不可能</em></td><td><em>不可能</em></td><td><em><strong>对InnoDB不可能</strong></em></td></tr><tr><td>串行化(Serializable)</td><td><em>不可能</em></td><td><em>不可能</em></td><td><em>不可能</em></td></tr></tbody></table><p>​    InnoDB支持的4个隔离级别和SQL92定义的完全一致，隔离级别越高，事务的并发度越低。唯一的区别是InnoDB在RR级别就解决了幻读的问题。也就是说不需要使用串行话去解决所有问你题，既保证了数据的一致性，又支持较高的并发度，这个就是InnoDB默认使用RR作为事务隔离级别的原因。</p><h3 id="1-9-读一致性解决方案"><a href="#1-9-读一致性解决方案" class="headerlink" title="1.9 读一致性解决方案"></a>1.9 读一致性解决方案</h3><p>​    如果要解决读一致性的问题，保证一个事务中前后两次读取数据结果一致，实现事务隔离，总体上有以下两大类方案。</p><h4 id="1-9-1-LBCC"><a href="#1-9-1-LBCC" class="headerlink" title="1.9.1 LBCC"></a>1.9.1 LBCC</h4><p>​    既要保证前后两次读取数据一致，那么我读取数据时锁定我要操作的数据，不允许其他的事务修改就行了。这种方案叫做基于锁的并发控制Lock Based Concurrency Control（LBCC）。</p><p>​    如果仅仅是基于锁来实现事务隔离，一个事务读取得时候不允许其他事务修改，那就意味着不支持并发得读写操作，而我们得大多数应用都是读多写少得，这样会极大得影响操作数据得效率。</p><h4 id="1-9-2-MVCC"><a href="#1-9-2-MVCC" class="headerlink" title="1.9.2 MVCC"></a>1.9.2 MVCC</h4><p>​    第二种，如果要让一个事务前后两次读取得数据保持一致，那么我们可以在修改数据之前给它建立一个备份或者快照，后面再来读取这个快照就行了。这种方案我们叫做多版本的并发控制Multi Version Concurrency Control（MVCC）。MVCC的原则：</p><p>一个事务能看到的数据版本：</p><ol><li><p>第一次查询之前已经提交的事务的修改</p></li><li><p>本事务的修改</p></li></ol><p>一个事务不能看见的数据版本：</p><ol><li><p>在本事务第一次查询之后创建的事务（事务ID比本事务ID大）</p></li><li><p>活跃的（未提交的）事务的修改</p></li></ol><p>​    MVCC的效果：我们可以查到在我这个事务之前已经存在数据，即使它在后面被修改删除了，而在我这个事务之后新增的数据，我是查不到的。所以我们才把这个叫做快照，不管别的事务做任何增删改查的操作，它只能看到第一次查询时看到的数据版本。</p><p>​    分析一下MVCC的原理。首先，InnoDB的事务都是由编号的，而且会不断递增。InnoDB为每行记录都实现了两个隐藏字段：</p><p>​    1.DB_TRX_ID，6字节：事务id，数据是在哪个事务插入或者修改为新数据的，就记录为当前事务ID。</p><p>​    2.DB_ROLL_PTR，7字节：回滚指针，我们把它理解为删除版本号，数据被删除或记录为旧数据时，记录当前事务ID，没有修改或者删除的时候是空。</p><table><thead><tr><th>id</th><th>name</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th></tr></thead><tbody><tr><td>1</td><td>aaa</td><td>01</td><td>NULL</td></tr></tbody></table><p>当第一个事务，初始化数据（检查初始数据）</p><table><thead><tr><th>Transaction 1</th></tr></thead><tbody><tr><td>begin; <br />insert into mvcctest values(null, ‘qs’);<br />insert into mvcctest values(null, ‘hh’);<br />commit;</td></tr></tbody></table><p>此时的数据，创建版本是当前事务ID（假设事务编号是1），删除版本为空：</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>qh</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>hh</td><td>1</td><td>undefined</td></tr></tbody></table><p>第二个事务，执行第一次查询，读取到两条原始数据，这时事务ID是2：</p><table><thead><tr><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;<br />select * from mvcctest; –(1)第一次查询</td></tr></tbody></table><p>第三个事务，插入数据：</p><table><thead><tr><th>Transaction 3</th></tr></thead><tbody><tr><td>begin;<br />insert into mvcctest values(NULL, ‘tom’);<br />commit</td></tr></tbody></table><p>此时的数据，多了一条tom，它的创建版本号是当前事务编号，3：</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>qs</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>hh</td><td>1</td><td>undefined</td></tr><tr><td>3</td><td>tom</td><td>3</td><td>undefined</td></tr></tbody></table><p>第二个事务，执行第二次查询：</p><table><thead><tr><th>Transaction 2</th></tr></thead><tbody><tr><td>select * from mvcctest;  –(2)第二次查询</td></tr></tbody></table><p>​    MVCC的查找原则：只能查找创建时间小于等于当前事务ID的数据，和删除时间大于当前事务ID的行（或未删除）。也就是不能查到在我的事务开始之后插入的数据，tom的创建ID大于2，所以还是只能查到两条数据。</p><p>第四个事务，删除数据，删除了id=2 hh这条记录：</p><table><thead><tr><th>Transaction 4</th></tr></thead><tbody><tr><td>begin;<br />delete from mvcctest where id=2;<br />commit;</td></tr></tbody></table><p>此时的数据，hh的删除版本被记录为当前事务ID，4，其他数据不变：</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>qs</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>hh</td><td>1</td><td>4</td></tr><tr><td>3</td><td>tom</td><td>3</td><td>undefined</td></tr></tbody></table><p>在第二个事务中，执行第三次查询：</p><table><thead><tr><th>Transaction 2</th></tr></thead><tbody><tr><td>select * from mvcctest; (3)第三次查询</td></tr></tbody></table><p>​    查找规则：只能查找创建时间小于等于当前事务ID的数据，和删除时间大于当前事务ID的行（或未删除）。也就是，在我事务开始之后删除的数据，所以huihui依然可以查出来。所以还是查出两条数据。</p><p>​    第五个事务，执行更新操作，这个事务ID是5：</p><table><thead><tr><th>Transaction 5</th></tr></thead><tbody><tr><td>begin;<br />update mvcctest ser name = ‘盆玉艳’ where id= 1;<br />commit;</td></tr></tbody></table><p>此时的数据，更新数据时，旧数据的删除版本被记录为当前事务ID5（undo），产生了一条新数据，创建ID为当前事务ID5：</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>qs</td><td>1</td><td>5</td></tr><tr><td>2</td><td>hh</td><td>1</td><td>4</td></tr><tr><td>3</td><td>tom</td><td>3</td><td>undefined</td></tr><tr><td>1</td><td>盆玉艳</td><td>5</td><td>undefined</td></tr></tbody></table><p>第二个事务，执行第四次查询：</p><table><thead><tr><th>Transaction 2</th></tr></thead><tbody><tr><td>select * from mvcctest; (4)第四次查询</td></tr></tbody></table><p>​    查找规则：只能查找创建时间小于等于当前事务ID的数据，和删除时间大于当前事务ID的行（或未删除）。因为更新后的数据盆鱼宴创建版本大于2，代表是在事务之后增加的，查不出来。而旧数据qingshan的删除版本大于2，代表是在事务之后删除的，可以查出来。</p><p>​    通过以上演示可以看到，通过版本号的控制，无论其他事务是插入，修改，删除，第一个事务查询到的数据都没有变化。这个是MVCC的效果，当然，这里是一个简化的模型。假设一条数据修改了3次，两次提交了一次未提交，每次修改之后都有开启一个事务去查询，那么事务2，4，6查到的数据会有不一样。</p><table><thead><tr><th>trx_id</th><th>SQL</th></tr></thead><tbody><tr><td>trx1</td><td>update user_info set name = ‘penyuyan’ where id =1;<br />commit;</td></tr><tr><td>trx2</td><td>select name from user_info where id = 1;</td></tr><tr><td>trx3</td><td>update user_info set name=’wuyanzu’ where id = 1; <br />commit;</td></tr><tr><td>trx4</td><td>select name from user_info where id = 1;</td></tr><tr><td>trx5</td><td>update user_info set name=’liudehua’ where id = 1;  <br />未提交</td></tr><tr><td>trx6</td><td>select name from user_info where id = 1;</td></tr><tr><td></td><td>trx2、4、6再各查一次</td></tr></tbody></table><p>​    InnoDB中，一条数据的旧版本，是存放在undo log中。因为修改了多次，这些undo log回形成一个链条，叫做undo log链，现在undo log中有刘德华，吴彦祖，盆鱼宴。所以前面说的DB_ROLL_PTR，它其实指向undo log链的指针。</p><p>​    第二个问题，事务2，4，6最后再查一次，他们去undo log链找数据时。拿到的数据是不一样的。再这个undo log链里面，一个事务怎么判断哪个版本的数据是它应该读取的？</p><p>回想一下MVCC的规则：</p><p>一个事务能看到的数据版本：1，第一次查询之前已经提交的事务的修改；2，本事务的修改。</p><p>一个事务不能看到的数据版本：1，本事务第一次查询之后创建的事务（事务ID比我的事务ID大）；2，活跃的（未提交的）事务的修改。</p><p>​    所以，必须要有一个数据结构，把本事务ID，活跃事务ID，当前系统最大事务ID存起来，这样才能实现判断。这个数据结构叫Read View（可见性视图），每个事务都维护一个自己的Read View。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/6.png"></p><p><em>m_ids</em>：表示在生成ReadView时当前系统活跃的读写事务的事务id列表。</p><p><em>min_trx_id</em>：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务ID，也就是m_ids中的最小值。</p><p><em>mmax_trx_id</em>：表示生成ReadView时系统中应该分配给下一个事务的id值。</p><p><em>creator_trx_id</em>：表示生成该ReadView的事务的事务id。</p><p>有了这个数据结构后，事务判断可见性的规则是这样的：</p><p>0，从数据的最早版本开始判断（undo log）。</p><p>1，数据版本的trx_id = creator_trx_id，本事务修改，可以访问。</p><p>2，数据版本的trx_id &lt; min_trx_id（未提交事务的最小ID），说明这个版本是生成ReadView已经提交，可以访问。</p><p>3，数据版本的trx_id &gt; max_trx_id（下一个事务ID），这个版本是生成ReadView之后才开启的事务建立的，不能访问。</p><p>4，数据版本的trx_id在min_trx_id和max_trx_id之间，看看是否在m_ids中。如果在，不可以。如果不在，可以。</p><p>5，如果当前版本不可见，就找undo log链中的下一个版本。</p><p>​    注意：RR中ReadView是事务第一次查询时建立的。RC的ReadView是事务每次查询的时候建立的。Oracle，Postgres等等其他数据库都有MVCC实现。需要注意，在InnoDB中，MVCC和锁是协同使用的，这两种方式并不是互斥的。</p><h2 id="2-InnoDB锁的基本类型"><a href="#2-InnoDB锁的基本类型" class="headerlink" title="2 InnoDB锁的基本类型"></a>2 InnoDB锁的基本类型</h2><h3 id="2-1-锁的粒度"><a href="#2-1-锁的粒度" class="headerlink" title="2.1 锁的粒度"></a>2.1 锁的粒度</h3><p>​    InnoDB和MyISAM支持的锁的类型是不同的。InnoDB同时支持表锁和行锁，MySIAM只支持表锁，用lock table的语法加锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">lock talbes xxx read;<br>lock tables xxx write;<br>unlock tables;<br></code></pre></td></tr></table></figure><h3 id="2-2-锁的类型"><a href="#2-2-锁的类型" class="headerlink" title="2.2 锁的类型"></a>2.2 锁的类型</h3><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html</a></p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/7.png"></p><p>​    官网把锁分成了8类。把前面的两个行级别锁（Shared and Exclusive Locks），和两个表级别的锁（Intention Locks）称为锁的基本模式。后面三个Record Locks，Gap Locks，Next-Key Locks，我们把它们叫做锁的算法。</p><p>​    插入意向锁（Insert Intention Locks）：是一个特殊的间隙锁。间隙锁不允许插入数据，但是插入意向锁允许多个事务同时插入数据到同一个范围，比如（4，7），一个事务插入5，一个事务插入6，不会发生锁等待。</p><p>​    自增锁（AUTO-INC Locks）：是一种特殊的表锁，用来防止自增字段重复，数据插入以后就会释放，不需要等到事务提交才释放。如果需要选择更快的子增值生成速度或者更加连续的子增值，就要通过修改自增锁的模式改变。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_autoinc_lock_mode&#x27;</span><br></code></pre></td></tr></table></figure><p>​    0：traditional（每次都会产生表锁）</p><p>​    1：consecutive（会产生一个轻量锁，simple insert会获得批量的锁，保证连续插入，默认值）</p><p>​    2：interleaved（不会锁表，来一个处理一个，并发最高）</p><p>​    Predicate Locks for Spatial Indexes是5.7版本中新增的一种数据类型的索引的锁。</p><h3 id="2-3-共享锁"><a href="#2-3-共享锁" class="headerlink" title="2.3 共享锁"></a>2.3 共享锁</h3><p>​    第一个行级别的锁就是Shared Locks（共享锁），获取了一行数据的读锁以后，可以用来读取数据，所以也叫做读锁，注意不要在加上了读锁以后去写数据，不然的话可能会出现死锁的情况。而且多个事务可以共享一把读锁。共享锁的作用：因为共享锁会阻塞其他事务的修改，所以可以用在不允许其他事务修改数据的情况（共享锁和写锁互斥的例子后面再看）。我们可以用select …… lock in share mode；的方式手工加上一把读锁。释放锁有两种方式，只要事务结束就会自动释放锁，包括提交事务和结束事务</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from student where id =1 lock in share mode;</td><td></td></tr><tr><td></td><td>begin;</td></tr><tr><td></td><td>select * from student where id = 1 lock in share mode;  <br />//OK</td></tr></tbody></table><h3 id="2-4-排他锁"><a href="#2-4-排他锁" class="headerlink" title="2.4 排他锁"></a>2.4 排他锁</h3><p>​    第二个行级别的锁叫做Exclusive Locks（排他锁），它是用来操作数据的，所以又叫做写锁。只要一个事务获取了一行数据的排他锁，其他事务就不能再获取这一行数据的共享锁和排他锁。加锁的方式有两种，第一种是自动加排他锁，增删改都会默认加上一个排他锁。还有一种是手工加锁，我们用一个FOR UPDATE给一行数据加上一个排他锁，这个无论是在我们的代码中还是操作数据的工具中都比较常用。释放锁和前面是一样的。</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>update student set sname=’fdasfd’ where id = 1;</td><td></td></tr><tr><td></td><td>begin;</td></tr><tr><td></td><td>select * from student where id=1 lock in share mode;  //blocked <br />select * from student where id=1 for update; //blocked   <br />delete from student where id=1 //blocked</td></tr></tbody></table><h3 id="2-5-意向锁"><a href="#2-5-意向锁" class="headerlink" title="2.5 意向锁"></a>2.5 意向锁</h3><p>​    意向锁是由数据库自己维护的。也就是说，当我们给一行数据加上共享锁之前，数据库会自动在这张表上面加上意向共享锁。当我们给一行数据加上排他锁之前，数据库会自动在这张表上面加上一个意向排他锁。反过来，如果一张表上至少有一个意向共享锁，说明其他事务给其中的某些数据加上了共享锁；如果表上至少有一个意向排他锁，说明其他事务给其中的某些数据行加上了排他锁。</p><p>​    意向锁和意向锁是不冲突的，意向锁和行锁也不冲突。那么这两个表级别的锁有什么意义？如果没有意向锁的话，当我们准备给一张表加上表锁时，我们首先需要去判断有没有其他事务锁定了某些行，如果有的话，肯定不能加上表锁。那么这时我们就要去扫描整张表才能确定能不能成功加上一个表锁，如果数据量很大，那么加表锁的效率就非常低。但是我们引入意向锁后就不一样了，我们只要判断这张表上是否有意向锁，如果有直接返回失败。如果没有就可以加锁成功。所以InnoDB中的表锁，我们可以把它理解为一个标志（就像火车上卫生间有没有使用的灯），是用来提高加锁效率的。</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from student where id=1 for update;</td><td></td></tr><tr><td></td><td>beginl</td></tr><tr><td></td><td>lock tables student write; //blocked <br />unlock tables; //释放表锁的方式</td></tr></tbody></table><p>​    数据库锁跟java中的锁是一样的，是为了解决资源竞争的问题，java中的资源是对象，数据库的资源是数据表或者数据行。所以锁是用来解决事务对数据的并发访问问题的。</p><h2 id="3-行锁的原理"><a href="#3-行锁的原理" class="headerlink" title="3 行锁的原理"></a>3 行锁的原理</h2><p>​    有三张表，一张没有索引的t1，一张有主键索引的t2，一张有唯一索引的t3</p><p><strong>1.没有索引的表（假设锁住记录）</strong></p><p>​    假设InnoDB的行锁是锁住了一行数据或者一条记录。先看一下t1的表结构，它有两个字段，int类型的id和varchar类型的name。里面有4条数据1，2，3，4。</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from t1 where id = 1 for update;</td><td></td></tr><tr><td></td><td>select * from t1 where id=3 for update;  //blocked</td></tr><tr><td></td><td>insert into ‘t1’(‘id’,’name’) values(5, ‘5’);  //blocked</td></tr></tbody></table><p>​    在两个会话中手工开启两个事务。第一个事务中我们通过where id = 1锁住第一行数据。第二个事务中，我们尝试给id=3的这一行数据加锁，被阻塞。插入一条id=5的数据，被阻塞。结果第二个事务的加锁操作被阻塞了，说明<strong>InnoDB的行锁锁住的不是Record</strong>。那为啥在没有索引或者没有用到索引的情况下，会锁住整张表？这个问题后续解释。</p><p><strong>2.有主键索引的表</strong></p><p>​    t2的表结构。字段是一样的，不同的地方是id上创建了一个主键索引。里面的数据是1，4，7，10.</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from t2 where id = 1 for update;</td><td></td></tr><tr><td></td><td>select * from t2 where id=1 for update;  //blocked</td></tr><tr><td></td><td>select * from t2 where id=4 for update  //OK</td></tr></tbody></table><p>第一种情况，使用相同的id值去加锁，冲突；使用不同的id加锁，加锁成功。</p><p><strong>3.唯一索引（假设锁住字段）</strong></p><p>t3的表结构。字段还是一样的，id上创建了一个主键索引，name上创建了一个唯一索引。里面数据1，4，7，10.</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from t3 where name=’4’ for update;</td><td></td></tr><tr><td></td><td>select * from t3 where name=’4’ for update;  //blocked</td></tr><tr><td></td><td>select * from t3 where id=4 for update  //blocked</td></tr></tbody></table><p>​    第一个事务中我们通过name字段去锁定值是4的数据。第二个事务中尝试获取一样的排他锁，失败。然后用id=4去给这行数据加锁，被阻塞，说明行锁锁住字段的推测也是错的。</p><p>​    既然锁住的不是record，也不是column，InnoDB的行锁到底锁住了什么？在这三个案例中，他们的差异就在于表结构，其实答案就是索引，InnoDB的行锁是**通过锁住索引实现的。还有两个问题没有解决：</p><p>​    1.为什么表中没有索引的时候，锁住一行数据会导致锁表？因为查询没有使用索引，会进行全表扫描，然后把每一个隐藏的聚集索引都锁住了。</p><p>​    2.为什么通过唯一索引给数据行加锁，主键索引也会被锁住？因为我们通过辅助索引锁定一行数据时，它跟我们检索数据的步骤是一样的，会通过主键值找到主键索引，然后也锁定。本质上是因为锁定的是同一行数据，是相互冲突的。</p><h2 id="4-行锁的算法"><a href="#4-行锁的算法" class="headerlink" title="4  行锁的算法"></a>4  行锁的算法</h2><p>​    我们先看一下测试用表t2，其中有个主键，插入4行数据，主键id分别是1，4，7，10.</p><p>​    首先，先普及一下三种范围的概念。因为我们用主键索引加锁，我们这里划分标准就是主键索引的值。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/9.png"></p><p>​    这些数据库中存在的主键值，我们把它叫做Record，记录，那么我们这里就有4个Record。根据主键，这些存在的Record隔开的数据不存在的区间，我们叫做Gap，间隙，它是一个左开右开的区间。假如我们有N个Record，那么我们就有N+1个Gap。最后一个，间隙（Gap）连同它左边的记录（Record），我们把它叫做临键的区间，它是左开右臂=闭得区间。整型的主键索引，它是可以排序的，所以才有这种区间，如果我的主键索引不是整型，是字符怎么办？任何一个字符集，都有相应得排序规则：</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/10.png"></p><h3 id="4-1-记录锁-Record-Locks"><a href="#4-1-记录锁-Record-Locks" class="headerlink" title="4.1 记录锁(Record Locks)"></a>4.1 记录锁(Record Locks)</h3><p>​    当对于唯一性的索引（包括唯一索引和主键索引）使用等值查询，精准匹配到一条记录的时候，这时使用的就是记录锁。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/11.png"></p><p>​    使用不同的key去加锁，不会冲突，它只锁住这个record。图片上红的字就是使用这种锁的条件。</p><h3 id="4-2-间隙锁-Gap-Locks"><a href="#4-2-间隙锁-Gap-Locks" class="headerlink" title="4.2 间隙锁(Gap Locks)"></a>4.2 间隙锁(Gap Locks)</h3><p>​    当查询的记录不存在，没有命中任何一个record，无论是用等值查询还是范围查询时，它使用的都是间隙锁。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/12.png"></p><p>​    举个例子，where id &gt; 4 and id &lt; 7, where id = 6。</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from t2 where id=6 for update;</td><td></td></tr><tr><td></td><td>insert into ‘t2’(‘id’,’name’) values(5,’6’); //blocked<br />insert into ‘t2’(‘id’,’name’) values(6,’6’); //blocked <br />select * from t2 where id=6 for update; //OK</td></tr><tr><td>select * from t2 where id &gt; 20 for update;</td><td></td></tr><tr><td></td><td>insert into ‘t2’(‘id’,’name’) values(11,’6’); //blocked</td></tr></tbody></table><p>当查询不存在时使用间隙锁。注意，间隙锁主要是阻塞插入insert，相同的间隙锁之间不冲突。</p><h3 id="4-3-临键锁-Next-Key-Locks"><a href="#4-3-临键锁-Next-Key-Locks" class="headerlink" title="4.3 临键锁(Next-Key Locks)"></a>4.3 临键锁(Next-Key Locks)</h3><p>​    当我使用了范围查询，不仅仅命中了Record记录，还包含了Gap间隙，在这种情况下我们使用的就是临键锁，它是Mysql中默认的行锁算法，相当于记录锁加上间隙锁。唯一性索引，等值查询匹配到一条记录时退化为记录锁。没有匹配到记录时退化成间隙锁。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/13.png"></p><p>​    比如使用&gt;5，&lt;9，它包含了记录不存在的区间，也包含了一个Record 7.</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select from t2 where id&gt;5 and id&lt;9 for update</td><td></td></tr><tr><td></td><td>begin;</td></tr><tr><td></td><td>select * from t2 where id=4 for update;  //OK<br />insert into ‘t2’(‘id’,’name’) values(6, ‘6’); //blocked <br />insert into ‘t2’(‘id’,’name’) values(8, ‘6’); //blocked <br />select * from t2 where id=10 for update; //blocked</td></tr></tbody></table><p>​    临键锁，锁住最后一个key的下一个左开右闭区间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t2 <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">7</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>; <span class="hljs-comment">--锁住(4,7] 和(7,10]</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t2 <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">8</span> <span class="hljs-keyword">and</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>; <span class="hljs-comment">--锁住(7,10] 和(10,正无穷)</span><br></code></pre></td></tr></table></figure><p>为什么要锁住下一个左开右闭区间？就是为了解决幻读的问题。</p><h3 id="4-4-InnoDB事务隔离级别的实现"><a href="#4-4-InnoDB事务隔离级别的实现" class="headerlink" title="4.4 InnoDB事务隔离级别的实现"></a>4.4 InnoDB事务隔离级别的实现</h3><p>​    所以，InnoDB的RR级别能够解决幻读的问题，就是用临键锁实现的。</p><p>​    最后总结一下四个事务隔离级别的实现：</p><p>​    1.Read Uncommited：RU隔离级别，不加锁</p><p>​    2.Serializable：所有的select语句都会被隐式的转化为select ……in share mode，会和update，delete互斥。</p><p>​    3.Repeatable Read：RR隔离级别下，普通的select使用快照读（snapshot），底层使用MVCC来实现。加锁的select（select … in share mode/select …for update）以及更新操作update，delete等语句使用当前读（current read），底层使用记录锁，或者间隙锁或者临键锁。</p><p>​    4.Read Commited：RC隔离级别下，普通的select都是快照读（MVCC）。加锁的select都使用记录锁，因为没有Gap Lock。除了两种特殊情况——外键约束检查（foreign-key constraint checking）以及重复键检查（duplicate-key checking）时会使用间隙锁封锁区间，所以RC会出现幻读问题。</p><h2 id="5-事务隔离级别的选择"><a href="#5-事务隔离级别的选择" class="headerlink" title="5 事务隔离级别的选择"></a>5 事务隔离级别的选择</h2><p>​    RU和Serializable肯定不能使用。为什么有些公司要用RC？</p><p>​    RC和RR主要有几个区别：</p><p>​    1.RR的间隙锁会导致锁定范围的扩大。</p><p>​    2.条件列未使用到索引，RR锁表，RC锁行</p><p>​    3.RC的“半一致性”（semi-consistent）读可以增加update操作的并发性。</p><p>​    在RC中，一个update语句，如果督导一行已经加锁的记录，此时InnoDB返回记录最近提交的版本，由MySQL上层判断此版本是否满足update的where条件。若满足（需要更新），则MuSQLhi重新发起一次读操作，此时会读取行的最新版本（并加锁）。</p><p>​    实际上，如果能够正确的使用锁（避免不使用索引去加锁），只锁定需要的数据，用默认的RR级别就可以了。在我们使用锁的时候，有个问题时需要注意和避免的，我们知道，排他锁由互斥的特性。一个事务或者说一个线程持有锁时，会阻止其他的线程获取锁，这时会造成阻塞等待，如果训话等待，会有可能造成死锁。</p><h2 id="6-死锁"><a href="#6-死锁" class="headerlink" title="6 死锁"></a>6 死锁</h2><h3 id="6-1-锁的释放与阻塞"><a href="#6-1-锁的释放与阻塞" class="headerlink" title="6.1 锁的释放与阻塞"></a>6.1 锁的释放与阻塞</h3><p>​    锁是在事务结束（commit，rollback）或者客户端断开连接的时候释放。控制锁的等待时间，默认是50秒</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_lock_wait_timeout&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="6-2-死锁的发生与检测"><a href="#6-2-死锁的发生与检测" class="headerlink" title="6.2 死锁的发生与检测"></a>6.2 死锁的发生与检测</h3><p>​    在发生死锁时，InnoDB一般通过算法（wait-for graph）自动检测到。 死锁产生的条件：</p><p>​    （1）同一时刻只能有一个事务持有这把锁</p><p>​    （2）其他事务需要在这个事务释放锁之后才能获取锁，而不可以强行剥夺</p><p>​    （3）当多个事务形成等待环路的时候，即发生死锁。</p><p>​    实际上，发生死锁的原因很多，但是都满足以上3个条件这个也是表锁是不会发生死锁的原因，因为表锁的资源都是一次性获取的。</p><h3 id="6-3-查看锁信息（日志）"><a href="#6-3-查看锁信息（日志）" class="headerlink" title="6.3 查看锁信息（日志）"></a>6.3 查看锁信息（日志）</h3><p>首先，SHOW STATUS命令中，包括了一些行锁的信息。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/15.png"></p><p>Show命令是一个概要信息。InnoDB还提供了三张表来分析事务与锁的情况：</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/16.png"></p><p>更加详细的锁信息，开启标准监控和锁监控：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> innodb_status_output<span class="hljs-operator">=</span><span class="hljs-keyword">ON</span>;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> innodb_status_output_locks<span class="hljs-operator">=</span><span class="hljs-keyword">ON</span>;<br></code></pre></td></tr></table></figure><p>​    如果一个事务长时间持有锁不释放，可以kill事务对应的线程ID，也就是INNODB_TRX表中的trx_mysql_thread_id。当然，死锁的问题不能每次都靠kill解决，我们应该尽量在编码的过程中避免。</p><h3 id="6-4-死锁的避免"><a href="#6-4-死锁的避免" class="headerlink" title="6.4 死锁的避免"></a>6.4 死锁的避免</h3><p>​    （1）在程序中，操作多张表时，尽量以相同的顺序来访问（避免形成等待环路）</p><p>​    （2）批量操作单张表数据时，先对数据进行排序（避免形成等待环路）</p><p>​    （3）申请足够级别的锁，如果要操作数据，就申请排他锁</p><p>​    （4）尽量使用索引访问数据，避免没有where条件的操作，避免锁表</p><p>​    （5）如果可以，大事务化成小事务</p><p>​    （6）使用等值查询而不是范围查询查询数据，命中记录，避免间隙锁对并发的影响。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引</title>
    <link href="/2023/02/16/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E7%B4%A2%E5%BC%95/"/>
    <url>/2023/02/16/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-索引含义"><a href="#1-索引含义" class="headerlink" title="1.索引含义"></a>1.索引含义</h2><h3 id="1-1-索引图解"><a href="#1-1-索引图解" class="headerlink" title="1.1 索引图解"></a>1.1 索引图解</h3><p>​    数据库索引是数据库管理系统（DBMS）中一个排序的数据结构，以协助快速查询，更新数据库表中数据。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/1.png"></p><p>​    数据是以文件的形式存放在磁盘上面的，每一行数据都有它的磁盘地址。如果没有索引的话，我们要从500万行数据里面检索一条数据，只能一次遍历这张表的全部数据，直到找到这条数据。但是有了索引后，只需要在索引中去检索这条数据就行了，因为它是一种特殊的专门用来快速检索的数据结构，我们找到数据存放的磁盘地址，就可以拿到数据了。</p><h3 id="1-2-索引类型"><a href="#1-2-索引类型" class="headerlink" title="1.2 索引类型"></a>1.2 索引类型</h3><p>​    打开navicat工具，右键设计表，在索引的这个选项卡里面，可以创建索引。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/2.png"></p><p>​    在InnoDB中，索引类型有三种：普通索引，唯一索引（主键索引是特殊的唯一索引），全文索引。</p><p>​    <em>普通（Normal）</em>：也叫非唯一索引，是最普通的索引，没有任何限制。</p><p>​    <em>唯一（Unique）</em>：唯一索引要求键值不能重复，另外注意的是，主键索引是一种特殊的唯一索引，它还多了一个限制条件是键值不能为空。主键索引引用primary key创建。</p><p>​    <em>全文（Fulltext）</em>：针对比较大的数据，比如我们存放的是消息内容，一篇文章，有几KB的数据的这种情况，如果要解决like查询在全文匹配时效率低的问题，可以创建全文索引。只有文本类型的字段才可以创建全文索引，比如char，varchar，text。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;fulltext_test&#x27;</span> (<br><span class="hljs-string">&#x27;content&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>    FULLTEXT KEY <span class="hljs-string">&#x27;content&#x27;</span>(<span class="hljs-string">&#x27;content&#x27;</span>)<br>)<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> fulltext_test <span class="hljs-keyword">where</span> <span class="hljs-keyword">match</span>(content) against(<span class="hljs-string">&#x27;咕泡学院&#x27;</span><span class="hljs-keyword">IN</span> <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">LANGUAGE</span> MODE)<br></code></pre></td></tr></table></figure><p>​    MyISAM和InnoDB支持全文索引。</p><h2 id="2-索引存储模型推演"><a href="#2-索引存储模型推演" class="headerlink" title="2. 索引存储模型推演"></a>2. 索引存储模型推演</h2><h3 id="2-1-二分查找（折半查找）"><a href="#2-1-二分查找（折半查找）" class="headerlink" title="2.1 二分查找（折半查找）"></a>2.1 二分查找（折半查找）</h3><p>​    每一次查找，都把候选数据缩小了一半，如果数据排过序的话，这种效率更高。所以第一个，我们可以考虑用有序数组作为索引的数据结构。有序数组的等值查询和比较查询效率非常高，但是更新数据时会出现一个问题，可能要挪动大量的数据（改变index），所以只适合存储静态的数据。为了支持频繁的修改，我们需要采用链表。链表的话，如果是单链表，它的查找效率还是不够高。所以为了解决这个问题出现二叉查找树BST（Binary Search Tree）出现了。</p><h3 id="2-2-二叉查找树"><a href="#2-2-二叉查找树" class="headerlink" title="2.2 二叉查找树"></a>2.2 二叉查找树</h3><p>​    二叉查找树的特点：左子树节点都小于父节点，右子树节点都大于父节点。投影到平面就是一个有序的线性表。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/3.png"></p><p>​    二叉查找树既能够实现快速查找，又能实现快速插入，但是它有个问题：它的查找耗时是和这棵树的深度相关的，在最坏的情况下时间复杂度会退化成O(n)。还是刚才这一批数字，如果插入的数据刚好是有序的，它就会变成链表（斜树），这种情况下不能达到加快检索速度的目的，和顺序查找效率是没有区别的。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/4.png"></p><h3 id="2-3-平衡二叉树-AVL-Tree-左旋右旋"><a href="#2-3-平衡二叉树-AVL-Tree-左旋右旋" class="headerlink" title="2.3 平衡二叉树(AVL Tree)(左旋右旋)"></a>2.3 平衡二叉树(AVL Tree)(左旋右旋)</h3><p>​    平衡二叉树解决了二叉树平衡的问题。索引必须要存你建立的字段的值，叫做键值，比如id的值。还要存完整记录在磁盘上的地址。由于AVL是二叉树，所以还要额外的存储左右子树的指针。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/5.png"></p><p>如图：</p><p>第一个是索引的键值，比如我们在id上面创建了一个索引，我在用where id = 1的条件查询时就会找到索引里面的id的这个键值。</p><p>第二个是数据的磁盘地址，因为索引的作用就是去查找数据存放的地址。</p><p>第三个，因为是二叉树，它必须还要有左右子节点的引用，这样我们能才能找到下个子节点。</p><p>​    当用树的结构了存储索引时，访问一个节点就要和磁盘间发生一次io操作。InnoDB操作磁盘的最小单位是一页（或者叫一个数据块，大小是16K）。那么，一个树的结点必须设计成16K的大小，不然就会出现读不完或者读不够的情况。如果一个节点只存一个键值+数据+引用，可能只用了十几个或者几十个字节，远远达不到16K的容量。我们基于索引查找数据时，肯定是希望一次从磁盘中加载很多的数据到内存中，如果一个节点只存1个这样的单元，就需要读更多的节点，发生更多的IO。</p><p>怎么解决这个问题？第一，  让每个节点存储更多的数据。第二，  节点上的关键字的数量越多，我们的指针数也越多，也就是有更多的分叉（路数），因为分叉越多，树的深度就会减少（根节点是0）。这样树的样子就从高瘦变成矮胖了。这时，时就变成多叉（多路）。</p><h3 id="2-4-多路平衡查找树-B-Tree-分裂合并"><a href="#2-4-多路平衡查找树-B-Tree-分裂合并" class="headerlink" title="2.4 多路平衡查找树(B Tree)(分裂合并)"></a>2.4 多路平衡查找树(B Tree)(分裂合并)</h3><p>​    Balance Tree，跟AVL树一样，B树在节点上存储键值，数据地址，节点引用。它有一个特点：分叉数（路数）永远比关键字数多1，比如下面这棵树，每个节点存储两个关键字，那么就会有三个指针指向三个子节点。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/6.png"></p><p>B Tree的查找规则是什么样的？</p><p>比如要找15：因为15&lt;17，走左边；15&gt;12，走右边，在磁盘7里找到了15，只用了3次IO。</p><p>B Tree是怎样保持平衡的，和AVL有什么区别？</p><p>当路数为3时，我们插入3的时候，本来应该在第一个磁盘块，但是如果一个节点有三个关键字，意味着有4个指针，子节点就会变成4格，所以这个时候就需要分裂。把中间数据2提上去，把1和3变成2的子节点。如果删除节点，会有相反的合并的操作（注意这里的合并和分裂跟AVL中的左右旋是不一样的）。从这里可以看到，在更新索引时会有大量的索引结构的调整，所以解释我们不要在频繁更新的列上加索引，或者不要更新主键。</p><p>节点的分裂和合并，其实就是InnoDB页的分裂和合并。如果索引键值有序，写满一页接着开辟一个新的页，如果索引值无序，存储过程中造成大量的磁盘碎片，带来频繁的page分裂和合并。</p><h3 id="2-5-B-树-加强版多平衡查找树"><a href="#2-5-B-树-加强版多平衡查找树" class="headerlink" title="2.5 B+树(加强版多平衡查找树)"></a>2.5 B+树(加强版多平衡查找树)</h3><p>B+树的存储结构。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/7.png"></p><p>B+树的特点：</p><p>1.它的关键字的数量和路数时相等的</p><p>2.B+树的根节点和枝节点都不会存储数据，只有叶子节点才存储数据，搜索到关键字不会直接返回，会到最后一层的叶子节点才会返回数据。</p><p>3.B+树的每个叶子节点增加了一个指向相邻叶子节点的指针，它的最后一个数据会指向下一个叶子节点的第一个数据，形成了一个有序链表，方便范围查询。</p><p>总结一下，InnoDB的B+tree特性带来的优势：</p><ol><li><p>它是B Tree的变种，B Tree能解决的问题，它都能解决（每个节点存储更多的关键字；路数更多），</p></li><li><p>扫库，扫表能力强（如果我们要对全表进行扫描，只需要遍历叶子节点就可以了，不需要便利整课B+树拿数据）。</p></li><li><p>B+树的磁盘读写能力比B树更强（根节点不保存数据，所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多）。</p></li><li><p>排序能力更强（因为叶子节点有下一个数据区的指针，数据形成了链表）</p></li><li><p>效率更加稳定（B+tree永远只在叶子节点拿数据，所以IO次数时稳定的）。</p></li></ol><h3 id="2-6-为什么不用红黑树？"><a href="#2-6-为什么不用红黑树？" class="headerlink" title="2.6 为什么不用红黑树？"></a>2.6 为什么不用红黑树？</h3><p>红黑树也是BST树，但是不是严格平衡的，通过变色和旋转来保持平衡，必须满足5个约束：</p><ol><li><p>节点为红色或者黑色</p></li><li><p>根节点必须是黑色的</p></li><li><p>叶子节点都是黑色的null节点</p></li><li><p>红色节点的两个子节点都是黑色（不允许两个相邻的红色节点）。</p></li><li><p>从任意节点出发，到每个叶子节点的路径中包含相同数量的黑色节点。</p></li></ol><p>基于以上节点，可以推导出：从根节点到叶子节点的最长路径（红黑相同的路径）不大于最短路径（全部是黑色节点）的2倍。</p><p>为什么不用红黑树？1，只有两路。2，不够平衡。红黑树一般在内存里运用。</p><h3 id="2-7-Hash索引"><a href="#2-7-Hash索引" class="headerlink" title="2.7 Hash索引"></a>2.7 Hash索引</h3><p>HASH：以KV的形式检索数据，也就是说，它会根据字段生成哈希码和指针，指针指向数据。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/8.png"></p><p>Hash索引的特点：</p><ol><li><p>它的时间复杂度是O(1)，查询速度比较快。因为哈希索引里面的数据不是按顺序存放的，所以不能用于排序。</p></li><li><p>我们在查询数据时要根据键值计算哈希码，所以它只能支持等值查询，不支持范围查询。</p></li><li><p>如果字段重复值很多的时候，会出现大量的哈希冲突（采用拉链法解决）效率会降低。</p></li></ol><p>​    在InnoDB中，不能显示的创建一个哈希索引（所谓的支持哈希索引指的是AHI,自适应哈希，它是InnoDB自动为buffer pool中的热点页创建的索引）。Memory存储引擎中可以使用Hash索引。</p><h2 id="3-B-Tree的落地形式"><a href="#3-B-Tree的落地形式" class="headerlink" title="3  B+Tree的落地形式"></a>3  B+Tree的落地形式</h2><p>​    MySQL的数据都是文件形式存放在磁盘的，可以找到这个目录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;datadir&#x27;</span>;<br></code></pre></td></tr></table></figure><p>​    每个数据库都有一个目录，主要关注一下最长用的两个存储引擎，MyISAM和InnoDB的索引的实现。InnoDB的表有两个文件（.frm和.ibd），MyISAM的表有三个文件（.frm，.MYD, .MYI）。其中.frm是Mysql数据库中定义表结构的文件，每一种存储引擎都有。</p><h3 id="3-1-MyISAM"><a href="#3-1-MyISAM" class="headerlink" title="3.1 MyISAM"></a>3.1 MyISAM</h3><p>在MyISAM中有另外两个文件，数据和索引是两个独立的文件：</p><p>​    1.MYD文件，D代表数据，是一个数据文件。</p><p>​    2.MYI文件，I代表index，是索引文件，存放索引</p><p>​    MyISAM的B+Tree中，叶子节点存储的是数据文件对应的磁盘地址。从索引文件中找到键值后，会到数据文件中获取相应的数据记录。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/9.png"></p><p>​    在MyISAM中，其他索引也在MYI文件中，非主键索引跟主键索引存储和检索数据的方式是没有任何区别的，一样是在索引文件中找到磁盘地址，然后到数据文件中获取数据。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/10.png"></p><h3 id="3-2-InnoDB"><a href="#3-2-InnoDB" class="headerlink" title="3.2 InnoDB"></a>3.2 InnoDB</h3><p>​    在InnoDB的某个索引的叶子节点上，直接存储了我们的数据。所以，为什么说在InnoDB中索引即数据，数据即索引，就是这个原因。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/11.png"></p><p>​    但是有一个问题，一张InnoDB表可能有很多索引，数据肯定只有一份，那数据是在哪个索引的叶子节点上呢？</p><p>​    这里要介绍一个叫做聚集索引（聚簇索引）的概念，就是索引键值的逻辑顺序和表数据行的物理存储顺序是一致的。</p><p>​    InnoDB组织数据的方式就是（聚集）索引组织表（clustered index organize table）。如果说一张表创建了主键索引，那么这个主键索引就是聚集索引，决定数据行的物理存储顺序。</p><p>​    问题来了，那聚集索引之外的索引，会不会也把完整记录在叶子节点放一份呢？并不会，因为这回带来额外的存储空间浪费和计算损耗。那他们的叶子节点上没有数据怎么检索完整的数据呢？比如我们在name字段上建立的普通索引。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/12.png"></p><p>​    InnoDB中，主键索引和辅助索引是由一个主次之分的，如果有主键索引，那么主键索引就是聚集索引，其他的索引统称为“二级索引”（secondary index）。二级索引存储的是二级索引的键值，而叶子节点存的是这条记录对应的主键的值，所以，二级索引检索数据的流程是这样的：</p><p>​    当我们用name索引查询一条记录，它会在二级索引的叶子节点找到name=qingshan，拿到主键值，也就是id=1，然后再到主键索引的叶子节点拿到数据。</p><p>​    为什么不存地址而是存键值？因为地址会变化。从这个角度来说，因为主键索引比二级索引少扫描了一棵B+Tree（避免了回表），所以它的速度相对快一些。</p><p>​    但是，如果一张表没有主键怎么办？那完整的记录放在哪个索引的叶子节点？或者这张表根本没有索引呢？数据放在哪里？</p><p>​    1.如果我们定义了主键（primary key），那么InnoDB会选择主键作为聚集索引。</p><p>​    2.如果没有显示定义主键，则InnoDB会选择第一个不包含有null值得唯一索引作为主键索引。</p><p>​    3.如果也没有这样得一个唯一索引，InnoDB会选择内置6字节长得ROWID作为隐藏得聚集索引，它会随着行记录得写入而主键递增。</p><h2 id="4-索引使用原则"><a href="#4-索引使用原则" class="headerlink" title="4 索引使用原则"></a>4 索引使用原则</h2><h3 id="4-1-列的离散度"><a href="#4-1-列的离散度" class="headerlink" title="4.1 列的离散度"></a>4.1 列的离散度</h3><p>​    列的离散度，定义公式：count(distinct(column_name)):count(*)，列的全部不同值和所有数据行的比例，数据行相同的情况下，分子越大，列的离散度越高。简单来说，如果列的重复值越多，离散度度劫越低，重复值越多，离散度就越高。我们不建议在离散度低的字段上，如果B+Tree中的重复值太多，MySQL的优化器发现走索引跟使用全表扫描差不多，就算建立了索引，也不一定会走索引。</p><h3 id="4-2-联合索引最左匹配原则"><a href="#4-2-联合索引最左匹配原则" class="headerlink" title="4.2 联合索引最左匹配原则"></a>4.2 联合索引最左匹配原则</h3><p>​    前面都是针对单列创建的索引，但有时我们的多条件查询的时候，也会建立联合索引。单列索引也可以看作是特殊的联合索引。如果我们创建三个字段的联合索引index(a, b, c)，相当于创建了三个索引：index(a), index(a, b), index(a, b, c)；</p><h3 id="4-3-覆盖索引"><a href="#4-3-覆盖索引" class="headerlink" title="4.3 覆盖索引"></a>4.3 覆盖索引</h3><p>​    回表：非主键索引，我们先通过索引找到主键索引的键值，再通过主键值查出索引中没有的数据，它比基于主键索引的查询多扫描了一棵索引树，这个过程就叫回表。在二级索引中，不管单列索引还是联合索引，如果select的数据列只用从索引中就能取得，不必从数据区中读取，这时使用的索引叫做覆盖索引，这样避免了回表。很明显，因为覆盖索引减少了IO次数，减少了数据的访问量，可以大大提高查询效率。</p><h3 id="4-4-索引条件下推（ICP）"><a href="#4-4-索引条件下推（ICP）" class="headerlink" title="4.4 索引条件下推（ICP）"></a>4.4 索引条件下推（ICP）</h3><p>​    索引条件下推（index condition pushdown），5.6后完善的功能。只适用于二级索引。ICP的目标是减少访问表的完整行的读数量从而减少IO操作。这里说的下推，其实意思是把过滤的动作在存储引擎做完，而不需要到Server层过滤。来看这么一张表。在last_name和first_name上面创建联合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> employees;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;employees&#x27;</span> (<br><span class="hljs-string">&#x27;emp_no&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-string">&#x27;birth_date&#x27;</span> <span class="hljs-type">date</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-string">&#x27;first_name&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">14</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-string">&#x27;last_name&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-string">&#x27;gender&#x27;</span> enum(<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-string">&#x27;hire_date&#x27;</span> <span class="hljs-type">date</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">primary</span> key (<span class="hljs-string">&#x27;emp_no&#x27;</span>)<br>) engine<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>latinl;<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> employees <span class="hljs-keyword">add</span> index idx_lastname_firstname(last_name,first_name);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;689&#x27;</span>,<span class="hljs-string">&#x27;liu&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;431&#x27;</span>,<span class="hljs-string">&#x27;afdu&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;3424&#x27;</span>,<span class="hljs-string">&#x27;fdasfng&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;41z&#x27;</span>,<span class="hljs-string">&#x27;fdasfg&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">5</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;41zz&#x27;</span>,<span class="hljs-string">&#x27;wfdasf&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">6</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;41zz&#x27;</span>,<span class="hljs-string">&#x27;wang&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">7</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;41zz&#x27;</span>,<span class="hljs-string">&#x27;wang&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">8</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;41zzi&#x27;</span>,<span class="hljs-string">&#x27;wang&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">9</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;41zi&#x27;</span>,<span class="hljs-string">&#x27;gda&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">10</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;4i&#x27;</span>,<span class="hljs-string">&#x27;qafd&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure><p>现在查询所有姓wang，并且最后一字是zi的员工。查询的sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> last_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;wang&#x27;</span> <span class="hljs-keyword">and</span> last_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;%zi&#x27;</span>;<br></code></pre></td></tr></table></figure><p>​    正常来说，因为字符是从左往右排序的，当你把%加在前面时，是不能基于索引去比较的，所以只有last_name这个字段能够用于索引比较和过滤。所以查询过程是这样的：</p><p>​    1）根据联合索引查出所有姓wang的二级索引数据（3个主键6，7，8）</p><p>​    2）回表，到主键索引上查询全部符合条件的数据（3条数据）</p><p>​    3）把这3台哦数据返回到Server层，在Server层过滤出名字以zi结尾的员工。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/13.png"></p><p>​    注意，索引的比较是在存储引擎中进行的，数据记录的比较是在Server中进行的。而当first_name的条件不能用于索引过滤时，Server层不会把first_name的条件传递给存储引擎，所以读取了两条没用的记录。这时，如果满足last_name=‘wang’的记录有10万条，就会有99999条没有必要读取的记录。所以，根据first_name字段过过滤的动作，能不能再存储引擎层完成呢？这是第二种查询方法：</p><p>​    1）根据联合索引查出所有姓wang的二级索引数据（3个主键值6，7，8）</p><p>​    2）然后从二级索引中筛选出first_name以zi结尾的索引（1个索引）</p><p>​    3）然后再回表，到主键索引上查询全部符合条件的数据（1条数据），返回给server层</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/14.png"></p><p>​    很明显，第二种方法到主键索引上查询的数据更少。 ICP时默认开启的，也就是说针对二级索引，只要能够把条件下推给存储引擎，它就会下推，不需要我们干预：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> optimizer_switch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;index_condition_pushdown=on&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/15.png"></p><p>关闭ICP：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> optimizer_switch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;index_condition_pushdown=off&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/16.png"></p><p>Using where代表从存储引擎返回的数据不全部满足条件，需要再server层过滤。</p><h2 id="5-索引的创建和使用"><a href="#5-索引的创建和使用" class="headerlink" title="5  索引的创建和使用"></a>5  索引的创建和使用</h2><h3 id="5-1-索引的创建"><a href="#5-1-索引的创建" class="headerlink" title="5.1 索引的创建"></a>5.1 索引的创建</h3><ol><li><p>在用于where判断order排序和join的（on），group by的字段上创建索引</p></li><li><p>索引的个数不要太多 —-浪费空间，更新变慢</p></li><li><p>过长的字段，建立前缀索引</p></li><li><p>区分度低的字段，例如性别，不要建立索引 —-离散度太低，导致扫描行数过多</p></li><li><p>频繁更新的值，不要作为主键或者索引  ——页分裂</p></li><li><p>随机无序的值，不建议建立索引，例如身份证，UUID</p></li><li><p>组合索引把离散度高的值放在前面</p></li><li><p>创建复合索引，而不是修改单列索引</p></li></ol><h3 id="5-2-索引失效的情况"><a href="#5-2-索引失效的情况" class="headerlink" title="5.2 索引失效的情况"></a>5.2 索引失效的情况</h3><ol><li><p>在索引列上使用函数，表达式</p></li><li><p>字符串不加引号，出现隐式转换</p></li><li><p>Like条件中前面带%</p></li><li><p>负向查询: NOT LIKE不能；！=  （&lt;&gt;）和not in某些情况下可以</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> emp_no <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span>(<span class="hljs-number">1</span>)<br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> emp_no <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ol><p>​    这个例子中，因为索引是有序的，只要从1之后开始顺序读取就行了。其实，用不用索引，最终都是优化器说了算。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL执行流程</title>
    <link href="/2023/02/15/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/02/15/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-查询SQL的执行流程"><a href="#1-查询SQL的执行流程" class="headerlink" title="1.查询SQL的执行流程"></a>1.查询SQL的执行流程</h2><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/1.png"></p><h3 id="1-1-连接"><a href="#1-1-连接" class="headerlink" title="1.1 连接"></a>1.1 连接</h3><p>​    MySQL的服务器监听端口默认时3306，客户端连接服务端的方式有很多。可以是同步的也可以是异步的，可以是长连接也可以是短连接，可以是TCP也可以是Unix Socket，MySQL有专门处理连接的模块，连接的时候需要验证权限。查看当前的连接数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;Thread%&#x27;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>Threads_cached</td><td>缓存中的线程连接数</td></tr><tr><td>Threads_connected</td><td>当前打开的连接数</td></tr><tr><td>Threads_created</td><td>未处理连接创建的线程数</td></tr><tr><td>Threads_running</td><td>非睡眠状态的连接数，通常指并发连接数</td></tr></tbody></table><p>​    客户端每产生一个连接或者一个会话，在服务端就会创建一个线程来处理。反过来，如果杀死会话，就是kill进程。既然分配进程的话，保持连接肯定会消耗服务端的资源。MySQL会把哪些长时间不活动的（sleep）连接自动断开。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;wait_timeour&#x27;</span>; <span class="hljs-comment">--非交互式超时时间，如JDBC程序</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;interactive_timeout&#x27;</span>; <span class="hljs-comment">--交互式超时时间，如数据库工具</span><br></code></pre></td></tr></table></figure><p>​    默认都是28800秒，8小时。查看mysql服务的最大连接数：5.7版本中默认是151，最大可设置成100000。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘max_connections’；<br></code></pre></td></tr></table></figure><p>​    <strong>参数级别说明：</strong></p><p>​    MySQL中的参数（变量）分为session和global级别，分别是在当前会话中生效和全局生效，但是并不是每个参数都有两个几倍，比如max_connections就只有全局级别。当没有带参数的时候，默认是session级别，包括查询和修改。比如修改了一个参数以后，在本窗口已经生效，但是其他窗口不生效：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;autocommit&#x27;</span>;<br><span class="hljs-keyword">set</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-keyword">on</span>;<br></code></pre></td></tr></table></figure><p>​    所以，如果只是临时修改，建议修改session级别。如果需要在其他会话中生效，必须显示的加上global参数。</p><h3 id="1-2-查询缓存"><a href="#1-2-查询缓存" class="headerlink" title="1.2 查询缓存"></a>1.2 查询缓存</h3><p>​    MySQL内部自带了一个缓存模块。但是MySQL的缓存默认是关闭的。在MySQL8.0中，查询缓存已经被移除了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;query_cache%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>​    默认关闭的意思是不推荐使用，因为MySQL自带的缓存的应用场景有限：第一个是它要求SQL语句必须一模一样，中间多一个空格，字母大小写都被认为是不同的SQL；第二个是表里面任何一条数据发生变化时，这张表所有缓存都会失效，所以对于大量数据更新的应用，也不适合。所以缓存这一块，我们还是交给orm框架（比如mybatis默认开启了一级缓存），或者独立的缓存服务，比如Redis来处理更合适。</p><h3 id="1-3-语法解析和预处理-Parser-amp-Preprocessor"><a href="#1-3-语法解析和预处理-Parser-amp-Preprocessor" class="headerlink" title="1.3 语法解析和预处理(Parser &amp; Preprocessor)"></a>1.3 语法解析和预处理(Parser &amp; Preprocessor)</h3><p>​    对语句基于SQL语法进行词法分析，语法分析和语义的解析。</p><h4 id="1-3-1-词法解析"><a href="#1-3-1-词法解析" class="headerlink" title="1.3.1 词法解析"></a>1.3.1 词法解析</h4><p>​    词法解析就是把一个完整的SQL语句打碎成一个个的单词</p><h4 id="1-3-2-语法解析"><a href="#1-3-2-语法解析" class="headerlink" title="1.3.2 语法解析"></a>1.3.2 语法解析</h4><p>​    语法解析会对SQL做一语法检查，比如单引号有没有闭合，然后根据MySQL定义的语法规则，根据SQL语句生成一个数据结构，这个数据结构我们把它叫做解析树（select_lex）。</p><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/2.png"></p><p>​    词法语法分析是一个非常基础的功能，java的编译器，百度搜索引擎如果要识别语句，必须也要有词法语法分析功能。任何数据库的中间件，要解析SQL完成路由功能，也必须要有词法语法功能，比如Mycat，Sharding-JDBC（用到了Druid Parser）。在市面上也有很多的开源的词法解析的工具（比如LEX，Yacc）。</p><h4 id="1-3-3-预处理器"><a href="#1-3-3-预处理器" class="headerlink" title="1.3.3 预处理器"></a>1.3.3 预处理器</h4><p>​    预处理器会检查生成的解析树，解决解析器无法解析的语义。比如它会检查表和列名是否存在，检查名字和别名，保证没有歧义。预处理后得到一个新的解析树。</p><h3 id="1-4-查询优化与查询执行计划"><a href="#1-4-查询优化与查询执行计划" class="headerlink" title="1.4 查询优化与查询执行计划"></a>1.4 查询优化与查询执行计划</h3><p>​    一条SQL语句是可以有很多执行方式的，最终返回相同的结果，他们是等价的。选择哪种执行方式就是由MySQL的查询优化器的模块（Optimizer）。查询优化器的目的是根据解析树生成不同的执行计划（Execution Plan），然后选择一种最优的执行计划，MySQL中使用的是基于开销（cost）的优化器，哪种执行计划开销最小，就用哪种。查看查询的开销：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> ‘Last_query_cost’;<br></code></pre></td></tr></table></figure><p>​    优化的细节可以查看《数据库查询优化器的艺术-原理解析与SQL性能优化》。优化器最终会把解析树变成一个查询执行计划，查询执行计划是一个数据结构。MySQL提供了一个执行计划的工具，我们在SQL语句前面加上explain，就可以看到执行计划的信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">select</span> name <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>​    如果要得到详细的信息，还可以用format=json，或者开启optimizer trace。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN FORMAT<span class="hljs-operator">=</span>JSON <span class="hljs-keyword">where</span> name <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="1-5-存储引擎"><a href="#1-5-存储引擎" class="headerlink" title="1.5 存储引擎"></a>1.5 存储引擎</h3><p>​    查看数据库存放数据的路径</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;datastr&#x27;</span>;<br></code></pre></td></tr></table></figure><p>​    默认情况下，每个数据库都有自己的一个文件夹。任何一个存储引擎都有一个frm文件，这是表结构定义文件。不同的存储引擎存放数据的方式不一样， 产生的问价也不一样，innodb是1个，memory没有，myisam是两个。</p><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/3.png"></p><h4 id="1-5-1-存储引擎的选择"><a href="#1-5-1-存储引擎的选择" class="headerlink" title="1.5.1 存储引擎的选择"></a>1.5.1 存储引擎的选择</h4><p>​    一张表的存储引擎，是在创建表的时候指定的，使用ENGINE关键字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;user_innodb&#x27;</span>(<br><span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    PRIMARY_KEY(<span class="hljs-string">&#x27;id&#x27;</span>),<br>    KEY <span class="hljs-string">&#x27;comidx_name&#x27;</span> (<span class="hljs-string">&#x27;name&#x27;</span>)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>urf8mb4;<br></code></pre></td></tr></table></figure><p>​    没有指定的话，数据库就会使用默认的存储引擎，5.5.5之前，默认的是myisam。5.5.5之后默认的是innodb。不同的业务需求对应相应的存储引擎。</p><h4 id="1-5-2-存储引擎的比较"><a href="#1-5-2-存储引擎的比较" class="headerlink" title="1.5.2 存储引擎的比较"></a>1.5.2 存储引擎的比较</h4><p>​    常见的存储引擎：<a href="https://dev.mysql.com/doc/refman/5.7/en/storage-engines.html">https://dev.mysql.com/doc/refman/5.7/en/storage-engines.html</a></p><p>​    <strong>MyISAM（3个文件）</strong></p><p>​    应用范围比较小。表级锁限制了读/写的性能，因此在web和数据仓库配置中，它通常用于只读或以读为主的工作。</p><p>​    特点：</p><p>​                1.支持表级别的锁（插入或更新会锁表）。不支持事务。</p><p>​                2.拥有较高的插入（insert）和查询（select）速度。</p><p>​                3.存储了表的行数（count速度更快）。</p><p>​    （怎么快速向数据库中插入100万条数据？我们有一种先用myisam插入数据，然后修改存储引擎为innodb的操作）</p><p>​    适合：只读之类的数据分析项目</p><p><strong>InnoDB（2个文件）</strong></p><p>​    MySQL5.7中默认的存储引擎。InnoDB是一个事务安全（与ACID兼容）的MySQL存储引擎，它具有提交，回滚和奔溃回复功能来保护用户数据。InnoDB行级锁（不升级为更粗粒度的锁）和Oracle风格的一致非锁读提高了多用户并发性和性能。InnoDB将用户数据存储在聚集索引中，以减少基于主键的常见查询的I/O。为了保持数据的完整性，InnoDB还支持外键引用完整性约束。</p><p>​    特点：</p><p>​        1.支持事务，支持外键，因此数据的玩成型，一致性更高。</p><p>​        2.支持行级锁和表级锁</p><p>​        3.支持读写并发，写不阻塞读（MVCC）</p><p>​        4.特殊的索引存放方式，可以减少IO，提升查询效率。</p><p>​    适合：经常更新的表，存在并发读写或者由事务处理的业务系统。</p><p>​    <strong>Memory（1个文件）</strong></p><p>​    将所有数据存储在RAM中，以便在需要快速查找非关键性数据的环境中快速访问。这个引擎以前被称为堆引擎。其使用案例正在减少；InnoDB及其缓存池内存区域提供了一种通用，持久的方法来将大部分或所有数据保存在内存中，而ndbcluster为大型分布式数据提供了快速的键值查找。</p><p>​    特点：把数据放在内存里面，读写速度很快。但是数据库重启或者奔溃，数据会全部消失，只适合做临时表。将表中的数据存储到内存中。</p><p>​    <strong>CSV（3个文件）</strong></p><p>​    它的表实际上是带有逗号分隔值的文本文件。Csv表允许以csv格式导入或转储数据，以便与读写相同格式的脚本和应用程序交换数据，因为csv表没有索引，所以通常在正常操作期间将数据保存在innodb中，并且只在导入或导出阶段使用csv表。</p><p>​    特点：不允许空行，不支持索引。格式通用，可以直接编辑。</p><p>​    适合：在不同数据库之间导入导出。</p><p><strong>Archive（2个文件）</strong></p><p>​    这些紧凑的未索引的表用于存储和检索大量很少引用的历史，存档或安全审计信息。</p><p>​    特点：不支持索引，不支持update delete。</p><p>​    这些是mysql中常见的一些存储引擎，不同的存储引擎提供的特性都不一样，它们由不同的存储机制。索引方式，锁定水平等功能。我们在不同的业务场景中对数据操作的要求不同，就可以选择不同的存储引擎来满足我们的需求。</p><h4 id="1-5-3-如何选择存储引擎"><a href="#1-5-3-如何选择存储引擎" class="headerlink" title="1.5.3 如何选择存储引擎"></a>1.5.3 如何选择存储引擎</h4><p>​    InnoDB：对数据一致性要求比较高，需要事务支持。</p><p>​    MyIsam：数据查询多更新少，对查询性能要求比较高。</p><p>​    Memory：需要一个用于查询的临时表。</p><p>​    还可以根据官网内部手册使用C语言开发一个存储引擎。所有的存储引擎都遵循了一定的规范，提供了相同的接口。</p><h3 id="1-6-执行引擎"><a href="#1-6-执行引擎" class="headerlink" title="1.6 执行引擎"></a>1.6 执行引擎</h3><p>​    它利用存储引擎提供相应的api来完成操作，不同功能的存储引擎实现的api是相同的。最后把数据返回给客户端。</p><h2 id="2-更新SQL执行流程"><a href="#2-更新SQL执行流程" class="headerlink" title="2. 更新SQL执行流程"></a>2. 更新SQL执行流程</h2><p>​    在数据库里，我们说的update操作其实包括了更新，插入和删除。MyBatis的源码中Executor里面只有doQuery()和doUpdate()方法，没有doDelete()和doInsert()。它和查询的基本流程是一致的，也就是说，它也要经过解析器，优化器得处理，最后交给执行器。区别在于拿到符合条件得数据之后的操作。</p><h3 id="2-1-Buffer-Pool-缓冲池"><a href="#2-1-Buffer-Pool-缓冲池" class="headerlink" title="2.1 Buffer Pool(缓冲池)"></a>2.1 Buffer Pool(缓冲池)</h3><p>​    首先，对于InnoDB存储引擎来说，数据都是放在磁盘上得，存储引擎要操作数据。必须先把磁盘里面的数据加载到内存中才能操作。这里有个问题，是不是我们需要的数据多大，我们就一次从磁盘加载多少数据到内存呢?比如我要读6个字节。</p><p>​    磁盘I/O的读写相对于内存的操作来说是很慢的。如果我们需要的数据分散在磁盘的不同的地方，那就意味着回产生很多次的I/O操作。所以，无论是操作系统也好，还是存储引擎也好，都有一个预读取的概念，也就是说，当磁盘上的一块区域被读取时，很有可能它附近的位置也回马上被读取到，这个就叫做局部性远离了，那么这样，我们干脆每次多读一些，而不是用多少都多少。</p><p>​    InnoDB设定了一个存储引擎从磁盘读取数据带内存的最小单位，叫做页。操作系统也有页的概念。操作系统的页一般是4k，而Innodb中最小的单位默认是16K。如果要修改这个值的大小，需要清空数据重新初始化服务。</p><p>​    还有一个问题，操作数据的时候，每次都要从磁盘读取到内存（再返回给Server），有没有什么办法可以提高效率？还是缓存的思想，把读取过来的数据页缓存起来。</p><p>​    InnoDB设计了一个内存的缓冲区，读取数据的时候，先判断是不是在这个内存区域里面，如果是，就直接读取，然后操作。不用再次从磁盘中加载。如果不是，读取后就写到这个内存的缓冲区。这个区域就叫Buffer Pool。</p><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/4.png"></p><p>​    修改数据的时候，也是先写入到buffer pool中，而不是直接写到磁盘。内存的数据页个磁盘数据不一致的时候，我们就叫它为脏页。InnoDB中有专门的后台线程把Buffer Pool的数据写入到磁盘，每个一段时间就一次性的把多个修改写入磁盘，这个动作叫做刷脏。</p><p>​    总结一下：Buffer Pool的作用是为了提高读写效率。</p><h3 id="2-2-Redo-Log"><a href="#2-2-Redo-Log" class="headerlink" title="2.2 Redo Log"></a>2.2 Redo Log</h3><p>​    因为刷脏不是实时的，如果Buffer Pool里面的脏页还没有刷入磁盘时，数据库宕机或者重启，这些数据就会丢失。所以内存必须要有一个持久化的措施。为了避免这个问题，InnoDB把对所有页面的修改操作专门写入一个日志文件。如果有未同步到磁盘的数据，数据库在启动的时候，回从这个日志文件进行恢复操作（实现Crash-safe）。我们说的事务的ACID中的D（持久性），就是用它来实现的。</p><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/5.png"></p><p>​    这个日志文件就是磁盘的redo log（重做日志）。 那么写日志文件和写到数据文件有什么区别？</p><p>​    我们说一下磁盘寻址的过程。这个是磁盘的构造。磁盘的盘片不停的旋转，磁头会在磁盘表面画出一个圆形轨迹，这个就叫做磁道。从内到外半径不同有很多磁道。然后又用半径线，把磁道分割成了扇区（两根射线之内的扇区组成扇面）。如果要读写数据，必须找到数据对应的扇区，这个过程就叫寻址。</p><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/6.png"></p><p>​    如果我们所需要的数据是随机分散在磁盘上不同页的不同扇区中，那么找到相应的数据需要等到磁臂旋转到指定的页，然后盘片寻找到对应的扇区，才能找到我们能所需要的一块数据，一次进行此过程知道找完所有数据。这个就是随机IO，读取数据速度较慢。</p><p>​    假设我们已经找到了第一块数据，并且其他所需的数据就在这块数据后边，那么就不需要重新寻址，可以依次拿到我们所需的数据，这个就叫顺序IO。 刷盘是随机IO，而记录日志是顺序IO，顺序IO效率更高，本质上是数据集中存储和分散存储的区别。因此先把修改写入日志文件，在保证了内存数据的安全性的情况下，可以延迟刷盘时机，进而提高系统吞吐。</p><p>​    Redo log位于/var/lib/mysql目录下的ib_logfile0和ib_logfile1，默认2个文件，每个48M。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_log%&#x27;</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>innodb_log_file_size</td><td>指定每个文件的大小，默认48M</td></tr><tr><td>innodb_log_files_in_group</td><td>指定文件的数量，默认为2</td></tr><tr><td>innodb_log_group_home_dir</td><td>指定文件所在路径，相对或绝对。如果不指定，则为datadir路径</td></tr></tbody></table><p> redo log特点？</p><ol><li><p>redo log是Innodb存储引擎实现的，并不是所有存储引擎都有。支持奔溃恢复是Innodb的一个特性。</p></li><li><p>redo log不是记录数据页更新之后的状态，而是记录的是“在某个数据也上做了什么修改”。属于物理日志。</p></li><li><p>redo log的大小是固定的，前面的内容会被覆盖，一旦写满，就会触发buffer pool到磁盘的同步，以便腾出空间记录后面的修改。</p></li></ol><p>除了redo log之外，还有一个跟修改有关的日志，叫做undo log，这两个日志和事务密切相关，统称为事务日志。</p><h3 id="2-3-Undo-Log"><a href="#2-3-Undo-Log" class="headerlink" title="2.3 Undo Log"></a>2.3 Undo Log</h3><p>​    Undo log（撤销日志或回滚日志）记录了事务发生之前的数据状态，分为insert undo log和update undo log。如果修改数据时出现异常，可以用undo log来实现回滚操作（保持原子性）。可以理解为undo log记录的是反向操作，比如insert会记录delete，update会记录update原来的值，跟redo log记录在哪个物理页做了什么操作不同，所以叫逻辑格式的日志。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>innodb_undo_directory</td><td>undo文件的路径</td></tr><tr><td>innodb_undo_log_truncate</td><td>设置为1，即开启在线回收(收缩)undo log日志文件</td></tr><tr><td>innodb_max_undo_log_size</td><td>如果innodb_undo_log_truncate设置为1，超过这个大小的时候会触发truncate回收的动作，如果page大小是16KB，truncate后空间缩小到10M，默认1073741824字节=1G</td></tr><tr><td>innodb_undo_logs</td><td>回滚段的数量，默认128，这个参数已经过时</td></tr><tr><td>innodb_undo_tablespaces</td><td>设置undo独立表空间个数，范围为0-95，默认为0，0表示不开启独立undo表空间，且undo日志存储在ibdata文件中，这个参数已经过时</td></tr></tbody></table><h3 id="2-4-更新过程"><a href="#2-4-更新过程" class="headerlink" title="2.4 更新过程"></a>2.4 更新过程</h3><p>有了这些日志之后，总结一下更新操作的流程。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;penyuyan&#x27;</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>1、 事务开始，从内存（buffer pool）或磁盘（data file）取到包含这条数据的数据页，返回给server的执行器</p><p>2、 Server的执行器修改数据页的这一行数据的值为penyuyan</p><p>3、 记录name=qingshan到undo log</p><p>4、 记录name=penyuyan到redo log</p><p>5、 调用存储引擎接口，记录数据页到buffer pool（修改name=penyuyan）</p><p>6、 事务提交</p><h3 id="2-5-Bin-log"><a href="#2-5-Bin-log" class="headerlink" title="2.5 Bin log"></a>2.5 Bin log</h3><p>​    Binlog以事件的形式记录了所有的ddl和dml语句（因为它记录的是操作而不是数据值，属于逻辑日志），可以用来做主从复制和数据恢复。跟redo log不同，它的文件内容是可以追加的，没有固定大小限制。在开启了binlog功能的情况下，我们可以把binlog导出成sql语句。把所有的操作重放一遍，来实现数据的恢复。Binlog的另一个功能就是用来实现主从复制，它的原理就是从服务器读取主服务器的binlog，然后再执行一遍。配置方式和主从复制的实现原理再Mycat第二节课中有讲述。有了这两个日志之后，一条更新语句是怎么执行的（redo不能一次写入了）</p><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/7.png"></p><p>例如一条语句：update teacher set name = ‘penyuyan’ where id = 1;</p><p>​    1.先查询到这条语句，如果有缓存，也会用到缓存</p><p>​    2.把name改成pengyuyan，然后调用引擎的API接口，写入这一行数据到内存，同时记录redo log。 这时redo log进入prepare状态，然后告诉执行器，执行完成了，可以随时提交</p><p>​    3.执行器收到通知后记录binlog，然后条用存储引擎接口，设置redo log为commit状态。</p><p>​    4.更新完成。</p><p>这张图片的重点：</p><p>​    1.先记录到内存，再写日志文件。</p><p>​    2.记录redo log分为两个阶段</p><p>​    3.存储引擎和Server记录不同的日志</p><p>​    4.先记录redo，再记录binlog</p><p>为什么需要两阶段提交：</p><p>举例：如果我们执行的是把name改成penyuyan，如果写完redo log，还没有写binlog的时候，MySQL重启了。因为redo log可以在重启时用于数据恢复，所以写入磁盘的是pengyuyan。但是binlog中没有记录这个逻辑日志，所以这时候用binlog去恢复数据或者同步到从库，就会出现数据不一致的情况。所以在写两个日志的情况下，binlog就充当了一个事务的协调者。通知InnoDB来执行prepare或者commit或者rollback。如果写入binlog失败，就不会提交。简单地说，这里有两个写日志的操作，类似于分布式事务，不同两阶段提交，就不能保证都成功或者都失败。</p><p>在奔溃恢复时，判断事务是否需要提交：</p><p>1.binlog无记录，redolog无记录：在redolog写之前crash，恢复操作，回滚事务。</p><p>2.binlog无记录，redolog状态prepare：在binlog写完之前crash，恢复操作，回滚事务。</p><p>3.binlog有记录，redolog状态prepare：在binlog写完提交事务之前crash，恢复操作，提交事务。</p><p>4.binlog有记录，redolog状态commit：正常完成事务，不需要恢复。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL架构</title>
    <link href="/2023/02/09/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/02/09/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>​    总体上，我们可以把mysql分成三层，跟客户端对接的连接层，真正执行操作的服务层，和硬件打交道的存储引擎层。</p><p><img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%871.png"></p><h2 id="1-连接层"><a href="#1-连接层" class="headerlink" title="1.连接层"></a>1.连接层</h2><p>​    客户端要连接到mysql服务器的3306端口，必须要跟服务器端建立连接，那么管理所有的连接，验证客户端的身份和权限，这些功能就在连接层完成。</p><h2 id="2-服务层"><a href="#2-服务层" class="headerlink" title="2.服务层"></a>2.服务层</h2><p>​    连接层会把SQL语句交给服务层，这里面又包含一系列流程：比如查询缓存的判断，根据SQL调用相应的接口，对我们的SQL语句进行次发和语法的解析，比如关键字怎么识别，语法有没有错误等等。</p><p>​    然后就是优化器，MySQL底层回根据一定的规则对我们的SQL语句进行优化，最后再交给执行器去执行。</p><h2 id="3-存储引擎"><a href="#3-存储引擎" class="headerlink" title="3.存储引擎"></a>3.存储引擎</h2><p>​    存储引擎就是我们的数据真正存放的地方，在MySQL里面支持不同的存储引擎。</p><p>​    再往下就是内存或者磁盘，具体请查看查询sql执行流程。</p><h2 id="4-InnoDB总体架构"><a href="#4-InnoDB总体架构" class="headerlink" title="4.InnoDB总体架构"></a>4.InnoDB总体架构</h2><p><img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%872.png"></p><h3 id="4-1-内存结构"><a href="#4-1-内存结构" class="headerlink" title="4.1 内存结构"></a>4.1 内存结构</h3><p>​    主要分为三个部分：Buffer Pool，Change Buffer，Adaptive Hash Index，（redo）log buffer。</p><h4 id="4-1-1-Buffer-pool"><a href="#4-1-1-Buffer-pool" class="headerlink" title="4.1.1 Buffer pool"></a>4.1.1 Buffer pool</h4><p>​    Buffer pool缓存的是页面信息，包括数据页，索引页。默认大小是128M（134217728字节），可以调整。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_buffer_pool<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>​    InnoDB用LRU算法来管理缓存池（链表实现，不是传统的LRU，分成了young和old），经过淘汰的数据就是热点数据。</p><h4 id="4-1-2-LRU算法"><a href="#4-1-2-LRU算法" class="headerlink" title="4.1.2 LRU算法"></a>4.1.2 LRU算法</h4><p>​    传统的LRU可以用Map+链表实现，value存的是在链表中的地址。</p><p><img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%873.png"></p><p>​    innodb中确实使用了一个双向链表，LRU list，但是这个list放的不是data page，而是指向缓存页的指针。如果写buffer pool的时候发现没有空闲页了，就要从buffer pool中淘汰数据页了，要根据LRU链表的数据来操作。</p><p>​    首先，innodb的数据页并不都是在访问的时候才缓存到buffer pool的，innodb由一个预读机制（read ahead），也就是说，设计者认为访问某个page数据的时候，相邻的一些page可能会很快被访问到，所以先把这些page放到buffer pool中缓存起来，能提高I/O性能。这种预读的机制分为两种：</p><p>​    <strong>1.线性预读（异步的）。</strong>为了方便管理，innodb中把64个相邻的page叫做一个extent（区）。如果顺序的访问了一个extent的56个page，这时innodb就会把下一个extent缓存到buffer pool中。顺序访问多少个page才缓存下一个extent，由一个参数控制：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_read_ahead_threshold<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>​     <strong>2.随机预读。</strong>如果buffer pool已经缓存了同一个extent的数据页的个数超过13个时，就会把这个extent剩余的所有page全部缓存到buffer pool，但是随机预读的功能默认是不启用的，由一个参数控制：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_random_read_ahead<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>​    但是预读肯定也会带来一些副作用，就是导致占用的内存空间更多，剩余的空闲页更少，如果说buffer pool的size不是很大，而预读的数据很多，很有可能那些真正的需要被缓存的热点数据被预读数据挤出buffer pool，淘汰掉了，下次访问时又要去磁盘。所以为了避免这种情况，对buffer pool进行冷热分离。靠近head的叫做new sublist，用来放热数据（热区），靠近tail的叫做old sublist，用来放冷数据（冷区）。</p><p><img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%874.png"><img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%875.png"></p><p>​    所有新数据加入到buffer pool时一律先放到冷区的head。如果有些预读的数据没有被用到，会在冷区直接被淘汰。放到冷区后如果再次被访问，都会把它移动到热区的head。如果热区的数据长时间没有被访问，会被先移动到冷区的head部，最后慢慢在tail淘汰。默认情况下，热区占了5/8的大小，冷区占了3/8，这个值由innodb_old_blocks_pct控制，它代表的是old区的大小，默认是37%也就是3/8. Innodb_old_blocks_pct的值可以调整，在5%到95%之间，这个值越大，new区越小，这个LRU算法越接近传统的LRU。如果这个值太小，old区没有被访问的速度淘汰会更快。</p><p>​    还有一个问题：假设一次加载然后被立即访问的冷区数据量非常大，导致它们全部被移到了热区的head，它会导致很多热点数据被移动到冷区甚至淘汰，造成了缓冲池的污染。这个问题的解决方法是设置一个时间窗口，只有超过这个时间之后被访问，才认为是有效访问。Innodb中通过innodb_old_blocks_time这个参数来控制，默认为1秒钟，也就是说1秒钟内被访问的不算数，继续呆在冷区。只有1秒钟之后被访问的才被移到热区。这样就可以从很大程度上避免全表扫描或者预读的数据污染真正的热数据。</p><p>​    进一步的优化，为了避免并发的问题，对于LRU链表的操作是要加锁的，也就是说每一次链表的移动，都会带来资源的竞争与等待，从这个角度来说，如果进一步提升InnoDB LRU的效率，就要尽量得减少LRU链表得移动。比如把热区一个非常靠近head得page移动到head。有没有这个必要呢？所以InnoDB对热区还有一个特殊得优化：如果一个缓存页处于热数据区域，且在热数据区域得前1/4区域（注意是热区得1/4，而不是这个链表得1/4），那么当访问这个缓存页得时候，就不用把它移动到热数据区域得头部；如果缓存页处于热区得后3/4区域，那么就得移动到热区得头部。</p><h4 id="4-1-3-Change-Buffer-写缓存"><a href="#4-1-3-Change-Buffer-写缓存" class="headerlink" title="4.1.3 Change Buffer-写缓存"></a>4.1.3 Change Buffer-写缓存</h4><p>​    Change Buffer是Buffer Pool的一部分。如果这个数据页不是唯一索引，不存在数据重复的情况，也就不需要从磁盘加载索引页判断数据是不是重复（唯一性检查）。这种情况下可以先把修改记录在内存的缓存池中，从而提升更新语句（Insert， Delete，Update）的执行速度。</p><p>​    这一块区域就是Change Buffer。5.5之前叫Insert Buffer插入缓冲，现在也支持delete和update。</p><p>​    最后把Change Buffer记录到数据页的操作叫做merge。发生merge的几种情况如下：在访问这个数据页的时候，或者通过后台线程，或者通过数据库shut down，redo log写满时触发。</p><p>​    如果数据库发部分索引都是非唯一索引，并且业务是写多读少，不会在写数据后立刻读取，就可以用Change Buffer（写缓存）</p><p>​    可以通过调大这个值来扩大Change的大小，以支持写多读少的业务场景。（代表Change Buffer占Buffer pool的比例，默认为25%）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_change_buffer_max_size<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><h4 id="4-1-4-Adaptive-Hash-Index"><a href="#4-1-4-Adaptive-Hash-Index" class="headerlink" title="4.1.4 Adaptive Hash Index"></a>4.1.4 Adaptive Hash Index</h4><p>​    查看索引模块</p><h4 id="4-1-5-Redo-Log-Buffer"><a href="#4-1-5-Redo-Log-Buffer" class="headerlink" title="4.1.5 Redo Log Buffer"></a>4.1.5 Redo Log Buffer</h4><p>​    Redo Log也不是每一次都直接写入磁盘，在Buffer Pool中有一块内存区域（Log Buffer）专门用来保存即将写入日志文件的数据，默认为16M，它同样可以节省磁盘IO。</p><p>​    <img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%876.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_log_buffer_size<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>注意：redo log的内容主要用于奔溃恢复。磁盘的数据文件，数据来自buffer pool。Redo log写入磁盘，不是写入数据文件。</p><p>​    在我们写入数据到磁盘的时候，操作系统本身是有缓冲的，flush就是把操作系统缓冲区写入到磁盘。Log buffer写入磁盘的时机由一个参数控制，默认是1。刷盘越快越安全，但是也会越消耗性能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_flush_log_at_trx_commit<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>​    <img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%877.png"></p><h3 id="4-2-磁盘结构"><a href="#4-2-磁盘结构" class="headerlink" title="4.2 磁盘结构"></a>4.2 磁盘结构</h3><p>​    表空间可以看作是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。InnoDB的表空间分为5大类。</p><h4 id="4-2-1-系统表空间-system-tablespace"><a href="#4-2-1-系统表空间-system-tablespace" class="headerlink" title="4.2.1 系统表空间-(system tablespace)"></a>4.2.1 系统表空间-(system tablespace)</h4><p>​    在默认情况下InnoDB存储引擎有一个共享表空间（/var/lib/mysql/ibdata1），也叫系统表空间。</p><p>​    InnoDB系统表空间包含InnoDB数据字典和双写缓冲区，Change Buffer和undo logs，如果没有指定file-per-table，也包含用户创建的表和索引数据。</p><p>​    1.undo log后面介绍</p><p>​    2.数据字典：由内部系统表组成，存储表和索引的元数据（定义信息）</p><p>​    3.双写缓冲（InnoDB的一个特性）</p><p>​    InnoDB的页和操作系统的页大小不一致，InnoDB页大小一般为16k，操作系统页大小为4k，InnoDB页写入磁盘中时，一个页需要分4次写。</p><p>​    <img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%878.png"></p><p>​    如果存储引擎正在写入页的数据到磁盘时发生了宕机，可能出现页只写了一部分的数据，比如只写了4k，就宕机了。这种情况叫做部分写失效（partial page write），可能会导致数据丢失。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_doublewrite<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>​    如果这个页本身已经损坏了，用它来做奔溃恢复是没有意义的。所以在对于应用redo log之前，需要一个页的副本，如果出现了写入失效，就用这个页的副本来还原这个页，然后再应用redo log。这个页的副本就是double write，InnoDB的双写技术，通过它实现了数据页的可靠性。跟redo log一样，double write由两部分组成，一部分是内存的double write，一部分是磁盘上的double write。因为double write是顺序写入的，不会带来很大的开销。在默认情况下，所有的表共享一个系统表空间这个文件会越来越大，而且它的空间不会收缩。</p><h4 id="4-2-2-独占表空间-file-per-table-tablespaces"><a href="#4-2-2-独占表空间-file-per-table-tablespaces" class="headerlink" title="4.2.2 独占表空间-(file-per-table tablespaces)"></a>4.2.2 独占表空间-(file-per-table tablespaces)</h4><p>​    我们可以让每张表独占一个表空间。这个开关通过innodb_file_per_table设置，默认开启。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_file_per_table<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>​    开启后，则每张表会开启一个表空间，这个文件就是数据目录下的ibd文件，存放表的索引和数据。但是其他类的数据，如回滚（undo）信息，插入缓冲索引页，系统事务信息，二次写缓冲（double write buffer）等还是存放在原来的共享表空间内。</p><h4 id="4-2-3-通用表空间-general-tablespaces"><a href="#4-2-3-通用表空间-general-tablespaces" class="headerlink" title="4.2.3 通用表空间-(general tablespaces)"></a>4.2.3 通用表空间-(general tablespaces)</h4><p>​    通用表空间也是一个共享的表空间，跟ibddata1类似。 可以创建一个通用表空间，用来存储不同数据库的表，数据路径和文件可以自定义，语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span>spaces ts <span class="hljs-keyword">add</span> datafile <span class="hljs-string">&#x27;/var/lib/mysql/ts.ibd&#x27;</span> file_block_size<span class="hljs-operator">=</span><span class="hljs-number">16</span>K engine<span class="hljs-operator">=</span>innodb;<br></code></pre></td></tr></table></figure><p>​    在创建表的时候可以指定表空间吗，用alert修改表空间可以转移表空间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t(id <span class="hljs-type">integer</span>) tablespace ts;<br></code></pre></td></tr></table></figure><p>​    不同的表空间的数据是可以移动的。删除表空间需要先删除里面的所有表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> t;<br><span class="hljs-keyword">drop</span> tablespace ts;<br></code></pre></td></tr></table></figure><h4 id="4-2-4-临时表空间-temporary-tablespaces"><a href="#4-2-4-临时表空间-temporary-tablespaces" class="headerlink" title="4.2.4 临时表空间-(temporary tablespaces)"></a>4.2.4 临时表空间-(temporary tablespaces)</h4><p>​    存储临时表的数据，包括用户创建的临时表，和磁盘的内部临时表。对应数据目录下的ibtmp1文件。当数据服务器正常关闭时，该表空间被删除，下次重启产生。</p><h4 id="4-2-5-Redo-Log"><a href="#4-2-5-Redo-Log" class="headerlink" title="4.2.5 Redo Log"></a>4.2.5 Redo Log</h4><p>​    在更新sql执行流程中讲述</p><h4 id="4-2-6-Undo-log-tablespaces"><a href="#4-2-6-Undo-log-tablespaces" class="headerlink" title="4.2.6 Undo log tablespaces"></a>4.2.6 Undo log tablespaces</h4><p>​    Undo log的数据默认在系统表空间ibdata1文件中，因为共享表空间不会自动收缩，页可以单独创建一个undo表空间。</p><h3 id="4-3-后台线程"><a href="#4-3-后台线程" class="headerlink" title="4.3 后台线程"></a>4.3 后台线程</h3><p>​    后台线程的主要作用是负责刷新内存池中的数据和把修改的数据页刷新到磁盘。后台线程分为：master thread，IO thread，ourge thread，page cleaner thread。</p><p>​    1.Master thread：负责刷新缓存数据到磁盘并协调调度其他后台线程。</p><p>​    2.IO thread：分为innodb buffer，log，read，write进程。分别用来处理insert buffer，重做日志，读写请求的IO回调。</p><p>​    3.Purge threadL用来回收undo页。</p><p>​    4.Page cleaner thread：用来刷新脏页。</p><p>​    除了InnoDB架构中的日志文件，MySQL的Server层也有一个日志文件，叫做binlog，它可以被所有的存储引擎使用。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
