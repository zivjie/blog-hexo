<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>运行时数据区</title>
    <link href="/2023/03/08/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    <url>/2023/03/08/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<p>负责读取Java字节代码，并转换成java.lang.Class 类的一个实例的代码模块。类加载器除了用于加载类外，还可用于确定类在Java虚拟机中的唯一性。一个类在同一个类加载器中具有唯一性(Uniqueness)，而不同类加载器中是允许同名类存在的，这里的同名是指全限定名相同。但是在整个JVM里，纵然全限定名相同，若类加载器不同，则仍然不算作是同一个类，无法通过 instanceOf 、equals 等方式的校验。</p>]]></content>
    
    
    <categories>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载器(ClassLoader)</title>
    <link href="/2023/03/08/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <url>/2023/03/08/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>负责读取Java字节代码，并转换成java.lang.Class 类的一个实例的代码模块。类加载器除了用于加载类外，还可用于确定类在Java虚拟机中的唯一性。一个类在同一个类加载器中具有唯一性(Uniqueness)，而不同类加载器中是允许同名类存在的，这里的同名是指全限定名相同。但是在整个JVM里，纵然全限定名相同，若类加载器不同，则仍然不算作是同一个类，无法通过 instanceOf 、equals 等方式的校验。</p><h2 id="1-分类"><a href="#1-分类" class="headerlink" title="1 分类"></a>1 分类</h2><p>1） Bootstrap ClassLoader 负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class或Xbootclassoath选项指定的jar，由C++实现，不是ClassLoader子类。</p><p>2） Extension ClassLoader 负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。</p><p>3） App ClassLoader 负责加载classpath中指定的jar包以及Djava.class.path所指定目录下的类和jar包。</p><p>4） Custom ClassLoader 通过java.lang.ClassLoader的子类自定义加载class，属于应用程序根据自身需要定义的ClassLoader，如tomcat，jboss都会根据j2ee规范自行实现ClassLoader。</p><h2 id="2-图解"><a href="#2-图解" class="headerlink" title="2 图解"></a>2 图解</h2><p><img src="/image/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/1.png"></p><p>为什么类加载器要分层？</p><p>​    1.2版本的JVM中，只有一个类加载器，就是现在的“Bootstrap”类加载器。也就是根类加载器。但是这样会出现一个问题。假如用户调用他编写的java.lang.String类。理论上该类可以访问和改变java.lang包下其他类的默认访问修饰符的属性和方法的能力。也就是说，其他的类使用String时也会调用这个类，因为只有一个类加载器，无法判定到底加载哪个。因为Java语言本身并没有阻止这种行为，所以会出现问题。</p><p>这个时候就想到，可不可以使用不同级别的类加载器来对信任级别做一个区分？比如用三种基础的类加载器做为三种不同的信任级别。最可信的级别是java核心API类。然后是安装的拓展类，最后才是在类路径中的类（属于本机的类）。所以，三种基础的类加载器由此生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//App ClassLoader</span><br>        System.out.printLn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>().getClass().getClassLoader());<br>        <span class="hljs-comment">//Ext ClassLoader</span><br>        System.out.printLn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>().getClass().getClassLoader().getParent());<br>        <span class="hljs-comment">//Bootstrap ClassLoader</span><br>        System.out.printLn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>().getClass().getClassLoader().getParent().getParent());<br>        <br>        System.out.printLn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>().getClass().getClassLoader());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/2.png"></p><h2 id="3-JVM类加载机制的三种方式"><a href="#3-JVM类加载机制的三种方式" class="headerlink" title="3 JVM类加载机制的三种方式"></a>3 JVM类加载机制的三种方式</h2><ol><li><p>全盘负责：当一个类加载器负责加载某个class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</p><p> 例如：系统类加载器AppClassLoader加载入口类（含有main方法的类）时，会把main方法所依赖的类及引用的类也载入，依此类推。“全盘负责”机制也可称为当前类加载器负责机制。显然，入口类所依赖的类及引用的类的当前类加载器就是入口类的类加载器。以上步骤只是调用了CLassLoader.loadClass(name)方法，并没有真正定义类。真正加载class字节码文件生成Class对象由“双亲委派”机制完成。</p></li><li><p>父类委托：“双亲委派”是指子类加载器如果没有加载过该目标类，就先委托父类加载器加载该目标类，只有在父类加载器找不到字节码文件的情况下才从自己的类路径中查找并装载目标类。父类委托别名就叫双亲委派机制。</p><p> “双亲委派”机制加载Class的具体过程是：</p></li></ol><p>​    （1）ClassLoader先判断该Class是否已加载，如果已加载，则返回Class对象；如果没有则委托给父类加载器。</p><p>​    （2）父类加载器判断是否加载过该Class，如果已加载，则返回Class对象；如果没有则委托给祖父类加载器。</p><p>​    （3）依此类推，直到始祖类加载器（引用类加载器）。</p><p>​    （4）始祖类加载器判断是否加载过该Class，如果已加载，则返回Class对象；如果没有则尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，则委托给始祖类加载器的子类加载器。</p><p>​    （5）始祖类加载器的子类加载器尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，则委托给始祖类加载器的孙类加载器。</p><p>​    （6）依此类推，直到源ClassLoader。</p><p>​    （7）源ClassLoader尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，源ClassLoader不会再委托其子类加载器，而是抛出异常。</p><p>​    “双亲委派”机制只是Java推荐的机制，并不是强制的机制。可以继承java.lang.ClassLoader类，实现自己的类加载器。如果想保持双亲委派模型，就应该重写findClass(name)方法；如果想破坏双亲委派模型，可以重写loadClass(name)方法。</p><ol start="3"><li>缓存机制：缓存机制将会保证所有加载过的Class都将在内存中缓存，当程序中需要使用某个Class时，类加载器先从内存的缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效.对于一个类加载器实例来说，相同全名的类只加载一次，即 loadClass方法不会被重复调用。而这里我们JDK8使用的是直接内存，所以我们会用到直接内存进行缓存。这也就是我们的类变量为什么只会被初始化一次的由来。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">//1.在虚拟机内存中查找是否已经加载过此类。。。类缓存的主要问题所在</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span>(parent != <span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-comment">//先让上一层加载器进行加载</span><br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e)&#123;<br>                <span class="hljs-comment">//ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">//from the non-null parneet class loader</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">//调用此类加载器所实现的findClass方法进行加载</span><br>                c = findClass(name);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(resolve)&#123;<br>            <span class="hljs-comment">//resolverClass方法是当字节码加载到内存后进行链接操作，对文件格式和字节码校验，并为static字段分配空间并初始化，符号引用转为直接引用，访问控制，方法覆盖等</span><br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-打破双亲委派"><a href="#4-打破双亲委派" class="headerlink" title="4 打破双亲委派"></a>4 打破双亲委派</h2><p>双亲委派这个模型并不是强制模型，而且会带来一些的问题。就比如java.sql.Driver这个东西。JDK只能提供一个规范接口，而不能提供实现。提供实现的是实际的数据库提供商。提供商的库总不能放JDK目录里。所以java想到了几种办法可以用来打破双亲委派。</p><p>（1）<strong>SPI</strong> :比如Java从1.6搞出了SPI就是为了优雅的解决这类问题——JDK提供接口，供应商提供服务。编程人员编码时面向接口编程，然后JDK能够自动找到合适的实现。Java 在核心类库中定义了许多接口，并且还给出了针对这些接口的调用逻辑，然而并未给出实现。开发者要做的就是定制一个实现类，在 META-INF/services 中注册实现类信息，以供核心类库使用。比如JDBC中的DriverManager</p><p>（2）<strong>OSGI</strong>:比如我们更加追求程序的动态性，比如代码热部署，代码热替换。也就是就是机器不用重启，只要部署上就能用。OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块都有一个自己的类加载器，当需要更换一个程序模块时，就把程序模块连同类加载器一起换掉以实现代码的热替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>    <span class="hljs-keyword">private</span> String root;<br>    <br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-type">byte</span>[] classData = loadClassData(name);<br>        <span class="hljs-keyword">if</span>(classData == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> defineClass(name, classData, <span class="hljs-number">0</span>, classData.length);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] loadClassData(String className)&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> root + File.separatorChar + className.replace(<span class="hljs-string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="hljs-string">&quot;.class&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">ins</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(fileName);<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">bufferSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span>;<br>            <span class="hljs-type">byte</span>[] buff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[bufferSize];<br>            <br>            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>((length = ins.read(buffer)) != -<span class="hljs-number">1</span>)&#123;<br>                baos.write(buffer, <span class="hljs-number">0</span>, length);<br>            &#125;<br>            <span class="hljs-keyword">return</span> baos.toByteArray();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRoot</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRoot</span><span class="hljs-params">(String root)</span>&#123;<br>        <span class="hljs-built_in">this</span>.root = root;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">MyclassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClassLoader</span>();<br>        classLoader.setRoot(<span class="hljs-string">&quot;E:\\temp&quot;</span>);<br>        <br>        Class&lt;?&gt; testClass = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            testClass = classLoader.loadClass(<span class="hljs-string">&quot;com.neo.classloader.Test2&quot;</span>);<br>            <br>            <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> testClass.newInstance();<br>            System.out.printLn(object.getClass().getClassLoader());<br>        &#125; <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/3.png"></p><p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意：</p><p>​    1、这里传递的文件名需要是类的全限定性名称，即 Test 格式的，因为 defineClass 方法是按这种格式进行处理的。如果没有全限定名，那么需要做的事情就是将类的全路径加载进去，而setRoot就是前缀地址 setRoot + loadClass的路径就是文件的绝对路径。</p><p>​    2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</p><p>​    3、这类Test 类本身可以被 AppClassLoader 类加载，因此不能把 Test.class 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader 加载，而不会通过自定义类加载器来加载。</p>]]></content>
    
    
    <categories>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载机制</title>
    <link href="/2023/03/08/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/03/08/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>类加载机制是指将类的字节码文件所包含的数据读入内存，同时会生成数据的访问入口的一种特殊机制。那么可以得知，类加载的最终产品是数据访问入口。</p><p><img src="/image/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/1.png"></p><p>加载.class文件的方式：</p><p>​    1.从本地系统中直接加载：最常使用</p><p>​    2.通过网络下载class文件：Web Applet，也就是小程序应用</p><p>​    3.从zip，jar等归档文件中加载class文件：后续演变成jar，war格式</p><p>​    4.从专有数据库中提取class文件：JSP应用从专有数据库中提取class文件，极为少见</p><p>​    5.将java源文件动态编译为class文件，也就是运行时计算而成：动态代理技术</p><p>​    6.从加密文件中获取：典型的防class文件被反编译的保护措施。</p><p><img src="/image/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/2.png"></p><h2 id="1-加载-Load"><a href="#1-加载-Load" class="headerlink" title="1  加载(Load)"></a>1  加载(Load)</h2><p>查找和导入class文件</p><p>（1）   通过一个类的全限定名获取定义此类的二进制字节流（由上可知，不一定从字节码文件中获得，还有很多方法）。那么这个时候需要一个工具来寻找获取类二进制字节流。而java中正好有这么一段代码模块，可以实现通过类全名来获取此类的二进制字节流这个动作，并且将这个动作放到java虚拟机外部去实现，以便让应用程序决定如何获取所需要的类，实现这个动作的代码就是“类加载器“</p><p>（2）   将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p><p>（3）   在java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口</p><p> 注：获取类的二进制字节流的阶段是java程序员最关注的阶段，也是操控性最强的一个阶段。因为这个阶段可以对于类加载器进行操作，比如想自定义类加载器进行操作用以完成加载，又或者想通过java agent来完成字节码增强操作。</p><p>​    在装载完成之后，这时在内存中，运行时数据区的方法区以及堆就已经有数据了。即时编译之后的热点代码并不在这个阶段进入方法区。</p><p>​    方法区：类信息、静态常量、常量</p><p>​    堆：代表被加载类的java.lang.Class对象</p><h2 id="2-链接-Link"><a href="#2-链接-Link" class="headerlink" title="2 链接(Link)"></a>2 链接(Link)</h2><h3 id="2-1-验证-Verify"><a href="#2-1-验证-Verify" class="headerlink" title="2.1 验证(Verify)"></a>2.1 验证(Verify)</h3><p>验证只是为了确保Class文件中的字节流包含的信息完全符合当前虚拟机的要求，并且还要求文件中的信息不会危害虚拟机自身的安全，导致虚拟机的奔溃。</p><p>1） 文件格式验证：验证字节流是否符合class文件格式的规范，并且能够被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确的解析并存储于方法区之内。这阶段的验证是基于二进制字节流进行的，只有经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面验证都是基于方法区的存储结构进行的。</p><p>举例：是否以16进制cafebabe开头；版本号是否正确。</p><p>2） 元数据验证：对类的元数据信息进行语义校验(其实就是对java语法校验)，保证不存在不符合java语法规范的元数据信息。</p><p>举例：是否有父类；是否继承了final类；一个非抽象类是否实现了所有的抽象方法。</p><p>3） 字节码验证：进行数据流和控制流分析，确定程序语义是合法的,符合逻辑的。对类的方法体进行校验分析，保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。字节码的验证相对来说较为复杂。</p><p>举例：运行检查；栈数据类型和操作码参数吻合(比如栈空间只有4个字节，但是实际需要的远远大于4个字节，那么这时字节码就是有问题的)；跳转指令指向合理的位置。</p><p>4） 符号引用验证：这时最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候(解析阶段)，可以看作是对类自身以外的信息(常量池中的各种符号引用)进行匹配性的校验。符号引用验证的目的是确保解析动作能正常执行。</p><p>举例：常量池中描述类是否存在；访问的方法或者字段是否存在且具有足够的权限。</p><p>但是，很多情况下可能认为代码肯定是没有问题的，验证过程完全没必要，那么其实可以添加参数取消验证：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">-Xverify: <span class="hljs-built_in">none</span><br></code></pre></td></tr></table></figure><h3 id="2-2-准备-Prepare"><a href="#2-2-准备-Prepare" class="headerlink" title="2.2 准备(Prepare)"></a>2.2 准备(Prepare)</h3><p>为类的静态变量分配内存，并将其初始化为默认值。</p><table><thead><tr><th>数据类型</th><th>零值</th></tr></thead><tbody><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>short</td><td>(short)0</td></tr><tr><td>char</td><td>‘\u0000’</td></tr><tr><td>byte</td><td>(byte)0</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0d</td></tr><tr><td>reference</td><td>null</td></tr></tbody></table><p>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化。这个不会为实例变量(也就是没加static)分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//正常打印0，因为静态变量i在准备阶段会有默认值0</span><br>        System.out.printLn(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//编译不通过，因为局部变量没有赋值不能被使用</span><br>        <span class="hljs-type">int</span> <span class="hljs-number">1</span>;<br>        System.out.printLn(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进行分配内存的只是包括类变量(静态变量)，而不包括实例变量，实例变量是在对象实例化时随着对象一起分配在java堆中的。通常情况下，初始值为零值，假设public static int a = 1；那么a在准备阶段过后的初始值为0，不为1，这时只是开辟了内存空间，并没有运行java代码，a赋值为1的指令是程序被编译后，存放于类构造器(方法)中，所以a被赋值为1是在初始化阶段才会执行。</p><p>​    对于一些特殊情况,如果类字段属性表中存在ConstantValue属性，那在准备阶段变量a就会被初始化为ConstantValue属性所指的值。</p><p>​    <em>1.ConstantValue属性到底是干什么的?</em></p><p>​    Constant Value属性的作用是通知虚拟机自动为静态变量赋值，只有被static修饰的变量才可以使用这项属性，非static类型的变量的赋值是在实例构造器方法中进行的；static类型变量赋值分两种，在类构造器中赋值，或使用ConstantValue属性赋值。</p><p>​    <em>2.在实际的程序中，什么时候才会用到ConstantValue属性?</em></p><p>​    在实际的程序中，只有同时被final和static修饰的字段才有ConstantValue属性，且限于基本类型和String。编译时javac将会为该变量生成ConstantValue属性，在类加载的准备阶段虚拟机便根据ConstantValue为常量设置相应的值，如果该变量没有被final修饰，或者并非基本类型即字符串，则选择在类构造器中进行初始化。</p><p>​    <em>3.为什么ConstantValue的属性值只限于基本类型和String?</em></p><p>因为常量池中只能引用到基本类型和String类型的字面量。</p><h3 id="2-3-解析-Resolve"><a href="#2-3-解析-Resolve" class="headerlink" title="2.3 解析(Resolve)"></a>2.3 解析(Resolve)</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p><p>​    符号引用就是一组符号来描述目标。可以是任何字面量。引用的目标并不一定已经加载到内存中。</p><p>​    直接引用就是直接指向目标的指针，相对偏移量或一个间接定位到目标的句柄。</p><p>​    直接引用是与虚拟机内存布局实现相关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定存在内存中。</p><p>​    <strong>对解析结果进行缓存:</strong></p><p>​    同一符号引用进行多次解析请求是很常见的，除invokedynamic指令以外，虚拟机实现可以对第一次解析结果进行缓存，来避免解析动作重复进行。无论是否真正执行了多次解析动作，虚拟机需要保证的是在同一个实体中，如果一个引用符号之前已经被成功解析过，那么后续的引用解析请求就应当一直成功；同样的，如果第一次解析失败，那么其他指令对这个符号的解析请求也应该收到相同的异常。</p><p>inDy（invokedynamic）是 java 7 引入的一条新的虚拟机指令，这是自 1.0 以来第一次引入新的虚拟机指令。到了 java 8 这条指令才第一次在 java 应用，用在 lambda 表达式中。 indy 与其他 invoke 指令不同的是它允许由应用级的代码来决定方法解析。</p><h2 id="3-初始化-Initialize"><a href="#3-初始化-Initialize" class="headerlink" title="3 初始化(Initialize)"></a>3 初始化(Initialize)</h2><p>初始化阶段是执行类执行器方法的过程。或者讲的通俗易懂些，在准备阶段，类变量已赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，比如赋值。</p><p>​    在java中对类变量进行初始值设定由两种方式：1.声明类变量时指定初始值。2.使用静态代码块为类变量指定初始值。</p><p>​    按照程序员的逻辑，必须把静态变量定义在静态代码块的前面。因为两个的执行是会根据代码编写的顺序来决定的，顺序搞错了可能会影响业务代码。</p><p>​    JVM初始化步骤：1.假如这个类还没有被加载和连接，则程序先加载并连接该类。2.假如该类的直接父类还没有被初始化，则先初始化其直接父类。3.假如类中有初始化语句，则系统一次执行这些初始化语句。  </p><h2 id="4-使用"><a href="#4-使用" class="headerlink" title="4 使用"></a>4 使用</h2><ol><li>主动引用：只有当对类的主动引用的时候才会导致类的初始化，类的主动使用有6种：</li></ol><p>​    （1）创建类的实例，也就是new的方式。</p><p>​    （2）访问某个类或接口的静态变量，或者对该静态变量赋值</p><p>​    （3）调用类的静态方法</p><p>​    （4）反射，如Class.fonName(“com.carl.Test”)</p><p>​    （5）初始化某个类的子类，则其父类也会被初始化</p><p>​    （6）java虚拟机启动时被标明为启动类的类(JvmCaseApplication)，直接使用java.exe命令来运行某个主类。</p><p>​    2. 被动引用：</p><p>​    （1）引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。</p><p>​    （2）定义类数组，不会引起类的初始化。</p><p>​    （3）引用类的static final常量，不会引起类的初始化，如果只有static修饰，还是会引起类的初始化。</p><h2 id="5-卸载"><a href="#5-卸载" class="headerlink" title="5 卸载"></a>5 卸载</h2><p>在类使用完之后，如果满足下面的情况，类就会被卸载：</p><p>​    （1）该类的所有实例都已经被回收，也就是java堆中不存在该类的任何实例</p><p>​    （2）加载该类的ClassLoader已经被回收。</p><p>​    （3）该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</p><p>​    java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用他们所加载的类的Class对象，因此这些Class对象始终是可触及的。如果以上三个条件全部满足，JVM就会在方法区垃圾回收时堆类进行卸载，类的卸载过程其实就是在方法区种清空类信息，java类的整个声明周期就结束了。但是一般情况下启动类加载器加载的类不会被卸载，而其他两种基础类型的类加载器只有在极少数情况下才会被卸载。</p>]]></content>
    
    
    <categories>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jvm初识</title>
    <link href="/2023/03/08/jvm/jvm%E5%88%9D%E8%AF%86/"/>
    <url>/2023/03/08/jvm/jvm%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-官网"><a href="#1-官网" class="headerlink" title="1  官网"></a>1  官网</h2><h3 id="1-1-JDK-8"><a href="#1-1-JDK-8" class="headerlink" title="1.1 JDK 8"></a>1.1 JDK 8</h3><p><a href="https://docs.oracle.com/javase/8/">https://docs.oracle.com/javase/8/</a></p><h3 id="1-2-The-relation-of-JDK-JRE-JVM"><a href="#1-2-The-relation-of-JDK-JRE-JVM" class="headerlink" title="1.2  The relation of JDK/JRE/JVM"></a>1.2  The relation of JDK/JRE/JVM</h3><p>Reference -&gt; Developer Guides -&gt; 定位到：<a href="https://docs.oracle.com/javase/8/docs/index.html">https://docs.oracle.com/javase/8/docs/index.html</a></p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/1.png"></p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/2.png"></p><h3 id="1-3-源码到类文件"><a href="#1-3-源码到类文件" class="headerlink" title="1.3 源码到类文件"></a>1.3 源码到类文件</h3><h4 id="1-3-1-源码"><a href="#1-3-1-源码" class="headerlink" title="1.3.1 源码"></a>1.3.1 源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String address;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">hobby</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Programming&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span>&#123;<br>        System.out.printLn(<span class="hljs-string">&quot;person say .....&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> op1, <span class="hljs-type">int</span> op2)</span>&#123;<br>        <span class="hljs-keyword">return</span> op1 + op2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译：javac Person.java -&gt; Person.class</p><h4 id="1-3-2-编译过程"><a href="#1-3-2-编译过程" class="headerlink" title="1.3.2 编译过程"></a>1.3.2 编译过程</h4><p>Person.java -&gt; 词法分析器 -&gt; tokens流 -&gt; 语法分析器 -&gt; 语法树/抽象语法树 -&gt; 语义分析器 -&gt; 注解抽象语法树 -&gt; 字节码生成器 -&gt; Person.class文件</p><p>​    由上可知：编译器其实做的事情就是“对等信息转换”。java文件中的信息其实跟class文件中的信息是一样的。</p><h4 id="1-3-3-类文件-class文件"><a href="#1-3-3-类文件-class文件" class="headerlink" title="1.3.3 类文件(class文件)"></a>1.3.3 类文件(class文件)</h4><p>官网: <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/3.png"></p><ol><li><p>magic（魔数）：The magic item supplies the magic number identifying the file format; it has the value 0xCAFEBABE：café babe.</p></li><li><p>minor_version, major_version：0000 0034 对应十进制的52，代表JDK8中的一个版本</p></li><li><p>constant_pool_count：003f 对应十进制63代表常量池中62个常量</p></li></ol><p><strong>常量池中主要存储两方面的内容：字面量和符号引用。</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">字面量：文本字符串，<span class="hljs-keyword">final</span>修饰等<br>符号引用：类和接口的全限定名、字段名称和描述符、方法名称和描述符<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassFile&#123;<br>u4magic;<br>    u2minor_version;<br>    u2major_version;<br>    u2constant_pool_count;<br>    cp_info constant_pool[constant_pool_count-<span class="hljs-number">1</span>];<br>    u2access_flags;<br>    u2this_class;<br>    u2super_class;<br>    u2interfaces_count;<br>    u2interfaces[interfaces_count];<br>    u2fields_count;<br>    field_infofields[fields_count];<br>    u2methods_count;<br>    method_info methods[methods_count];<br>    u2attributes_count;<br>    attribute_infoattributes[attributes_count];<br>&#125;<br></code></pre></td></tr></table></figure><p>.class字节码文件</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">魔术和<span class="hljs-keyword">class</span>文件版本<br>常量池<br>访问标志<br>类索引、父类索引、接口索引<br>字段表集合<br>方法表集合<br>属性表集合<br></code></pre></td></tr></table></figure><h4 id="1-3-4-反编译验证"><a href="#1-3-4-反编译验证" class="headerlink" title="1.3.4  反编译验证"></a>1.3.4  反编译验证</h4><p>用javap指令验证上述猜想正确性。编译指令：javap -v -p Person.class</p><p>进行反编译之后，查看字节码信息和指令等信息。JVM相对class文件来说可以理解为是操作系统；class文件相对JVM来说可以理解是汇编语言或者机器语言。</p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/4.png"></p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/5.png"></p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/6.png"></p><p>上面分析到常量池中常量的数量是62，接下来来具体分析一下这62个常量，也就是这块包含的信息：cp_info constant_pool[constant_pool_count-1]，cp其实就是一个表格的形式。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">cp_info</span> &#123;<br><span class="hljs-attribute">u1</span> tag;<br><span class="hljs-attribute">u1</span> <span class="hljs-literal">info</span>[];<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4</a></p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/7.png"></p><p>（1）往下数一个u1，即0a-&gt;10：代表的是CONSTANT_Methodref，表示这是一个方法引用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">CONSTANT_Fieldref_info&#123;<br>u1 tag<span class="hljs-comment">;</span><br>u2 class_index<span class="hljs-comment">;</span><br>u2 name_and_type_index<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>往下数两个u2：</p><p>​    第一个u2，即00 0a-&gt;10：代表的是class_index，表示该方法所属的类在常量池中的索引</p><p>​    第二个u2，即00 2b-&gt;43：代表的是name_and_type_index，表示该方法的名称和类型的索引。</p><p>（2）往下数u1，即08-&gt;8：表示的是CONSTANT_String，表示字符串类型</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">CONSTANT_String_info &#123;<br>u1 tag<span class="hljs-comment">;</span><br>u2 string_index<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>往下数u2，即00 2c-&gt;44：代表的是string_index</p><p>（3）往下数u1，即09 -&gt;9：表示CONSTANT_Fieldref，表示字段类型</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">CONSTANT_Fieldref_info&#123;<br>u1 tag<span class="hljs-comment">;</span><br>u2 class_index<span class="hljs-comment">;</span><br>u2 name_and_type_index<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>往下数两个u2：</p><p>​    第一个u2：即00 0d -&gt;13：代表的是class_index</p><p>​    第二个u2：即00 2d -&gt;45：代表的是name_and_type_index</p>]]></content>
    
    
    <categories>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nacos配置中心</title>
    <link href="/2023/03/07/springcloud/nacos/nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <url>/2023/03/07/springcloud/nacos/nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p><em>Nacos版本：2.0.4  nacos2.x已不支持ribbon，使用nacos2.x需要手动引入LoadBalancer</em></p><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1 基本使用"></a>1 基本使用</h2><h3 id="1-1-本地配置"><a href="#1-1-本地配置" class="headerlink" title="1.1 本地配置"></a>1.1 本地配置</h3><h4 id="1-1-1-实现"><a href="#1-1-1-实现" class="headerlink" title="1.1.1 实现"></a>1.1.1 实现</h4><p>（1）application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">lecturer:</span> <span class="hljs-string">Test</span><br></code></pre></td></tr></table></figure><p>（2）UserController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @Value</span><br><span class="hljs-meta">@Value(&quot;$&#123;lecturer&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String lecturer;<br><br><span class="hljs-meta">@RequestMapping(&quot;/local-config-value&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">localConfigValue</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;lecturer: &quot;</span>+<span class="hljs-built_in">this</span>.lecturer;<br>&#125;<br><br><span class="hljs-comment">// env</span><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> Environment environment;<br><br><span class="hljs-meta">@RequestMapping(&quot;/local-config-env&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">localConfigEnv</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;environment lecturer: &quot;</span>+<span class="hljs-built_in">this</span>.environment.getProperty(<span class="hljs-string">&quot;lecturer&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-1-2-实现原理"><a href="#1-1-2-实现原理" class="headerlink" title="1.1.2 实现原理"></a>1.1.2 实现原理</h4><p><a href="https://docs.spring.io/spring-boot/docs/2.7.6/reference/htmlsingle/#features.external-config">https://docs.spring.io/spring-boot/docs/2.7.6/reference/htmlsingle/#features.external-config</a></p><p>（1）加载application.yml文件中的配置</p><p>PropertySourceLoader#load() -&gt; YamlPropertySourceLoader#load() -&gt; OriginTrackedMapPropertySource</p><p>（2）查看Environment的属性配置源</p><p>SpringApplication#run()  –&gt;debug: configureIgnoreBeanInfo(environment)</p><p>（3）比如在Program arguments中配置timeout=1000，</p><p>观察environment中的 SimpleCommandLinePropertySource</p><p>（4）@Value实现原理</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">（<span class="hljs-number">1</span>）使用BeanPostProcessor解析类上的<span class="hljs-meta">@Value</span>字段<br>（<span class="hljs-number">2</span>）获取到字段上的<span class="hljs-meta">@Value</span>字段<br>（<span class="hljs-number">3</span>）解析<span class="hljs-meta">@Value</span>字段的value属性值，比如age<br>（<span class="hljs-number">4</span>）从environment中的属性配置源OriginTrackedMapPropertySource中寻找age的key<br>（<span class="hljs-number">5</span>）根据key获取到对应的value值<br>（<span class="hljs-number">6</span>）通过field反射的方式设置value值<br></code></pre></td></tr></table></figure><h3 id="1-2-在nacos上创建配置文件"><a href="#1-2-在nacos上创建配置文件" class="headerlink" title="1.2 在nacos上创建配置文件"></a>1.2 在nacos上创建配置文件</h3><p>（1）创建user-dev.yaml文件</p><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/1.png"></p><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/2.png"></p><p>（2）文件存储位置</p><p>mysql     nacos库     config_info表</p><p>nacos home</p><h3 id="1-3-基于HTTP的配置管理"><a href="#1-3-基于HTTP的配置管理" class="headerlink" title="1.3 基于HTTP的配置管理"></a>1.3 基于HTTP的配置管理</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 发布配置</span><br>curl -X POST <span class="hljs-string">&quot;http://127.0.0.1:8848/nacos/v1/cs/configs?</span><br><span class="hljs-string">dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld&quot;</span><br><br><span class="hljs-comment">#获取配置</span><br>curl -X POST <span class="hljs-string">&quot;http://127.0.0.1:8848/nacos/v1/cs/configs?</span><br><span class="hljs-string">dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld&quot;</span><br></code></pre></td></tr></table></figure><h3 id="1-4-基于Java-SDK的配置管理"><a href="#1-4-基于Java-SDK的配置管理" class="headerlink" title="1.4 基于Java SDK的配置管理"></a>1.4 基于Java SDK的配置管理</h3><p><a href="https://nacos.io/zh-cn/docs/sdk.html">https://nacos.io/zh-cn/docs/sdk.html</a></p><p>（1）引入nacos-client包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.nacos<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>nacos-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）编写Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">COnfigExample</span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">serverAddr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;localhost&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">dataId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;redis.yaml&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;DEFAULT_GROUP&quot;</span>;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        properties.put(PropertyKeyConst.SERVER_ADDR, serverAddr);<br>        <span class="hljs-type">ConfigService</span> <span class="hljs-variable">configService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosFactory</span>.createConfigService(properties);<br>        <br>        <span class="hljs-comment">//添加监听</span><br>        configService.addListencer(dataId, group, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Listence</span>()&#123;<br>           <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveConfigInfo</span><span class="hljs-params">(String configInfo)</span>&#123;<br>                System.out.printLn(<span class="hljs-string">&quot;receive: &quot;</span> + configInfo);<br>            &#125;<br>            <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">getExecutor</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;);<br>        <br>        <span class="hljs-comment">//发布配置</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isPublishOK</span> <span class="hljs-operator">=</span> configService.publishConfig(dataId, group, <span class="hljs-string">&quot;redis.host: 120.0.0.1:6379&quot;</span>);<br>        System.out.printLn(isPublishOK);<br>        <br>        Threan.sleep(<span class="hljs-number">3000</span>);<br>        <span class="hljs-comment">//获取配置</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> configService.getConfig(dataId, group, <span class="hljs-number">5000</span>);<br>        System.out.printLn(content);<br>        <br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）通过dashboard修改redis.yaml文件中的配置内容，观察监听器的回调打印信息</p><h3 id="1-5-user服务基于SC的配置管理"><a href="#1-5-user服务基于SC的配置管理" class="headerlink" title="1.5 user服务基于SC的配置管理"></a>1.5 user服务基于SC的配置管理</h3><p>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）在resources目录下创建bootstrap.yaml文件，并写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">user</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/3.png"></p><p>（3）启动user服务，如若报错如下信息，则在pom文件中添加bootstrap starter，并重新启动user服 务</p><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/4.png"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（4）创建访问接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Value的方式获取</span><br><span class="hljs-meta">@Value(&quot;$&#123;age&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String age;<br><br><span class="hljs-meta">@RequestMapping(&quot;/nacos-config-value&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">nacosConfigValue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> age;<br>&#125;<br><br><span class="hljs-comment">//Env的方式获取</span><br><span class="hljs-meta">@RequestMapping(&quot;/nacos-config-env&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">nacosConfigEnv</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.environment.getProperty(<span class="hljs-string">&quot;age&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）访问/user/nacos-config-value和/user/nacos-config-env </p><p>（6）通过dashboard修改age的值，不重启项目的情况下 访问/user/nacos-config-env，发现已经更新 访问/user/nacos-config-value，发现没有更新，在UserController上添加@RefreshScope注解后再尝试</p><h3 id="1-6-当前服务的通用配置"><a href="#1-6-当前服务的通用配置" class="headerlink" title="1.6 当前服务的通用配置"></a>1.6 当前服务的通用配置</h3><p>创建user.yaml文件，nacos会自动加载user、user-dev.yaml、user.yaml三个配置文件</p><h3 id="1-7-不同服务的公共配置"><a href="#1-7-不同服务的公共配置" class="headerlink" title="1.7 不同服务的公共配置"></a>1.7 不同服务的公共配置</h3><p>（1）创建公共配置文件mysql.yaml和es.yaml</p><p>（2）在bootstrap.yaml文件中添加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span><br>        <span class="hljs-string">shared-configs[0]:</span><br>          <span class="hljs-attr">data-id:</span> <span class="hljs-string">mysql.yaml</span><br>          <span class="hljs-attr">refresh:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-string">extension-configs[0]:</span><br>          <span class="hljs-attr">data-id:</span> <span class="hljs-string">es.yaml</span><br>          <span class="hljs-attr">refresh:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">user</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><p>（3）启动user服务观察日志并访问</p><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/5.png"></p>]]></content>
    
    
    <categories>
      
      <category>springcloud</category>
      
      <category>nacos</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
      <tag>nacos</tag>
      
      <tag>配置中心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenFeign</title>
    <link href="/2023/03/07/springcloud/openfegin/openfegin/"/>
    <url>/2023/03/07/springcloud/openfegin/openfegin/</url>
    
    <content type="html"><![CDATA[<p><em>新版本的OpenFeign把ribbon移除了，正常使用应该引入LoadBalancer依赖</em></p><h2 id="1-OpenFeign使用"><a href="#1-OpenFeign使用" class="headerlink" title="1 OpenFeign使用"></a>1 OpenFeign使用</h2><p>(1) 整合openfeign依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）写注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserApplication</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）编写FeignClient接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderFeignClient</span> &#123;<br><span class="hljs-meta">@RequestMapping(&quot;/order/query&quot;)</span><br>String <span class="hljs-title function_">query</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）在Controller中使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> OrderFeignClient orderFeignClient;<br><br><span class="hljs-meta">@RequestMapping(&quot;/openfeign&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">openfeign</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.orderFeignClient.query();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Feign单独请求url"><a href="#2-Feign单独请求url" class="headerlink" title="2 Feign单独请求url"></a>2 Feign单独请求url</h2><p>（1）定义FeignClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;jack&quot;,url = &quot;https://ke.gupaoedu.cn/&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">JackFeignClient</span> &#123;<br><span class="hljs-meta">@RequestMapping(&quot;/gupao&quot;)</span><br>String <span class="hljs-title function_">gupao</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> JackFeignClient jackFeignClient;<br><br><span class="hljs-meta">@RequestMapping(&quot;/openfeign-url&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">openfeignUrl</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.jackFeignClient.gupao();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-配置OpenFeign的日志级别"><a href="#3-配置OpenFeign的日志级别" class="headerlink" title="3 配置OpenFeign的日志级别"></a>3 配置OpenFeign的日志级别</h2><p><a href="https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/#feign-logging">https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/#feign-logging</a></p><h3 id="3-1-OrderFeignClient-Java代码方式"><a href="#3-1-OrderFeignClient-Java代码方式" class="headerlink" title="3.1 OrderFeignClient-Java代码方式"></a>3.1 OrderFeignClient-Java代码方式</h3><p>（1）为注解@FeignClient配置configuration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;order&quot;, configuration = OrderFeignClientConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderFeignClient</span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/order/query&quot;)</span><br>    String <span class="hljs-title function_">query</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）新建配置类，并配置日志级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里不需要添加@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderFeignClientConfiguration</span> &#123;<br><span class="hljs-meta">@Bean</span><br>Logger.Level <span class="hljs-title function_">feignLoggerLevel</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">// 将feign的日志级别设置为FULL</span><br><span class="hljs-keyword">return</span> Logger.Level.FULL;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）在application.yml文件中将OrderFeignClient的日志级别设置为debug</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.test.openfeign.OrderFeignClient:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h3 id="3-2-OrderFeignClient-yml文件方式"><a href="#3-2-OrderFeignClient-yml文件方式" class="headerlink" title="3.2 OrderFeignClient-yml文件方式"></a>3.2 OrderFeignClient-yml文件方式</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.test.openfeign.OrderFeignClient:</span> <span class="hljs-string">debug</span><br><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-comment">#目标服务名称</span><br>      <span class="hljs-attr">order:</span><br>       <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">full</span><br></code></pre></td></tr></table></figure><h3 id="3-3-全局配置-Java代码方式"><a href="#3-3-全局配置-Java代码方式" class="headerlink" title="3.3 全局配置-Java代码方式"></a>3.3 全局配置-Java代码方式</h3><p>（1）找到Spring Boot的启动入口类，在@EnableFeignClients注解中配置defaultConfiguration属性， 为其指定全局配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableFeignClients(defaultConfiguration = GlobalFeignConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserApplication</span> immplements ApplicationRunner&#123;&#125;<br></code></pre></td></tr></table></figure><p>（2）新建配置类，并配置日志级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalFeignConfiguration</span> &#123;<br><span class="hljs-meta">@Bean</span><br>Logger.Level <span class="hljs-title function_">feignLoggerLevel</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">// 将feign的日志级别设置为FULL</span><br><span class="hljs-keyword">return</span> Logger.Level.FULL;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）在application.yml文件中将UserFeignClient的日志级别设置为debug</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>   <span class="hljs-attr">com.test.opennfeign.OrderFeignClient:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h3 id="3-4-全局配置-yml文件方式"><a href="#3-4-全局配置-yml文件方式" class="headerlink" title="3.4 全局配置-yml文件方式"></a>3.4 全局配置-yml文件方式</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.jack.user.openfeign.OrderFeignClient:</span> <span class="hljs-string">debug</span><br><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-comment"># 全局配置</span><br>      <span class="hljs-attr">default:</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">full</span><br></code></pre></td></tr></table></figure><h2 id="4-更改OpenFeign调用方式"><a href="#4-更改OpenFeign调用方式" class="headerlink" title="4 更改OpenFeign调用方式"></a>4 更改OpenFeign调用方式</h2><p>将OpenFeign默认使用的HttpURLConnection更改为httpclient</p><p>（1）查看当前http调用方式</p><p>SynchronousMethodHandler#invoke-&gt;executeAndDecode-&gt;client#execute-&gt;Default#execute- &gt;HttpURLConnection</p><p>（2）引入httpclient依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（3）写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-comment"># 全局配置</span><br>      <span class="hljs-attr">default:</span> <br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">full</span><br>  <span class="hljs-attr">httpclient:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">max-connections:</span> <span class="hljs-number">200</span><br>    <span class="hljs-attr">max-connections-per-route:</span> <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><h2 id="5-OpenFeign架构"><a href="#5-OpenFeign架构" class="headerlink" title="5 OpenFeign架构"></a>5 OpenFeign架构</h2><p><img src="/image/springcloud/openFegin/openfeign%E6%9E%B6%E6%9E%84.jpg"></p><h2 id="6-核心源码分析"><a href="#6-核心源码分析" class="headerlink" title="6 核心源码分析"></a>6 核心源码分析</h2><p>Spring Boot启动的时候，会扫描指定的包路径，然后判断接口上有没有添加@FeignClient，通过Spring提供的扩展FactoryBean接口，实现getObject方法实现自定义动态代理类，OrderFeignClient=Proxy#newInstance，将动态代理实现类放到ioc容器中。</p><p>调用接口时orderFeignClient#query() –&gt; Proxy#XXXHandler#invoke() ：通过loadbalancer根据order进行服务发现和负载均衡，然后得到一个localhost:9091/order/query ，调用uri进行结果返回。</p><p><img src="/image/springcloud/openFegin/openfeign%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>springcloud</category>
      
      <category>OpenFeign</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>OpenFeign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>负载均衡LoadBalancer</title>
    <link href="/2023/03/06/springcloud/LoadBalancer/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1LoadBalancer/"/>
    <url>/2023/03/06/springcloud/LoadBalancer/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1LoadBalancer/</url>
    
    <content type="html"><![CDATA[<p>nacos2.x已不支持ribbon，使用nacos2.x需要手动引入LoadBalancer</p><h2 id="1-手写随机负载均衡算法"><a href="#1-手写随机负载均衡算法" class="headerlink" title="1 手写随机负载均衡算法"></a>1 手写随机负载均衡算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br><span class="hljs-comment">//通过restTemplate访问随机一个url地址</span><br><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">loadbalance</span><span class="hljs-params">()</span>&#123;<br>    List&lt;ServiceInstance&gt; instances = discoveryClient.getInstance(<span class="hljs-string">&quot;order&quot;</span>);<br>    List&lt;String&gt; uris = instances.stream().map(instance -&gt; instance.getUri().toString() + <span class="hljs-string">&quot;/order/query&quot;</span>).collect(Collections.toList());<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> ThreadLocalRandom.current().nextInt(uris.size());<br>    <span class="hljs-type">String</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> uris.get(i);<br>    System.out.printLn(<span class="hljs-string">&quot;访问地址为&quot;</span> + uri);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.restTemplate.getForObject(uri, String.calss);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-LoadBalancerClient-API"><a href="#2-LoadBalancerClient-API" class="headerlink" title="2 LoadBalancerClient API"></a>2 LoadBalancerClient API</h2><p><a href="https://spring.io/guides/gs/spring-cloud-loadbalancer/">https://spring.io/guides/gs/spring-cloud-loadbalancer/</a></p><p>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> LoadBalancerClient loadBalancerClient;<br><br><span class="hljs-meta">@RequestMapping(&quot;/loadbalancerclient-api&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">loadbalancerclientApi</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">ServiceInstance</span> <span class="hljs-variable">serviceInstance</span> <span class="hljs-operator">=</span> loadBalancerClient.choose(<span class="hljs-string">&quot;order&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> serviceInstance.getUri().toString()+<span class="hljs-string">&quot;/order/query&quot;</span>;<br><span class="hljs-keyword">return</span> restTemplate.getForObject(url,String.class);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-LoadBalanced注解方式"><a href="#3-LoadBalanced注解方式" class="headerlink" title="3 @LoadBalanced注解方式"></a>3 @LoadBalanced注解方式</h2><p>（1）引入loadbalancer starter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）自定义一个@LoadBalanced注解的RestTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span> <span class="hljs-comment">// 相当于为restTemplate整合了lb的能力</span><br><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplateLoadBalancer</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RestTemplate restTemplateLoadBalancer;<br><br><span class="hljs-meta">@RequestMapping(&quot;/loadbalancerclient-annotation&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">loadbalancerclientAnnotation</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.restTemplateLoadBalancer.getForObject(<span class="hljs-string">&quot;http://order/order/query&quot;</span>, String.class);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-更改默认负载均衡方式"><a href="#4-更改默认负载均衡方式" class="headerlink" title="4 更改默认负载均衡方式"></a>4 更改默认负载均衡方式</h2><p><a href="https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#switching-between-the-load-balancing-algorithms">https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#switching-between-the-load-balancing-algorithms</a></p><p>默认的负载均衡为轮询</p><p>（1）定义配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomLoadBalancerConfiguration</span> &#123;<br><span class="hljs-meta">@Bean</span><br>ReactorLoadBalancer&lt;ServiceInstance&gt; <span class="hljs-title function_">randomLoadBalancer</span><span class="hljs-params">(Environment environment, LoadBalancerClientFactory loadBalancerClientFactory)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomLoadBalancer</span>(loadBalancerClientFactory.getLazyProvider(name,ServiceInstanceListSupplier.class), name);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）在启动类上通过@LoadBalancerClients注解使用自定义的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@LoadBalancerClients(defaultConfiguration = CustomLoadBalancerConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserApplication</span> &#123;<br></code></pre></td></tr></table></figure><h2 id="5-核心源码分析"><a href="#5-核心源码分析" class="headerlink" title="5 核心源码分析"></a>5 核心源码分析</h2><p>实际上，loadbalancer注解就是给RestTemplate添加了一个拦截器，调用过程简单来说，就是RestTemplate加上loadbalancer注解后，在创建请求之前添加了一个拦截器，在拦截器中通过服务名称调用LoadBalancer的choose方法，获取到真实的ip:port然后再拼接上具体的接口，替换原有uri，再通过RestTemplate进行远程调用。</p><h3 id="5-1-LoadBalancerClient-choose"><a href="#5-1-LoadBalancerClient-choose" class="headerlink" title="5.1 LoadBalancerClient#choose"></a>5.1 LoadBalancerClient#choose</h3><p>（1）LoadBalancerClient的自动装配</p><p><em>BlockingLoadBalancerClientAutoConfiguration</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnBean(LoadBalancerClientFactory.class)</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> LoadBalancerClient <span class="hljs-title function_">blockingLoadBalancerClient</span><span class="hljs-params">(LoadBalancerClientFactory loadBalancerClientFactory)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingLoadBalancerClient</span>(loadBalancerClientFactory);<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）LoadBalancerClient-choose源码分析</p><p><img src="/image/springcloud/loadbalancer/LoadBalancer-choose%E6%BA%90%E7%A0%81.jpg"></p><h3 id="5-2-LoadBalanced和RestTemplate"><a href="#5-2-LoadBalanced和RestTemplate" class="headerlink" title="5.2 @LoadBalanced和RestTemplate"></a>5.2 @LoadBalanced和RestTemplate</h3><h4 id="5-2-1-RestTamplate调用过程"><a href="#5-2-1-RestTamplate调用过程" class="headerlink" title="5.2.1 RestTamplate调用过程"></a>5.2.1 RestTamplate调用过程</h4><p><img src="/image/springcloud/loadbalancer/1.png"></p><h4 id="5-2-2-RestTemplate使用-LoadBalanced"><a href="#5-2-2-RestTemplate使用-LoadBalanced" class="headerlink" title="5.2.2 RestTemplate使用@LoadBalanced"></a>5.2.2 RestTemplate使用@LoadBalanced</h4><p>（1）向Spring IoC容器中注入RestTemplate的Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span> <span class="hljs-comment">// 相当于为RestTemplate整合了LoadBalancer的功能</span><br><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplateLoadBalancer</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）依赖注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(RestTemplate.class)</span><br><span class="hljs-meta">@ConditionalOnBean(LoadBalancerClient.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(LoadBalancerRetryProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoadBalancerAutoConfiguration</span> &#123;<br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-meta">@Autowired(required = false)</span> <span class="hljs-comment">// 获取到restTemplateLoadBalancer，然后给其添加拦截器</span><br><span class="hljs-keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();<br></code></pre></td></tr></table></figure><p>（3）创建拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> LoadBalancerInterceptor <span class="hljs-title function_">loadBalancerInterceptor</span><span class="hljs-params">(LoadBalancerClient loadBalancerClient,</span><br><span class="hljs-params">                                                       LoadBalancerRequestFactory requestFactory)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoadBalancerInterceptor</span>(loadBalancerClient, requestFactory);<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）给指定的restTemplate添加拦截器属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> RestTemplateCustomizer <span class="hljs-title function_">restTemplateCustomizer</span><span class="hljs-params">(<span class="hljs-keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> &#123;<br><span class="hljs-keyword">return</span> restTemplate -&gt; &#123;<br>        List&lt;ClientHttpRequestInterceptor&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(restTemplate.getInterceptors());<br>list.add(loadBalancerInterceptor);<br>restTemplate.setInterceptors(list);<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）拥有了拦截器能力的RestTemplate</p><p><img src="/image/springcloud/loadbalancer/2.png"></p>]]></content>
    
    
    <categories>
      
      <category>springcloud</category>
      
      <category>LoadBalancer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>LoadBalancer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis常见问题</title>
    <link href="/2023/03/03/redis/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/03/03/redis/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1-数据一致性问题"><a href="#1-数据一致性问题" class="headerlink" title="1   数据一致性问题"></a>1   数据一致性问题</h2><h3 id="1-1-缓存使用场景"><a href="#1-1-缓存使用场景" class="headerlink" title="1.1  缓存使用场景"></a>1.1  缓存使用场景</h3><p>针对读多写少的高并发场景，可以使用缓存来提升查询速度。使用redis作为缓存的时候，一般流程是这样的：</p><ol><li>如果数据在redis存在，应用就可以直接从redis拿到数据，不用访问数据库。</li></ol><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/1.png"></p><ol start="2"><li>应用新增了数据，只保存在数据库中，这个时候redis没有这条数据。如果redis里面没有，先到数据库查询，然后写入到redis，再返回给应用。</li></ol><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/2.png"></p><h3 id="1-2-一致性问题的定义"><a href="#1-2-一致性问题的定义" class="headerlink" title="1.2  一致性问题的定义"></a>1.2  一致性问题的定义</h3><p>因为数据最终是以数据库为准的（这是原则），如果redis没有数据，就不存在这个问题。当redis和数据库都有同一条记录，而这条记录发生变化的时候，就可能出现一致性问题。一旦被缓存的数据发生变化（比如修改，删除）的时候，既要操作数据库的数据，也要操作redis的数据，才能让redis和数据库保持一致。所以问题来了。现在有两种选择：</p><p>​    1.先操作redis的数据再操作数据库的数据</p><p>​    2.先操作数据库的数据再操作redis的数据</p><p>​    首先需要明确的是，不管选择哪一种方案，肯定是希望两个操作要么都成功，要么都不成功。但是，redis的数据和数据库是不可能通过事务达到统一的，只能根据相应的场景和所需要付出的代价来采取一些措施降低数据不一致的问题出现的概率，在数据一致性和性能之间取得一个权衡。</p><p>​    比如，对于数据库的实时性一致性要求不是特别高的场合，比如T+1的报表，可以采用定时任务查询数据库数据同步到redis的方案。由于是以数据库的数据为准的，所以给缓存设置一个过期时间，删除redis的数据，也能保证最终一致性。既然提到了Redis和数据库一致性的问题，一般是希望尽可能靠近实时一致性，操作延迟带来的不一致的时间越少越好。</p><h3 id="1-3-方案选择"><a href="#1-3-方案选择" class="headerlink" title="1.3  方案选择"></a>1.3  方案选择</h3><h4 id="1-3-1-redis：删除还是更新？"><a href="#1-3-1-redis：删除还是更新？" class="headerlink" title="1.3.1 redis：删除还是更新？"></a>1.3.1 redis：删除还是更新？</h4><p>这里补充一点：当存储的数据发生变化，redis的数据也要更新的时候，有两种方案，一种就是直接更新redis数据，调用set；还有一种是直接删除redis数据，让应用在下次查询的时候重新写入。</p><p>​    更新缓存之前，是不是要经过其他表的查询，接口调用，计算才能得到最新的数据，而不是直接从数据库拿到的值。如果是的话，建议直接删除，这种方案更加简单，而且避免了数据库的数据和缓存不一致的情况。在一般情况下，也推荐使用删除的方案。所以，更新操作和删除操作，只要数据变化，都用删除。</p><h4 id="1-3-2-先更新数据库，再删除缓存"><a href="#1-3-2-先更新数据库，再删除缓存" class="headerlink" title="1.3.2 先更新数据库，再删除缓存"></a>1.3.2 先更新数据库，再删除缓存</h4><p>正常情况：更新数据库成功，删除缓存成功。</p><p>异常情况：</p><p>​    1. 更新数据库失败，程序捕获异常，不会走到下一步，数据不会出现不一致。</p><p>​    2. 更新数据成功，删除缓存失败。数据库是新数据，缓存是旧数据，发生了不一致的情况。</p><p>​    对于这个问题，可以提供一个重试机制。比如：如果删除缓存失败，捕获这个异常，把需要删除的key发送到消息队列。然后自己创建一个消费者消费，尝试再次删除这个key。这种方式有个缺点，会对业务代码造成入侵。</p><p>​    所以有了第二种方案(异步更新缓存)：因为更新数据库时会往binlog写入日志，所以可以通过一个服务来监听binlog的变化(比如阿里的canal)，然后在客户端完成删除key的操作。如果删除失败的话，在发送到消息队列。<a href="https://gper.club/articles/7e7e7f7ff3g59gc6g6d">https://gper.club/articles/7e7e7f7ff3g59gc6g6d</a> (canal)。总之，对于后删除缓存失败的情况，我们的做法是不断地重试删除，直到成功。无论是重试还是异步删除，都是最终一致性地思想。</p><h4 id="1-3-3-先删除缓存，再更新数据库"><a href="#1-3-3-先删除缓存，再更新数据库" class="headerlink" title="1.3.3 先删除缓存，再更新数据库"></a>1.3.3 先删除缓存，再更新数据库</h4><p>正常情况：删除缓存成功，更新数据库成功。</p><p>异常情况：</p><p>​    1.删除缓存，程序捕获异常，不会走到下一步，数据不会出现不一致。</p><p>​    2.删除缓存成功，更新数据库失败。因为以数据库的数据为准，所以不存在数据不一致的情况。</p><p>​    看起来好像没有问题，但是如果有程序并发操作的情况下：</p><p>​    1）线程A需要更新数据，首先删除了redis缓存</p><p>​    2）线程B查询数据，发现缓存不存在，到数据库查询旧值，写入redis，返回</p><p>​    3）线程A更新了数据库</p><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/3.png"></p><p>这个时候，redis 是旧值，数据库是新的值，发生了数据不一致的情况。</p><p>​    这个是由线程并发造成的问题，能不能让对同一条数据的访问串行化呢？代码肯定保证不了，因为有多个线程，即使做了任务队列也可能有多个应用实例（应用做了集群部署）。数据库也保证不了，因为会有多个数据库的连接。只有一个数据库只提供一个连接的情况下，才能保证读写的操作的串行的，或者我们把所有的读写请求放到同一个内存队列当中，但是强制串行操作，吞吐量太低了。</p><p>​    所以有一种延时双删的策略，在写入数据之后，再删除一次缓存。</p><p>​    A线程：1）删除缓存。 2）更新数据库。 3）休眠500ms（这个时间，依据读取数据的耗时而定）。 4）再次删除缓存。 伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String key, Object data)</span>&#123;<br>    redis.delKey(key);<br>    db.updateData(data);<br>    Thread.sleep(<span class="hljs-number">500</span>);<br>    redis.delKey(key);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-高并发问题"><a href="#2-高并发问题" class="headerlink" title="2  高并发问题"></a>2  高并发问题</h2><p>在redis存储的所有数据中，有一部分是被频繁访问的。有两种情况可能会导致热点问题的产生，一个是用户集中访问的数据，比如抢购商品，明星结婚和明星出轨的微博。还有一种就是在数据进行分片的情况下，负载不均衡，超过了单个服务器的承受能力。热点问题可能引起缓存服务的不可用，最终造成压力堆积到数据库。出于存储和流量优化的角度，必须要找到这些热点数据。</p><h3 id="2-1-热点数据发现"><a href="#2-1-热点数据发现" class="headerlink" title="2.1  热点数据发现"></a>2.1  热点数据发现</h3><h4 id="2-1-1-客户端"><a href="#2-1-1-客户端" class="headerlink" title="2.1.1 客户端"></a>2.1.1 客户端</h4><p>比如可不可以在所有调用了get，set方法的地方，加上key的计数。但是这样的话，每一个地方都要修改，重复代码也多。如果用的是Jedis的客户端，可以修改Jedis的源码，在jedis的connection类的sendCommand()里面，用一个HashMap进行key的计数。但是这种方式有几个问题：</p><p>​    1.会对客户端的代码造成入侵</p><p>​    2.不知道要存多少个key，可能发生内存泄漏的问题。</p><p>​    3.只能统计当前客户端的热点key。</p><h4 id="2-1-2-代理层"><a href="#2-1-2-代理层" class="headerlink" title="2.1.2 代理层"></a>2.1.2 代理层</h4><p>第二种方式就是在代理层实现，比如TwemProxy或者Codis，但是不是所有的项目都使用了代理的架构。</p><h4 id="2-1-3-服务端"><a href="#2-1-3-服务端" class="headerlink" title="2.1.3 服务端"></a>2.1.3 服务端</h4><p>第三种就是在服务端统计，redis有一个monitor的命令，可以监控到所有redis执行的命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.monitor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisMonitor</span>()&#123;<br>   <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCommand</span><span class="hljs-params">(String command)</span>&#123;<br>        System.out.printLn(<span class="hljs-string">&quot;#monitor&quot;</span> + command);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>Facebook的开源项目redis-faina就是基于这个原理实现的。它是一个python脚本，可以分析monitor的数据。</p><p><a href="https://github.com/facebookarchive/redis-faina.git">https://github.com/facebookarchive/redis-faina.git</a></p><p>这种方法也会有两个问题：1）monitor命令在高并发的场景下，会影响性能，所以不适合长时间使用。2）只能统计一个redis节点的热点key。</p><h4 id="2-1-4-机器层面"><a href="#2-1-4-机器层面" class="headerlink" title="2.1.4 机器层面"></a>2.1.4 机器层面</h4><p>还有一种方法就是机器层面的，通过对TCP协议进行抓包，也有一些开源的方案，比如ELK的packetbeat插件。发现了热点key之后，来看下热点数据在高并发的场景下可能会出现的问题，以及怎么去解决。</p><h3 id="2-2-缓存雪崩"><a href="#2-2-缓存雪崩" class="headerlink" title="2.2  缓存雪崩"></a>2.2  缓存雪崩</h3><h4 id="2-2-1-什么是缓存雪崩"><a href="#2-2-1-什么是缓存雪崩" class="headerlink" title="2.2.1 什么是缓存雪崩"></a>2.2.1 什么是缓存雪崩</h4><p>缓存雪崩就是Redis的大量热点数据同时过期（失效），因为设置了相同的过期时间，刚好这个时候redis请求的并发量又很大，就会导致所有的请求落到数据库。</p><h4 id="2-2-2-缓存雪崩的解决方案"><a href="#2-2-2-缓存雪崩的解决方案" class="headerlink" title="2.2.2 缓存雪崩的解决方案"></a>2.2.2 缓存雪崩的解决方案</h4><p>​    1）加互斥锁或者使用队列，针对同一个key只允许一个线程到数据库查询</p><p>​    2）缓存定时预先更新，避免同时失效</p><p>​    3）通过加随机数，使得key在不同的时间过期</p><p>​    4）缓存永不过期</p><h3 id="2-3-缓存穿透"><a href="#2-3-缓存穿透" class="headerlink" title="2.3  缓存穿透"></a>2.3  缓存穿透</h3><h4 id="2-3-1-缓存穿透何时发生"><a href="#2-3-1-缓存穿透何时发生" class="headerlink" title="2.3.1 缓存穿透何时发生"></a>2.3.1 缓存穿透何时发生</h4><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/4.png"></p><p>在这里redis起到了提升查询速度和保护数据库的作用。还有一种情况，数据在数据库和redis里面都不存在，可能是一次条件错误的查询。在这种情况下，因为数据库值不存在，所以肯定不会写入redis，那么下一次查询相同的key的时候，肯定还是会再到数据库查一次。那么这种循环查询数据库中不存在的值，并且每次使用的是相同的key的情况，该怎么避免应用到数据库查询？</p><p>​    （1）缓存空数据 （2）缓存特殊字符串，比如&amp;&amp;</p><p>​    可以在数据库缓存一个空字符串，或者缓存一个特殊的字符串。那么在应用里面拿到这个特殊字符串的时候，就知道数据库没有值了，也没有必要再到数据库查询了。但是这里需要设置一个过期时间，不然的话数据库已经新增了这一条记录，应用也还是拿不到值。</p><p>​    这个是应用重复查询同一个不存在的值的情况，如果应用每一次查询的不存在的值是不一样的？即使每次都缓存特殊字符串也没用，因为它的值不一样，比如我们的用户系统登陆的场景，如果是恶意的请求，它每次都生成了一个符合ID规则的账号，但是这个账号在数据库是不存在的，那redis就完全失去了作用。这种因为每次查询的值都不存在导致的redis失效的情况，应该怎么去解决？</p><h4 id="2-3-2-经典面试题"><a href="#2-3-2-经典面试题" class="headerlink" title="2.3.2 经典面试题"></a>2.3.2 经典面试题</h4><p>其实它也是一个通用的问题，关键就在于怎么知道请求的key在数据库中是否存在，如果数据量特别大的话，怎么去快速判断。</p><p>​    这也是一个非常经典的面试题：如何在海量元素中（例如10亿无序，不定长，不重复）快速判断一个元素是否存在？</p><p>​    如果是缓存穿透的这个问题，要避免到数据库查询不存在的数据，肯定要把这10亿放在别的地方。为了加快检索速度，要把数据放到内存里面来判断，问题来了：如果直接把这些元素的值放到基本的数据结构（List，Map，Tree）里面，比如一个元素一字节的字段，10亿的数据大概需要900G的内存空间，这个对于普通的服务器来说是承受不了的。所以，存储着几十亿个元素，不能直接存值，应该找到一种最简单的最节省空间的数据结构，用来标记这个元素有没有出现。（比如签到表顺序打勾）</p><p>​    这个东西叫做位图，它是一个有序的数组，只有两个值，0和1：0代表不存在，1代表存在。</p><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/5.png"></p><p>对于这个映射方法，有几个基本的要求：</p><p>​    1）因为值长度是不固定的，希望不同长度的输入，可以得到固定长度的输出。</p><p>​    2）转换成下标的时候，希望他在我的这个有序数组里面是分布均匀的，不然的话全部挤到一对去了，也没办法判断哪个元素存了，哪个元素没存。</p><p>​    这个就是哈希函数，比如MD5，SHA-1等等这些都是常见的哈希算法。</p><p>比如这6个元素，经过哈希函数和位运算，得到了相应的下标。</p><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/6.png"></p><h4 id="2-3-3-哈希碰撞"><a href="#2-3-3-哈希碰撞" class="headerlink" title="2.3.3 哈希碰撞"></a>2.3.3 哈希碰撞</h4><p>这个时候，Tom和Mic经过计算得到的哈希值是一样的，那么再经过位运算得到的下标肯定是一样的，把这种情况叫做哈希冲突或者哈希碰撞。如果发生过了哈希碰撞，这个时候对于容器存值肯定是由影响的，从数据结构和映射方法这两个角度来分析，可以通过哪些方式去降低哈希碰撞的概率呢？</p><p>第一种是扩大数组的长度或者说位图容量。因为函数是分布均匀的，所以，位图容量越大，再同一位置发生哈希碰撞的概率越小。是不是位图的容量越大越好？不管存多少个元素，都创建一个几万亿大小的位图，可以吗？当然不行，因为越大的位图容量，意味着越多的内存消耗，所以要建立一个合适大小的位图容量。</p><p>除了扩大位图容量，还有第二种方法，只用一个哈希函数，现在对于每一个要存储的元素都用多个哈希函数计算，这样每次计算出来的下标都相同的概率就小很多了。</p><p>同样的，可以引入很多个哈希函数，也会有问题，第一个就是它会填满位图的更多空间，第二个是计算是需要消耗时间的。</p><p>所以总的来说，既要节省空间，又要很高的计算效率，就必须在位图容量和函数个数之间找到一个最佳的平衡。</p><h4 id="2-3-4-布隆过滤器-BF-原理"><a href="#2-3-4-布隆过滤器-BF-原理" class="headerlink" title="2.3.4 布隆过滤器(BF)原理"></a>2.3.4 布隆过滤器(BF)原理</h4><p>当然，这个事情早就有人研究过了，在1970年的时候，有一个叫做布隆的前辈对于判断海量元素中元素是否存在的问题进行了研究，也就是到底需要多大的位图容量和多少个哈希函数，提出的这个容器就叫做布隆过滤器。</p><p>布隆过滤器的工作原理：首先，布隆过滤器的本质就是刚才分析的，一个位数组码和若干个哈希函数。</p><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/7.png"></p><p>集合中有三个元素，要把它存到布隆过滤器中去，怎么做？首先是a元素，这里用3次计算。b，c元素也一样。元素已经存进去之后，现在要来判断一个元素在这个容器里面是否存在，就要使用同样的三个函数进行计算。比如d元素，用第一个函数f1计算，发现这个位置上是1，没问题。第二个位置也是1，第三个位置也是1.如果经过三次计算得到的下标位置都是1，这种情况下，能不能确定d元素一定在这个容器中呢？实际上是不能的。比如这张图里面，这三个位置分别是把abc存进去的时候置成1的，所以即使d元素之前没有存进去，也会得到1，判断返回true。</p><p>​    所以，这个是布隆过滤器的一个很重要的特性，因为哈希碰撞不可避免，所以它会存在一定的误判率。这种把本来不存在布隆过滤器中的元素误判为存在的情况，把它叫做假阳性(False Positive Probability，FPP)。</p><p>​    再来看另一个元素，e元素。要判断它在容器中是否存在，一样的要用这三个函数去计算。第一个位置是1，第二个位置是1，第三个位置是0。E元素是不是一定不在这个容器中呢？可以确定一定不存在，如果说但是已经把e元素存到布隆过滤器中去了，那么这三个位置肯定是1，不会出现0.</p><p>​    总结，布隆过滤器的特点；</p><p>​    从容器的角度来说：</p><ol><li><p>如果布隆过滤器判断元素在集合中存在，不一定存在</p></li><li><p>如果布隆过滤器判断不存在，一定不存在</p></li></ol><p>从元素的角度来说：</p><ol start="3"><li><p>如果元素实际存在，布隆过滤器一定判断存在</p></li><li><p>如果元素实际不存在，布隆过滤器可能判断存在</p></li></ol><h4 id="2-3-5-Guava-BF实现"><a href="#2-3-5-Guava-BF实现" class="headerlink" title="2.3.5 Guava BF实现"></a>2.3.5 Guava BF实现</h4><p>谷歌的Guava中就提供了一个现成的布隆过滤器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>21.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>创建布隆过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">BloomFilter&lt;String&gt; bf = BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), insertions);<br></code></pre></td></tr></table></figure><p>布隆过滤器提供的存放元素的方法是put()。布隆过滤器提供的判断元素是否存在的方法是mightContain().</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(bf.mightContain(data))&#123;<br>    <span class="hljs-keyword">if</span>(sets.contains(data))&#123;<br>        <span class="hljs-comment">//判断存在实际存在的时候，命中</span><br>        right++;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-comment">//判断存在但实际不存在的时候，错误</span><br>    wrong++;<br>&#125;<br></code></pre></td></tr></table></figure><p>布隆过滤器把误判率默认设置位0.03，也可以在创建的时候指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; BloomFilter&lt;T&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(Funnel&lt;? <span class="hljs-built_in">super</span> T&gt;funnel, <span class="hljs-type">long</span> expectedInsertions)</span>&#123;<br>    <span class="hljs-keyword">return</span> create(funnel, expectedInsertions, <span class="hljs-number">0.03D</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>位图的容量是基于元素个数和误判率计算出来的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">long numBits = optimal<span class="hljs-constructor">NumOfBits(<span class="hljs-params">expectedInsertions</span>, <span class="hljs-params">fpp</span>)</span>;<br></code></pre></td></tr></table></figure><p>根据位图数组的大小，进一步计算出了哈希函数的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">numHashFunctions</span> <span class="hljs-operator">=</span> optimalNumOfHashFunctions(expectedInsertions, numBits);<br></code></pre></td></tr></table></figure><p>存储100万个元素只占用了0.87M的内存，生成了5个哈希函数。</p><h4 id="2-3-6-bf在项目中的使用"><a href="#2-3-6-bf在项目中的使用" class="headerlink" title="2.3.6 bf在项目中的使用"></a>2.3.6 bf在项目中的使用</h4><p>布隆过滤器的工作位置</p><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/8.png"></p><p>因为要判断数据库的值是否存在，所以第一步是加载数据库所有的数据。在去redis查询之前，现在布隆过滤器查询，如果bf说没有，那数据库肯定没有，也不用去查了。如果bf说有，才走之前的流程。</p><h4 id="2-3-7-布隆过滤器的不足与变种"><a href="#2-3-7-布隆过滤器的不足与变种" class="headerlink" title="2.3.7 布隆过滤器的不足与变种"></a>2.3.7 布隆过滤器的不足与变种</h4><p>如果数据库删除了，布隆过滤器的数据也要删除。但是布隆过滤器里面没有提供删除的方法。为什么布隆过滤器不提供删除的方法呢？或者说，如果删除了布隆过滤器的元素，会发生什么问题？</p><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/9.png"></p><p>比如把a删除了，那么三个位置都要改成0，但是再来判断b元素是否存在的时候，因为有一个位置变成了0，所以b元素也判断不存在。就是因为存在哈希碰撞，所以元素只能存入，不能删除。</p><p>那如果要实现删除的功能，怎么做？类似于HashMap的链地址法，可以在每个下标位置上增加一个计数器。比如这个位置命中了两次，计数器就是2。当删除a元素的时候，先把计数器改成1，删除b元素的时候，计数器变成0，这个时候下标对应的位才置成0。</p><p>实际上在布隆过滤器提出来的几十年中，出现了很多布隆过滤器的变种，这种通过计数器提供删除功能的bf叫做Counting Bloom Filter</p><h4 id="2-3-8-布隆过滤器的其他应用场景"><a href="#2-3-8-布隆过滤器的其他应用场景" class="headerlink" title="2.3.8 布隆过滤器的其他应用场景"></a>2.3.8 布隆过滤器的其他应用场景</h4><p>布隆过滤器解决的问题是如何在海量元素中快速判断一个元素是否存在。所以除了解决缓存穿透的问题之外，还有很多其他的用途。</p><p>比如爬虫，爬过的url不需要重复爬，那么在几十亿的url中，怎么判断一个url是不是已经爬过了？还有邮箱服务器，发送垃圾邮件的账号把它们叫做spamer，在这么多的邮箱账号中，怎么判断一个账号是不是spamer？等等一些场景，都可以使用到布隆过滤器。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis客户端</title>
    <link href="/2023/03/02/redis/Redis%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <url>/2023/03/02/redis/Redis%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="1-通信协议"><a href="#1-通信协议" class="headerlink" title="1  通信协议"></a>1  通信协议</h2><p>Redis监听默认6379的端口号，可以通过TCP方式建立连接。服务端约定了一种特殊的消息格式，每个命令都是以\r\n（CRLF回车+换行）结尾。这种编码格式之前在AOF文件中见到了，叫做Redis Serialization Protocol（RESP，redis序列化协议），发消息或者相应消息需要按这种格式编码，接受消息需要按这种格式解码，redis设计这种格式的原因：容易实现，解析快，可读性强。Redis6.0新特性里面说得RESP协议升级到了3.0版本，其实就是对于服务端和客户端可以接受的消息进行了升级扩展，比如客户端缓存的功能就是在这个版本中实现的。自己实现一个Redis的java客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClient</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">private</span> OutputStream write;<br>    <span class="hljs-keyword">private</span> InputStream read;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClient</span><span class="hljs-params">(String host, <span class="hljs-type">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(host, port);<br>        write = socket.getOutputStream();<br>        read = socket.getInputStream();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(String key, String val)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-comment">// 代表3个参数</span><br>        sb.append(<span class="hljs-string">&quot;*3&quot;</span>).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第一个参数(set)的长度</span><br>        sb.append(<span class="hljs-string">&quot;#3&quot;</span>).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第一个参数的内容</span><br>        sb.append(<span class="hljs-string">&quot;SET&quot;</span>).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第二个参数key的长度，(不定，动态获取)</span><br>        sb.append(<span class="hljs-string">&quot;$&quot;</span>).append(key.getBytes().length).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第二个参数key的内容</span><br>        sb.append(key).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第三个参数value的长度，(不定，动态获取)</span><br>        sb.append(<span class="hljs-string">&quot;$&quot;</span>).append(val.getBytes().length).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第三个参数val的内容</span><br>        sb.append(val).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <br>        <span class="hljs-comment">//发送命令</span><br>        write.write(sb.toString().getBytes());<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">//接受响应</span><br>        read.read(bytes);<br>        System.out.printLn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-comment">// 代表2个参数</span><br>        sb.append(<span class="hljs-string">&quot;*2&quot;</span>).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第一个参数(get)的长度</span><br>        sb.append(<span class="hljs-string">&quot;#3&quot;</span>).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第一个参数的内容</span><br>        sb.append(<span class="hljs-string">&quot;GET&quot;</span>).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第二个参数key的长度，(不定，动态获取)</span><br>        sb.append(<span class="hljs-string">&quot;$&quot;</span>).append(key.getBytes().length).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第二个参数key的内容</span><br>        sb.append(key).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <br>        <span class="hljs-comment">//发送命令</span><br>        write.write(sb.toString().getBytes());<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">//接受响应</span><br>        read.read(bytes);<br>        System.out.printLn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-type">MyClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClient</span>(<span class="hljs-string">&quot;192.168.44.181&quot;</span>, <span class="hljs-number">6379</span>);<br>        client.set(<span class="hljs-string">&quot;qs&quot;</span>, <span class="hljs-string">&quot;2673&quot;</span>);<br>        client.get(<span class="hljs-string">&quot;qs&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用这种协议，可以用java实现所有的redis操作命令。</p><h2 id="2-常用客户端"><a href="#2-常用客户端" class="headerlink" title="2  常用客户端"></a>2  常用客户端</h2><p><a href="https://redis.io/resources/clients/#java%EF%BC%8C%E5%AE%98%E7%BD%91%E6%8E%A8%E8%8D%90%E7%9A%84java%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%89%E4%B8%89%E4%B8%AA%EF%BC%9AJedis%EF%BC%8CRedisson%E5%92%8CLuttce">https://redis.io/resources/clients/#java，官网推荐的java客户端有三个：Jedis，Redisson和Luttce</a></p><table><thead><tr><th>客户端</th><th>作用</th></tr></thead><tbody><tr><td>Jedis</td><td>体系非常小，但是功能很完善</td></tr><tr><td>Lettuce</td><td>高级客户端，支持线程安全，异步，反应式编程，支持集群，哨兵，pipeline，编解码</td></tr><tr><td>Redisson</td><td>基于Redis服务实现的java分布式可扩展的数据结构</td></tr></tbody></table><p>Spring操作redis提供了一个模板方法，RedisTemplate。实际上这个并不是spring官方开发的一个客户端呢。Spring定义了一个连接工厂接口：redisConnectionFactory。这个接口有很多实现，例如：JedisConnectionFactory，JredisConnectionFactory，LettuceConnectionFactory，SrpConnectionFactory。也就是说，RedisTemplate对其他现成的客户端再进行了一层封装而已。在springboot 2.x版本之前，RedisTemplate默认使用Jedis。2.x版本之后，默认使用Lettuce。</p><h2 id="3-Jedis"><a href="#3-Jedis" class="headerlink" title="3  Jedis"></a>3  Jedis</h2><p><a href="https://github.com/redis/jedis/">https://github.com/redis/jedis/</a></p><h3 id="3-1-Jedis功能特性"><a href="#3-1-Jedis功能特性" class="headerlink" title="3.1 Jedis功能特性"></a>3.1 Jedis功能特性</h3><p>Jedis是最熟悉和最常用的客户端。如果不用RedisTemplate，就可以直接创建Jedis的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>    jedis.set(<span class="hljs-string">&quot;qs&quot;</span>, <span class="hljs-number">6379</span>);<br>    System.out.printLn(jedis.get(<span class="hljs-string">&quot;qs&quot;</span>));<br>    jedis.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>Jedis有一个问题：多个线程使用一个连接的时候线程不安全。</p><p>下面也提供了解决思路：使用连接池，为每个请求创建不同的连接，基于Apache common pool实现。Jedis的连接池有三个实现：JedisPool，ShardedJedisPool。JedisSentinePool。都是用getResource从连接池获取一个连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//普通连接池</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ordinaryPool</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">JedisPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(<span class="hljs-string">&quot;192.168.44.181&quot;</span>, <span class="hljs-number">6379</span>);<br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> pool.getResource();<br>    System.out.printLn(jedis.get(<span class="hljs-string">&quot;qs&quot;</span>));<br>&#125;<br><br><span class="hljs-comment">//分片连接池</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shardedPool</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>    <span class="hljs-type">JedisSjardInfo</span> <span class="hljs-variable">shardInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisShardInfo</span>(<span class="hljs-string">&quot;192.168.44.181&quot;</span>, <span class="hljs-number">6379</span>);<br>    List&lt;JedisShardInfo&gt; infoList = Arrays.asList(shardInfo);<br>    <span class="hljs-type">ShardedJedisPool</span> <span class="hljs-variable">jedisPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShardedJedisPool</span>(poolConfig, infoList);<br>    <br>    <span class="hljs-type">ShardedJedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> jedisPool.getResource();<br>    System.out.printLn(jedis.get(<span class="hljs-string">&quot;qs&quot;</span>));<br>&#125;<br><br><span class="hljs-comment">//哨兵连接池</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sentinelPool</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">masterName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;redis-master&quot;</span>;<br>    Set&lt;String&gt; sentinels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    sentinels.add(<span class="hljs-string">&quot;192.168.44.186:26379&quot;</span>);<br>    sentinels.add(<span class="hljs-string">&quot;192.168.44.187:26379&quot;</span>);<br>    sentinels.add(<span class="hljs-string">&quot;192.168.44.188:26379&quot;</span>);<br>    <br>    <span class="hljs-type">JedisSentinelPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisSentinelPool</span>(masterName, sentinels);<br>    System.out.printLn(pool.getResource().get(<span class="hljs-string">&quot;qs&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>Jedis的功能比较完善，redis官方的特性全部支持，比如发布订阅，事务，Lua脚本，客户端分片，哨兵，集群，pipeline等等。</p><h3 id="3-2-Sentinel获取连接原理"><a href="#3-2-Sentinel获取连接原理" class="headerlink" title="3.2 Sentinel获取连接原理"></a>3.2 Sentinel获取连接原理</h3><p>在构造方法中（JedisSentinelPool）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisSentinelPool</span>(masterName, sentinels);<br></code></pre></td></tr></table></figure><p>调用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HostAndPort</span> <span class="hljs-variable">master</span> <span class="hljs-operator">=</span> initSentinels(sentinels, masterName);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">private</span> HostAndPort <span class="hljs-title function_">initSentinels</span><span class="hljs-params">(Set&lt;String&gt; sentinels, String masterName)</span> &#123;<br>      <span class="hljs-type">HostAndPort</span> <span class="hljs-variable">master</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">sentinelAvailable</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-built_in">this</span>.log.info(<span class="hljs-string">&quot;Trying to find master from available Sentinels...&quot;</span>);<br>      <span class="hljs-type">Iterator</span> <span class="hljs-variable">var5</span> <span class="hljs-operator">=</span> sentinels.iterator();<br><br>      String sentinel;<br>      HostAndPort hap;<br>      <span class="hljs-comment">//有多个sentinels，遍历这些sentinel</span><br>      <span class="hljs-keyword">while</span>(var5.hasNext()) &#123;<br>          sentinel = (String)var5.next();<br>          <span class="hljs-comment">//host:port表示的sentinel地址转化成一个HostAndPort对象</span><br>          hap = HostAndPort.parseString(sentinel);<br>          <span class="hljs-built_in">this</span>.log.debug(<span class="hljs-string">&quot;Connecting to Sentinel &#123;&#125;&quot;</span>, hap);<br>          <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>          <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">//连接到sentinel</span><br>              jedis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(hap.getHost(), hap.getPort(), <span class="hljs-built_in">this</span>.sentinelConnectionTimeout,<br>                                <span class="hljs-built_in">this</span>.sentinelSoTimeout);<br>              <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.sentinelUser != <span class="hljs-literal">null</span>) &#123;<br>                  jedis.auth(<span class="hljs-built_in">this</span>.sentinelUser, <span class="hljs-built_in">this</span>.sentinelPassword);<br>              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.sentinelPassword != <span class="hljs-literal">null</span>) &#123;<br>                  jedis.auth(<span class="hljs-built_in">this</span>.sentinelPassword);<br>              &#125;<br><br>              <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.sentinelClientName != <span class="hljs-literal">null</span>) &#123;<br>                  jedis.clientSetname(<span class="hljs-built_in">this</span>.sentinelClientName);<br>              &#125;<br><span class="hljs-comment">//根据masterName得到master的地址，返回一个list，host=list[0],port=list[1]</span><br>              List&lt;String&gt; masterAddr = jedis.sentinelGetMasterAddrByName(masterName);<br>              sentinelAvailable = <span class="hljs-literal">true</span>;<br>              <span class="hljs-keyword">if</span> (masterAddr != <span class="hljs-literal">null</span> &amp;&amp; masterAddr.size() == <span class="hljs-number">2</span>) &#123;<br>                  <span class="hljs-comment">//如果在任何一个sentinel中找到了master，不再遍历sentinels</span><br>                  master = <span class="hljs-built_in">this</span>.toHostAndPort(masterAddr);<br>                  <span class="hljs-built_in">this</span>.log.debug(<span class="hljs-string">&quot;Found Redis master at &#123;&#125;&quot;</span>, master);<br>                  <span class="hljs-keyword">break</span>;<br>              &#125;<br>              <span class="hljs-built_in">this</span>.log.warn(<span class="hljs-string">&quot;Can not get master addr, master name: &#123;&#125;. Sentinel: &#123;&#125;&quot;</span>, masterName, hap);<br>          &#125; <span class="hljs-keyword">catch</span> (JedisException var13) &#123;<br>              <span class="hljs-built_in">this</span>.log.warn(<span class="hljs-string">&quot;Cannot get master address from sentinel running @ &#123;&#125;.&quot;</span>+<br>                            <span class="hljs-string">&quot; Reason: &#123;&#125;. Trying next one.&quot;</span>, hap, var13);<br>          &#125; <span class="hljs-keyword">finally</span> &#123;<br>              <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) &#123;<br>                  jedis.close();<br>              &#125;<br><br>          &#125;<br>      &#125;<br><span class="hljs-comment">//到这里，如果master为null，则说明两种情况，一种是所有的sentinel节点都down了，一种是master节点没有被存活的sentinel监控到</span><br>      <span class="hljs-keyword">if</span> (master == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">if</span> (sentinelAvailable) &#123;<br>              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisException</span>(<span class="hljs-string">&quot;Can connect to sentinel, but &quot;</span> + masterName <br>                                       + <span class="hljs-string">&quot; seems to be not monitored...&quot;</span>);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisConnectionException</span>(<span class="hljs-string">&quot;All sentinels down, cannot determine where is &quot;</span> <br>                                                 + masterName + <span class="hljs-string">&quot; master is running...&quot;</span>);<br>          &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">//如果走到这里，说明找到了master地址</span><br>          <span class="hljs-built_in">this</span>.log.info(<span class="hljs-string">&quot;Redis master running at &#123;&#125;, starting Sentinel listeners...&quot;</span>, master);<br>          var5 = sentinels.iterator();<br><span class="hljs-comment">//启动对每个sentinels的监听为每个sentinel都启动了一个监听者MasterListener。MasterListener本身是一个线程，它会去订阅sentinel上关于master节点地址改变的信息</span><br>          <span class="hljs-keyword">while</span>(var5.hasNext()) &#123;<br>              sentinel = (String)var5.next();<br>              hap = HostAndPort.parseString(sentinel);<br>              <span class="hljs-type">MasterListener</span> <span class="hljs-variable">masterListener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MasterListener</span>(masterName, hap.getHost(),<br>                                                                 hap.getPort());<br>              masterListener.setDaemon(<span class="hljs-literal">true</span>);<br>              <span class="hljs-built_in">this</span>.masterListeners.add(masterListener);<br>              masterListener.start();<br>          &#125;<br>          <span class="hljs-keyword">return</span> master;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-Cluster获取连接原理"><a href="#3-3-Cluster获取连接原理" class="headerlink" title="3.3 Cluster获取连接原理"></a>3.3 Cluster获取连接原理</h3><p>使用Jedis连接Cluster的时候，我们只需要连接到任意一个或者多个redis group中的实例地址，为了避免get，set的时候发生重定向错误，需要把slot和redis节点的关系保存起来，在本地计算slot，就可以获得redis节点信息。</p><p><img src="/image/redis/redis%E5%AE%A2%E6%88%B7%E7%AB%AF/1.png"></p><p>注意slots的数量是写死的，不能修改。</p><p>第一，在服务端表示16384个位，只需要2kb的大小（每个group维护一个位数组，在16384bit里面把对应下表的值改成1，就代表slot由当前节点负责）。再大的话，获取slots信息有点浪费通信资源。</p><p>第二，一般来说集群的节点数不会特别大，16384个slots够他们分了。</p><p><em>关键问题：在于如何存储slot和redis连接池的关系。</em></p><ol><li>程序启动初始化集群环境，读取配置文件中的节点配置，无论是主从，无论多少个，只拿第一个，获取redis连接实例。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeSlotsCache</span><span class="hljs-params">(Set&lt;HostAndPort&gt; startNodes, GenericObjectPoolConfig poolCOnfig, String password)</span>&#123;<br>    <span class="hljs-keyword">for</span>(HostAndPort hostAndPort : startNodes)&#123;<br>        <span class="hljs-comment">//获取一个Jedis实例</span><br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(hostAndPort.getHost(),hostAndPort.getPort());<br>        <span class="hljs-keyword">if</span>(password != <span class="hljs-literal">null</span>)&#123;<br>            jedis.auth(password);<br>        &#125;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//获取redis节点和Slot虚拟槽</span><br>            cache.discoverClusterNodesAndSlots(jedis);<br>            <span class="hljs-comment">//直接跳出循环</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">catch</span>(JedisConnectionException e)&#123;<br>            <br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span>(jedis != <span class="hljs-literal">null</span>)&#123;<br>                jedis.close();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>discoverClusterNodesAndSlots方法，用获取的redis 连接实例执行clusterSlots()方法，实际执行redis服务端cluster slots命令，获取虚拟槽信息。该集合的基本信息为[long.long,List,List]，第一，第二个元素是该节点负责槽点的其实位置，第三个元素是主节点信息，第四个元素为主节点对应的从节点信息。该list的基本信息为[string,int,string]，第一个为host信息，第二个为port信息，第三个为唯一id。</p></li><li><p>获取有关节点的槽点信息后，调用getAssignedSlotArray(slotinfo)来获取所有的槽点值。</p></li><li><p>再获取主节点的地址信息，调用generateHostAndPort(hostInfo)方法，生成一个hostAndPort对象。</p></li><li><p>再assignSlotsToNode方法中，再根据节点地址信息来设置节点对应的JedisPool，即设置Map&lt;Srting, JedisPool&gt; nodes的值。</p></li></ol><p>接下来判断若此时节点信息为主节点信息时，则调用assignSlotsToNodes方法，设置每个槽点对应的连接池（slave不需要连接），即设置Map&lt;Integer, JedisPool&gt; slots的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">discoverClusterNodesSlots</span><span class="hljs-params">(Jedis jedis)</span>&#123;<br>    w.lock();<br>    <span class="hljs-keyword">try</span>&#123;<br>        reset();<br>        <span class="hljs-comment">//获取节点集合</span><br>        List&lt;Object&gt; slots = jedis.clusterSlots();<br>        <span class="hljs-comment">//遍历3个master节点</span><br>        <span class="hljs-keyword">for</span>(Object slotInfoObj : slots)&#123;<br>            List&lt;object&gt; slotInfo = (List&lt;Object&gt;) slotInfoObj;<br>            <span class="hljs-comment">//如果&lt;=2，代表没有分配slot</span><br>            <span class="hljs-keyword">if</span>(slotInfo.size() &lt;= MASTER_NODE_INDEX)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//获取分配到当前master节点的数据槽</span><br>            List&lt;Integer&gt; slotNums = getAssignedSlotArray(slotInfo);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> slotInfo.size();<br>            <span class="hljs-comment">//第3位和第4位是主从端口的信息</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> MASTER_NODE_INDEX ; i &lt; size ; i++)&#123;<br>                List&lt;Object&gt; hostInfos = (List&lt;Object&gt;) slotInfo.get(i);<br>                <span class="hljs-keyword">if</span>(hostInfos.size() &lt;= <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">//根据IP端口生成HostAndPort实例</span><br>                <span class="hljs-type">HostAndPort</span> <span class="hljs-variable">targetNode</span> <span class="hljs-operator">=</span> generateHostAndPort(hostInfos);<br>                <span class="hljs-comment">//根据HostAndPort解析出ip:port的key值，再根据key从缓存中查询对应的jedisPool实例。如果没有jedisPool实例，就创建JedisPool实例，最后放入缓存中，nodeKey和nodePool的关系</span><br>                setupNodeIfNotExist(targetNode);<br>                <span class="hljs-keyword">if</span>(i == MASTER_NODE_INDEX)&#123;<br>                    assignSlotsToNode(slotNums, targetNode);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        w.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显，这个Map有16384个key，key对应的value是一个连接池信息。有几个Redis Group（或者说有几个master），就有几个不同的连接池。获取slot和redis实例的对应关系之后，接下来就是从集群环境获取值。Jedis集群模式下所有的命令都要调用这个方法：核心代码JedisClusterCommand#runWithRetries</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">connection = connectionHandler.getConnectionFromSlot(JedisClusterCRC16.getSlot(key));<br></code></pre></td></tr></table></figure><ol><li><p>把key作为参数，执行CRC16算法，获取key对应的slot值。</p></li><li><p>通过该slot值，去slots的map集合中获取jedisPool实例。</p></li><li><p>通过jedisPool实例获取jedis实例，最终完成redis数据存取工作。</p></li></ol><h3 id="3-4-Jedis实现分布式锁"><a href="#3-4-Jedis实现分布式锁" class="headerlink" title="3.4 Jedis实现分布式锁"></a>3.4 Jedis实现分布式锁</h3><p>分布式锁的基本需求：</p><p>​    1. 互斥性：只有一个客户端能够持有锁</p><p>​    2. 不会产生死锁：即使持有锁的客户端奔溃，也能保证后续其他客户端可以获取锁。</p><p>​    3. 只有持有这把锁的客户端才能解锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryGetDistributedLock</span><span class="hljs-params">(Jedis jedis, String lockKey, String requestId, <span class="hljs-type">int</span> expireTime)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);<br>    <span class="hljs-keyword">if</span>(LOCK_SUCCESS.equals(result))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    1. lockKey是redis key的名称，谁添加成功这个key，就代表谁获取锁成功。比如有一把修改1001账户余额的锁。</p><p>​    2. requestId是客户端的ID（设置成value），如果我们要保证只有加锁的客户端才能释放锁，就必须获取客户端的ID（保证第三点，自己才能解锁）。</p><p>​    3. SET_IF_NOT_EXIST是我们的命令中加上NX（保证第一点，互斥）。</p><p>​    4. SET_WITH_EXPIRE_TIME，PX代表以毫秒为单位设置key的过期时间（保证第二点，不会死锁）。expireTime是自动释放锁的时间，比如5000代表5秒。</p><p>如果在释放锁的时候，这把锁已经不属于这个客户端（例如已经过期，并且被别的客户端获取锁成功了），那就会出现释放了其他客户端的锁的情况。所以，要先判断是不是自己加的锁，才能释放，为了保证原子性，我们把判断客户端是否相等和删除key的操作放在Lua脚本中执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseDistributedLock</span><span class="hljs-params">(Jedis jedis, String lockKey, String requestId)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1])==ARGV[1] then return redis.call(&#x27;del&#x27;,KEY[1]) else return 0 end&quot;</span>;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.eval(script, Collections.singletonList(lockKey), CollectionssingletonList(requestId));<br>    <span class="hljs-keyword">if</span>(RELEASE_SUCCESS.equals(result))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-Pipline"><a href="#3-5-Pipline" class="headerlink" title="3.5 Pipline"></a>3.5 Pipline</h3><p>平时说redis是单线程的，说的是redis的请求是单线程处理的，只有上一个命令的结果响应以后，下一个命令才会处理。如果要一次操作10万个key，客户端跟服务端就要交互10万次，排队的时间加上网络通信的时间，就会很慢。举个例子，假设一次交互的网络延迟的1毫秒，客户端1秒钟最多只能发送1000个命令。这个就太浪费服务端的性能了。</p><p>​    能不能像把一组命令组装在一起发送给redis服务端执行，然后一次性获得返回结果呢？这个就是Pipeline的作用。Pipeline通过一个队列把所有的命令缓存起来，然后把多个命令在一次连接中发送给服务器。</p><p>​    要是按Pipeline，既要服务端的支持，也要客户端的支持。对于服务端来说，需要能够处理客户端通过一个TCP连接发来的多个命令，并且逐个地执行命令一起返回。对于客户端来说，要把多个命令缓存起来，达到一定地条件就发送出去，最后才处理redis地应答（这里要注意对客户端内存地消耗）。jedis-pipeline的client0buffer限制：8192bytes，客户端堆积的命令超过8M时，会发送给服务端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisOutputStream</span><span class="hljs-params">(<span class="hljs-keyword">final</span> OutputStream out)</span>&#123;<br>    <span class="hljs-built_in">this</span>(out, <span class="hljs-number">8192</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>pipeline对于命令条数没有限制，但是命令可能会受限于TCP包大小。需要注意的是，并不是所有业务场景都要用pipeline。如果某些操作需要马上得到redis操作是否成功的结果，这种场景就不合适。有些场景，例如批量写入数据，对于结果的实时性和成功性要求不高，就可以用Pipeline。</p><h2 id="4-Lettuce"><a href="#4-Lettuce" class="headerlink" title="4  Lettuce"></a>4  Lettuce</h2><p>与Jedis相比，Lettuce则完全克服了其线程不安全的缺点：Lettuce是一个可伸缩的线程安全的redis客户端，支持同步，异步和响应式模式（Reactive）。多个线程可以共享一个连接实例，而不必担心多线程并发问题。</p><p>Lettuce基于Netty框架构建，支持Redis的全部高级功能，如发布订阅，事务，Lua脚本，Sentinel，集群，pipeline支持连接池。Lettuce是springboot 2.x默认的客户端，替换了jedis。集成之后我们不需要单独使用它，直接调用spring的redisTemplate操作，连接和创建和关闭也不需要我们操心。</p><h2 id="5-Redisson"><a href="#5-Redisson" class="headerlink" title="5  Redisson"></a>5  Redisson</h2><p>Redisson是一个在redis的基础上实现的java内存数据网格（In-Memory Data Grid），提供了分布式和可扩展的java数据结构，比如分布式的Map，List，Queue，Set，不需要自己去运行一个服务实现。</p><h3 id="5-1-特点"><a href="#5-1-特点" class="headerlink" title="5.1 特点"></a>5.1 特点</h3><p>基于Netty实现，采用非阻塞IO，性能高；支持异步请求。支持连接池，pipeline，Lua脚本，redis Sentinel， redis cluster。不支持事务，官方建议以lua脚本代替事务。主从，哨兵，集群都支持。Spring也可以配置和注入RedissonClient。</p><h3 id="5-2-实现分布式锁"><a href="#5-2-实现分布式锁" class="headerlink" title="5.2 实现分布式锁"></a>5.2 实现分布式锁</h3><p>在Redisson里面提供了更见简单的分布式锁的实现。</p><p><img src="/image/redis/redis%E5%AE%A2%E6%88%B7%E7%AB%AF/2.png"></p><p>加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">rLock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;updateAccount&quot;</span>);<br>    <span class="hljs-comment">//最多等待100秒，上锁10后自动解锁</span><br>    <span class="hljs-keyword">if</span>(rLock.tryLock(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS))&#123;<br>        System.out.printLn(<span class="hljs-string">&quot;获取锁成功&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">//do something</span><br>    rLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>在获得锁之后，只需要一个tryLock方法，里面有三个参数：</p><p>​    1.waitTime：获取锁的最大等待时间，超过这个时间不再尝试获取锁。</p><p>​    2.leaseTime：如果没有调用unlock，超过了这个时间会自动释放锁。</p><p>​    3.TimeUnit：释放时间的单位</p><p>Redisson的分布式锁的实现原理，在加锁的时候，在redis写入了一个HASH，key是锁名称，field是线程名称，value是1（表示锁的重入次数）。</p><p><img src="/image/redis/redis%E5%AE%A2%E6%88%B7%E7%AB%AF/3.png"></p><p>trylock() -&gt;tryAcquire() -&gt; tryAcquireAsync()-&gt; trylockInnerAsync()，最终也是调用了一段lua脚本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//KEYS[1]锁名称 updateAccount</span><br><span class="hljs-comment">//ARGV[1]key过期时间10000ms</span><br><span class="hljs-comment">//ARGV[2]线程名称</span><br><span class="hljs-comment">//锁名称不存在</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;exists&#x27;</span>,KEYS[<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>)) then<br>    <span class="hljs-comment">//创建一个hash，key=锁名称，field=线程名，value=1</span><br>    redis.call(<span class="hljs-string">&#x27;hset&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">2</span>],<span class="hljs-number">1</span>);<br><span class="hljs-comment">//设置hash的过期时间</span><br>redis.call(<span class="hljs-string">&#x27;prxpire&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> nil;<br>end;<br><span class="hljs-comment">//锁名称存在，判断是否当前线程持有的锁</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">2</span>])==<span class="hljs-number">1</span>) then<br>    <span class="hljs-comment">//如果是，value+1，代表重入次数+1</span><br>    redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">2</span>],<span class="hljs-number">1</span>);<br><span class="hljs-comment">//重新获得锁，需要重新设置key的过期时间</span><br>redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> nil;<br>end;<br><span class="hljs-comment">//锁存在，但是不是当前线程持有，返回过期时间(毫秒)</span><br><span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;pttl&#x27;</span>,KEYS[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><p>释放锁:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//KEYS[1]锁名称 updateAccount</span><br><span class="hljs-comment">//KEYS[2]频道名称rredisson_lock_channel:&#123;updateAccount&#125;</span><br><span class="hljs-comment">//ARGV[1]释放锁的消息 0</span><br><span class="hljs-comment">//ARGV[2]释放时间 10000</span><br><span class="hljs-comment">//ARGV[3]线程名称</span><br><span class="hljs-comment">//锁不存在，过期或者已经释放</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;exists&#x27;</span>,KEYS[<span class="hljs-number">1</span>])==<span class="hljs-number">0</span>) then<br>    <span class="hljs-comment">//发布锁已经释放的消息</span><br>    redis.call(<span class="hljs-string">&#x27;publish&#x27;</span>,KEYS[<span class="hljs-number">2</span>],ARGV[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>end;<br><span class="hljs-comment">//锁存在，但是不是当前线程加的锁</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">3</span>])==<span class="hljs-number">0</span>) then<br>    <span class="hljs-keyword">return</span> nil;<br>end;<br><span class="hljs-comment">//锁存在，是当前线程加的锁，重入次数-1</span><br>local counter=redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">3</span>],<span class="hljs-number">-1</span>);<br><span class="hljs-comment">//减1后大于0，说明这个线程持有这把锁还有其他的任务需要执行</span><br><span class="hljs-keyword">if</span>(counter&gt;<span class="hljs-number">0</span>) then<br>    <span class="hljs-comment">//重新设置锁的过期时间</span><br>    redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">2</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">//减1后等于0，释放锁</span><br>    redis.call(<span class="hljs-string">&#x27;del&#x27;</span>,KEYS[<span class="hljs-number">1</span>]);<br><span class="hljs-comment">//释放后发布消息</span><br>redis.call(<span class="hljs-string">&#x27;publish&#x27;</span>,KEYS[<span class="hljs-number">2</span>],ARGV[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>end;<br><span class="hljs-comment">//其他情况返回nil</span><br><span class="hljs-keyword">return</span> nil;<br></code></pre></td></tr></table></figure><p>这个是Redisson里面分布式锁的实现，在调用的时候非常简单。</p><p>​    1.业务没执行完，锁到期了怎么办？ watchdog（Redisson github wiki）</p><p>​    2.集群模式下，如果对多个master加锁，导致重复加锁怎么办？  Redisson会自动选择同一个master</p><p>​    3.业务没执行完，redis master挂了怎么办？ redis slave还有这个数据</p><p>​    Redisson跟jedis定位不同，它不是一个单纯的redis客户端，而是基于redis实现的分布式的服务，如果有需要用到一些分布式的数据结构，比如还可以基于Redisson的分布式队列实现分布式事务，就可以引入redisson的依赖实现。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis分布式</title>
    <link href="/2023/03/01/redis/Redis%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <url>/2023/03/01/redis/Redis%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>如果要实现redis数据的分片，有三种方案。</p><p>第一种是在客户端实现相关的逻辑，例如用取模或者一致性哈希对key进行分片，查询和修改都先判断key的路由。</p><p>第二种是把做分片处理的逻辑抽取出来，运行一个独立的代理服务，客户端连接到这个代理服务，代理服务做请求的转发。</p><p>第三种就是基于服务端实现。</p><h2 id="1-客户端Sharding-ShardedJedis"><a href="#1-客户端Sharding-ShardedJedis" class="headerlink" title="1  客户端Sharding-ShardedJedis"></a>1  客户端Sharding-ShardedJedis</h2><p>RedisTemplate就是对jedis的封装。</p><p>Jedis有几种连接池。比如这里一个连接到186，一个连接到windows的redis服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShardingTest</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>        <span class="hljs-comment">//Redis服务器</span><br>        <span class="hljs-type">JedisShardInfo</span> <span class="hljs-variable">shardInfo1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisShardInfo</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>        <span class="hljs-type">JedisShardInfo</span> <span class="hljs-variable">shardInfo2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisShardInfo</span>(<span class="hljs-string">&quot;192.168.44.186&quot;</span>, <span class="hljs-number">6379</span>);<br>        <span class="hljs-comment">//连接池</span><br>        List&lt;JedisShardInfo&gt; infoList = Arrays.asList(shardInfo1, shardInfo2);<br>        <span class="hljs-type">ShardedJedisPool</span> <span class="hljs-variable">jedisPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShardedJedisPool</span>(poolConfig, infoList);<br>        <br>        <span class="hljs-type">ShardedJedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            jedis = jedisPool.getResource();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">100</span> i++)&#123;<br>                jedis.set(<span class="hljs-string">&quot;k&quot;</span>+i, <span class="hljs-string">&quot;&quot;</span>+i);<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">100</span> ; i++)&#123;<br>                System.out.printLn(jedis.get(<span class="hljs-string">&quot;k&quot;</span>+i));<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span>(jedis != <span class="hljs-literal">null</span>)&#123;<br>                jedis.close();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过dbsize命令发现，一台服务器有44个key，一台服务器有56个key。如果是希望数据分布相对均匀的话，首先可以考虑哈希后取模(因为key不一定是整数，所以先计算哈希)。</p><p><strong>哈希后取模</strong></p><p>例如，hash(key)%N，根据余数，决定映射到哪个节点。这种方式比较简单，属于静态的分片规则，但是一旦节点数量变化，由于取模的N发生变化，数据需要重新分布。为了解决这个问题，又有了一致性哈希算法。ShardedJedis实际上用的就是一致性哈希算法。</p><p><strong>一致性哈希</strong></p><p>原理：把所有的哈希值空间组织成一个虚拟的圆环(哈希环)，整个空间按顺时针方向组织。因为是环形空间，0和2^32-1是重叠的。假如有四台机器要哈希环来实现映射(分布数据)，先根据机器的名称或者ip计算哈希值，然乎分布到哈希环中(红色圆圈)。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/1.png"></p><p>现在有4条数据或者4个访问请求，对key计算后，得到哈希环中的位置（绿色圆圈）。沿哈希环顺时针找到的第一个node，就是数据存储的节点。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/2.png"></p><p>在这种情况下，新增了一个node5节点，只影响一部分数据的分布。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/3.png"></p><p>删除了一个节点node4，只影响相邻的一个节点。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/4.png"></p><p>一致性哈希解决了动态增减节点时，所有数据都需要重新分布的问题，它只会影响到下一个相邻的系欸但，对其他节点没有影响。但是这样的一致性算法有一个缺点，因为节点不一定是均匀分布的，特别是在节点数比较少的情况下，所以数据不能得到均匀分布。解决这个问题的办法是引入虚拟节点(Virtual node)。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/5.png"></p><p>Node1设置了两个虚拟节点，node2也设置了两个虚拟节点（虚线圆圈）。这时候有3条数据分布到了node1，1条数据分布到了node2。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/6.png"></p><p>一致性哈希在分布式系统中，负载均衡，分库分表等场景中都有应用，跟LRU一样，是一个基础的算法。</p><p><strong>java源码</strong></p><p>Redis.client.util.Sharded.initialze()，jedis实例被放到了一棵红黑树TreeMap中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(List&lt;S&gt; shards)</span> &#123;<br>      <span class="hljs-comment">//创建一个红黑树</span><br>      <span class="hljs-built_in">this</span>.nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>();<br><span class="hljs-comment">//把所有节点放入红黑树中</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i != shards.size(); ++i) &#123;<br>          <span class="hljs-type">S</span> <span class="hljs-variable">shardInfo</span> <span class="hljs-operator">=</span> (ShardInfo)shards.get(i);<br>          <span class="hljs-comment">//为每个Redis节点创建160个虚拟节点，放到红黑树中</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">160</span> * shardInfo.getWeight();<br>          <span class="hljs-type">int</span> n;<br>          <span class="hljs-keyword">if</span> (shardInfo.getName() == <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span>; n &lt; N; ++n) &#123;<br>                  <span class="hljs-built_in">this</span>.nodes.put(<span class="hljs-built_in">this</span>.algo.hash(<span class="hljs-string">&quot;SHARD-&quot;</span> + i + <span class="hljs-string">&quot;-NODE-&quot;</span> + n), shardInfo);<br>              &#125;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span>; n &lt; N; ++n) &#123;<br>                  <span class="hljs-comment">//对名字计算哈希(MurmurHash)</span><br>                  <span class="hljs-built_in">this</span>.nodes.put(<span class="hljs-built_in">this</span>.algo.hash(shardInfo.getName() + <span class="hljs-string">&quot;*&quot;</span> + n), shardInfo);<br>              &#125;<br>          &#125;<br><span class="hljs-comment">//添加到map中，键为ShardInfo，值为redis实例</span><br>          <span class="hljs-built_in">this</span>.resources.put(shardInfo, shardInfo.createResource());<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>当存取键值对时，计算键的哈希值，然后从红黑树上摘下比该值大的第一个节点上的JedisShardInfo，随后从resources去除jedis。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> R <span class="hljs-title function_">getShard</span><span class="hljs-params">(String key)</span>&#123;<br>    <span class="hljs-keyword">return</span> resources.get(getShardInfo(key));<br>&#125;<br></code></pre></td></tr></table></figure><p>获取红黑树子集，找出比它大的第一个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> S <span class="hljs-title function_">getShardInfo</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] key)</span> &#123;<br>    <span class="hljs-comment">//获取比当前key的哈希值要大的红黑树的子集</span><br>    SortedMap&lt;Long, S&gt; tail = <span class="hljs-built_in">this</span>.nodes.tailMap(<span class="hljs-built_in">this</span>.algo.hash(key));<br>    <span class="hljs-keyword">return</span> tail.isEmpty() ? <br>        <span class="hljs-comment">//没有比它大的了，直接从nodes中取出</span><br>        (ShardInfo)<span class="hljs-built_in">this</span>.nodes.get(<span class="hljs-built_in">this</span>.nodes.firstKey()) : <br>    <span class="hljs-comment">//返回第一个比它大的JedisShardInfo</span><br>    (ShardInfo)tail.get(tail.firstKey());<br>&#125;<br></code></pre></td></tr></table></figure><p>使用ShardedJedis之类的客户端分片代码的优势是配置简单，不依赖于其他中间件，分区的逻辑可以自定义，比较灵活。但是基于客户端的方案，不能实现动态的服务增减，每个客户端需要自行维护分片则略，存在重复代码。</p><h2 id="2-代理Proxy"><a href="#2-代理Proxy" class="headerlink" title="2  代理Proxy"></a>2  代理Proxy</h2><p>典型的代理分区方案有Twitter开源的Twemproxy和国内的豌豆荚开源的Codis。</p><h3 id="2-1-Twemproxy"><a href="#2-1-Twemproxy" class="headerlink" title="2.1 Twemproxy"></a>2.1 Twemproxy</h3><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/7.png"></p><p>Twemproxy的优点：比较稳定，可用性高。</p><p>不足：</p><ol><li><p>出现故障不能自动转移，架构复杂，需要借助其他组件（LVS/HAProxy+Keepalived）实现HA</p></li><li><p>扩缩容需要修改配置，不能实现平滑地扩缩容（需要重新分布数据）。</p></li></ol><h3 id="2-2-Codis"><a href="#2-2-Codis" class="headerlink" title="2.2 Codis"></a>2.2 Codis</h3><p>Codis是一个代理中间件，豌豆荚公司用Go语言开发的（快三年时间没有更新了）。跟数据库分库分表中间件的Mycat的工作层次是一样的。功能：客户端连接Codis跟连接redis没有区别。</p><table><thead><tr><th>功能特性</th><th>Codis</th><th>Tewmproxy</th><th>Redis Cluster</th></tr></thead><tbody><tr><td>重新分片不需要重启</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>pipeline</td><td>yes</td><td>yes</td><td>–</td></tr><tr><td>多key操作的hash tags {}</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>重新分片时的多key操作</td><td>yes</td><td>–</td><td>no</td></tr><tr><td>客户端支持</td><td>所有</td><td>所有</td><td>支持cluster协议的客户端</td></tr></tbody></table><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/8.png"></p><p>分片原理：Codis把所有的key分成了N个槽（例如1024），每个槽对应一个分组，一个分组对应于一个或者一组Redis实例。Codis对key进行CRC32运算，得到一个32位的数字，然后模拟N（槽的个数），得到余数，这个就是key对应的槽，槽后面就是redis实例（跟Mycat的先哈希后范围的算法思想类似）。比如4个槽：</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/9.png"></p><p>Codis的槽位映射关系是保存在proxy中的，如果要解决单点的问题，Codis也要做集群部署，多个Codis节点同步槽和实例的关系需要运行一个Zookeeper（或者etcd/本地文件）。</p><p>在新增节点的时候，可以为节点指定特定的槽位。Coids也提供了自动均衡策略。Codis不支持事务，其他的一些命令也不支持。获取数据原理（mget）在redis中的各个实例里获取到符合的key，然后再汇总到Codis中。Codis是第三方提供的分布式解决方案，再官网的集群功能稳定之前，Coids也得到了大量的应用。</p><h2 id="3-Redis-Cluster"><a href="#3-Redis-Cluster" class="headerlink" title="3  Redis Cluster"></a>3  Redis Cluster</h2><p>Redis Cluster是在Redis3.0版本正式推出的，用来解决分布式的需求，同时也可以实现高可用。跟Codis不一样，它是去中心化的，客户端可以连接到任意一个可用节点。数据分片有几个关键的问题需要解决：</p><ol><li><p>数据怎么相对均匀的分片</p></li><li><p>客户端怎么访问到相应的节点和数据</p></li><li><p>重新分片的过程，怎么保证正常服务</p></li></ol><h3 id="3-1-架构"><a href="#3-1-架构" class="headerlink" title="3.1 架构"></a>3.1 架构</h3><p>Redis Cluster可以看成是由多个Redis实例组成的数据集合。客户端不需要关注数据到底存储在哪个节点，只需要关注这个集合整体。以3主3从为例，节点之间两两交互，共享数据分片，节点状态等信息。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/10.png"></p><h3 id="3-2-搭建"><a href="#3-2-搭建" class="headerlink" title="3.2 搭建"></a>3.2 搭建</h3><table><thead><tr><th>类型</th><th>命令</th></tr></thead><tbody><tr><td>集群</td><td>cluster info：打印集群的信息<br />cluster nodes：列出集群当前已知的所有节点，以及这些节点的相关信息</td></tr><tr><td>节点</td><td>cluster meet &lt;ip<ip>&gt;&lt;port<port>&gt; : 将ip与port所指定的节点添加到集群当中，让它成为集群的一份子<br />cluster forget&lt;node_id<node_id>&gt; : 从集群中移除node_id指定的节点(保证空槽道)<br />cluster replicate&lt;node_id<node_id>&gt; : 将当前节点设置为node_id指定节点的从节点 <br />cluster saveconfig：将节点的配置文件保存到硬盘中</td></tr><tr><td>槽(slot)</td><td>cluster addslots&lt;slot<slot>&gt;[slot …]：将一个或多个槽指派给当前节点<br />cluster delslots&lt;slot<slot>&gt;[slot …]：移除一个或多个槽对当前节点的指派 <br />cluster flushslots：移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点<br />cluster setslot&lt;slot<slot>&gt; node&lt;node_id<node_id>&gt;：将槽slot指派给node_id指定的节点，如果槽已经指派给另一个节点，那么先让另一个节点删除该槽，然后再进行指派<br />cluster setslot&lt;slot<slot>&gt; migrating<node_id>&gt;：将本节点的槽迁移到node_id指定的节点中<br />cluster setslot&lt;slot<slot>&gt; importing<node_id>&gt;：从node_id指定的节点中导入槽到本节点<br />cluster setslot&lt;slot<slot>&gt; stable：取消对槽的导入或者迁移</td></tr><tr><td>键</td><td>cluster keyslot &lt;key<key>&gt;：计算键key应该被放置在哪个槽上<br />cluster countkeysinslot &lt;slot<slot>&gt;：返回槽目前包含的键值对数量<br />cluster getkeysinslot&lt;slot<slot>&gt; &lt;count<count>&gt;：返回count个槽中的键</td></tr></tbody></table><h3 id="3-3-数据分布"><a href="#3-3-数据分布" class="headerlink" title="3.3 数据分布"></a>3.3 数据分布</h3><p>Redis既没有用哈希取模，也没有用一致性哈希，而是用虚拟槽来实现的。Redis创建了16384个槽（slot），每个节点负责一定区间的slot。比如Node1负责0-5460，Node2负责5461-10922，Node3负责10923-163838.</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/11.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli -p 7291<br>redis-cli -p 7292<br>redis-cli -p 7293<br></code></pre></td></tr></table></figure><p>对象分布到Redis节点上时，对key用CRC16算法计算再%16384，得到一个slot的值，数据落到负责这个slot的redis节点上。Redis的每个master节点都会维护自己负责的slot。用一个bit序列实现，比如：序列的第0位是1，就代表第一个slot是它负责；序列的第1位是0，就代表第二个slot不归它负责。查看key属于哪个slot：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">redis&gt; <span class="hljs-keyword">cluster</span> keyslot qs<br></code></pre></td></tr></table></figure><p>注意：key与slot的关系是永远不会变的，汇编的只有slot和redis节点的关系。</p><p><em>问题：怎么让相关的数据落到同一个节点上？</em></p><p>比如有些multi key操作是不能跨节点的，例如用户2673的基本信息和金融信息？</p><p>在key里面加入{hash tag}即可。Redis在计算槽编号的时候只会获取{}之间的字符串进行槽便哈计算，这样由于上面两个不同的键。{}里面的字符串是相同的，因此他们可以被计算出相同的槽。</p><h3 id="3-4-客户端重定向"><a href="#3-4-客户端重定向" class="headerlink" title="3.4 客户端重定向"></a>3.4 客户端重定向</h3><p>比如在7291端口的redis的redis-cli客户端操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">127.0.0.1:7291&gt; <span class="hljs-built_in">set</span> qs 1<br>(error)MOVED 13724 127.0.0.1:7293<br></code></pre></td></tr></table></figure><p>服务器返回MOVED，也就是根据key计算出来的slot不归7291端口管理，而是归7293端口管理，服务器返回MOVED告诉客户端去7293端口操作。这个时候更换端口，用redis-cli-p 7293操作，才会返回OK。或者用./redis-cli-c -o port的命令。Jedis等客户端会在本地维护一份slot——node的映射关系，大部分时候不需要重定向，所以叫做smart jedis（需要客户端支持）。</p><h3 id="3-5-数据迁移"><a href="#3-5-数据迁移" class="headerlink" title="3.5 数据迁移"></a>3.5 数据迁移</h3><p>因为key和slot的关系是永远不会变的，当新增了节点的时候，需要把原有的slot分配给新的节点负责，并且把相关的数据迁移过来。</p><p>添加新节点（新增一个7297）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli --cluster add-node 127.0.0.1:7291 127.0.0.1:7297<br></code></pre></td></tr></table></figure><p>新增的节点没有哈希槽，不能分布数据，在原来的任意一个节点上执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli --cluster reshard 127.0.0.1:7291<br></code></pre></td></tr></table></figure><p>输入需要分配的哈希槽的数量（比如500），和哈希槽的来源节点（可以输入all或者id）。</p><h3 id="3-6-高可用和主从切换原理"><a href="#3-6-高可用和主从切换原理" class="headerlink" title="3.6 高可用和主从切换原理"></a>3.6 高可用和主从切换原理</h3><p>当slave发现自己的master变成FAIL状态时，便尝试进行Failover，成为新的master。由于挂掉的master可能会有多个slave，从而存在多个slave竞争成为master节点的过程，其过程如下：</p><ol><li><p>slave发现自己的master变成Fail</p></li><li><p>将自己记录的集群currentEpoch加1，并广播FAILOVER_AUTH_REQUEST信息</p></li><li><p>其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack。</p></li><li><p>尝试failover的slave收集FAILOVER_AUTH_ACK</p></li><li><p>超过半数后变成新master</p></li><li><p>广播pong通知其他集群节点</p></li></ol><p>总结：Redis Cluster既能够实现主从的角色分配，又能够实现主从切换，相当于集成了Replication和Sentinel的功能。</p><h3 id="3-7-总结"><a href="#3-7-总结" class="headerlink" title="3.7 总结"></a>3.7 总结</h3><p>Redis Cluster特点：</p><ol><li><p>无中心架构</p></li><li><p>数据按照slot存储分布在多个节点，节点间数据共享，可动态调整数据分布。</p></li><li><p>可扩展性，可线性扩展到1000个节点（官方推荐不超过1000个），节点可动态添加或删除。</p></li><li><p>高可用性，部分节点不可用时，集群仍可用。通过增加Slave做standby数据副本，能够实现故障自动failover，节点之间通过gossip协议交换状态信息，用投票机制完成slave到master的角色提升。</p></li><li><p>降低运维成本，提高系统的扩展性和可用性。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis主从复制</title>
    <link href="/2023/03/01/redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <url>/2023/03/01/redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>redis支持集群的架构。集群的节点有主节点和从节点之分，主节点叫master，从节点叫slave。slave会通过复制的技术，自动同步master的数据。</p><h2 id="1-主从复制配置"><a href="#1-主从复制配置" class="headerlink" title="1  主从复制配置"></a>1  主从复制配置</h2><p>Redis的主从配置非常的简单，只需要在配置文件里面添加一行配置就可以了。例如一主多从，186是主节点，在每个slave节点的redis.conf配置文件增加一行:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">replicaof</span> <span class="hljs-string">192.168.44.186 6379</span><br></code></pre></td></tr></table></figure><p>从节点启动之后，就会自动连接到master节点，开始同步数据。如果master节点变了，比如原来的master宕机，选举出了新的master，这个配置会被重写。还有一种方式，就是在启动服务器时通过参数直接指定master节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">./redis-server --slaveof <span class="hljs-number">192.168</span><span class="hljs-number">.44</span><span class="hljs-number">.186</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><p>一个正在运行的节点，可以改变其他节点的从节点，这就是第三种方式，在客户端直接执行slaveof IP port，使该redis实例成为从节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">slaveof <span class="hljs-number">192.168</span><span class="hljs-number">.44</span><span class="hljs-number">.186</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><p>一个从节点也可以是其他节点的主节点，形成级联复制的关系。查看集群状态:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">redis&gt; info replication<br></code></pre></td></tr></table></figure><p>从节点是只读的，不能执行写操作。执行命令会报错。在主节点写入后，slave会自动从master同步数据。把配置文件里面的replica of去掉重启，或者直接断开复制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">redis&gt; slaveof no one<br></code></pre></td></tr></table></figure><p>此时从节点会变成自己的主节点，不再复制数据。MySQL的主从复制原理是依赖binlog，然后还有几个线程。</p><h2 id="2-主从复制原理"><a href="#2-主从复制原理" class="headerlink" title="2 主从复制原理"></a>2 主从复制原理</h2><p>Redis的主从复制分为两类，一种叫全量复制，就是一个节点第一次连接到master节点，需要全部的数据。第二种叫做增量复制，比如之前已经连接到master节点，但是中间网络断开，或者slave节点宕机了，缺失了一部分的数据。</p><h3 id="2-1-连接阶段"><a href="#2-1-连接阶段" class="headerlink" title="2.1 连接阶段"></a>2.1 连接阶段</h3><ol><li><p>  slave节点启动时（或者执行slaveof命令时），会在自己本地保存master节点的消息，包括master node的host和ip。</p></li><li><p>slave节点内部有个定时任务replicationCron，每个一秒检查是否有新的master node要连接和复制。</p></li></ol><p>如果发现有master节点，就跟master节点建立连接。如果连接成功，从节点就会连接建立一个专门处理复制工作的文件事件处理器负责后续的复制工作。为了让主节点感知到slave节点的存在，slave节点定时会给主节点发送ping请求。</p><h3 id="2-2-数据同步阶段"><a href="#2-2-数据同步阶段" class="headerlink" title="2.2 数据同步阶段"></a>2.2 数据同步阶段</h3><p>如果是新加入的slave节点，那就需要全量复制。Master通过bgsave命令再本地生成一份RDB快照，将RDB快文件发给slave节点（如果超时会重连，可以调大repl-timeout的值）。</p><p>如果slave自己本来有数据，Slave节点首先需要清除自己的旧数据，然后用RDB文件加载数据。</p><p>master节点生成RDB期间，如果接收到写命令，开始生成RDB文件时，master会把所有新的写命令缓存在内存中，在slave节点保存了RDB之后，再将新的写命令复制给slave节点。（跟AOF重写rewrite期间接收到的命令的处理思路是一样的）。</p><p>第一次全量同步完了，主从已经保持一致了，后面就是持续把接收到的命令发送给slave节点。</p><h3 id="2-3-命令传播阶段"><a href="#2-3-命令传播阶段" class="headerlink" title="2.3 命令传播阶段"></a>2.3 命令传播阶段</h3><p>master节点持续把写命令，异步复制给slave节点。总结起来非常的简单，前面同RDB文件，后面把命令发给slave节点，就实现了主从复制。注意，一般情况下不会用redis做读写分离，因为redis的吞吐量已经够高了，做集群分片之后并发的问题更少，所以不需要考虑主从延迟的问题。跟MySQL一样主从之间复制延迟是不可避免的，只能通过优化网络来改善。</p><p>第二种情况就是增量复制了。slave通过master_repl_offset记录偏移量。Redis的一个新特性，就是主从复制的无盘复制（从2.8.18版本开始支持无盘复制）。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">repl-diskless-sync</span>=<span class="hljs-string">no</span><br></code></pre></td></tr></table></figure><p>为了降低主节点的磁盘开销，redis支持无盘复制，master生成的RDB文件并不保存到磁盘而是直接通过网络发送给从节点。无盘复制适用于主节点所在机器磁盘性能较差但网络带宽较充裕的场景。</p><h2 id="3-主从复制不足"><a href="#3-主从复制不足" class="headerlink" title="3  主从复制不足"></a>3  主从复制不足</h2><p>Redis的主从复制解决了数据备份和一部分性能的问题，但是没有解决高可用的问题。在一主一从或者多主多从的情况下，如果主服务器挂了，对外提供的服务就不可用了，单点问题没有得到解决。跟mysql一样。如果每次都是手动把之前的从服务器切换到主服务器，然后再把剩余节点设置为它的从节点，这个比较费时费力，还会造成一定时间的服务不可用。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis哨兵(Sentinel)</title>
    <link href="/2023/03/01/redis/Redis%E5%93%A8%E5%85%B5(Sentinel)/"/>
    <url>/2023/03/01/redis/Redis%E5%93%A8%E5%85%B5(Sentinel)/</url>
    
    <content type="html"><![CDATA[<h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1  原理"></a>1  原理</h2><p>怎么实现高可用？第一个对于服务器来说，能够实现主从自动切换；第二个，对于客户端来说，如果发生了主从切换，它需要获取最新的master节点。这个怎么实现呢？这里面应该要有一个管理redis节点状态的角色，而且具备路由功能。比如RocketMQ是通过nameserver来实现的。思路：创建一台监控服务器来监控所有redis服务节点的状态，比如，master节点超过一定时间没有给监控服务器发送心跳报文，就把master标记为下线，之后把某一个slave变成master，应用每一次都是从这个监控服务器拿到master的地址。</p><p>Redis的高可用是通过哨兵Sentinel来保证的。它的思路就是通过运行监控服务器来保证服务的可用性。从redis2.8版本起，提供了一个稳定版本的哨兵，用来解决高可用的问题。我们会启动奇数个的哨兵服务（通过src/redis-sentinel）。可以同sentinel的脚本启动，也可以用redis-server的脚本加sentinel参数启动。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">./redis-sentinel ../sentinel.conf<br># 或者<br>./redis-server ../sentinel.conf --sentinel<br></code></pre></td></tr></table></figure><p>它的本质上只是一个运行在特殊模式之下的redis。Sentinel通过info命令得到被监听redis机器的master，slave信息。</p><p><img src="/image/redis/redis%E5%93%A8%E5%85%B5/1.png"></p><p>为保证监控服务器的可用性，会对Sentinel做集群的部署。Sentinel既监控所有的redis服务，Sentinel相互之间也监控。注意：Sentinel本身没有主从之分，地位是平等的，只有redis服务节点有主从之分。sentinel唯一的联系，就是监控相同的master，sentinel节点是怎么知道其他的Sentinel节点的存在的？因为Sentinel是一个特殊状态的redis节点，它也有发布订阅的功能。哨兵上线时，给所有的redis节点的名字为_sentinel_:hello的channle发送消息。每个哨兵都订阅了所有redis节点为_sentinel_:helo的channle，所以能相互感知对方的存在，而进行监控。</p><h3 id="1-1-服务下线"><a href="#1-1-服务下线" class="headerlink" title="1.1 服务下线"></a>1.1 服务下线</h3><p>sentinel默认以每秒钟1次的频率向redis服务节点发送ping命令。如果在指定时间内没有收到有效回复，sentinel会将该服务器标记为下线（主观下线）。由这个参数控制：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># sentiel.conf</span><br><span class="hljs-attr">sentiel</span> <span class="hljs-string">down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br></code></pre></td></tr></table></figure><p>默认是30秒。但是，只有发现master下线，并不代表master真的下线了。也有可能是网络出问题了。所以，这个时候第一个发现master下线的sentinel节点会继续询问其他的sentinel节点，确认这个节点是否下线，如果多数sentinel节点都认为master下线，master才真正被确认下线（客观下线）。确定master下线后，就需要重新选举master。Kafka有会在Broke里面选一个Controller出来。RocketMQ用Dledger技术选举（基于Raft协议）。</p><h3 id="1-2-故障转移"><a href="#1-2-故障转移" class="headerlink" title="1.2 故障转移"></a>1.2 故障转移</h3><p>Redis的选举和故障转移都是由sentinel完成的，故障转移流程的第一步就是在sentinel集群选择一个leader，由leader完成故障转移流程。Sentinel通过Raft算法，实现sentinel选举。</p><p><strong>Raft算法</strong></p><p>只要有了多个副本，就必然要面对副本一致性的问题。如果要所有的节点达成一致，必然要通过复制的方式实现。所以数据保持一致需要两个步骤：领导选举，数据复制。数据复制在redis主从复制中说过了，这里关注一下选举的实现。</p><p>Raft算法是一个共识算法(consensus algorith)。Spring cloud的注册中心解决方案Consul也用到了Raft协议。Raft的核心思想：先到先得，少数服从多数。sentinel的raft实现跟原生的算法有所区别，但是大体思想一致。</p><ol><li><p>分布式环境中的节点有三个状态: Follower,Candidate,Leader.</p></li><li><p>一开始所有的节点都是Follower状态.如果follower连接不到leader(leader挂了),它就会成为candidate。candidate请求其他节点的投票，其他的节点会投给它，如果它得到了大多数节点的投票，它就成为了主节点.这个过程就叫做leader election。</p></li><li><p>现在所有的写操作需要在leader节点上发生。leader会记录操作日志，没有同步到其他follower节点的日志，状态是uncommitted。等到超过半数的follower同步了这条记录，日志状态就会变成committed。leader会通知所有的follower日志已经committed，这个时候所有的节点就达成了一致，这个过程叫log replication。</p></li><li><p>在raft协议中，选举的时候有两个超时时间。第一个叫election timeout，也就是说，为了防止同一时间大量节点参与选举，每个节点在变成candidate之前需要随机等待一段时间，时间范围是150ms and 300ms之间。第一个变成candidate的节点会先发起投票，它会先投给自己，然后请求其他节点投票(request vote)。</p></li><li><p>如果还没有收到投票结果，又到了超时时间，需要重置超时时间，只要有大部分节点投给了一个节点，他就会变成leader。</p></li><li><p>成为leader之后，它会发消息来同步数据(append entries)，发消息的间隔是由heartbeat timeout的计时。</p></li><li><p>只要follower收到了同步数据的信息，代表leader没挂，他们就会清除heartbeat timeout的计时。</p></li><li><p>但是一旦followers在heartbeat timeout时间之内没有收到append entries消息，它就会认为leader挂了，开始让其他节点投票，成为新的leader。</p></li><li><p>必须超过半数以上节点投票，保证只有一个leader被选出来。</p></li><li><p>如果两个follower同时变成了candidate，就会出现分割投票，比如有两个节点同时变成candidate，而且各自有一个投票请求先达到了其他的节点。加上他们给自己的投票，每个candidate手上有两票。但是，因为他们的election timeout不同，在发起新的一轮选举的时候，有一个节点收到了更多的投票，所以它变成了leader。</p></li></ol><p>总结:sentinel的raft算法和raft论文略有不同.</p><ol><li><p>master客观下线触发选举，而不是过了election timeout时间开始选举。</p></li><li><p>leader并不会把自己成为leader的消息发送给其他sentinel。其他sentinel等待leader从slave选出master后，检测到新的master正常工作后，就会去掉客观下线的标识，从而不需要进入故障转移流程。</p></li></ol><p>到达这里，从所有的sentinel节点里面选出来一个leader，也就是所谓选举委员会主席，下面才是真正的选举。</p><p><strong>故障转移</strong></p><p>对于所有的slave节点，一共有四个因素影响选举的结果，分别是断开连接时长、优先级排序、复制数量、进程id。</p><ol><li><p>如果与哨兵连接断开的比较久，超过了某个阈值，就直接失去了选举权。</p></li><li><p>如果拥有选举权，那就看谁的优先级高，这个在配置文件里可以设置(replica-priority 100)，数值越小优先级越高。</p></li><li><p>如果优先级相同，那就看谁从master中复制的数据最多(复制偏移量最大)，选最多的那个。</p></li><li><p>如果复制量也相同，就选进程id最小的那个。</p></li></ol><p>Master节点确定之后，让其他的节点变成它的从节点：</p><ol><li><p>选出sentinel leader之后，由sentinel leader向某个节点发送slaveof no one命令，让他成为独立节点。</p></li><li><p>然后向其他节点发送slaveof x.x.x.x xxxx(本机ip端口)，让它们成为这个节点的从节点，故障转移完成。</p></li></ol><h2 id="2-功能总结"><a href="#2-功能总结" class="headerlink" title="2  功能总结"></a>2  功能总结</h2><p>监控：sentinel会不断检查主服务器和从服务器是否正常运行。</p><p>通知：如果某一个被监控的实例出现问题，sentinel可以通过命令发出通知。</p><p>自动故障转移(failover)：如果主服务器发生故障，sentinel可以启动故障转移过程，把某台服务器升级为主服务器，并发出通知。</p><p>配置管理：客户端连接到sentinel，获取当前的redis主服务器的地址。</p><h2 id="3-实战"><a href="#3-实战" class="headerlink" title="3  实战"></a>3  实战</h2><h3 id="3-1-Sentinel配置"><a href="#3-1-Sentinel配置" class="headerlink" title="3.1 Sentinel配置"></a>3.1 Sentinel配置</h3><p>为了保证sentinel的高可用,sentinel也需要做集群部署,集群中至少需要三个sentinel实例(推荐奇数个,防止脑裂).</p><table><thead><tr><th>hostname</th><th>ip地址</th><th>节点角色&amp;端口</th></tr></thead><tbody><tr><td>master</td><td>192.168.44.186</td><td>Master: 6379 / Sentinel: 26379</td></tr><tr><td>slave1</td><td>192.168.44.187</td><td>Slave: 6379 / Sentinel: 26379</td></tr><tr><td>slave2</td><td>192.168.44.188</td><td>Slave: 6379 / Sentinel: 26379</td></tr></tbody></table><p>以redis的安装路径/user/local/soft/redis-6.0.9/为例，在187和188的src/redis.conf配置文件中添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">replicaof <span class="hljs-number">192.168</span><span class="hljs-number">.44</span><span class="hljs-number">.186</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><p>在186,187,188创建sentinel配置文件(安装后根目录下默认有sentinel.conf)，三台服务器内容相同：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">daemonize</span> <span class="hljs-string">yes</span><br><span class="hljs-attr">port</span> <span class="hljs-string">26739</span><br><span class="hljs-attr">protected-mode</span> <span class="hljs-string">no</span><br><span class="hljs-attr">dir</span> <span class="hljs-string">&quot;/usr/local/soft/redis-6.0.9/sentinel-tmp&quot;</span><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">monitor redis-master 192.168.44.186 6379 2</span><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">down-after-milliseconds redis-master 30000</span><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">failover-timeout redis-master 180000</span><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">parallel-syncs redis-master 1</span><br></code></pre></td></tr></table></figure><p>上面出现了4个’redis-master’,这个名称要统一,并且使用客户端(比如jedis)连接的时候要使用这个名字。</p><table><thead><tr><th>配置</th><th>作用</th></tr></thead><tbody><tr><td>protected-mode</td><td>是否允许外部网络访问，yes不允许</td></tr><tr><td>dir</td><td>sentinel的工作目录</td></tr><tr><td>sentinel monitor</td><td>sentinel监控的redis主节点</td></tr><tr><td>sentinel down-after-milliseconds（毫秒）</td><td>master宕机多久，才会被sentinel主观认为下线</td></tr><tr><td>sentinel failover-timeout（毫秒）</td><td>1.同一个sentinel对同一个master两次failover之间的间隔时间<br />2.当一个slave从一个错误的master那里同步数据开始计算时间，知道slave被纠正为向正确的master那里同步的数据时间。<br />3.当想要取消一个正进行的failover所需要的时间。<br />4.当进行failover时，配置所有slaves指向新的master所需的最大时间</td></tr><tr><td>sentinel parallel-syncs</td><td>这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成failover所需的时间就越长，但是这个数字越大，就意味着越多的slave因为replication而不可用，可以通过将这个值设为1来保证每次只有一个slave处于不能处理命令请求的状态</td></tr></tbody></table><h3 id="3-2-Sentinel验证"><a href="#3-2-Sentinel验证" class="headerlink" title="3.2 Sentinel验证"></a>3.2 Sentinel验证</h3><p>启动redis服务和sentinel，查看集群状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">redis&gt; info replication<br></code></pre></td></tr></table></figure><p>模拟宕机,在主节点执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">redis&gt; shutdown<br></code></pre></td></tr></table></figure><p>某个节点会被选为新的master，只有一个slave节点。注意看sentinel.conf里面的redis-master被修改了！模拟原master恢复，启动redis-server。master又有两个slave了。</p><h3 id="3-3-Sentinel连接使用"><a href="#3-3-Sentinel连接使用" class="headerlink" title="3.3 Sentinel连接使用"></a>3.3 Sentinel连接使用</h3><p>Jedis连接sentinel，master name来自于sentinel.conf的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisSentinelPool <span class="hljs-title function_">createJedisPool</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">masterName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;redis-master&quot;</span>;<br>    Set&lt;String&gt; sentinels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    sentinels.add(<span class="hljs-string">&quot;192.168.44.186:26379&quot;</span>);<br>    sentinels.add(<span class="hljs-string">&quot;192.168.44.187:26379&quot;</span>);<br>    sentinels.add(<span class="hljs-string">&quot;192.168.44.188:26379&quot;</span>);<br>    pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisSentinelPool</span>(masterName, sentinels);<br>    <span class="hljs-keyword">return</span> pool;<br>&#125;<br></code></pre></td></tr></table></figure><p>Springboot连接sentinel:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.redis.sentinel.master</span>=<span class="hljs-string">redis-master</span><br><span class="hljs-attr">spring.redis.sentinel.nodes</span>=<span class="hljs-string">192.168.44.186:26379,192.168.44.187:26379,192.168.44.188:26379</span><br></code></pre></td></tr></table></figure><p>无论是jedis还是springbot(2.x版本默认是Lettuce)，都只需要配置全部哨兵的地址，由哨兵返回当前的master节点地址。</p><h2 id="4-不足"><a href="#4-不足" class="headerlink" title="4 不足"></a>4 不足</h2><p>主从切换的过程中会丢失数据，因为只有一个master。只能单点写，没有解决水平扩容的问题。如果数据量非常大，这个时候就要对redis的数据进行分片了。这个时候需要多个master-slave的group，把数据分布到不同的group中。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis持久化机制</title>
    <link href="/2023/02/28/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/02/28/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>Redis速度快，很大一部分原因是因为它所有的数据都存储在内存中。如果断电或者宕机，都会导致内存的数据丢失。为了实现重启后数据不丢失，redis提供了两种持久化的方案，一种是RDB快照（Redis Database），一种是AOF（Append Only File）。持久化是redis跟memcache的主要区别之一。</p><h2 id="1-RDB"><a href="#1-RDB" class="headerlink" title="1. RDB"></a>1. RDB</h2><p>RDB是redis默认的持久化方案（注意如果开启了AOF，优先用AOF）。当满足一定条件的时候，会把当前内存中的数据写入磁盘，生成一个快照文件dump.rdb。redis重启会通过加载dump.rdb文件恢复数据。</p><h3 id="1-1-Rdb触发"><a href="#1-1-Rdb触发" class="headerlink" title="1.1 Rdb触发"></a>1.1 Rdb触发</h3><p><strong>1 自动触发</strong></p><p>a） 配置规则触发。</p><p>redis.conf，SNAPSHOTTING，其中定义了触发把数据保存到磁盘的触发频率。如果不需要rdb方案，注释save或者配置成空字符串“”。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span>     #<span class="hljs-number">900</span>秒内至少有一个key被修改（包括添加）<br><span class="hljs-attribute">save</span> <span class="hljs-number">400</span> <span class="hljs-number">10</span>    #<span class="hljs-number">400</span>秒内至少有<span class="hljs-number">10</span>个key被修改<br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span>  #<span class="hljs-number">60</span>秒内至少有<span class="hljs-number">10000</span>个key被修改<br></code></pre></td></tr></table></figure><p>注意上面的配置是不冲突的，只要满足任意一个都会触发。用lastsave命令可以查看最近一次成功生成快照的时间。Rdb文件位置和目录（默认在安装根目录下）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">dir</span> ./  <span class="hljs-comment">#文件路径</span><br>dbfilename dump.rdb  <span class="hljs-comment">#文件名称</span><br>rdbcompression <span class="hljs-built_in">yes</span>  <span class="hljs-comment">#是否以LZF压缩rdb文件</span><br>rdbchechsum <span class="hljs-built_in">yes</span>  <span class="hljs-comment">#开启数据校验</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>dir</td><td>rdb文件默认在启动目录下（相对路径） config get dir获取</td></tr><tr><td>dbfilename</td><td>文件名称</td></tr><tr><td>rdbcompression</td><td>开启压缩可以节省存储空间，但是会消耗一些CPU的计算时间，默认开启</td></tr><tr><td>rdbchecksum</td><td>使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</td></tr></tbody></table><p>b） shutdown触发，保证服务器正常关闭。</p><p>c） flushall，rdb文件是空的，没什么意义。</p><p><strong>2 手动触发</strong></p><p>如果我们需要重启服务或者迁移数据，这个时候就需要手动触发快照保存。Redis提供了两条命令：</p><p>a） save，在生成快照的时候会阻塞当前redis服务器，redis不能处理其他命令。如果内存中的数据比较多，会造成redis长时间的阻塞。生产环境下不建议使用这个命令。</p><p>b） 执行bgsave，执行bgsave时，redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体操作是redis进程执行fork操作创建子线程（copy-on-write），rdb持久化过程由子进程负责，完成后自动结束。它不会记录fork之后产生的数据。阻塞只发生在fork阶段，一般时间很短。</p><h3 id="1-2-RDB数据恢复"><a href="#1-2-RDB数据恢复" class="headerlink" title="1.2 RDB数据恢复"></a>1.2 RDB数据恢复</h3><ol><li> shutdown持久化</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#添加键值</span><br>redis&gt; <span class="hljs-built_in">set</span> k1 1<br>redis&gt; <span class="hljs-built_in">set</span> k2 2<br>redis&gt; <span class="hljs-built_in">set</span> k3 3<br>redis&gt; <span class="hljs-built_in">set</span> k4 4<br>redis&gt; <span class="hljs-built_in">set</span> k5 5<br><span class="hljs-comment">#停止服务器，触发save</span><br>redis&gt; shutdown<br><span class="hljs-comment">#备份dump.rdb文件</span><br><span class="hljs-built_in">cp</span> dump.rdb dump.rdb.bak<br><span class="hljs-comment">#启动服务器，数据都在</span><br>redis&gt; redis-server redis.conf<br></code></pre></td></tr></table></figure><ol start="2"><li>模拟数据丢失</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#模拟数据丢失，触发save</span><br>redis&gt; shutdown<br><span class="hljs-comment">#停止服务器</span><br>redis&gt; shutdown<br><span class="hljs-comment">#启动服务器</span><br>redis&gt; redis-server redis.conf<br><span class="hljs-comment">#数据丢失</span><br></code></pre></td></tr></table></figure><ol start="3"><li> 通过该备份文件恢复数据</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#停止服务器</span><br>redis&gt; shutdown<br><span class="hljs-comment">#重命名备份文件</span><br><span class="hljs-built_in">mv</span> dump.rdb.bak dump.rdb<br><span class="hljs-comment">#启动服务器</span><br>redis&gt; redis-server redis.conf<br><span class="hljs-comment">#数据找回</span><br></code></pre></td></tr></table></figure><h3 id="1-3-RDB文件的优劣"><a href="#1-3-RDB文件的优劣" class="headerlink" title="1.3 RDB文件的优劣"></a>1.3 RDB文件的优劣</h3><p>一、 优势</p><p>1． Rdb是一个非常紧凑（compact）的文件，它保存了redis在某个时间点上的数据集。这种文件非常适合用于进行备份和灾难恢复。</p><p>2． 生成rdb文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘io操作。</p><p>3． Rdb在恢复大数据集时的速度比aof的恢复速度快。</p><p>二．劣势</p><p>1.rdb方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，频繁执行成本过高。</p><p>2.在一定间隔时间做一次备份，所以如果redis意外当掉的话，就会丢失最后一次快照之后的所有修改（数据又丢失）。</p><p>​    如果数据相对来说比较重要，希望将损失降到最小，则可以使用aof方式进行持久化。</p><h2 id="2-AOF"><a href="#2-AOF" class="headerlink" title="2. AOF"></a>2. AOF</h2><p>Redis默认不开启。aof采用日志的形式来记录每个写操作，并追加文件中。开启后，执行更改redis数据的命令时，就会把命令写入到aof文件中。Redis重启时会根据日志文件的内容把写指令从前到后执行一次以完成数据的恢复工作。</p><h3 id="2-1-aof配置"><a href="#2-1-aof配置" class="headerlink" title="2.1 aof配置"></a>2.1 aof配置</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 开关</span><br><span class="hljs-attr">appendonly</span> <span class="hljs-string">no</span><br><span class="hljs-comment"># 文件名</span><br><span class="hljs-attr">appendfilename</span> <span class="hljs-string">&quot;appendonly.aof&quot;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>appendonly</td><td>Redis默认只开启RDB持久化，开启AOF需要修改为yes</td></tr><tr><td>appendfilename</td><td>路径也是通过dir参数配置，config get dir</td></tr></tbody></table><p>由于操作系统的缓存机制，aof数据并没有真正地写入磁盘，而是进入了系统的硬盘缓存。什么时候把缓冲区的内容写入到aof文件？</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>appendfsync everysec</td><td>AOF持久化策略(硬盘缓存到磁盘)，默认everysec <br />no—-表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快，但是不安全<br />always—-表示每次写入都执行fsync，以保证数据同步到磁盘，效率很低<br />everysec—-表示每秒执行一次fsync，可能会导致丢失这1s的数据，通常选择everysec，兼顾安全和效率</td></tr></tbody></table><p>由于aof持久化是redis不断将写命令记录到aof文件中，随着redis不断的进行，aof文件会越来越大，文件越大，占用服务器内存越大以及aof恢复要求时间越长。例如计数器增加100万次，100万个命令都记录进去了，但是结果只有一个。为了解决这个问题，redis新增了重写机制，当aof文件的大小超过锁设定的阈值时，redis就会启动aof文件的内容压缩，值保留可以恢复数据的最小指令集。可以使用命令bgrewriteaof来重写。Aof文件重写并不是对原文件进行重新整理，而是读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令，生成一个新的文件后去替换原来的aof文件。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 重写触发机制</span><br><span class="hljs-attr">auto-aof-rewrite-percentage</span> <span class="hljs-string">100</span><br><span class="hljs-attr">auto-aof-rewrite-min-size</span> <span class="hljs-string">64mb</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>auto-aof-rewrite-percentage</td><td>默认值是100，aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写，当前AOF文件大小是上次日志重写得到aof文件大小的二倍(设置为100)时，自动启动新的日志重写过程。</td></tr><tr><td>auto-aof-rewrite-min-size</td><td>默认64M。设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写</td></tr></tbody></table><p><em>问题：重写过程中，AOF文件被更改了怎么办？</em></p><p>当子进程执行aof重写时，主进程需要执行以下三个工作：</p><p>（1）处理命令请求；（2）将写命令追加到现有的aof文件中；（3）将写命令追加到aof重写缓存中</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>no-appendfsync-on-rewrite</td><td>在aof重写或者写入rdb文件时，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成过长时间的阻塞，no-appendfsync-on-rewrite字段设置为默认no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。设置为yes表示rewrite期间对新写操作不fsync，暂时存在内存中，等rewrite完成后再写入，默认为no，建议修改为yes。Linux默认fsync策略是30秒。可能丢失30秒数据。</td></tr><tr><td>aof-load-truncated</td><td>aof文件可能在尾部是不完整的，当redis启动时，aof文件的数据被载入内存中。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项，出现这种现象。redis宕机或者异常终止不会造成尾部不完整现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复aof文件才可以。默认为yes。</td></tr></tbody></table><h3 id="2-2-AOF数据恢复"><a href="#2-2-AOF数据恢复" class="headerlink" title="2.2 AOF数据恢复"></a>2.2 AOF数据恢复</h3><p>重启redis后就会进行aof文件的恢复</p><h3 id="2-3-AOF的优劣势"><a href="#2-3-AOF的优劣势" class="headerlink" title="2.3 AOF的优劣势"></a>2.3 AOF的优劣势</h3><p>一、 优点：</p><p>​    1． Aof持久化的方法提供了多种的同步频率，即使用默认的同步频率每秒同步一次，redis最多也就丢失1秒的数据而已。</p><p>二、缺点</p><p>​    1.对于具有相同数据的redis，aof文件通常会比RDB文件体积更大（rdb存的是数据快照）</p><p>​    2.虽然aof提供了多种同步的频率，默认情况下，每秒同步一次的频率也具有较高的性能，在高并发的情况下，rdb比aof具有更好的性能保证。</p><h2 id="3-两种方案比较"><a href="#3-两种方案比较" class="headerlink" title="3.  两种方案比较"></a>3.  两种方案比较</h2><p>如果可以忍受一小段时间内数据的丢失，毫无疑问使用rdb是最好的，定时生成rdb快照（snapshot）非常便于进行数据库备份，并且rdb恢复数据集的速度也要比aof恢复的速度要快。否则就是用AOF重写。但是一般情况下建议不要单独使用某一种持久化机制，而是应该两种一起用，在这种情况下，当redis重启的时候会优先加载aof文件来恢复原始的数据，因为在通常情况下aof文件保存的数据集要比RDB文件保存的数据集要完整。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis内存回收</title>
    <link href="/2023/02/27/redis/Redis%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    <url>/2023/02/27/redis/Redis%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="1-过期策略"><a href="#1-过期策略" class="headerlink" title="1. 过期策略"></a>1. 过期策略</h2><h3 id="1-1-立即过期-主动淘汰"><a href="#1-1-立即过期-主动淘汰" class="headerlink" title="1.1 立即过期(主动淘汰)"></a>1.1 立即过期(主动淘汰)</h3><p>每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好，但是会占用大量CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p><h3 id="1-2-惰性过期-被动淘汰"><a href="#1-2-惰性过期-被动淘汰" class="headerlink" title="1.2 惰性过期(被动淘汰)"></a>1.2 惰性过期(被动淘汰)</h3><p>只有当访问一个key时，才会判断该key是否已经过期，过期则清除。该策略可以最大化的节省CPU资源，却对内存非常不友好。极端情况下可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p><p>第一种情况，所有的查询都会调用expireIfNeeded判断是否过期：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">expireIfNeeded(redisDb *db, robj *key)<br></code></pre></td></tr></table></figure><p>第二种情况，每次写入key时，发现内存不够，吊桶activeExpireCycle释放一部分内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">activeExpireCycle(<span class="hljs-type">int</span> type)<br></code></pre></td></tr></table></figure><h3 id="1-3-定期过期"><a href="#1-3-定期过期" class="headerlink" title="1.3 定期过期"></a>1.3 定期过期</h3><p>每隔一定的时间，会扫描一定数量的数据库的expire字典中一定数量的key，并清除其中已经过期的key。该策略是前两者的一个折中方案，通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以再不同情况下使得Cpu和内存资源达到最优的平衡效果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span>&#123;</span><br>    dict *dict;<br>    dict *expires;<br>    dict *blocking_keys;<br>    dict *ready_keys;<br>    dict *watched_keys;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> avg_ttl;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> expires_cursor;<br>    <span class="hljs-built_in">list</span> *defrag_later;<br>&#125; redisDb;<br></code></pre></td></tr></table></figure><p>总结: Redis中同时使用了惰性过期和定期过期两种过期策略，并不是实时的清除过期的key。</p><h2 id="2-淘汰策略"><a href="#2-淘汰策略" class="headerlink" title="2. 淘汰策略"></a>2. 淘汰策略</h2><p>Redis的内存淘汰策略，是指当内存使用达到最大内存极限时，需要使用淘汰算法来决定清理掉哪些数据，以保证新数据的存入。</p><h3 id="2-1-最大内存设置"><a href="#2-1-最大内存设置" class="headerlink" title="2.1 最大内存设置"></a>2.1 最大内存设置</h3><p>Redis.conf参数配置  #maxmemory <bytes></p><p>如果不设置maxmemory或者设置为0，32位系统最多使用3GB内存，64位系统不限制内存。</p><p>动态修改（先get一下）：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">redis&gt;<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> maxmemory 2GB<br></code></pre></td></tr></table></figure><h3 id="2-2-淘汰策略"><a href="#2-2-淘汰策略" class="headerlink" title="2.2 淘汰策略"></a>2.2 淘汰策略</h3><p><a href="https://redis.io/docs/reference/eviction/">https://redis.io/docs/reference/eviction/</a></p><p>redis.conf   #maxmemory-policy noeviction</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coq"># volatile-lru -&gt; Evict <span class="hljs-built_in">using</span> approximated LRU, only keys <span class="hljs-built_in">with</span> an expire <span class="hljs-built_in">set</span><br># allkeys-lru  -&gt; Evict any key <span class="hljs-built_in">using</span> approximated LRU<br># vloatile-lfu -&gt; Evict <span class="hljs-built_in">using</span> approximated LFU, only keys <span class="hljs-built_in">with</span> an expire <span class="hljs-built_in">set</span><br># allkeys-lfu  -&gt; Evict any key <span class="hljs-built_in">using</span> approximated LFU<br># volatile-random -&gt; <span class="hljs-keyword">Remove</span> a random key having an expire <span class="hljs-built_in">set</span><br># allkeys-random  -&gt; <span class="hljs-keyword">Remove</span> a random key, any key<br># volatile-ttl -&gt; <span class="hljs-keyword">Remove</span> the key <span class="hljs-built_in">with</span> the nearest expire <span class="hljs-built_in">time</span>(minor TTL)<br></code></pre></td></tr></table></figure><p>（1）先从后缀的算法名来看：</p><p>LRU，Least Recently Used：最近最少使用。判断最近被使用的时间，目前最远的数据有限被淘汰。</p><p>LFU，Least Frequently Used：最不常用，按照使用频率删除，4.0版本新增。</p><p>Random 随机删除。</p><p>（2）从前缀针对的对象来分：volatile是针对设置了ttl的key，allkeys是针对所有key</p><table><thead><tr><th>策略</th><th>含义</th></tr></thead><tbody><tr><td>volatile-lru</td><td>根据LRU算法删除设置了超时属性(expire)的键，直到腾出足够内存为止。如果没有可删除的对象，回退到noeviction策略</td></tr><tr><td>allkeys-lru</td><td>根据LRU算法删除键，不管数据有没有设置超时属性，知道腾出足够的内存为止</td></tr><tr><td>volatile-lfu</td><td>在带有过期时间的键中选择最不常用的</td></tr><tr><td>allkeys-lfu</td><td>在所有键中选择最不常用的，不管数据有没有设置超时属性</td></tr><tr><td>volatile-random</td><td>在带有过期时间的键中随机选择</td></tr><tr><td>allkeys-random</td><td>随机删除所有键，知道腾出足够内存为止</td></tr><tr><td>volatile-ttl</td><td>根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noevitcion策略</td></tr><tr><td>noeviction</td><td>默认策略，不会删除任何数据，拒绝所有写入操作并返回客户端错误信息(error)OOM command not allowed when used memory, 此时Redis只响应读操作</td></tr></tbody></table><p>如果没有设置ttl或者没有符合前提条件的key被淘汰，那么volatile-lru，volatile-random，volatile-ttl相当于noeviction（不做内存回收）。动态修改淘汰策略（先get一下）</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">redis&gt; config set maxmemory-policy <span class="hljs-keyword">volatile</span>-lru<br></code></pre></td></tr></table></figure><p>建议使用volatile-lru，在保证正常服务的情况下，有限删除最近最少使用的key。</p><h3 id="2-3-LRU淘汰原理"><a href="#2-3-LRU淘汰原理" class="headerlink" title="2.3 LRU淘汰原理"></a>2.3 LRU淘汰原理</h3><p>LRU是一个很常见的算法，比如InnoDB的Buffer Pool也用到了LRU。传统LRU：通过链表+HashMap实现，设置链表长度，如果新增或者被访问，就移动到头节点，超过链表长度，末尾的节点被删除。</p><p><img src="/image/redis/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/1.png"></p><p>如果基于传统LRU算法实现redis LRU的话，需要额外的数据结构存储，消耗内存。所以Redis LRU对传统的LRU算法进行了改良，通过随机采样来调整算法的精度。如果淘汰策略是LRU，则根据篇日志的采样值maxmemory_samples（默认是5个），随机从数据库中选择m个key，淘汰其中热度最低的key对应的缓存数据。所以采样参数m配置的数值越大，就越能精确的查找到待淘汰的缓存数据，但是也消耗更多的CPU计算，执行效率降低。</p><p>Redis中所有对象结构都有一个lru字段，且使用了unsigned的低24位，这个字段用来记录对象的热度。对象被创建时会记录lru值。在被访问的时候也会更新lru的值。但并不是获取系统当前的时间戳，而是设置位全局变量server.lruclock的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span>&#123;</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS;<br>    <span class="hljs-type">int</span> refcount;<br>    <span class="hljs-type">void</span> *ptr;<br>&#125; robj;<br></code></pre></td></tr></table></figure><p>Redis中有个定时处理的函数serverCron，默认每100毫秒调用函数updateCachedTime更新一次全局变量的server.lruclock的值，它记录的是当前unix时间戳。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">updateCachedTime</span><span class="hljs-params">(<span class="hljs-type">int</span> update_daylight_info)</span>&#123;<br>    server.ustime = ustime();<br>    server.mstime = server.ustime / <span class="hljs-number">1000</span>;<br>    server.unixtime = server.mstime / <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">if</span>(update_daylight_info)&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> <span class="hljs-title">tm</span>;</span><br>        <span class="hljs-type">time_t</span> ut = server.unixtime;<br>        localtime_r(&amp;ut,&amp;tm);<br>        server.daylight_active = tm.tm_isdst;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>问题：为什么不获取精确的时间而是放在全局变量中？不会有延迟的问题吗？</em></p><p>这样函数查询key调用lookupKey中更新数据的lru热度值时，就不用换每次调用系统函数time，可以提高执行效率。</p><p>当对象里面已经有了LRU字段的值，就可以评估对象的热度了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">estimeteObjectIdleTime</span><span class="hljs-params">(robj *o)</span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> lrulock = LRU_CLOCK();<br>    <span class="hljs-keyword">if</span>(lruclock &gt;= o-&gt;lru)&#123;<br>        <span class="hljs-keyword">return</span> (lruclock - o-&gt;lru) * LRU_CLOCK_RESOLUTION;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> (lruclock + (LRU_CLOCK_MAX - o-&gt;lru)) * LRU_CLOCK_RESOLUTION;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数estimateObjectIdleTime评估指定对象的lru热度，方法就是对象的lru值和全局的server.lruclock的差值越大（越久没有得到更新）,该对象热度越低。server.lruclock 只有24位，按秒位单位来标识才能存储194天。但超过24bit能表示的最大时间的时候，他会从头开始计算。在这种情况下，可能会出现对象的lru大于server.lruclocl的情况，如果这种情况出现那么就两个相加而不是相减来求最久的key。</p><p>Redis LRU算法在sample为10的情况下，已经能接近传统LRU算法了。</p><h3 id="2-4-LFU"><a href="#2-4-LFU" class="headerlink" title="2.4 LFU"></a>2.4 LFU</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span>&#123;</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-type">unsigned</span> enncoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS;<br>    <span class="hljs-type">int</span> refcount;<br>    <span class="hljs-type">void</span> *ptr;<br>&#125; robj;<br></code></pre></td></tr></table></figure><p>当这24bits 用作LFU时，其被分为两部分：高16位用来记录访问时间（单位为分钟，Idt-last decrement time）低8位用来记录访问频率，简称counter（logc-logistic counter）</p><p>counter是用基于概率的对数计数器来实现的，8位可以标识百万次的访问频率。对象被读写的时候，lfu的值会被更新。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">updateLFU</span><span class="hljs-params">(robj *val)</span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counter = LFUDecrAndReturn(val);<br>    counter = LFULogIncr(counter);<br>    val-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="hljs-number">8</span>) | counter;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然这里并不是访问一次，技术就加1。增长的速率由一个参数决定，lfu-log-factor越大，counter增长的越慢，redis.conf配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># lfu-log-factor 10</span><br></code></pre></td></tr></table></figure><p>如果一段时间热点高，就一直保持这个热度，肯定也是不行的，体现不了整体频率。所以，没有被访问的时候，计数器还要递减。减少的值由衰减因子lfu-decay-time(分钟)来控制，如果值是1的话，N分钟没有访问，计数器就要减少N。lfu-decay-time越大，衰减越慢。Redis.conf配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># lfu-decay-time 1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nacos注册中心</title>
    <link href="/2023/02/27/springcloud/nacos/nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <url>/2023/02/27/springcloud/nacos/nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p><em>Nacos版本：2.0.4   nacos2.x已不支持ribbon，使用nacos2.x需要手动引入LoadBalancer</em></p><p><a href="https://nacos.io/zh-cn/docs/sdk.html">https://nacos.io/zh-cn/docs/sdk.html</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#服务注册</span><br>curl -X POST <span class="hljs-string">&#x27;http://localhost:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=8080&#x27;</span><br><br><span class="hljs-comment">#服务发现</span><br>curl -X GET <span class="hljs-string">&#x27;http://localhost:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h2><h3 id="1-1-基于Java-SDK的服务注册与发现"><a href="#1-1-基于Java-SDK的服务注册与发现" class="headerlink" title="1.1 基于Java SDK的服务注册与发现"></a>1.1 基于Java SDK的服务注册与发现</h3><p><a href="https://nacos.io/zh-cn/docs/sdk.html">https://nacos.io/zh-cn/docs/sdk.html</a></p><p>（1）引入nacos-client包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.nacos<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>nacos-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）编写Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceRegisterAndDiscovery</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NacosException, IOException&#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        properties.setProperty(<span class="hljs-string">&quot;serverAddr&quot;</span>, <span class="hljs-string">&quot;192.168.0.108:8848&quot;</span>); <span class="hljs-comment">//集群地址用逗号隔开</span><br>        <span class="hljs-type">NamingService</span> <span class="hljs-variable">naming</span> <span class="hljs-operator">=</span> NamingFactory.createNamingService(properties);<br>        <span class="hljs-comment">// 服务注册</span><br>System.out.println(<span class="hljs-string">&quot;-----服务注册-----&quot;</span>);<br>naming.registerInstance(<span class="hljs-string">&quot;nacos.test.3&quot;</span>, <span class="hljs-string">&quot;11.11.11.11&quot;</span>, <span class="hljs-number">8888</span>, <span class="hljs-string">&quot;TEST1&quot;</span>);<br><span class="hljs-comment">// 服务发现</span><br>System.out.println(<span class="hljs-string">&quot;-----服务发现-----&quot;</span>);<br>System.out.println(naming.getAllInstances(<span class="hljs-string">&quot;nacos.test.3&quot;</span>));<br>System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-基于SC的服务注册"><a href="#1-2-基于SC的服务注册" class="headerlink" title="1.2 基于SC的服务注册"></a>1.2 基于SC的服务注册</h3><p>（1）引入版本管理依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入spring cloud 版本管理 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入spring cloud alibaba 版本管理 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--引入spring cloud netflix 版本管理--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-netflix-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）引入nacos discovery依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（3）在application.yml文件中编写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-comment"># nacos server地址</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-comment"># 服务名称</span><br>        <span class="hljs-attr">service:</span> <span class="hljs-string">order</span><br></code></pre></td></tr></table></figure><p>（4）启动order-9091、9092、9093，观察nacos dashboard的服务情况</p><h3 id="1-3-SC的服务发现"><a href="#1-3-SC的服务发现" class="headerlink" title="1.3 SC的服务发现"></a>1.3 SC的服务发现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义服务发现接口，使用DiscoveryClient测试</span><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;<br><span class="hljs-meta">@RequestMapping(&quot;/instances&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;ServiceInstance&gt; <span class="hljs-title function_">instances</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;serviceId&quot;)</span>String serviceId)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.discoveryClient.getInstances(serviceId);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-Nacos领域模型"><a href="#1-4-Nacos领域模型" class="headerlink" title="1.4 Nacos领域模型"></a>1.4 Nacos领域模型</h3><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/1.png"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 创建一个命名空间，名称为dev，并获取到其id：9c52616a-48c0-4f78-a256-573b6fb5a152</span><br><span class="hljs-comment"># 查看dev命名空间下的服务，发现没有任何服务</span><br><span class="hljs-comment"># 修改user服务的application.yml文件，主要配置体验一下namespace、group和cluster</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-comment"># nacos server地址</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-comment"># 服务名称</span><br>        <span class="hljs-attr">service:</span> <span class="hljs-string">user</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">9c52616a-48c0-4f78-a256-573b6fb5a152</span><br>        <span class="hljs-attr">group:</span> <span class="hljs-string">shop-group</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">BJ</span><br><span class="hljs-comment"># 启动user服务，观察nacos dashboard dev命名空间下的数据</span><br><span class="hljs-comment"># 调用user服务中UserController提供的服务发现代码，发现调用失败，说明不同名命名空间下的服务是隔离的</span><br><span class="hljs-comment"># http://localhost:8081/user/instances?serviceId=order</span><br></code></pre></td></tr></table></figure><h3 id="1-5-Nacos元信息-Metadata"><a href="#1-5-Nacos元信息-Metadata" class="headerlink" title="1.5 Nacos元信息(Metadata)"></a>1.5 Nacos元信息(Metadata)</h3><p>Nacos数据（如配置和服务）描述信息，如服务版本、权重、容灾策略、负载均衡策略、鉴权配置、 各种自定义标签 (label)，从作用范围来看，分为服务级别的元信息、集群的元信息及实例的元信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 配置元信息</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">Jack</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/2.png"></p><h3 id="2-1-Nacos-Server启动"><a href="#2-1-Nacos-Server启动" class="headerlink" title="2.1 Nacos Server启动"></a>2.1 Nacos Server启动</h3><ol><li>Nacos 2.x</li></ol><p>（1）http方式，以Spring Boot的方式启动内置的Tomcat容器，并且实例化很多Controller提供Http请求的访问形式，比如InstanceController。启动方式和正常springboot启动相同。用于持久节点注册</p><p>（2）在Nacos2.X中新增了gRPC的通信方式，所以会在Server端提供gRPC的监听，用于处理客户端的连接。用于临时节点注册。</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos-grpc-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.jpg"></p><ol start="2"><li><p>Nacos 1.x</p><p> 只有http方式</p></li></ol><h3 id="2-2-Spring-Boot启动调用Nacos-API"><a href="#2-2-Spring-Boot启动调用Nacos-API" class="headerlink" title="2.2 Spring Boot启动调用Nacos API"></a>2.2 Spring Boot启动调用Nacos API</h3><p>（1）Spring Boot项目启动 </p><p>（2）Spring Boot发布ServletWebServerInitializedEvent事件 </p><p>（3）Spring Cloud监听器AbstractAutoServiceRegistration 监听感兴趣事件 WebServerInitializedEvent </p><p>（4）回调AbstractAutoServiceRegistration#onApplicationEvent</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/3.png"></p><h3 id="2-3-Nacos客户端向服务端发起服务注册"><a href="#2-3-Nacos客户端向服务端发起服务注册" class="headerlink" title="2.3 Nacos客户端向服务端发起服务注册"></a>2.3 Nacos客户端向服务端发起服务注册</h3><p>（1）Nacos 2.x</p><ul><li>入口：NacosNamingService#registerInstance(serviceName,groupName,Instance instance)</li></ul><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos2.x-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.jpg"></p><p>（2）Nacos 1.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos1.x-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.jpg"></p><h3 id="2-4-Nacos服务端处理服务注册"><a href="#2-4-Nacos服务端处理服务注册" class="headerlink" title="2.4 Nacos服务端处理服务注册"></a>2.4 Nacos服务端处理服务注册</h3><p>（1）Nacos 2.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos2.x-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C.jpg"></p><p>（2）Nacos 1.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos1.x-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C.jpg"></p><h3 id="2-5-心跳机制与健康检查"><a href="#2-5-心跳机制与健康检查" class="headerlink" title="2.5 心跳机制与健康检查"></a>2.5 心跳机制与健康检查</h3><p>（1）Nacos 2.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos2.x-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5.jpg"></p><p>（2）Nacos 1.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos1.x-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5.jpg"></p><h3 id="2-6-服务发现与订阅及通知客户端"><a href="#2-6-服务发现与订阅及通知客户端" class="headerlink" title="2.6 服务发现与订阅及通知客户端"></a>2.6 服务发现与订阅及通知客户端</h3><p>（1）Nacos 2.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos2.x-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0.jpg"></p><p>（2）Nacos 1.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos1.x-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0.jpg"></p><h3 id="2-7-分布式架构"><a href="#2-7-分布式架构" class="headerlink" title="2.7 分布式架构"></a>2.7 分布式架构</h3><p>如果注册Nacos的client节点注册时ephemeral=true，那么Nacos集群对这个client节点的效果就是AP，采用distro协议实现；而注册Nacos的client节点注册时ephemeral=false，那么Nacos集群对这个节点的效果就是CP的，采用raft协议实现。根据client注册时的属性，AP，CP同时混合存在，只是对不同的client节点效果不同。Nacos可以很好的解决不同场景的业务需求。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#false为永久实例，true表示临时实例开启，注册为临时实例，默认是true</span><br><span class="hljs-attr">spring.cloud.nacos.discovery.ephemeral</span> = <span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><h4 id="2-7-1-AP架构-distro"><a href="#2-7-1-AP架构-distro" class="headerlink" title="2.7.1 AP架构-distro"></a>2.7.1 AP架构-distro</h4><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos2.x-%E5%88%86%E5%B8%83%E5%BC%8FAP%E6%9E%B6%E6%9E%84.jpg"></p><h4 id="2-7-2-CP架构-raft"><a href="#2-7-2-CP架构-raft" class="headerlink" title="2.7.2 CP架构-raft"></a>2.7.2 CP架构-raft</h4><p><a href="https://raft.github.io/">https://raft.github.io/</a></p><p><a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p><p><a href="https://raft.github.io/#implementations/">https://raft.github.io/#implementations/</a></p>]]></content>
    
    
    <categories>
      
      <category>springcloud</category>
      
      <category>nacos</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
      <tag>nacos</tag>
      
      <tag>服务注册中心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nacos安装与配置</title>
    <link href="/2023/02/27/springcloud/nacos/nacos%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/02/27/springcloud/nacos/nacos%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p><em>Nacos版本：2.0.4   nacos2.x已不支持ribbon，使用nacos2.x需要手动引入LoadBalancer</em></p><h2 id="1-单机版"><a href="#1-单机版" class="headerlink" title="1. 单机版"></a>1. 单机版</h2><h3 id="1-1-package-基于CentOS"><a href="#1-1-package-基于CentOS" class="headerlink" title="1.1 package(基于CentOS)"></a>1.1 package(基于CentOS)</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#（1）下载nacos-server的二进制包，比如：nacos-server-2.0.4.tar.gz</span><br><span class="hljs-comment">#（2）解压并进入bin目录</span><br>unzip nacos-server-<span class="hljs-variable">$version</span>.zip OR tar -xvf nacos-server-<span class="hljs-variable">$version</span>.tar.gz<br><span class="hljs-built_in">cd</span> nacos/bin<br><span class="hljs-comment">#（3）打开startup.sh文件，寻找MODE的默认方式，发现是&quot;cluster&quot;</span><br>vim startup.sh<br><span class="hljs-comment">#（4）查看nacos的启动配置文件，可以发现默认端口是8848，默认访问路径是/nacos</span><br>vim ../conf/application.properties<br><span class="hljs-comment">#（5）以单机模式启动nacos server</span><br>sh startup.sh -m standalone<br><span class="hljs-comment">#（6）查看启动日志</span><br><span class="hljs-built_in">tail</span> -f /root/nacos/logs/start.out<br><span class="hljs-built_in">tail</span> -f ../logs/start.out<br><span class="hljs-comment">#（7）关闭nacos server</span><br>sh shutdown.sh<br><span class="hljs-comment">#（8）打开浏览器访问，输入默认用户名:nacos和密码:nacos</span><br>centosip:8848/nacos<br></code></pre></td></tr></table></figure><h3 id="1-2-source"><a href="#1-2-source" class="headerlink" title="1.2 source"></a>1.2 source</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">（<span class="hljs-number">1</span>）下载nacos-<span class="hljs-keyword">server</span>的源码，比如：nacos<span class="hljs-number">-2.0</span><span class="hljs-number">.4</span>.zip<br>（<span class="hljs-number">2</span>）解压并进入nacos目录<br>（<span class="hljs-number">3</span>）maven构建<br>mvn -Prelease-nacos -Dmaven.test.skip=<span class="hljs-keyword">true</span> clean install -U<br>（<span class="hljs-number">4</span>）使用idea打开nacos工程<br>（<span class="hljs-number">5</span>）配置启动信息<br>Spring Boot<br><span class="hljs-type">Name</span>: nacos-<span class="hljs-keyword">server</span>-standalone<br>Main <span class="hljs-keyword">Class</span>: com.alibaba.nacos.Nacos<br>VM <span class="hljs-keyword">options</span>: -Dnacos.standalone=<span class="hljs-keyword">true</span> -Dnacos.home=nacos-home-standalone<br>classpath <span class="hljs-keyword">of</span> module: nacos-console<br></code></pre></td></tr></table></figure><h2 id="2-集群版"><a href="#2-集群版" class="headerlink" title="2. 集群版"></a>2. 集群版</h2><p><a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html</a></p><h3 id="2-1-package"><a href="#2-1-package" class="headerlink" title="2.1 package"></a>2.1 package</h3><p>（1）准备3台centos机器，把对应的nacos二进制包上传到3台机器中并解压</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.1.81</span><br><span class="hljs-number">192.168.1.82</span><br><span class="hljs-number">192.168.1.83</span><br></code></pre></td></tr></table></figure><p>（2）复制并编辑nacos/conf目录下的cluster.conf文件：cp cluster.conf.example cluster.conf</p><p>（3）选择其中一台机器作为MySQL的安装机器，比如81，生产使用建议至少主备模式，或者采用高可用数据库，并执行提供好的sql文件，用于创建数据库表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p<br><span class="hljs-keyword">create</span> database nacos;<br>use nacos;<br>source <span class="hljs-operator">/</span>root<span class="hljs-operator">/</span>nacos<span class="hljs-operator">/</span>conf<span class="hljs-operator">/</span>nacos<span class="hljs-operator">-</span>mysql.sql;<br><span class="hljs-keyword">show</span> tables;<br></code></pre></td></tr></table></figure><p>（4）将derby的配置切换成MySQL</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#（1）打开conf/application.properties文件</span><br><span class="hljs-comment"># vim application.properties</span><br><span class="hljs-comment">#（2）根据自己MySQL的安装情况修改如下配置信息</span><br><span class="hljs-comment">#*************** Config Module Related Configurations ***************#</span><br><span class="hljs-comment">### If use MySQL as datasource:</span><br><span class="hljs-attr">spring.datasource.platform</span>=<span class="hljs-string">mysql</span><br><span class="hljs-comment">### Count of DB:</span><br><span class="hljs-attr">db.num</span>=<span class="hljs-string">1</span><br><span class="hljs-comment">### Connect URL of DB:</span><br><span class="hljs-attr">db.url.0</span>=<span class="hljs-string">jdbc:mysql://192.168.1.81:3306/nacos?</span><br><span class="hljs-attr">characterEncoding</span>=<span class="hljs-string">utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span><br><span class="hljs-attr">&amp;useUnicode</span>=<span class="hljs-string">true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="hljs-attr">db.user.0</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">db.password.0</span>=<span class="hljs-string">root123</span><br></code></pre></td></tr></table></figure><p>（5）来到nacos/bin目录，直接启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sh startup.sh<br></code></pre></td></tr></table></figure><p>（6）访问任意一台机器的8848端口，看看dashboard中的内容</p><h3 id="2-2-source"><a href="#2-2-source" class="headerlink" title="2.2 source"></a>2.2 source</h3><p>​    nacos2.x的版本使用到了grpc进行通信，而grpc的端口会相对于server.port端口做的偏移 比如nacos server的http端口为8848，则grpc的会使用8848+1000，即9848作为和客户端的通信端口，同时grpc会使用8848+1001，即9849作为nacos集群间的数据同步端口，所以在源码搭建的时候，要避免端口冲突</p><p>（1）前置准备</p><p>​    下载nacos-server的源码，比如：nacos-2.0.4.zip ；解压并进入nacos目录 ；maven构建 mvn -Prelease-nacos -Dmaven.test.skip=true clean install -U ；使用idea打开nacos工程</p><p>（2）准备好MySQL数据库</p><p>（3）在nacos源码根目录创建3个文件夹，作为集群的nacos home。同时在3个nacos home下新建 conf目录，并创建cluster.conf文件，配置内容如下</p><p><img src="/image/springcloud/nacos/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/1.png"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:8841</span><br><span class="hljs-number">127.0.0.1:8843</span><br><span class="hljs-number">127.0.0.1:8845</span><br></code></pre></td></tr></table></figure><p>4）将derby修改成mysql，配置文件：nacos2.0.4\console\src\main\resources\application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#*************** Config Module Related Configurations ***************#</span><br><span class="hljs-comment">### If use MySQL as datasource:</span><br><span class="hljs-attr">spring.datasource.platform</span>=<span class="hljs-string">mysql</span><br><span class="hljs-comment">### Count of DB:</span><br><span class="hljs-attr">db.num</span>=<span class="hljs-string">1</span><br><span class="hljs-comment">### Connect URL of DB:</span><br><span class="hljs-attr">db.url.0</span>=<span class="hljs-string">jdbc:mysql://192.168.0.81:3306/nacos?</span><br><span class="hljs-attr">characterEncoding</span>=<span class="hljs-string">utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span><br><span class="hljs-attr">&amp;useUnicode</span>=<span class="hljs-string">true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="hljs-attr">db.user.0</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">db.password.0</span>=<span class="hljs-string">root123</span><br></code></pre></td></tr></table></figure><p>（5）配置集群的启动参数</p><ul><li><p>8841</p><p>  <img src="/image/springcloud/nacos/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/2.png"></p></li><li><p>8843</p><p>  <img src="/image/springcloud/nacos/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/3.png"></p></li><li><p>8845</p><p>  <img src="/image/springcloud/nacos/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/4.png"></p></li></ul><p>（6）分别启动集群的3个server</p>]]></content>
    
    
    <categories>
      
      <category>springcloud</category>
      
      <category>nacos</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>架构演进以及版本更迭</title>
    <link href="/2023/02/27/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/"/>
    <url>/2023/02/27/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="1-架构演进"><a href="#1-架构演进" class="headerlink" title="1. 架构演进"></a>1. 架构演进</h2><h3 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1 单体架构"></a>1.1 单体架构</h3><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/1.png"></p><h3 id="1-2-垂直化拆分"><a href="#1-2-垂直化拆分" class="headerlink" title="1.2 垂直化拆分"></a>1.2 垂直化拆分</h3><p>按功能模块进行垂直化拆分</p><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/2.png"></p><h3 id="1-3-集群-负载均衡"><a href="#1-3-集群-负载均衡" class="headerlink" title="1.3 集群+负载均衡"></a>1.3 集群+负载均衡</h3><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/3.png"></p><h3 id="1-4-SOA"><a href="#1-4-SOA" class="headerlink" title="1.4 SOA"></a>1.4 SOA</h3><p>SOA：Service Oriented Architecture </p><p>ESB：Enterprise Service Bus 企业服务总线。ESB就相当于是一根管道，主要是为了集成不同协议的服务，使得不同服务之间能够彼此调用</p><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/4.png"></p><h3 id="1-5-微服务"><a href="#1-5-微服务" class="headerlink" title="1.5 微服务"></a>1.5 微服务</h3><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/5.png"></p><h2 id="2-微服务架构下问题的解决方案"><a href="#2-微服务架构下问题的解决方案" class="headerlink" title="2. 微服务架构下问题的解决方案"></a>2. 微服务架构下问题的解决方案</h2><p><a href="https://landscape.cncf.io/">Cloud Native Landscape (cncf.io)</a></p><p>（1）服务注册与发现：eureka、zookeeper、nacos、consul、etcd等 </p><p>（2）负载均衡：ribbon、nginx等 </p><p>（3）服务调用：dubbo、thrift、feign等 </p><p>（4）熔断：hystrix、sentinel等 </p><p>（5）网关：zuul、gateway、kong等 </p><p>（6）配置中心：config、nacos、apoll等 </p><p>（7）分布式消息：rocketmq、kafka、pulsar、rabbitmq等 </p><p>（8）分布式锁：redis、zookeeper等 </p><p>（9）分布式事务：seata、tx-lcn等</p><h2 id="3-Spring-Cloud生态"><a href="#3-Spring-Cloud生态" class="headerlink" title="3. Spring Cloud生态"></a>3. Spring Cloud生态</h2><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/6.png"></p><h2 id="4-版本对比"><a href="#4-版本对比" class="headerlink" title="4. 版本对比"></a>4. 版本对比</h2><h3 id="4-1-Spring-Cloud和Spring-Boot"><a href="#4-1-Spring-Cloud和Spring-Boot" class="headerlink" title="4.1 Spring Cloud和Spring Boot"></a>4.1 Spring Cloud和Spring Boot</h3><p><a href="https://spring.io/projects/spring-cloud#overview">https://spring.io/projects/spring-cloud#overview</a></p><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/7.png"></p><h3 id="4-2-Spring-Cloud和SCA"><a href="#4-2-Spring-Cloud和SCA" class="headerlink" title="4.2 Spring Cloud和SCA"></a>4.2 Spring Cloud和SCA</h3><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E</a></p><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/8.png"></p><h3 id="4-3-Spring-Cloud和SCN"><a href="#4-3-Spring-Cloud和SCN" class="headerlink" title="4.3 Spring Cloud和SCN"></a>4.3 Spring Cloud和SCN</h3><p><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2021.0-Release-Notes#202104">https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2021.0-Release-Notes#202104</a></p><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/9.png"></p><h3 id="4-4-SCA与具体组件版本"><a href="#4-4-SCA与具体组件版本" class="headerlink" title="4.4 SCA与具体组件版本"></a>4.4 SCA与具体组件版本</h3><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E#%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E#%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB</a></p><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/10.png"></p><h3 id="4-5-最终版本"><a href="#4-5-最终版本" class="headerlink" title="4.5 最终版本"></a>4.5 最终版本</h3><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/11.png"></p>]]></content>
    
    
    <categories>
      
      <category>springcloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lua脚本-redis</title>
    <link href="/2023/02/22/lua/Lua-redis/"/>
    <url>/2023/02/22/lua/Lua-redis/</url>
    
    <content type="html"><![CDATA[<h2 id="1-在redis中调用lua脚本"><a href="#1-在redis中调用lua脚本" class="headerlink" title="1  在redis中调用lua脚本"></a>1  在redis中调用lua脚本</h2><p>使用eval方法，语法格式：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">eval</span> lua-script <span class="hljs-built_in">key</span>-<span class="hljs-built_in">num</span> [key1 key2 key3 ...] [value1 value2 value3 ...]<br><br>//<span class="hljs-built_in">eval</span> 代表执行Lua语言的命令<br>//lua-script 代表Lua语言脚本内容<br>//<span class="hljs-built_in">key</span>-<span class="hljs-built_in">num</span> 表示参数中有多少个<span class="hljs-built_in">key</span>，需要注意的是Redis中的<span class="hljs-built_in">key</span>是从<span class="hljs-number">1</span>开始的，如果没有<span class="hljs-built_in">key</span>的参数，那么写<span class="hljs-number">0</span><br>//[key1 key2 key3 ...]是<span class="hljs-built_in">key</span>作为参数传递给Lua语言，也可以不写，但是需要和<span class="hljs-built_in">key</span>-<span class="hljs-built_in">num</span>的个数对应起来<br>//[value1 value2 value3 ...]参数的value值，一一对应，可填可不填<br></code></pre></td></tr></table></figure><p>示例：返回一个字符串，0个参数：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">eval</span> <span class="hljs-string">&quot;return &#x27;Hello World&#x27;&quot;</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>实际上，Lua脚本在Redis里面真正的用途是用来执行redis命令。</p><h2 id="2-在Lua脚本中调用redis命令"><a href="#2-在Lua脚本中调用redis命令" class="headerlink" title="2  在Lua脚本中调用redis命令"></a>2  在Lua脚本中调用redis命令</h2><h3 id="2-1-命令格式"><a href="#2-1-命令格式" class="headerlink" title="2.1 命令格式"></a>2.1 命令格式</h3><p>使用redis.call(command, key, [param1, param2 ……])进行操作。语法格式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">redis.call(command, key [param1, param2, ...])<br><span class="hljs-comment">-- command是命令，包括set、get、del等</span><br><span class="hljs-comment">-- key是被操作的键</span><br><span class="hljs-comment">-- param1， param2 ...代表给key的参数</span><br></code></pre></td></tr></table></figure><p>一个简单的案例，让Lua脚本执行set qingshan 2673</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">eval <span class="hljs-string">&quot;return redis.call(&#x27;set&#x27;,&#x27;qingshan&#x27;,&#x27;2673&#x27;)&quot;</span>  <span class="hljs-regexp">//</span>写死值<br>eval <span class="hljs-string">&quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[1])&quot;</span> <span class="hljs-number">1</span> qingshan <span class="hljs-number">2673</span> <span class="hljs-regexp">//</span>参数传递<br></code></pre></td></tr></table></figure><p>在redis-cli中直接写Lua脚本不够方便，也不能实现编辑和复用，通常我们会把lua脚本凡在文件中，然后执行这个文件。</p><h3 id="2-2-Lua脚本文件"><a href="#2-2-Lua脚本文件" class="headerlink" title="2.2 Lua脚本文件"></a>2.2 Lua脚本文件</h3><p>创建脚本文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft/redis-6.0.9/src<br>vim test.lua<br></code></pre></td></tr></table></figure><p>Lua脚本内容，先赋值，再取值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">redis.call(<span class="hljs-string">&#x27;set&#x27;</span>,<span class="hljs-string">&#x27;qingshan&#x27;</span>,<span class="hljs-string">&#x27;lua666&#x27;</span>)<br><span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;get&#x27;</span>,<span class="hljs-string">&#x27;qingshan&#x27;</span>)<br></code></pre></td></tr></table></figure><p>调用脚本文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft/redis-6.0.9/src<br>redis-cli --<span class="hljs-built_in">eval</span> test.lua 0<br></code></pre></td></tr></table></figure><h3 id="2-3-案例：对IP进行限流"><a href="#2-3-案例：对IP进行限流" class="headerlink" title="2.3 案例：对IP进行限流"></a>2.3 案例：对IP进行限流</h3><p>需求：每个用户再X秒内只能访问Y次。设计思路：</p><p>首先是数据类型。用String的key记录IP，用value记录访问的次数。几秒钟和几次哟啊用参数动态传进去。拿到IP以后，对IP+1。如果是第一次访问，对key设置国企时间（参数1）.否则判断次数，超过限定次数（参数2），返回0。如果没有超过次数返回1。超过时间，key国企之后，可以再次访问。</p><p>KEY[1]是IP，ARGV[1]是过期时间X，ARGV[2]是限制访问的次数Y。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- ip_limit.lua</span><br><span class="hljs-comment">-- IP限流，对某个IP频率进行校址，6秒钟访问10次</span><br><span class="hljs-keyword">local</span> num=redis.call(<span class="hljs-string">&#x27;incr&#x27;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">tonumber</span>(num)==<span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>   <span class="hljs-keyword">elseif</span> <span class="hljs-built_in">tonumber</span>(num)&gt;<span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">2</span>]) <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>   <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>6秒钟内限制访问10次，调用测试（连续调用10次）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli --<span class="hljs-built_in">eval</span> ip_limit.lua app:ip:<span class="hljs-built_in">limit</span>:192.168.8.111 , 6 10<br></code></pre></td></tr></table></figure><p>Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LuaTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> getJedisUtil();<br>        jedis.eval(<span class="hljs-string">&quot;return redis.call(&#x27;set&#x27;,KEYS[1],ARGV[1])&quot;</span>, <span class="hljs-number">1</span>,<span class="hljs-string">&quot;test:lua:key&quot;</span>,<span class="hljs-string">&quot;qingshan2673lua&quot;</span>);<br>        System.out.println(jedis.get(<span class="hljs-string">&quot;test:lua:key&quot;</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>            limit();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 10秒内限制访问5次</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">limit</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> getJedisUtil();<br>        <span class="hljs-comment">// 只在第一次对key设置过期时间</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">lua</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;local num = redis.call(&#x27;incr&#x27;, KEYS[1])\n&quot;</span> +<br>                <span class="hljs-string">&quot;if tonumber(num) == 1 then\n&quot;</span> +<br>                <span class="hljs-string">&quot;\tredis.call(&#x27;expire&#x27;, KEYS[1], ARGV[1])\n&quot;</span> +<br>                <span class="hljs-string">&quot;\treturn 1\n&quot;</span> +<br>                <span class="hljs-string">&quot;elseif tonumber(num) &gt; tonumber(ARGV[2]) then\n&quot;</span> +<br>                <span class="hljs-string">&quot;\treturn 0\n&quot;</span> +<br>                <span class="hljs-string">&quot;else \n&quot;</span> +<br>                <span class="hljs-string">&quot;\treturn 1\n&quot;</span> +<br>                <span class="hljs-string">&quot;end\n&quot;</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.evalsha(jedis.scriptLoad(lua), Arrays.asList(<span class="hljs-string">&quot;localhost&quot;</span>), Arrays.asList(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>));<br>        System.out.println(result);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedisUtil</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> ResourceUtil.getKey(<span class="hljs-string">&quot;redis.host&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> Integer.valueOf(ResourceUtil.getKey(<span class="hljs-string">&quot;redis.port&quot;</span>));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> ResourceUtil.getKey(<span class="hljs-string">&quot;redis.password&quot;</span>);<br>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">jedisPoolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>        <span class="hljs-type">JedisPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(jedisPoolConfig, ip, port, <span class="hljs-number">10000</span>, password);<br>        <span class="hljs-keyword">return</span> pool.getResource();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-缓存Lua脚本"><a href="#2-4-缓存Lua脚本" class="headerlink" title="2.4 缓存Lua脚本"></a>2.4 缓存Lua脚本</h3><p><strong>为什么要缓存</strong></p><p>​    在Lua脚本比较长的情况下，如果多次调用脚本都需要把整个脚本传给Redis服务端，会产生比较大的网络开销。为了解决这个问题，Redis可以缓存Lua脚本并生成SHA1摘要码，后面可以直接通过摘要码来执行Lua脚本。</p><p><strong>如何缓存</strong></p><p>这里面涉及到两个命令，首先是在服务端缓存lua脚本生成一个摘要码，用script load命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">script load <span class="hljs-string">&quot;return Hello World&quot;</span><br></code></pre></td></tr></table></figure><p>第二个命令是通过摘要码执行缓存的脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">evalsha <span class="hljs-string">&quot;摘要码&quot;</span> 0<br></code></pre></td></tr></table></figure><p><strong>自乘案例</strong></p><p>Redis有incrby这样的自增命令，但是没有自乘。比如乘以3，乘以5</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">set</span> num 2<br></code></pre></td></tr></table></figure><p>写一个自乘的运算，让它乘以后面的参数:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> curVal=redis.call(<span class="hljs-string">&quot;get&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">if</span> curVal==<span class="hljs-literal">false</span> <span class="hljs-keyword">then</span><br>    curVal=<span class="hljs-number">0</span><br>   <span class="hljs-keyword">else</span><br>    curVal=<span class="hljs-built_in">tonumber</span>(curVal)<br><span class="hljs-keyword">end</span><br>curVal=curVal*<span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>])<br>redis.call(<span class="hljs-string">&quot;set&quot;</span>,KEYS[<span class="hljs-number">1</span>],curVal)<br><span class="hljs-keyword">return</span> curVal<br></code></pre></td></tr></table></figure><p>这个命令变成串行，语句之间使用分号隔开，Script load命令（redis客户端执行）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">script locad <span class="hljs-string">&#x27;local curVal=redis.call(&quot;get&quot;,KEYS[1]);if curVal==false then curVal=0 else curVal=tonumber(curVal) end;curVal=curVal*tonumber(ARGV[1]);redis.call(&quot;set&quot;,KEYS[1],curVal);return curVal&#x27;</span><br></code></pre></td></tr></table></figure><p>调用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">evalsha <span class="hljs-string">&quot;摘要码&quot;</span> 1 num 6<br></code></pre></td></tr></table></figure><h3 id="2-5-脚本超时"><a href="#2-5-脚本超时" class="headerlink" title="2.5 脚本超时"></a>2.5 脚本超时</h3><p>Redis的指令执行本身是单线程的，这个线程还要执行客户端的Lua脚本，如果Lua脚本执行超时或者陷入了死循环，是不是没有办法为客户端提供服务了？它会导致其他的命令都会进入等待状态。为了防止这种情况，首先，脚本执行有一个超时时间，默认为5秒钟。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">lua-time-limit</span> <span class="hljs-string">5000</span><br></code></pre></td></tr></table></figure><p>超过5秒钟，其他客户端的命令不会等待，而是直接返回BUSY错误。这样也不行，不能一直拒绝其他客户端的命令执行。在提示中看到有两个命令可以使用，第一个是script kill，终止脚本的执行。但是需要注意:并不是所有的lua脚本执行都可以kill。如果当前执行的lua脚本对Redis的数据进行了修改（set，DEL、等），那么通过script kill命令是不能终止脚本运行的。为什么包含修改的脚本不能中断？因为要保证脚本运行的原子性。如果脚本执行了一部分被终止，那就违背了脚本原子性的目标。遇到这种情况，只能通过shutdown nosave命令，直接把redis服务停掉。正常关机是shutdown。Shutdown nosave和shutdown的区别在于shutdown nosave不会进行持久化操作，意味着发生在上一个快照后的数据库修改都会丢失。</p>]]></content>
    
    
    <categories>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis为什么这么快</title>
    <link href="/2023/02/22/redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/"/>
    <url>/2023/02/22/redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/</url>
    
    <content type="html"><![CDATA[<p>总结起来主要有三点：1.纯内存结构。2.请求处理单线程。3.多路复用机制</p><h2 id="1-原因"><a href="#1-原因" class="headerlink" title="1  原因"></a>1  原因</h2><h3 id="1-1-内存"><a href="#1-1-内存" class="headerlink" title="1.1 内存"></a>1.1 内存</h3><p>KV结构的内存数据库，时间复杂度是O(1)。</p><h3 id="1-2-单线程"><a href="#1-2-单线程" class="headerlink" title="1.2 单线程"></a>1.2 单线程</h3><p>这里说的单线程其实指的是处理客户端的请求是单线程的，可以把它叫做主线程。从4.0版本之后，还引入了一些线程处理其他的事情，比如清理脏数据，无用连接的释放，大key的删除。</p><p>​    把处理请求的主线程设置成单线程有什么好处呢？</p><p>​    1.没有创建线程，销毁线程带来的消耗</p><p>​    2.避免了上下文切换导致的CPU消耗</p><p>​    3.避免了线程之间带来的竞争关系，例如加锁释放锁死锁等等。</p><p>​    这里有个问题，就算单线程确实有这些好处，但是会不会白白浪费了CPU的资源？也就是说只能用到单核。官方的解释是这样的：在Redis中单线程已经够用了，CPU不是redis的瓶颈。redis的瓶颈最有可能是机器内存或者网络带宽，既然单线程容易实现，又不需要处理线程并发的问题，那就顺理成章的采用单线程的方案了。注意，因为请求处理是单线程的，不要在生产环境运行长命令，比如keys，flushall，flushdb。否则会导致请求被阻塞。</p><h3 id="1-3-同步非阻塞IO"><a href="#1-3-同步非阻塞IO" class="headerlink" title="1.3 同步非阻塞IO"></a>1.3 同步非阻塞IO</h3><p>同步非阻塞IO，多路复用并发连接</p><h2 id="2-单线程为什么这么快？"><a href="#2-单线程为什么这么快？" class="headerlink" title="2  单线程为什么这么快？"></a>2  单线程为什么这么快？</h2><p>因为redis是基于内存的操作，先从内存开始说起</p><h3 id="2-1-虚拟存储器-虚拟内存Virtual-Memory"><a href="#2-1-虚拟存储器-虚拟内存Virtual-Memory" class="headerlink" title="2.1 虚拟存储器(虚拟内存Virtual Memory)"></a>2.1 虚拟存储器(虚拟内存Virtual Memory)</h3><p>计算机里面的内存叫做主存，硬盘叫做辅存。主存可看作一个很长的数组，一个字节一个单元，每个字节有一个唯一的地址，这个地址叫做物理地址（Physical Address）。早期的计算机中，如果CPU需要内存，使用物理寻址，直接访问主存储器。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/1.png"></p><p>这种方式有几个弊端：</p><p>​    1.一般的操作系统都是多用户多任务的，所有的进程共享主存。如果每个进程都独占一块物理地址空间，主存很快就会被用完。我们希望在不同的时刻，不同的进程共用同一块物理地址空间。</p><p>​    2.如果所有进程都是直接访问物理内存，那么一个进程就可以修改其他进程的内存数据，导致物理地址空间被破坏，程序运行就会出现异常。</p><p>​    所以想了一个办法，在CPU和主存之间增加一个中间层。CPU不再使用物理地址访问主存，而是访问一个虚拟地址，由这个中间层把地址转换成物理地址，最终获得数据。这个中间层叫做MMU（Memory Management Unit），内存管理单元。</p><p>​    具体的操作如下所示：</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/2.png"></p><p>访问MMU就跟访问物理内存一样，所以把虚拟出来的地址叫做虚拟内存（Virtual Memory）。</p><p>在每一个进程开始创建的时候，都会分配一段虚拟地址，然后通过虚拟地址和物理地址的映射来获取真实数据，这样进程就不会直接接触到物理地址，甚至不知道自己调用的哪块物理地址的数据。目前，大多数操作系统都使用了虚拟内存，如Windows系统的虚拟内存，Linux系统的交换空间等。Windows的虚拟内存（pagefile.sys）是磁盘空间的一部分。在32位系统上，虚拟地址空间大小是2^32=4G。在64位系统上，最大虚拟地址空间大小是多少？是不是2^64-1024*1024TB?实际上没有用到64位，因为用不到这么大的空间，而且会造成很大的系统开销。linux一般用低48位来表示虚拟地址空间，也就是2^48=256T.</p><p>实际的物理内存可能远远小于虚拟内存的大小。总结：引入虚拟内存的作用：</p><p>​    1.通过把同一块物理内存映射到不同的虚拟地址空间实现内存共享。</p><p>​    2.对物理内存进行隔离，不同的进程操作互不影响</p><p>​    3.虚拟内存可以提供更大的地址空间，并且地址空间是连续的，使得程序编写，连接更加简单。</p><p>​    Linux/GNU的虚拟内存又进一步划分成了两块</p><h3 id="2-2-用户空间和内核空间"><a href="#2-2-用户空间和内核空间" class="headerlink" title="2.2 用户空间和内核空间"></a>2.2 用户空间和内核空间</h3><p>一部分是内核空间（Kernel-space）,一部分是用户空间（User-space）。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/3.png"></p><p>Linux系统中，虚拟地址布局如下：</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/4.png"></p><p>进程的用户空间中存放的是用户程序的代码和数据，内核空间中存放的是内核代码和数据。不管内核空间还是用户空间，它们都处于虚拟内存空间中，都是对物理地址的映射。当进程运行在内核空间时就处于内核态，而进程运行在用户空间时则处于用户态。进程在内核空间可以访问受保护的内存空间，也可以访问底层硬件设备。也就是可以执行任意命令，调用系统的一切资源。在用户空间只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称system call），才能向内核发出指令。所以，这样划分的目的是为了避免用户进程直接操作内核，保证内核安全。</p><h3 id="2-3-进程切换（上下文切换）"><a href="#2-3-进程切换（上下文切换）" class="headerlink" title="2.3 进程切换（上下文切换）"></a>2.3 进程切换（上下文切换）</h3><p>多任务操作系统是怎么实现运行远大于CPU数量的任务个数的?当然，这些任务实际上并不是真的在同时运行，而是因为系统通过时间片算法，在很短的时间内，将CPU轮流分配给它们，造成多任务同时运行的错觉。在这个交替运行的过程中，为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，以及恢复以前挂起的某个进程的执行。这个行为被称为进程切换。</p><p>​    什么叫上下文（Context）？在每个任务运行前，CPU都需要知道任务从哪里加载，又从哪里开始运行，也就是说，需要系统事先帮它设置好CPU寄存器和程序计数器，这个叫做CPU的上下文。</p><p>​    而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p><p>​    在切换上下文的时候，需要完成一系列的工作，这是一个很消耗资源的操作。</p><h3 id="2-4-进程的阻塞"><a href="#2-4-进程的阻塞" class="headerlink" title="2.4 进程的阻塞"></a>2.4 进程的阻塞</h3><p>正在运行的进程由于提出系统服务请求（如IO操作），但因为某种原因未得到操作系统的立即响应，该进程只能把自己变成阻塞状态，等待响应的时间出现后才被唤醒。进程在阻塞状态不占用CPU资源。</p><h3 id="2-5-文件描述符FD"><a href="#2-5-文件描述符FD" class="headerlink" title="2.5 文件描述符FD"></a>2.5 文件描述符FD</h3><p>Linus系统将所有设备都当作文件来处理，而Linux用文件描述符来标识每个文件对象。文件描述符（File Descriptior）是内核为了高效管理已被打开的文件锁创建的索引，用于指向被打开的文件，所有执行IO操作的系统调用都通过文件描述符。</p><p>​    文件描述符是一个简单的非负整数，用以标名每个被进程打开的文件。linux系统里面有三个标准文件描述符：</p><p>​    0：标准输入（键盘）；1：标准输出（显示器）；2：标准错误输出（显示器）。</p><h3 id="2-6-传统IO数据拷贝"><a href="#2-6-传统IO数据拷贝" class="headerlink" title="2.6 传统IO数据拷贝"></a>2.6 传统IO数据拷贝</h3><p>以读操作为例：但应用程序执行read系统调用读取文件描述符（FD）的时候，如果这块数据已经存在于用户进程的页内存中，就直接从内存中读取数据。如果数据不存在，则先将数据从磁盘加载数据到内核缓冲区中，再从内核缓冲器拷贝到用户进程的页内存中。（两个拷贝，两次user和kernel的上下文切换）。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/5.png"></p><h3 id="2-7-Bocking-I-O"><a href="#2-7-Bocking-I-O" class="headerlink" title="2.7 Bocking I/O"></a>2.7 Bocking I/O</h3><p>当使用read或write对某个文件描述符进行过读写时，如果当前FD不可读，系统就不会对其他的操作做出响应，从硬件设备复制数据到内核缓冲区是阻塞的，从内核缓冲区拷贝到用户空间，也是阻塞的，知道copy complete，内核返回结果，用户进程才解除block的状态。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/6.png"></p><p>为了解决阻塞的问题，有几个思路</p><p>​    1.在服务端创建多个线程或者使用线程池，但是在高并发的情况下需要的线程会很多，系统无法承受，而且创建和释放线程都需要消耗资源。</p><p>​    2.由请求方定期轮询，在数据准备完毕后再从内核缓存区复制数据到用户空间（非阻塞IO），这种方式存在一定的延迟。</p><p>​    能不能用一个线程处理多个客户端请求？</p><h3 id="2-8-I-O多路复用-IO-Multiplexing"><a href="#2-8-I-O多路复用-IO-Multiplexing" class="headerlink" title="2.8 I/O多路复用(IO Multiplexing)"></a>2.8 I/O多路复用(IO Multiplexing)</h3><p>​    IO指的是网络IO</p><p>​    多路指的是多个TCP连接（Socket或Channel）。</p><p>​    复用指的是复用一个或多个线程。</p><p>​    它的基本原理就是不再由应用程序自己监视连接，而是由内核替应用程序监视文件描述符。客户端再操作的时候，会产生具有不同事件类型的socket。在服务端，IO多路复用程序（IO Multiplexing Module）会把消息放入队列中，然后通过文件事件分派其（File event Dispatcher），转发到不同的事件处理器中。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/7.png"></p><p>多路复用有很多实现，以select为例，当用户进程调用了多路复用器，进程会被阻塞。内核会监视多路复用器负责的所有socket，当任何一个socket的数据准备好了，多路复用器就会返回。这时候用户进程再调用read操作，把数据从内核缓冲器拷贝到用户空间。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/8.png"></p><p>所以，IO多路复用的特点是通过一种机制让一个进程能同时等待多个文件描述符，而这些文件描述符其中的任意一个进入读就绪(readable)状态，select()函数就可以返回。多路复用需要操作系统的支持。redis的多路复用，提供了select，epoll，evport，kqueue几种选择，在编译的时候来选择一种。</p><p>​    evport是Solaris系统内核提供支持的；</p><p>​    epoll是Linux系统内核提供支持的；</p><p>​    kqueue是Mac系统提供支持的；</p><p>​    select是POSIX提供的，一般操作系统都有支撑(保底方案)</p><p>总结：redis抽象了一套AE事件模型，将IO事件和时间事件融入一起，同时借助多路复用机制的回调特性（Linux上用epoll），使得IO读写都是非阻塞的，实现高性能的网络处理能力。</p><p>​    一直在说的redis新版本多线程的特性，意思并不是服务端接收客户端请求变成多线程了，它还是单线程的。严格意义上来说，redis从4.0之后就引入了多线程用来处理一些耗时长的工作和后台工作，那不然的话，如果真的只有一个线程，那些耗时的操作肯定会导致金额护短请求被阻塞。我们这里说的多线程，确切的说叫做多线程IO</p><h3 id="2-9-多线程IO"><a href="#2-9-多线程IO" class="headerlink" title="2.9 多线程IO"></a>2.9 多线程IO</h3><p>服务端的数据返回给客户端，需要从内核空间copy数据到用户空间，然后会写道socket(write调用)，这个过程是非常耗时的。所以多线程IO指的就是把结果写道socket的这个环节是多线程的。处理请求依然是单线程的，所以不存在线程并发安全问题。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/9.png"></p><p>Redis本质上是一个存储系统。所有的存储系统在数据量过大的情况下都会面临存储瓶颈，包括MySQL，RabbitMQ等等。这里要解决两个问题：首先作为一个内存的KV系统，redis服务肯定不是无限制的使用内存，应该设置一个上限（max_memory）。第二个，数据应该有过期属性，这样就能清除不再使用的key。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis事务</title>
    <link href="/2023/02/22/redis/Redis%E4%BA%8B%E5%8A%A1/"/>
    <url>/2023/02/22/redis/Redis%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="1-为什么要用事务"><a href="#1-为什么要用事务" class="headerlink" title="1 为什么要用事务"></a>1 为什么要用事务</h2><p>Redis的单个命令是原子性的（比如get set mget mset），要么成功要么失败，不存在并发干扰的问题。如果涉及到多个命令的时候，需要把多个命令作为一个不可分割的处理序列，就必须要依赖redis的功能特性来实现了。</p><p>Redis提供了事务的功能，可以把一组命令一起执行。Redis的事务有3个特点：</p><ol><li><p>按进入队列的顺序执行。</p></li><li><p>不会受到其他客户端的请求的影响</p></li><li><p>事务不能嵌套，多个multi命令效果一样</p></li></ol><h2 id="2-事务的用法"><a href="#2-事务的用法" class="headerlink" title="2  事务的用法"></a>2  事务的用法</h2><p>Redis的事务涉及到四个命令：multi（开启事务），exec（执行事务），discard（取消事务），watch（监视）</p><p>案例场景：tom和mic各有1000元，tom向mic转账100元。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> tom <span class="hljs-comment">1000</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">mic 1000</span><br>multi<br>decrby <span class="hljs-comment">tom 100</span><br>incrby <span class="hljs-comment">mic 100</span><br>exec<br>get <span class="hljs-comment">tom</span><br>get <span class="hljs-comment">mic</span><br></code></pre></td></tr></table></figure><p>通过multi命令开启事务。Multi执行后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即执行，而是被放到一个队列中。当exec命令被调用时，所有队列中的命令才会被执行。如果没有执行exec，所有的命令都不会被执行。如果中途不想执行事务了，可以调用discard可以清空事务队列，放弃执行。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">multi </span><br>decrby tom <span class="hljs-number">100</span><br><span class="hljs-keyword">discard</span><br><span class="hljs-keyword"></span>get tom<br></code></pre></td></tr></table></figure><h2 id="3-Watch命令"><a href="#3-Watch命令" class="headerlink" title="3  Watch命令"></a>3  Watch命令</h2><p>为了防止事务过程中某个key‘的值被其他客户端请求修改，在Redis中还提供那个了一个watch命令。也就是多个客户端更新变量的时候，会跟原值做比较，只有它没有被其他线程修改的情况下，才更新成新的值。它可以为Redis事务提供CAS乐观锁行为。</p><p>可以一个用watch监视一个或者多个key，如果开启事务之后，至少一个被监视key键在exec执行之前被修改了，那么整个事务都会被取消（key提前过期除外）。可以用unwatch取消。</p><table><thead><tr><th>client 1</th><th>client 2</th></tr></thead><tbody><tr><td>set balance 1000 <br />watch balance <br />multi <br />incrby balance 100</td><td></td></tr><tr><td></td><td>decrby balance 100</td></tr><tr><td>exec [返回null] <br />get balance</td><td></td></tr></tbody></table><h2 id="4-事务可能遇到的问题"><a href="#4-事务可能遇到的问题" class="headerlink" title="4 事务可能遇到的问题"></a>4 事务可能遇到的问题</h2><h3 id="4-1-在执行exec之前发生错误"><a href="#4-1-在执行exec之前发生错误" class="headerlink" title="4.1 在执行exec之前发生错误"></a>4.1 在执行exec之前发生错误</h3><p>比如：入队的命令存在语法错误，包括参数数量，参数名称等等（编译器错误）。事务会被拒绝执行，也就是队列中所有的明林都不会得到执行。</p><h3 id="4-2-在执行exec之后发生错误"><a href="#4-2-在执行exec之后发生错误" class="headerlink" title="4.2 在执行exec之后发生错误"></a>4.2 在执行exec之后发生错误</h3><p>比如String使用了hash的命令，参数个数正确，但是数据类型错误，这是一种运行时错误。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gams">flushall<br>multi<br><span class="hljs-keyword">set</span> k1 <span class="hljs-comment">1</span><br>hset <span class="hljs-comment">k1 a b</span><br>exec<br>1) OK<br>2) (error) WRONGTYPE <span class="hljs-comment">Operation againest a key holding the wrong kind of value</span> <br>get <span class="hljs-comment">k1</span><br></code></pre></td></tr></table></figure><p>最后发现set k1 1的命令是成功的，也就是在这种发生了运行时异常的情况下，只有错误的命令没有被执行，但是其他命令没有收到影响。这个显然不符合对原子性的定义，也就是没办法用redis的这种事务机制来实现原子性，保证数据的一致。</p><h3 id="4-3-为什么不回滚？"><a href="#4-3-为什么不回滚？" class="headerlink" title="4.3 为什么不回滚？"></a>4.3 为什么不回滚？</h3><p>官方的解释是这样的：</p><ol><li><p>redis命令只会因为错误的语法而失败，也就是说，从实用性的角度来说，失败的命令是由代码错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</p></li><li><p>因为不需要对回滚进行支持，所以redis的内部可以保持简单且快速。需要知道的是：回滚不能够解决代码问题。</p></li></ol><p>Redis从2.6版本开始引入了Lua脚本，也就是说redis可以用lua来执行redis命令。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot启动流程</title>
    <link href="/2023/02/21/springboot/springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/02/21/springboot/springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-启动方式"><a href="#1-启动方式" class="headerlink" title="1. 启动方式"></a>1. 启动方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-comment">//方式一</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Application.class, args);<br>    &#125;<br>    <span class="hljs-comment">//方式二</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SpringApplication</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplication</span>(MySpringConfiguration.class);<br>        app.run(args);<br>    &#125;<br>    <span class="hljs-comment">//方式三</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplicationBuilder</span>()<br>            .sources(Parent.class)<br>            .child(Application.class)<br>            .run(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-启动流程概览"><a href="#2-启动流程概览" class="headerlink" title="2. 启动流程概览"></a>2. 启动流程概览</h2><p><img src="/image/springboot/springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.jpg"></p><h2 id="3-启动流程详解"><a href="#3-启动流程详解" class="headerlink" title="3. 启动流程详解"></a>3. 启动流程详解</h2><h3 id="3-1-new-Application初始化"><a href="#3-1-new-Application初始化" class="headerlink" title="3.1 new Application初始化"></a>3.1 new Application初始化</h3><h4 id="3-1-1-initializers初始化器"><a href="#3-1-1-initializers初始化器" class="headerlink" title="3.1.1 initializers初始化器"></a>3.1.1 initializers初始化器</h4><p>​    SPI方式设置初始化器initializers：this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));</p><p>​    扩展：自定义初始化器，在spring容器启动前执行，实现ApplicationContextInitializer接口，实现方法，在spring.factories中加入org.springframework.context.ApplicationContextInitializer=初始化器类全路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//springboot源码</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApplicationContextInitializer</span>&lt;C <span class="hljs-keyword">extends</span><br><span class="hljs-title class_">ConfigurableApplicationContext</span>&gt; &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Initialize the given application context.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> applicationContext the application to configure</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(C applicationContext)</span>;<br>&#125;<br><br><span class="hljs-comment">//自定义初始化器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextInitializer</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;自定义初始化器执行...&quot;</span>);<br><span class="hljs-type">ConfigurableEnvironment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> applicationContext.getEnvironment();<br><span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;jack&quot;</span>);<br>environment.getPropertySources().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MapPropertySource</span>(<span class="hljs-string">&quot;myInitializer&quot;</span>,map));<br>System.out.println(<span class="hljs-string">&quot;myInitializer execute, and add some property&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//通过SPI机制将自定义初始化器交给list集合initializers</span><br>org.springframework.context.ApplicationContextInitializer=com.intializer.MyInitializer<br></code></pre></td></tr></table></figure><p>初始化器的回调 SpringApplication#run()-&gt;prepareContext(..)–&gt;applyInitializers(context)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">applyInitializers</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> &#123;<br><span class="hljs-keyword">for</span> (ApplicationContextInitializer initializer : getInitializers()) &#123;<br>Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),ApplicationContextInitializer.class);<br>Assert.isInstanceOf(requiredType, context, <span class="hljs-string">&quot;Unable to call initializer.&quot;</span>);<br>initializer.initialize(context);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/springboot/1.png"></p><h4 id="3-1-2-listeners监听器"><a href="#3-1-2-listeners监听器" class="headerlink" title="3.1.2 listeners监听器"></a>3.1.2 listeners监听器</h4><p><img src="/image/springboot/2.png"></p><p>SPI方式设置监听器listeners：this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));</p><p>​    扩展：自定义监听器(starting-servlet启动前执行 or started-servlet启动后执行)，在spring容器启动前(后)执行，实现ApplicationContextInitializer接口，实现方法，在spring.factories中加入org.springframework.context.ApplicationContextInitializer=初始化器类全路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义监听器</span><br><span class="hljs-comment">//容器启动前调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStartingListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;ApplicationStartingEvent&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ApplicationStartingEvent event)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;myStartingListener 容器正在启动...&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">//容器启动完成调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStartedListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;ApplicationStartedEvent&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ApplicationStartedEvent event)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;myStartedListener 容器启动完成...&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//通过SPI机制将自定义初始化器交给list集合listeners</span><br>org.springframework.context.ApplicationListener=\<br>com.jack.springbootmybatis.listener.MyStartingListener,\<br>com.jack.springbootmybatis.listener.MyStartedListener<br></code></pre></td></tr></table></figure><p><img src="/image/springboot/3.png"></p><h3 id="3-2-run方法"><a href="#3-2-run方法" class="headerlink" title="3.2 run方法"></a>3.2 run方法</h3><ol><li><p>获取监听器，并启动starting类型的监听器</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SpringApplicationRunListeners</span> <span class="hljs-variable">listeners</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getRunListeners(args);<br>listeners.starting(bootstrapContext, <span class="hljs-built_in">this</span>.mainApplicationClass);<br></code></pre></td></tr></table></figure></li><li><p>准备Environment，和配置中心扩展有关</p></li><li><p>打印Banner；自定义Banner，有txt和image两种方式，在resources目录下创建一个banner.txt的文件就可以自定义banner效果</p></li><li><p>确定context类型：context = createApplicationContext()</p></li><li><p>prepareContext，执行初始化器initializers</p></li><li><p><strong>refreshContext(context) -&gt;AbstractApplicationContext#refresh()：创建tomcat容器；创建bean工厂；实例化bean</strong></p></li></ol><p>（1）this.prepareRefresh();上下文刷新前的准备工作：启动日期，设置context的当前状态，初始化属性和环境</p><p>（2）获取beanFantory工厂：obtainFreshFactory</p><p>（3）准备beanFactory工厂，配置一些标准的特性，比如上下文类加载器和后置处理器等</p><p>（4）postProcessBeanFactory(beanFactory)：处理一些web相关的bean以及作用域，比如：request和session等</p><p>（5）invokeBeanFactoryPostProcessors(beanFactory)：执行BeanFactory的后置处理器，解析@Configuration，生成BeanDefinition</p><p>​    扩展：自定义BeanFactoryPostProcessor：实现BeanFactoryPostProcessor，添加@Component注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义BeanFactoryPostProcessor</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JackBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactorybeanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>Arrays.asList(beanFactory.getBeanDefinitionNames()).forEach(beanDefinitionName -&gt;<br>System.out.println(beanDefinitionName));<br>System.out.println(<span class="hljs-string">&quot;JackBeanFactoryPostProcessor...&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>（6）registerBeanPostProcessors(beanFactory)：向BeanFactory中注册bean的postprocessor，用于后续bean创建的拦截操作，应用场景AOP</p><p>​    扩展：自定义BeanPostProcessor：实现BeanPostProcessor，添加@Component</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义BeanPostProcessor</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JackBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><span class="hljs-keyword">if</span>(beanName.equals(<span class="hljs-string">&quot;userController&quot;</span>))&#123;<br>System.out.println(<span class="hljs-string">&quot;找到了userController: &quot;</span>+bean);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（7）initMessageSource国际化</p><p>（8）initApplicationEventMulticaster：初始化一些广播器，用于发布事件</p><p>（9）<strong>onRefresh：初始化context子类上下文中的其他特别bean，创建tomcat容器等</strong></p><p>（10）finishBeanFactoryInitialization(beanFactory)：bean的初始化并加入beanFactory中</p><p>​    1-beanFactory.preInstantiateSingletons() </p><p>​    2-获取到所有BeanDefinition的名称 List beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames) </p><p>​    3-判断当前的bean是否为factorybean if (isFactoryBean(beanName)) </p><p>​    4-来到else部分的getBean(beanName)方法</p><p>​    5-判断是否可以从缓存中获取到bean或者父容器中获取：getSingleton(beanName)以及 getParentBeanFactory()</p><p>​    6-getSingleton(String beanName,Object Factory singleFactory)，调用singleFactory#getObject 方法时，会来到其实现类createBean(beanName,mbd,args)</p><p>​    7-AbstractAutowireCapableBeanFactory#doCreateBean()</p><p>​    8-选择无参构造函数创建Bean：</p><ol start="7"><li><p>执行runners</p><p> 扩展：自定义runner，在spring容器启动前执行，实现ApplicationRunner接口，实现方法，添加通过@Component注解</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义Runner</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplicationRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationRunner</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>System.out.println(<span class="hljs-string">&quot;MyApplicationRunner...&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/springboot/4.png"></p>]]></content>
    
    
    <categories>
      
      <category>Springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis入门</title>
    <link href="/2023/02/17/redis/Redis%E5%85%A5%E9%97%A8/"/>
    <url>/2023/02/17/redis/Redis%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-redis定位与特性"><a href="#1-redis定位与特性" class="headerlink" title="1 redis定位与特性"></a>1 redis定位与特性</h2><h3 id="1-1-SQL与NoSQL"><a href="#1-1-SQL与NoSQL" class="headerlink" title="1.1 SQL与NoSQL"></a>1.1 SQL与NoSQL</h3><p>​    大部分时候，我们都会首先考虑用关系型数据库来存储我们的数据，比如SQLServer，Oracle，MySQL 等等。关系型数据库的特点：</p><p>​    1.它以表格的形式，基于行存储数据，是一个二维的模式。</p><p>​    2.它存储的是结构化的数据，数据存储有固定的模式（scheme），数据需要适应表结构。</p><p>​    3.表与表之间存在关联（Reletionship）。</p><p>​    4.大部分关系型数据库都支持SQL（结构化查询语句）的操作，支持复杂的关联查询。</p><p>​    5.通过支持事务（ACID）来提供严格或者实时的数据一致性。</p><p>​    但是使用关系型数据库也存在一些限制，比如：</p><p>​    1.要实现扩容的话，只能向上（垂直）扩展，比如磁盘限制了数据的存储，就要扩大磁盘容量，通过堆硬件的方式，不支持动态的扩缩容。水平扩容需要复杂的技术来实现，比如分库分表。</p><p>​    2.表结构修改困难，因此存储的数据格式也收到限制。</p><p>​    3.在高并发和高数据量的情况下，关系型数据库通常会把数据持久化到磁盘，基于磁盘的读写压力比较大。</p><p>​    为了规避关系型数据库的一系列问题，就有了非关系型的数据库，一般把它叫做“non-relational”或者“Not Only SQL”。NoSQL 最开始是不提供SQL 的数据库的意思，但是后来意思慢慢地发生了变化。</p><p>​    非关系型数据库的特点：</p><p>​    1、存储非结构化的数据，比如文本、图片、音频、视频。</p><p>​    2、表与表之间没有关联，可扩展性强。</p><p>​    3、保证数据的最终一致性。遵循BASE（碱）理论。Basically Available（基本可用）； Soft-state（软状态）； Eventually Consistent（最终一致性）。</p><p>​    4、支持海量数据的存储和高并发的高效读写。</p><p>​    5、支持分布式，能够对数据进行分片存储，扩缩容简单。</p><p>​    对于不同的存储类型，又有各种各样的非关系型数据库，比如有几种常见的类型：</p><p>​    1 、KV 存储， 用Key Value 的形式来存储数据。比较常见的有Redis 和MemcacheDB。</p><p>​    2、文档存储，MongoDB。</p><p>​    3、列存储，HBase。</p><p>​    4、图存储，这个图（Graph）是数据结构，不是文件格式。Neo4j。</p><p>​    5、对象存储。</p><p>​    6、XML 存储等等等等。</p><p>​    这个列举了各种各样的NoSQL 数据库<a href="http://nosql-database.org/">http://nosql-database.org/</a> 。NewSQL 结合了SQL 和NoSQL 的特性（例如PingCAP 的TiDB）。</p><h3 id="1-2Redis特性"><a href="#1-2Redis特性" class="headerlink" title="1.2Redis特性"></a>1.2Redis特性</h3><p>​    官网介绍：<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a></p><p>​    中文网站：<a href="http://www.redis.cn/">http://www.redis.cn</a> </p><p>​    硬件层面有CPU 的缓存；浏览器也有缓存；手机的应用也有缓存。把数据缓存起来的原因就是从原始位置取数据的代价太大了，放在一个临时位置存储起来，取回就可以快一些。</p><p>​    1.为什么要把数据放在内存中？</p><p>​    1）内存的速度快，10w QPS</p><p>​    2）减少计算的时间，减轻数据库的压力</p><p>​    2.如果是用内存的数据结构作为缓存，为什么不用HashMap或者Memcached？</p><p>​    1）更丰富的数据类型</p><p>​    2）进程内与跨进程；单机与分布式</p><p>​    3）功能丰富：持久化机制、内存淘汰策略，事务，发布订阅，pipeline，lua</p><p>​    4）支持多种编程语言</p><p>​    5）高可用，集群</p><p>注：Memcached只能存储KV，没有持久化机制，不支持主从复制，是多线程的。</p><h2 id="2-redis安装启动"><a href="#2-redis安装启动" class="headerlink" title="2 redis安装启动"></a>2 redis安装启动</h2><h3 id="2-1-服务端安装"><a href="#2-1-服务端安装" class="headerlink" title="2.1 服务端安装"></a>2.1 服务端安装</h3><p>1、Linux 安装</p><p>​    CentOS7 安装Redis 单实例<a href="https://gper.club/articles/7e7e7f7ff7g5egc4g6b">https://gper.club/articles/7e7e7f7ff7g5egc4g6b</a></p><p>​    Docker 安装Redis<a href="https://gper.club/articles/7e7e7f7ff7g5egc5g6c">https://gper.club/articles/7e7e7f7ff7g5egc5g6c</a></p><p>  主要是注意配置文件几处关键内容（后台启动、绑定IP、密码）的修改，配置别名</p><p>2、Windows 服务端安装</p><p>​    自行百度</p><h3 id="2-2-服务启动"><a href="#2-2-服务启动" class="headerlink" title="2.2 服务启动"></a>2.2 服务启动</h3><p>​    src 目录下，直接启动   ./redis-server</p><p>​    后台启动（指定配置文件）1、redis.conf -&gt;修改两行配置daemonize yes ；bind 0.0.0.0</p><p>​                         2、启动Redis -&gt; redis-server /usr/local/soft/redis-5.0.5/redis.conf</p><p>​    总结：redis 的参数可以通过三种方式配置，一种是redis.conf，一种是启动时–携带的参数，一种是config set。</p><h3 id="2-3-基本操作"><a href="#2-3-基本操作" class="headerlink" title="2.3 基本操作"></a>2.3 基本操作</h3><p>​    Redist默认有16个库（0-15）.可以在配置文件redis.conf中修改   database 16</p><p>​    因为没有完全隔离，不像数据库的database，不适合把不同的库分配给不同的业务使用。默认使用第一个库db0。在集群中只能使用第一个db。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">select 0;   <span class="hljs-comment">#切换数据库</span><br>flushdb;    <span class="hljs-comment">#清空当前数据库</span><br>flushall;   <span class="hljs-comment">#清空所有数据库</span><br></code></pre></td></tr></table></figure><p>​    Redis的存储叫做key-value存储，或者叫做字典结构。key的最大长度限制是512M，值得限制不同，有的是用长度限制，有的是用个数限制。先从key的基本操作入手。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">set</span> qs 2673   <span class="hljs-comment">#存值</span><br>get qs        <span class="hljs-comment">#取值</span><br>keys *        <span class="hljs-comment">#查看所有键</span><br>dbsize        <span class="hljs-comment">#获取键总数(生产环境数据量大，慎用)</span><br>exists qs     <span class="hljs-comment">#查看键是否存在</span><br>del qs hh     <span class="hljs-comment">#删除键</span><br>rename qs pyy <span class="hljs-comment">#重命名键</span><br><span class="hljs-built_in">type</span> qs       <span class="hljs-comment">#获取数据类型</span><br></code></pre></td></tr></table></figure><h2 id="3-redis基本数据类型"><a href="#3-redis基本数据类型" class="headerlink" title="3 redis基本数据类型"></a>3 redis基本数据类型</h2><h3 id="3-1-String字符串"><a href="#3-1-String字符串" class="headerlink" title="3.1 String字符串"></a>3.1 String字符串</h3><p><strong>存储类型</strong>  </p><p>​    可以用来存储INT（整数），float（单精度浮点数），String（字符串）</p><p><strong>操作命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh">getrange qs 0 1                        <span class="hljs-comment">#获取指定范围的字符</span><br>strlen                                 <span class="hljs-comment">#获取值长度</span><br>append qs good                         <span class="hljs-comment">#字符串追加内容</span><br>mset qs 888 hh 666                     <span class="hljs-comment">#设置多个值(批量操作，原子性)</span><br>mget qs hh                             <span class="hljs-comment">#获取多个值</span><br>setnx qs pyy                           <span class="hljs-comment">#设置值，如果key存在，则不成功</span><br><span class="hljs-comment">#基于此可实现分布式锁，用del key释放锁</span><br><span class="hljs-comment">#但如果释放锁的操作失败了，导致其他节点永远获取不到锁，怎么办？</span><br><span class="hljs-comment">#加过期时间，单独用expire加过期，也失败了。无法保证原子性，怎么办？多参数</span><br><span class="hljs-built_in">set</span> key value [expriation EX seconds|PX milliseconds][NX|XX]<br><span class="hljs-built_in">set</span> k1 v1 EX 10 NX                     <span class="hljs-comment">#使用参数的方式</span><br>incr qs                                <br>incrby qs 100                          <span class="hljs-comment">#(整数)值递增(值不存在会得到1)</span><br>decr qs<br>decrby qs 100                          <span class="hljs-comment">#(整数)值递减</span><br><span class="hljs-built_in">set</span> mf 2.6<br>incrbyfloat mf 7.3                     <span class="hljs-comment">#浮点数增量</span><br></code></pre></td></tr></table></figure><p><strong>存储实现原理</strong></p><p><em>1.数据模型</em></p><p>​    Redis是KV的数据库，Key-value一般会用哈希表来存储它。Redis的最外层是通过hashtable实现的（把这个叫做外层的哈希）。在redis里面。这个哈希表怎样实现呢？看一下C语言的源码（dict.h 47行），每一个键值对都是一个dictEntry（怪不得叫远程字典服务）,通过指针指向key的存储结构和value的存储结构，而且next 存储了指向下一个键值对的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span>&#123;</span><br>    <span class="hljs-type">void</span> *key; <span class="hljs-comment">//key关键字定义</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">void</span> *val; <span class="hljs-comment">//value定义</span><br>        <span class="hljs-type">uint64_t</span> u64;<br>        <span class="hljs-type">int64_t</span> s64;<br>        <span class="hljs-type">double</span> d;<br>    &#125; v;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dicEntry</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">//只向下一个键值对节点</span><br>&#125; dictEntry;<br></code></pre></td></tr></table></figure><p>实际上最外层是redisDb，redisDb里面放的是dict。源码server.h 661行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span>&#123;</span><br>    dict *dict; <span class="hljs-comment">//所有的键值对</span><br>    dict *expires; <span class="hljs-comment">//设置了过期时间的键值对</span><br>    dict *blocking_keys; <span class="hljs-comment">//Keys with clients waiting for data(BLOPOP)</span><br>    dict *ready_keys; <span class="hljs-comment">//Blocked keys that received a PUSH</span><br>    dict *watched_keys; <span class="hljs-comment">//WATCHED keys for MULTI/EXEC CAS</span><br>    <span class="hljs-type">int</span> id; <span class="hljs-comment">//Database ID</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> avg_ttl; <span class="hljs-comment">//Average TTL, just for stats</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> expires_cursor; <span class="hljs-comment">//Cursor of the active expore cycle</span><br>    <span class="hljs-built_in">list</span> *defrag_later; <span class="hljs-comment">// List of key names to attempt to defrag one by one, gradully</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以set hello world为例，因为key是字符串，Redis自己实现了一个字符串类型，叫做SDS，所以hello指向一个SDS的结构。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/1.png"></p><p>​    value是world，同样是一个字符串，当value存储一个字符串时，Redis并没有直接使用SDS存储，而是存储在redisObject中，实际上五种常用的数据类型的任何一种value，都是通过redisObject来存储的。最终redisObject再通过一个指针指向实际的数据结构，比如字符串或者其他。来看一下redisObject怎么定义的：redisObject：源码src/server.h 622行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C">typdef <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span>&#123;</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>; <span class="hljs-comment">//对象的类型，包括：OBJ_STRING,OBJ_LIST,OBJ_HASH,OBJ_SET,OBJ_ZSET</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>; <span class="hljs-comment">//具体的数据结构</span><br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS; <span class="hljs-comment">//24位，对象最后一次被命令程序访问的时间，与内存回收有关</span><br>    <span class="hljs-type">int</span> refcount; <span class="hljs-comment">//引用计数，当refcount为0的时候，表示该对象已经不被任何对象引用，则可以进行回收</span><br>    <span class="hljs-type">void</span> *ptr; <span class="hljs-comment">//只向对象实际的数据结构</span><br>&#125;<br></code></pre></td></tr></table></figure><p>用type命令看到的类型就是type的内容。</p><p>为什么一个value会有一种对外的类型，还有一种实际的编码呢？我们刚才说字符串会用SDS存储，那这个redisObject的value就会指向一个SDS：</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/2.png"></p><p>2.内部编码</p><p>用的String的命令，但是出现了三种不同的编码。这三种编码有什么区别？</p><p>​    （1）int，存储8个字节的长整型（long， 2^63-1）</p><p>​    （2）embstr，代表embstr格式的SDS，存储小于44个字节的字符串</p><p>​    （3）raw，存储大于44个字节的字符串</p><p><em>问题1，SDS是什么？</em></p><p>Redis中字符串的实现，Simple Dynamic String简单动态字符串。源码：sds.h 47行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">attribute_</span> ((_<span class="hljs-title">packed_</span>)) <span class="hljs-title">sdshdr8</span>&#123;</span><br>    <span class="hljs-type">uint8_t</span> len; <span class="hljs-comment">//当前字符数组的长度</span><br>    <span class="hljs-type">uint8_t</span> alloc; <span class="hljs-comment">//当前字符数组总共分配的内存大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">//当前字符数组的属性，用来标识到底是sdshdr8还是sdshdr16等</span><br>    <span class="hljs-type">char</span> buf[]; <span class="hljs-comment">//字符串真正的值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    本质上其实还是字符数组。SDS又有多种结构（sds.h）：sdshdr5，sdshdr8，sdshdr32，sdshdr32，sdshdr64，用于存储不同长度的字符串，分贝代表2^5=32byte，2^8=256byte, 2^16=65536byte=64KB, 2^32byte=4GB。</p><p><em>问题2：为什么Redis要用SDS是实现字符串？</em></p><p>​    因为C语言本身没有字符串类型，只能用字符串数组char[]实现。</p><p>​    （1）使用字符串数组必须先给目标变量分配足够的空间，否则可能会溢出</p><p>​    （2）如果要获取字符长度，必须遍历字符数组，时间复杂度是O(n)</p><p>​    （3）C字符长度的变更会对字符数组做内存重分配</p><p>​    （4）通过从字符串开始到结尾碰到的第一个‘\0’来标记字符串的结束，因此不能保存图片，音频，视频，压缩文件等二进制（bytes）保存的内容，二进制不安全。</p><p>SDS的特点：</p><p>​    1.不用担心内存溢出问题，如果需要会对SDS进行扩容</p><p>​    2.获取字符串长度时间复杂度为O(1)，因为定义了len属性</p><p>​    3.通过“空间预分配”（sdsMakeRoonFor）和“惰性空间释放”，防止多次重分配内存</p><p>​    4.判断是否结束的标志是len属性，可以包含‘\0‘（它同样以’\0’结尾是因为这样就可以使用C语言中函数库操作字符串的函数了）</p><table><thead><tr><th>C字符数组</th><th>SDS</th></tr></thead><tbody><tr><td>获取字符串长度的复杂度为O(N)</td><td>获取字符串长度的复杂度为O(1)</td></tr><tr><td>API是不安全的，可能会造成缓冲区溢出</td><td>API是安全的，不会造成缓冲区溢出</td></tr><tr><td>修改字符串长度N次必然需要执行N次内存重分配</td><td>修改字符串长度N次最多需要执行N次内存重分配</td></tr><tr><td>只能保存文本数据</td><td>可以保存文本或者二进制数据</td></tr><tr><td>可以使用所有&lt;string.h&gt;库中的函数</td><td>可以使用一部分&lt;string.h&gt;库中的函数</td></tr></tbody></table><p><em>问题3：embstr和raw编码的区别？为什么要为不同大小设计不同编码？</em></p><p>​    embstr的使用值分配一次内存空间（因为RedisObject和SDS是连续的），而raw需要分配两次内存空间（分别为RedisObject和SDS分配空间）。embstr的好处在于创建时少分配一次空间，删除时少释放一次空间，以及对象的所有数据连在一起，寻找方便。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/3.png"></p><p>​    而embstr的坏处也很明显，如果字符串的长度增加需要重新分配内存时，整个RedisObject和SDS都需要重新分配空间，因此Redis中的embstr实现为只读（这种编码的内容是不能修改的）。</p><p><em>问题4：int和embstr什么时候转化为raw？</em></p><ol><li><p>int数据不再是整数——raw</p></li><li><p>int大小超过了long的范围(2^63-1)——embstr</p></li><li><p>embstr长度超过了44个字节——raw</p></li></ol><p><em>明明没有超过44个字节，为什么变成raw了？</em></p><p>​    对于embstr，由于它的实现是只读的，因此在对embstr对象进行修改时，都会先转化为raw再进行修改。因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了44个字节。</p><p><em>问题5：当长度小于阈值时，会还原吗？</em></p><p>​    关于Redis内部编码的转换，都符合一下规律：编码转换在Redis写入数据时完成，且转换过程不可逆转，只能从小内存编码向大内存编码转换。</p><p><em>问题6：为什么要对底层的数据结构使用redisObject进行一层包装呢？</em></p><p>​    其实无论是设计redisObject，还是对存储字符设计这么多的SDS，都是为了根据存储的不同内容选择不同的存储方式，这样可以实现尽量地节省内存空间和提升查询速度的目的。</p><p><strong>应用场景</strong></p><p><em>1.缓存</em></p><p>​    String类型，缓存热点数据。例如明星出轨，网站首页，报表数据等等。可以显著提升热点数据的访问速度。</p><p><em>2.分布式数据共享</em></p><p>​    String类型，因为Redis是分布式的独立服务，可以在多个应用之间共享</p><p><em>3.分布式锁</em></p><p>​    String类型的setnx方法，只有不存在时才能添加成功，返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">getLock</span><span class="hljs-params">(Object lockObject)</span>&#123;<br>    jedisUtil = getJedisConnection();<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> jedisUtil.setNx(lockObject, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(flag)&#123;<br>        expire(lockObject, <span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> falg;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseLock</span><span class="hljs-params">(Object lockObject)</span>&#123;<br>    del(lockObject);<br>&#125;<br></code></pre></td></tr></table></figure><p><em>4.全局ID</em></p><p>​    INT类型，INCRBY，利用原子性（分库分表的场景，一次性拿一段）</p><p><em>5.计数器</em></p><p>INT类型，INCR方法。例如：文章的阅读量，微博点赞数，允许一定的延迟，先写入Redis再定时同步到数据库</p><p><em>6. 限流</em></p><p>INT类型，INCR方法。以访问者的IP和其他信息作为key，访问一次再增加一次计数，超过次数则返回false。</p><h3 id="3-2-Hash哈希"><a href="#3-2-Hash哈希" class="headerlink" title="3.2 Hash哈希"></a>3.2 Hash哈希</h3><p><strong>存储类型</strong></p><p>​    Hash用来存储多个无序的键值对。最大存储数量2^32-1（40亿左右）。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/4.png"></p><p>注意：前面说Redis所有的KV本身就是键值对，用dictEntry实现的，叫做外层的哈希，现在我们讲的是内层的哈希。</p><p>注意：Hash的value只能是字符串，不能是嵌套其他类型，比如hash或者list。</p><p>同样是存储字符串，Hash和String的主要区别?</p><ol><li><p>把所有相关的值聚集到一个key中，节省内存空间</p></li><li><p>只使用一个key，减少key中途</p></li><li><p>当需要批量获取值的时候，只需要使用一个命令，减少内存IO/CPU的消耗</p></li></ol><p>Hash不适合的场景：</p><ol><li><p>Field不能单独设置过期时间</p></li><li><p>需要考虑数据量分布的问题（field非常多的时候，无法分布到多个节点）</p></li></ol><p><strong>操作命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">hset h1 f 6;<br>hset h1 e 5;<br>hmset h1 a 1 b 2 c 3 d 4;<br>hget h1 a;<br>hmget h1 a b c;<br>hkeys h1;<br>hvals h1;<br>hgetall h1;<br>hdel h1 a;<br>hlen h1;<br></code></pre></td></tr></table></figure><p><strong>存储（实现）原理</strong></p><p>​    Redis的Hash本身也是一个KV结构，内层哈希底层可以使用两种数据结构实现：</p><p>​       （1）Ziplist: OBJ_ENCODING_ZIPLIST(压缩列表)</p><p>​       （2）Hashtable：OBJ_ENCODING_HT(哈希表)</p><p><em>1.ziplist压缩列表</em></p><p>​    ziplist是一个经过特殊编码的，由连续内存块组成的双向链表。它不存储指向上一个链表节点和指向下一个链表节点的指针，而是存储上一个节点长度和当前节点长度，这样读写可能会慢一些，因为你要去算长度，但是可以节省内存，是一种时间换空间的思想。</p><p>Ziplist的内部结构-源码ziplist.c第16行的注释：</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/5.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zlentry</span>&#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> privrawlensize; <span class="hljs-comment">//存储上一个链表节点的长度数值所需要的字节数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> prevrawlen; <span class="hljs-comment">//上一个链表节点占用的长度</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> lensize; <span class="hljs-comment">//存储当前链表节点长度数值所需要的字节数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len; <span class="hljs-comment">//当前链表节点占用的长度</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> headersize; <span class="hljs-comment">//当前链表节点的头部大小(privrawlensize + lensize)，即非数据域的大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> encoding; <span class="hljs-comment">//编码方式</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p; <span class="hljs-comment">//压缩链表以字符串的形式保存，该指针指向当前节点起始位置</span><br>&#125; zlentry;<br></code></pre></td></tr></table></figure><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/6.png"></p><p>编码类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIP_STR_06B(0&lt;&lt;6) <span class="hljs-comment">//长度小于等于63字节</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIP_STR_14B(1&lt;&lt;6) <span class="hljs-comment">//长度小于等于16383字节</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIP_STR_32B(2&lt;&lt;6) <span class="hljs-comment">//长度小于等于4294967295字节</span></span><br></code></pre></td></tr></table></figure><p><em>问题：什么时候使用ziplist存储？</em></p><p>当哈希对象同时满足一下两个条件的时候，使用ziplist编码：</p><p>1） 哈希对象保存的键值对数量&lt;512个</p><p>2） 所有的键值对的键和值的字符串长度都&lt;64byte（一个英文字母一个字节）</p><p>src/redis.conf配置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">hash-max-ziplist-value <span class="hljs-number">64</span> <span class="hljs-comment">//ziplist中最大能存放的值长度</span><br>hash-max-ziplist-entries <span class="hljs-number">512</span> <span class="hljs-comment">//ziplist中最多能存放的entry节点数量</span><br></code></pre></td></tr></table></figure><p>如果超过这两个阈值的任何一个，存储接后就会转换为hashtable。总结：字段个数少，字段值小，用ziplist。</p><p><em>2.hashtable（dict）</em></p><p>​    在redis中，hashtable被称为字典（dictionary）。前面我们知道了，Redis的KV结构是通过一个dictEntry来实现的。在hashtable中，又对dictEntry进行了多层的封装。源码位置Ldict.h 47行。首先有一个dictEntry：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span>&#123;</span><br>    <span class="hljs-type">void</span> *key; <span class="hljs-comment">//关键字定义</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">void</span> *val; <span class="hljs-comment">//value定义</span><br>        <span class="hljs-type">uint64_t</span> u64;<br>        <span class="hljs-type">int64_t</span> s64;<br>        <span class="hljs-type">double</span> d;<br>    &#125; v;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">//只向下一个键值对节点</span><br>&#125; dictEntry；<br></code></pre></td></tr></table></figure><p>dictEntry放到了dictht（hashtable里面）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span>&#123;</span><br>    dictEntry **table; <span class="hljs-comment">//哈希表数组</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size; <span class="hljs-comment">//哈希表大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask; <span class="hljs-comment">//掩码大小，用于计算索引值，总是等于size-1</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used; <span class="hljs-comment">//已有节点数</span><br>&#125; dictht;<br></code></pre></td></tr></table></figure><p>Ht放到了dict里面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>  &#123;</span><br>    dictType *type; <span class="hljs-comment">//字典类型</span><br>    <span class="hljs-type">void</span> *privdata; <span class="hljs-comment">//私有数据</span><br>    dictht ht[<span class="hljs-number">2</span>]; <span class="hljs-comment">//一个字典有两个哈希表</span><br>    <span class="hljs-type">long</span> rehashidx; <span class="hljs-comment">//rehash索引</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> iterators; <span class="hljs-comment">//当前正在使用的迭代器数量</span><br>&#125; dict;<br></code></pre></td></tr></table></figure><p>从最底层到最高层dictEntry——dictht——dict。它是一个数组+链表的结构，展开一下，哈希的整体存储结构：</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/7.png"></p><p>​    注意：dictht后面是null说明第二个ht还没有用到。DictEntry*后面是Null说明没有hash到这个地址。DictEntry后面是NULL说明没有发生哈希冲突。</p><p><em>问题：为什么要定义两个哈希表，其中一个不同呢？</em></p><p>Redis的哈希默认使用的是ht[0]，ht[1]不会初始化和分配空间。哈希表dictht是用链地址法来解决碰撞问题的。在这种情况下，哈希表的性能取决于它的大小（size属性）和它锁保存的节点的数量（used属性）之间的比率：</p><p>*比率在1：1时（一个哈希表ht只储一个节点entry）哈希表的性能最好。</p><p>*如果节点数量比哈希表的大小要大很多的话（这个比率用ratio表示，5标识平均一个ht存储5个entry），那么哈希表就会退化成多个链表，哈希表本身的性能优势就不再存在。</p><p>如果单个哈希表的节点数量过多，哈希表的大小需要扩容。Redis里面的这种操作叫做rehash。步骤：</p><ol><li><p>为字符ht[1]哈希表分配空间，ht[1]的大小为第一个大于等于ht[0].used*2的2的N次方幂。比如已经使用了10000，那就是16384.</p></li><li><p>将所有的ht[0]上的节点rehash到ht[1]上，重新计算hash值和索引，然后放入指定的位置。</p></li><li><p>当ht[0]全部迁移到了ht[1]之后，释放ht[0]的空间，将ht[1]设置为ht[0]表，并创建新的ht[1]，为下次rehash做准备。</p></li></ol><p><em>问题：什么时候触发扩容？</em></p><p>负载因子（源码dict.c）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> dict_can_resize = <span class="hljs-number">1</span>; <span class="hljs-comment">//是否需要扩容</span><br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> dict_force_resize_ratio = <span class="hljs-number">5</span>; <span class="hljs-comment">//扩容因子</span><br></code></pre></td></tr></table></figure><p>总结一下，Redis的Hash类型，可以用ziplist和hashtables来实现。</p><p><strong>应用场景</strong></p><p><em>1. 跟String一样</em></p><p>String可以做的事情。Hash都可以做</p><p><em>2.存储对象类型的数据</em></p><p>比如对象或者一张表的数据，比String节省了更多key的空间，也更加便于集中管理。</p><h3 id="3-3-List列表"><a href="#3-3-List列表" class="headerlink" title="3.3 List列表"></a>3.3 List列表</h3><p><strong>存储类型</strong></p><p>存储有序的字符串（从左到右），元素可以重复。最大存储数量2^32-1（40亿左右）。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/8.png"></p><p><strong>操作命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#元素增减</span><br>lpush queue a;<br>lpush queue b c;<br>rpush queue d e;<br>lpop queue;<br>rpop queue;<br><span class="hljs-comment">#取值</span><br>lindex queue 0;<br>lrange queue 0 -1;<br></code></pre></td></tr></table></figure><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/9.png"></p><p><strong>存储（实现）原理</strong></p><p>​    在早期的版本中，数据量较小时用ziplist存储（特殊编码的双向链表），达到临界值时转换为linkedlist进行存储，分别对应OBJ_ENCODING_ZIPLIST和OBJ_ENCODING_LINKEDLIST。3.2版本之后，统一用quicklist来存储。quicklist存储了一个双向链表，每个节点都是一个ziplist，所以是ziplist和linkedlist的结合体。</p><p><strong>quicklist：</strong>总体结构：</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/10.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklist</span>&#123;</span><br>    quicklistNode *head; <span class="hljs-comment">//指向双向列表的表头</span><br>    quicklistNode *tail; <span class="hljs-comment">//指向双向列表的表尾</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> count; <span class="hljs-comment">//所有的ziplist中一共存了多少个元素</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len; <span class="hljs-comment">//双向列表的长度，node的数量</span><br>    <span class="hljs-type">int</span> fill : QL_FILL_BITS; <span class="hljs-comment">//ziplist最大大小，对应list-max-ziplist-size</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> compress: QL_COMP_BITS; <span class="hljs-comment">//压缩深度，对应list-compress-depth</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bookmark_count: QL_BM_BITS; <span class="hljs-comment">//4位，bookmarks数组的大小</span><br>    quicklistBookmark bookmarks[]; <span class="hljs-comment">//bookmarks是一个可选字段，quicklist重新分配内存空间时使用，不使用时不占用空间</span><br>&#125; quicklist；<br></code></pre></td></tr></table></figure><p>redis.conf相关参数：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>list-max-ziplist-size (fill)</td><td>正数表示单个ziplist最多所包含的entry个数<br />负数表示单个ziplist的大小，默认8K</td></tr><tr><td>list-compress-depth (compress)</td><td>压缩深度，默认为0。<br />1：首尾的ziplist不压缩；2：首尾第一第二个ziplist不压缩，以此类推</td></tr></tbody></table><p>quicklist.h 46行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">pre</span>;</span> <span class="hljs-comment">//指向前一个节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">//指向后一个节点</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zl; <span class="hljs-comment">//指向实际的ziplist</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz; <span class="hljs-comment">//当前ziplist占用多少字节</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count : <span class="hljs-number">16</span>; <span class="hljs-comment">//当前ziplist中存储了多少个元素，占16bit（下同），最大65536个</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> encoding : <span class="hljs-number">2</span>; <span class="hljs-comment">//是否采用了LZF压缩算法压缩节点，RAW == 1 or LZF == 2</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> container : <span class="hljs-number">2</span>; <span class="hljs-comment">//未来可能支持其他结构存储 NONE==1 or ziplist == 2</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> recompress : <span class="hljs-number">1</span>; <span class="hljs-comment">//当前ziplist是不是已经被解压出来作临时使用</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> attempted_compress: <span class="hljs-number">1</span>; <span class="hljs-comment">//测试用</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> extra : <span class="hljs-number">10</span>; <span class="hljs-comment">//预留给未来用</span><br>&#125; quicklistNode;<br></code></pre></td></tr></table></figure><p><strong>应用场景</strong></p><p>list主要用在存储有序内容的场景。</p><p>​    <em>1.列表</em></p><p>​    例如用户的消息列表，网站的公告列表，活动列表，博客的文章列表，评论列表等等。思路：存储所有字段，LRANGE取出一页，按顺序显示。</p><p><em>2.队列/栈</em></p><p>​    list还可以当作分布式环境的队列/栈使用。list提供了两个阻塞的弹出操作：BLPOP/BRPOP，可以设置超时时间（单位：秒）.</p><p>​    BLPOP：BLPOP key 1 timeout移出并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p><p>​    BRPOP：BRPOP key 1 timeout移出并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/11.png"></p><p>​    队列：先进先出：rpush blpop，左头右尾，有便进入队列，左边出队列。</p><p>​    栈：先进后出：rpush brpop</p><p>​    总结一下：List存储有序的内容，用quicklist实现，本质上是数组——链表。Hashtable也是数组+链表，只是内部编码结构不一样。</p><h3 id="3-4-Set集合"><a href="#3-4-Set集合" class="headerlink" title="3.4 Set集合"></a>3.4 Set集合</h3><p><strong>存储类型</strong></p><p>Set存储String类型的无序集合，最大存储数量2^32-1（40亿左右）。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/12.png"></p><p><strong>操作命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">sadd myset a b c d e f g  <span class="hljs-comment">#添加一个或者多个元素</span><br>smembers myset            <span class="hljs-comment">#获取多个元素</span><br>scard myset               <span class="hljs-comment">#统计元素个数</span><br>srandmember myset         <span class="hljs-comment">#随机获取一个元素</span><br>spop myset                <span class="hljs-comment">#随机弹出一个元素</span><br>srem myset d e f          <span class="hljs-comment">#移除一个或多个元素</span><br>sismember myset a         <span class="hljs-comment">#查看元素是否存在</span><br></code></pre></td></tr></table></figure><p><strong>存储（实现）原理</strong></p><p>Redis用inset或hashtable存储set。如果元素都是整数类型，就用inset存储。inset.h 35行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intset</span>&#123;</span><br>    <span class="hljs-type">uint32_t</span> encoding; <span class="hljs-comment">//编码类型</span><br>    <span class="hljs-type">uint32_t</span> length; <span class="hljs-comment">//长度</span><br>    <span class="hljs-type">int8_t</span> contents[]; <span class="hljs-comment">//用来存储成员的动态数组</span><br>&#125; intset；<br></code></pre></td></tr></table></figure><p>如果不是整数类型，就用hashtable（数组+链表的存储结构），如果元素超过512个，也会用hashtable存储，跟一个配置有关</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">set-max-intset-entries</span> <span class="hljs-string">512</span><br></code></pre></td></tr></table></figure><p>问题：set的key没有value，怎么用hashtable存储？value存null就好了。</p><p><strong>应用场景</strong></p><p>抽奖：随机获取元素：spop myset。点赞，签到，打卡。商品标签。商品筛选。用户关注，推荐模型</p><h3 id="3-5-ZSet有序集合"><a href="#3-5-ZSet有序集合" class="headerlink" title="3.5 ZSet有序集合"></a>3.5 ZSet有序集合</h3><p><strong>存储类型</strong></p><p>sorted set存储有序的元素。每个元素有个score，按照score从小到大排名。score相同时，按照key的ASCII码排序。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/13.png"></p><table><thead><tr><th>数据结构</th><th>是否允许存在重复元素</th><th>是否有序</th><th>与有序实现方式</th></tr></thead><tbody><tr><td>列表list</td><td>是</td><td>是</td><td>索引下标</td></tr><tr><td>集合set</td><td>否</td><td>否</td><td>无</td></tr><tr><td>有序集合zset</td><td>否</td><td>否</td><td>分值score</td></tr></tbody></table><p><strong>操作命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">zadd myzset 10 java 20 php 30 ruby 40 cpp 50 python <span class="hljs-comment">#添加元素</span><br>zrange myzset 0 -1 withscores                       <br>zrevrange myzset 0 -1 withscores                     <span class="hljs-comment">#获取全部元素</span><br>zrangebyscore myzset 20 30                           <span class="hljs-comment">#根据分值区间获取元素</span><br>zrem myzset php cpp                                  <span class="hljs-comment">#移除元素，亦可以根据score rank删除</span><br>zcard myzset                                         <span class="hljs-comment">#统计元素个数</span><br>zincrby myzset 5 python                              <span class="hljs-comment">#分值递增</span><br>zcount myzset 20 60                                  <span class="hljs-comment">#根据分值统计个数</span><br>zrank myzset python                                  <span class="hljs-comment">#获取元素rank</span><br>zscore myzset python                                 <span class="hljs-comment">#获取元素score</span><br></code></pre></td></tr></table></figure><p><strong>存储（实现）原理</strong></p><p>​    默认使用ziplist编码（第三次见到了，hash的小编码，quicklist的Node，都是ziplist）。在ziplist内部，按照score排序递增来存储，插入的时候要移动之后的数据。如果元素数量大于等于128个，或者任一member长度大于等于64字节使用skiplist+dict存储。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">zset-max-ziplist-entries</span> <span class="hljs-string">128</span><br><span class="hljs-attr">zset-max-ziplist-value</span> <span class="hljs-string">64</span><br></code></pre></td></tr></table></figure><p>​    <em>什么是skiplist（跳表）？</em></p><p>​    我们先来看一下有序链表：</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/14.png"></p><p>​    在这样一个链表中，如果我们要查找某个数据，那么需要从头开始逐个进行比较，直到找到包含数据的那个节点，或者找到第一个比给定数据大的节点为止。时间复杂度为O(n)。同样，当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置。二分查找只适用于有序数组，不适用于链表。</p><p>​    假如我们每相邻两个节点增加一个指针，让指针指向下个节点（或者理解为有三个元素进入了第二层）。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/15.png"></p><p>​    这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一般（上图中是7，19，26）</p><p>​    问题：是哪些元素运气这么好，进入到第二层？在插入一个数据的时候，决定要放到哪一层，取决于一个算法，源码：t_zset.c 122行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">zslRandomLevel</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">int</span> level = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>((random()&amp;<span class="hljs-number">0xFFFF</span>) &lt; (ZSKIPLIST_P*<span class="hljs-number">0xFFFF</span>))<br>        level += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL)?level:ZSKIPLIST_MAXLEVEL;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在当我们想查找数据的时候，可以先沿着这个新链表进行查找。当碰到比待查数据大的节点时，再到下一层进行查找。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/16.png"></p><p>​    比如，我们想查找23，查找的路径是沿着标红的指针所指向的方向进行的：</p><p>​    1.23首先和7比较，再和19比较，比它们都大，继续向后比较。</p><p>​    2.但23和26比较的时候，比26要小，因此回到下面的链表（原链表），与19在第一层的下一个节点22比较。</p><p>​    3.23比22要大，沿下面的指针继续向后和26比较。23比26小，说明待查数据23在原链表中不存在。</p><p>​    在这个查找过程中，由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了。需要比较节点数大概只有原来的一般。这就是跳表。为什么不用AVL树或者红黑树？因为skiplist更加简洁。因为level是随机的，得到的skiplist可能是这样的，有些在第四层，有些在第三层，有些在第二层，有些在第一层。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/17.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span>&#123;</span><br>    sds ele;<br>    <span class="hljs-type">double</span> score;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span>&#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> span;<br>    &#125; level[];<br>&#125; zskiplistNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>, *<span class="hljs-title">tail</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br>    <span class="hljs-type">int</span> level;<br>&#125; zskiplist;<br><br>typdef <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zset</span>&#123;</span><br>    dict *dict;<br>    zskiplist *zsl;<br>&#125; zset;<br></code></pre></td></tr></table></figure><p><strong>应用场景</strong></p><p>顺序会动态变化的列表, 比如：排行榜</p><h3 id="3-6-其他数据结构简介"><a href="#3-6-其他数据结构简介" class="headerlink" title="3.6 其他数据结构简介"></a>3.6 其他数据结构简介</h3><h4 id="3-6-1-BitMaps"><a href="#3-6-1-BitMaps" class="headerlink" title="3.6.1 BitMaps"></a>3.6.1 BitMaps</h4><p>bitMaps是在字符串类型上面定义的位操作。一个字节由8个二进制位组成。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/18.png"></p><p>set k1 a</p><p>​    获取value在offset处的值（a对应的ASCII码是97，转换为二进制数据是01100001）</p><p>​    getbit k1 0</p><p>​    修改二进制数据</p><p>​    setbit k1 6 1</p><p>​    setbit k1 7 0</p><p>​    get k1</p><p>​    <em>问题：怎么变成b了？（b对应的ASCII码是98，二进制数是01100010）</em></p><p>​    统计二进制位中1的个数</p><p>​    bitcount k1</p><p>​    获取第一个1或者0的位置</p><p>​    bitpos k1 1</p><p>​    bitpos k1 0</p><p>​    因为bit非常节省空间（1MB=8388608bit），可以用来做大数据量的统计。</p><p>​    应用场景：用户访问统计， 在线用户统计</p><h4 id="3-6-2-Hyperloglogs"><a href="#3-6-2-Hyperloglogs" class="headerlink" title="3.6.2 Hyperloglogs"></a>3.6.2 Hyperloglogs</h4><p>​    Hyperloglogs：提供了一种不太精确的基数统计方法，用来统计以集合中不重复的元素个数，比如统计网站的UV，或者应用的日活，月活，存在一定的误差。在redis中实现HyperLogLog，只需要12K内存就能统计2^54个数据。</p><h4 id="3-6-3-Geo"><a href="#3-6-3-Geo" class="headerlink" title="3.6.3 Geo"></a>3.6.3 Geo</h4><p>​    消费金融，给客户使用的客户端有这么一个需求，要获取半径1公里以内的门店，那么我们就要把门店的经纬度保存起来。那个时候我们是直接把经纬度保存到数据库的，一个字段存经度一个字段存维度。计算距离比较复杂。Redis的GEO直接提供了这个方法。</p><p>操作：增加地址位置信息，获取地址位置信息，计算两个位置的距离，获取指定范围内的地理位置集合等等。</p><h4 id="3-6-4-Streams"><a href="#3-6-4-Streams" class="headerlink" title="3.6.4 Streams"></a>3.6.4 Streams</h4><p>5.0推出的数据类型。支持多播的可持久化的消息队列，用于实现发布订阅功能，借鉴了kafka的设计。</p><h3 id="3-7-总结"><a href="#3-7-总结" class="headerlink" title="3.7 总结"></a>3.7 总结</h3><table><thead><tr><th>对象</th><th>对象type属性值</th><th>type命令输出</th><th>object_encoding</th></tr></thead><tbody><tr><td>字符串对象</td><td>OBJ_STRING</td><td>string</td><td>int  embstr  raw</td></tr><tr><td>列表对象</td><td>OBJ_LIST</td><td>list</td><td>quicklist</td></tr><tr><td>哈希对象</td><td>OBJ_HASH</td><td>hash</td><td>ziplist   hashtable</td></tr><tr><td>集合对象</td><td>OBJ_SET</td><td>set</td><td>intset   hashtable</td></tr><tr><td>有序集合对象</td><td>OBJ_ZSET</td><td>zset</td><td>ziplist  skiplist+hashtable</td></tr></tbody></table><p><strong>应用场景总结</strong></p><p>​    缓存——提升热点数据库的访问速度</p><p>​    共享数据——数据的存储和共享的问题</p><p>​    全局ID——分布式全局ID的生成方案（分库分表）</p><p>​    分布式锁——进程间共享数据的原子操作保证</p><p>​    在线用户统计和计数</p><p>​    队列，栈——跨进程的队列/栈</p><p>​    消息队列——异步解耦的消息队列</p><p>   服务注册与发现——RPC通信机制的服务协调中心（Dubbo支持Redis）</p><p>​    购物车</p><p>​    新浪/Twitter 用户消息时间线</p><p>​    抽奖逻辑（礼物，转发）</p><p>​    点赞，打卡，签到</p><p>​    商品标签</p><p>​    用户（商品）关注（推荐）模型</p><p>​    电商产品筛选</p><p>​    排行榜</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis发布订阅模式</title>
    <link href="/2023/02/17/redis/Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/17/redis/Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-列表的局限"><a href="#1-列表的局限" class="headerlink" title="1 列表的局限"></a>1 列表的局限</h2><p>通过队列的rpush和blpop可以实现消息队列（队尾进队头出），没有任何元素可以弹出的时候，连接会被阻塞。但是基于list实现的消息队列，不支持一对多的消息分发，相当于只有一个消费者。</p><h2 id="2-发布订阅模式"><a href="#2-发布订阅模式" class="headerlink" title="2 发布订阅模式"></a>2 发布订阅模式</h2><p>除了通过list实现消息队列之外，Redis还提供了发布订阅的功能</p><h3 id="2-1-订阅频道"><a href="#2-1-订阅频道" class="headerlink" title="2.1 订阅频道"></a>2.1 订阅频道</h3><p>消息的生产者和消费者是不同的客户端，连接到同一个redis的服务。通过什么对象把生产者和消费者关联起来？</p><p>在RabbitMQ中叫Queue，在kafka中叫Topic。Redis的模型中这个叫channel（频道）。订阅者可以订阅一个或多个channel。消息的发布者可以给指定的channel发布于消息，只要有消息到达了channel，所有订阅了这个channel的订阅者都会收到这条消息。</p><p><img src="/image/redis/redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/1.png"></p><p>订阅者订阅频道：可以一次订阅多个，比如这个客户端订阅了3个频道，频道不用实现创建。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">subscribe</span> channel-<span class="hljs-number">1</span> channel-<span class="hljs-number">2</span> channel-<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>发布者可以向指定的频道发布消息（并不支持一次向多个频道发送消息）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">publish</span> channel-<span class="hljs-number">1</span> test<br></code></pre></td></tr></table></figure><p>取消订阅（不能在订阅状态下使用）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">unsubscribe</span> channel-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="2-2-按规则-Pattern-订阅频道"><a href="#2-2-按规则-Pattern-订阅频道" class="headerlink" title="2.2 按规则(Pattern)订阅频道"></a>2.2 按规则(Pattern)订阅频道</h3><p>?代表一个字符，*代表0个或多个字符。</p><p>例如，现在有三个新闻频道，运动新闻（news-sport），音乐新闻（news-music），天气新闻（news-weather）。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">psubscribe *sport  <span class="hljs-comment">//消费端1关注运动消息</span><br>psubscribe <span class="hljs-keyword">new</span><span class="hljs-type">s</span>*  <span class="hljs-comment">//消费端2关注所有消息</span><br>psubscribe <span class="hljs-keyword">new</span><span class="hljs-type">s</span>-weather  <span class="hljs-comment">//消费端3关注天气新闻</span><br></code></pre></td></tr></table></figure><p><img src="/image/redis/redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/2.png"></p><p>一般来说，考虑到性能和持久化的因素，不建议使用Redis的发布订阅功能来实现MQ。Redis的一些内部机制用到了发布订阅功能。</p><h3 id="2-3-java伪代码"><a href="#2-3-java伪代码" class="headerlink" title="2.3 java伪代码"></a>2.3 java伪代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PublishTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>        jedis.publish(<span class="hljs-string">&quot;test-123&quot;</span>, <span class="hljs-string">&quot;666&quot;</span>);<br>        jedis.publish(<span class="hljs-string">&quot;test-abc&quot;</span>, <span class="hljs-string">&quot;pengyuyan&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JedisPubSub</span> &#123;<br>    <span class="hljs-comment">// 取得订阅的消息后的处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String channel, String message)</span> &#123;<br>        System.out.println(channel + <span class="hljs-string">&quot;=&quot;</span> + message);<br>    &#125;<br>    <span class="hljs-comment">// 初始化订阅时候的处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSubscribe</span><span class="hljs-params">(String channel, <span class="hljs-type">int</span> subscribedChannels)</span> &#123;<br>        <span class="hljs-comment">// System.out.println(channel + &quot;=&quot; + subscribedChannels);</span><br>    &#125;<br>    <span class="hljs-comment">// 取消订阅时候的处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUnsubscribe</span><span class="hljs-params">(String channel, <span class="hljs-type">int</span> subscribedChannels)</span> &#123;<br>        <span class="hljs-comment">// System.out.println(channel + &quot;=&quot; + subscribedChannels);</span><br>    &#125;<br>    <span class="hljs-comment">// 初始化按表达式的方式订阅时候的处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPSubscribe</span><span class="hljs-params">(String pattern, <span class="hljs-type">int</span> subscribedChannels)</span> &#123;<br>        <span class="hljs-comment">// System.out.println(pattern + &quot;=&quot; + subscribedChannels);</span><br>    &#125;<br>    <span class="hljs-comment">// 取消按表达式的方式订阅时候的处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPUnsubscribe</span><span class="hljs-params">(String pattern, <span class="hljs-type">int</span> subscribedChannels)</span> &#123;<br>        <span class="hljs-comment">// System.out.println(pattern + &quot;=&quot; + subscribedChannels);</span><br>    &#125;<br>    <span class="hljs-comment">// 取得按表达式的方式订阅的消息后的处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPMessage</span><span class="hljs-params">(String pattern, String channel, String message)</span> &#123;<br>        System.out.println(pattern + <span class="hljs-string">&quot;=&quot;</span> + channel + <span class="hljs-string">&quot;=&quot;</span> + message);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListenTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">MyListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyListener</span>();<br>        <span class="hljs-comment">// 使用模式匹配的方式设置频道</span><br>        <span class="hljs-comment">// 会阻塞</span><br>        jedis.psubscribe(listener, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;test-*&quot;</span>&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL性能优化</title>
    <link href="/2023/02/17/mysql/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2023/02/17/mysql/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="1-优化思路"><a href="#1-优化思路" class="headerlink" title="1 优化思路"></a>1 优化思路</h2><p>​    说到性能调优，大部分时候想要实现的目标是让查询更快。一个查询的流程又是由很多个环节组成的，每个环节都会消耗时间。要减少查询所消耗的时间，就要从每一个环节入手。</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.png"></p><p>确定环境：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> version();<br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%engine%&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="2-连接-配置优化"><a href="#2-连接-配置优化" class="headerlink" title="2 连接-配置优化"></a>2 连接-配置优化</h2><p>​    第一个环节是客户端连接到服务端，连接这一块有可能出现的问题是服务端连接数不够导致应用程序获取不到连接。比如Mysql：error 1040：Too many connections的错误。这个是超过了服务端设置的最大并发连接数。</p><p>​    可以从两个方面来解决连接数不够的问题：</p><p>​    1.从服务端来说，可以增加服务端的可连接数。如果有多个应用或者很多请求同时访问数据库，连接数不够的时候，可以:</p><p>​    （1）增加可用连接数，修改max_connections的大小：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> varibales <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;max_connections&#x27;</span>; <span class="hljs-comment">--修改最大连接数，当有多个应用连接的时候</span><br></code></pre></td></tr></table></figure><p>​    （2）及时释放不活动的连接。交互式和非交互式的客户端的默认超时时间都是28800秒，8小时，可以把这个值调小。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;wait_timeout&#x27;</span>; <span class="hljs-comment">--及时释放不活动的连接，注意不要释放连接池还在使用的连接</span><br></code></pre></td></tr></table></figure><p>​    2.从客户端来说，可以减少从服务端获取的连接数。如果想要不是每一次执行SQL都要创建一个新的连接，这时可以引入连接池，可以实现连接的重用。常见的连接池有老牌的DBCP和C3P0，阿里的Druid，Hikari（Spring Boot2.X版本默认的连接池）。连接池不是越大越好，只要维护一定数量大小的连接池，其他的客户端排队等待获取连接就可以了。有的时候连接池越大，效率反而越低。</p><p>​    Druid默认最大连接池大小是8。Hikari默认最大连接池大小是10。在Hikari的githuhb文档中，给出了一个PostgreSQL数据库建议的设置连接池小大的公式。它的建议是机器核数乘以2加1.也就是说，4核的机器，连接池维护9个连接就够了。这个公式从一定程度上来说对其他数据库也是适用的。每一个连接，服务端都需要创建一个线程去处理它。连接数越多，服务端创建的线程数就会越多。问题：CPU是怎么同时执行远远超过它的核数大小的任务的？分配时间片。上下文切换。而CPU的核数是有限的，频繁的上下文切换回造成比较大的性能开销。</p><p>​    这里说到了从数据库配置的层面去优化数据库。不管是数据库本身的配置，还是安装这个数据库服务的操作系统的配置，对于配置进行优化，最终的目标都是为了更好的发挥硬件本身的性能，包括CPU，内存，磁盘，网络。在不同的硬件环境下，操作系统和MySQL的参数的配置是不同的，没有标准的配置。 一般修改配置的工作是由专业的DBA完成，也有一些工具可以给出推荐值。</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/2.png"></p><h2 id="3-架构优化"><a href="#3-架构优化" class="headerlink" title="3 架构优化"></a>3 架构优化</h2><h3 id="3-1-缓存"><a href="#3-1-缓存" class="headerlink" title="3.1 缓存"></a>3.1 缓存</h3><p>​    在系统中有一些很慢的查询，要么数据量大，要么关联的表多，要么是计算逻辑非常复杂，这样的查询每次会占用连接很长时间。所以为了减轻数据库的压力，和提升查询效率，把数据放到内存中缓存起来，比如使用redis。</p><p>​    缓存适用于实时性不是很高的业务，比如报表数据，一次查询要2分钟，但是一天只需要更新一次。</p><p>​    独立的缓存服务，属于架构层面的优化。</p><h3 id="3-2-集群，主从复制"><a href="#3-2-集群，主从复制" class="headerlink" title="3.2 集群，主从复制"></a>3.2 集群，主从复制</h3><p>​    在分布式中，有一种提升可用性的手段叫做冗余，也就是创建集群。</p><p>​    集群的话必然会面临一个问题，就是不同的节点之间数据一致性的问题。如果同时读写多台数据库节点，怎么让所有的节点数据保持一致？这个时候需要用到复制技术（replication），被复制的节点称为master，复制的节点称为slave。Slave本身也可以作为其他节点的数据来源，这个叫做级联复制。之前说过，MySQL所有的更新语句都会记录到Server层binlog中。从服务器会不断获取主服务器的binlog文件，然后解析里面的SQL语句，在从服务器上面执行一遍，保持主从的数据一致。</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.png"></p><p>​    这里面涉及到三个线程，连接到master获取binlog，并且解析binlog写入中继日志，这个线程叫做IO线程。Master节点上有一个log dump线程，是用来发送binlog给slave的。从库的SQl线程，是用来读取relay log，把数据写入到数据库的。</p><p>​    做了主从复制配置之后，我们只把数据写入master节点，而读的请求可以分担到slave节点。我们把这种方案叫做读写分离。</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/4.png"></p><p>​    对于读多写少的项目来说，读写分离对于减轻主服务器的访问压力很有用。</p><h3 id="3-3-分库分表"><a href="#3-3-分库分表" class="headerlink" title="3.3 分库分表"></a>3.3 分库分表</h3><p>​    在集群架构中，所有的节点存储的都是相同的数据。如果单张表存储的数据过大的时候，比如一张表有上亿的数据，每天以百万的量级增加，单表的查询性能还是会大幅下降。这时就要用到第二手段，叫做分片。把单个节点的数据分散到多个节点存储，减少存储和访问压力，这个就是分库分表。</p><p>​    分库分表总体上可以分为两类：垂直分库，减少并发压力；水平分表，解决存储瓶颈。</p><p><strong>1.垂直分库</strong>：把一个数据库按照业务拆分成不同的数据库</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/5.png"></p><p><strong>2.水平分库分表</strong>：把单张表的数据按照一定的规则分布到多个数据库</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/6.png"></p><h2 id="4-优化器-SQL优化"><a href="#4-优化器-SQL优化" class="headerlink" title="4  优化器-SQL优化"></a>4  优化器-SQL优化</h2><p>​    优化器的作用是对SQL语句进行优化分析，生成执行计划。首先，要用到服务端的慢查询日志。</p><h3 id="4-1-慢查询日志slow-query-log"><a href="#4-1-慢查询日志slow-query-log" class="headerlink" title="4.1 慢查询日志slow query log"></a>4.1 慢查询日志slow query log</h3><h4 id="4-1-1-打开慢查询开关"><a href="#4-1-1-打开慢查询开关" class="headerlink" title="4.1.1 打开慢查询开关"></a>4.1.1 打开慢查询开关</h4><p>因为开启慢查询日志是有代价的（跟binlog，optimizer-trace一样），所以它默认是关闭的.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;slow_query%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>除了这个开关，还有一个参数，控制执行超过多长时间的SQL才记录到慢日志，默认是10秒。如果改成0秒的话就是记录所有的SQL。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%long_query%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>参数的两种修改方式：</p><p>​    1.set动态修改参数（重启后失效）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> @<span class="hljs-variable">@global</span>.slow_query_log<span class="hljs-operator">=</span><span class="hljs-number">1</span>; <span class="hljs-comment">--1开启，0关闭，重启后失效</span><br><span class="hljs-keyword">set</span> @<span class="hljs-variable">@global</span>.long_query_time<span class="hljs-operator">=</span><span class="hljs-number">3</span>; <span class="hljs-comment">--默认10秒，另开一个窗口后才会查到最新值</span><br></code></pre></td></tr></table></figure><p>​    2.修改配置文件my.cnf，以下配置定义了慢查询日志的开关，慢查询的时间，日志文件的存放路径。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">show_query_log</span>=<span class="hljs-string">ON</span><br><span class="hljs-attr">long_query_time</span>=<span class="hljs-string">2</span><br><span class="hljs-attr">show_query_log_file</span>=<span class="hljs-string">/var/lib/mysql/localhost-slow.log</span><br></code></pre></td></tr></table></figure><h4 id="4-1-2-慢日志分析"><a href="#4-1-2-慢日志分析" class="headerlink" title="4.1.2 慢日志分析"></a>4.1.2 慢日志分析</h4><p>1.日志内容</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/7.png"></p><p>2.mysqldumpslow</p><p>MySQL提供了mysqldumpslow的工具，在Mysql的bin目录下。例如：查询用时最多的10条慢SQL：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mysqldumpslow -s t -t 10 -g <span class="hljs-string">&#x27;select&#x27;</span> /var/lib/mysql/localhost-slow.log<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/8.png"></p><p>​    Count代表这个SQL执行了多少次；Time代表执行的时间，括号中是累计时间；Lock表示锁定的时间，括号是累计；Rows表示返回的记录数，括号是累计。当然，有的时候查询慢，不一定是SQL语句的问题，也有可能是服务器状态的问题。所以也要掌握一些查看服务器和存储引擎状态的命令。</p><h4 id="4-1-3-其他系统命令"><a href="#4-1-3-其他系统命令" class="headerlink" title="4.1.3 其他系统命令"></a>4.1.3 其他系统命令</h4><p>1.Show processlist 运行线程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">full</span> processlist;<br></code></pre></td></tr></table></figure><p>这是一个很重要的命令，用于显示用户运行线程。可以根据id号kill线程。也可以查表，效果一样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> information.processlist<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/9.png"></p><table><thead><tr><th>列</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>线程的唯一标识，可以根据它kill线程</td></tr><tr><td>User</td><td>启动这个线程的用户，普通用户只能看到自己的线程</td></tr><tr><td>Jpst</td><td>哪个端口发起的连接</td></tr><tr><td>db</td><td>操作的数据库</td></tr><tr><td>Command</td><td>线程的命令 <a href="https://dev.mysql.com/doc/refman/5.7/en/thread-commands.html">https://dev.mysql.com/doc/refman/5.7/en/thread-commands.html</a></td></tr><tr><td>Time</td><td>操作持续时间，单位秒</td></tr><tr><td>State</td><td>线程状态，比如查询所有可能有copying to tmp table, Sorting result, Sending data <br /> <a href="https://dev.mysql.com/doc/refman/5.7/en/general-thread-states.html">https://dev.mysql.com/doc/refman/5.7/en/general-thread-states.html</a></td></tr><tr><td>Info</td><td>SQL语句的前100个字符。如果要查看完整的SQL语句，用show full processlist</td></tr></tbody></table><p>2.Show status 服务器运行状态</p><p>Show status用于查看mysql服务器运行状态（重启后会清空）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> status;<br></code></pre></td></tr></table></figure><p>有session和global两种作用域，格式：参数-值。可以通过like带通配符过滤：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">showo <span class="hljs-keyword">global</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;com_select&#x27;</span>; <span class="hljs-comment">--查看select次数</span><br></code></pre></td></tr></table></figure><p>3.show engine 存储引擎运行信息</p><p>​    Show engine用来显示存储引擎的当前运行信息，包括事务持有的表锁，行锁信息；事务锁等待情况；线程信号量等待；文件IO请求；buffer pool统计信息。 例如：show engine innodb status；开启InnoDB监控：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> innodb_status_output<span class="hljs-operator">=</span><span class="hljs-keyword">ON</span>;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> innodb_status_output_locks<span class="hljs-operator">=</span><span class="hljs-keyword">ON</span>;<br></code></pre></td></tr></table></figure><p>​    很多开源的MySQL监控工具，其实他们的原理也都是读取的服务器，操作系统，MYSQL服务的状态和变量。之后，MySQL提供了一个执行计划的工具。通过EXPLAIN可以模拟服务端执行SQL查询语句的过程。通过这种方式可以分析语句或者表的性能瓶颈。</p><p>​    MYSQL5.6.3以前只能分析select，之后可以分析update，delete，insert。</p><h3 id="4-2-EXPLAIN执行计划"><a href="#4-2-EXPLAIN执行计划" class="headerlink" title="4.2 EXPLAIN执行计划"></a>4.2 EXPLAIN执行计划</h3><p>先创建三张表。课程表，老师表，老师联系方式表（没有任何索引）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if_exists course;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;course&#x27;</span> (<br><span class="hljs-string">&#x27;cid&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-string">&#x27;cname&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-string">&#x27;tid&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span><br>) engine<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">default</span> charrest<span class="hljs-operator">=</span>utf8mb4;<br><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if_exists teacher;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;teacher&#x27;</span> (<br><span class="hljs-string">&#x27;tid&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-string">&#x27;tname&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-string">&#x27;tcid&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span><br>) engine<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">default</span> charrest<span class="hljs-operator">=</span>utf8mb4;<br><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if_exists teacher_contact;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;teacher_contact&#x27;</span> (<br><span class="hljs-string">&#x27;tcid&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-string">&#x27;phone&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>) engine<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">default</span> charrest<span class="hljs-operator">=</span>utf8mb4;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;course&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;mysql&#x27;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;course&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;jvm&#x27;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;course&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;juc&#x27;</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;course&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;spring&#x27;</span>, <span class="hljs-number">3</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;teacher&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;qs&#x27;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;teacher&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;hh&#x27;</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;teacher&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;mic&#x27;</span>, <span class="hljs-number">3</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;teacher_contact&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;13688888888&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;teacher_contact&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;13688888889&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;teacher_contact&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;13688888810&#x27;</span>);<br></code></pre></td></tr></table></figure><p>Explain的结果字段有很多，详细分析一下：</p><h4 id="4-2-1-Id"><a href="#4-2-1-Id" class="headerlink" title="4.2.1 Id"></a>4.2.1 Id</h4><p>Id是查询序列编号，每张表都是单独访问的，一个select就会有一个序号。</p><p>（1）Id值不同的时候，先查询id值大的（先大后小）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> tc.phone <br><span class="hljs-keyword">from</span> teacher_contact tc<br><span class="hljs-keyword">where</span> tcid <span class="hljs-operator">=</span> (<br>    <span class="hljs-keyword">select</span> tcid <span class="hljs-keyword">from</span> teacher t <span class="hljs-keyword">where</span> t.tid <span class="hljs-operator">=</span> (<br>        <span class="hljs-keyword">select</span> c.tid <span class="hljs-keyword">from</span> course c <span class="hljs-keyword">where</span> c.cname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;mysql&#x27;</span><br>        )<br>    )<br></code></pre></td></tr></table></figure><p>查询顺序：course c——teacher t——teacher_contact tc</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/10.png"></p><p>先查课程表，再查老师表，最后查老师联系表。子查询只能以这种方式进行，只有拿到内层的结果之后才能进行外层的查询。</p><p>（2）id值相同</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> t.tname, c.name, tc.phone<br><span class="hljs-keyword">from</span> teacher t, course c, teacher_contact tc<br><span class="hljs-keyword">where</span> t.tid <span class="hljs-operator">=</span> c.tid <span class="hljs-keyword">and</span> t.tcid <span class="hljs-operator">=</span> tc.tcid <span class="hljs-keyword">and</span> (c.cid <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> tc.cid <span class="hljs-operator">=</span> <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/11.png"></p><p>Id值相同时，表的查询顺序是从上往下顺序执行。例如这次查询的id都是1（说明子查询被优化器转换成了连接查询），查询的顺序是teacher t（3条）——course c（4条）——teacher_contact tc（3条）。</p><p>​    （3）如果id有相同也有不同，就是id不同的先大后小，相同的从上往下。</p><p>​    在连接查询中，先查询的叫做驱动表，后查询的叫做被驱动表。应该先查小表（得到的结果少），小表驱动大表。</p><h4 id="4-2-2-Select-type-查询类型"><a href="#4-2-2-Select-type-查询类型" class="headerlink" title="4.2.2 Select type 查询类型"></a>4.2.2 Select type 查询类型</h4><p>​    这里并没有列出全部（其他：dependent union，dependent subquery，materialized，uncacheable subquery，uncacheable union）。下面列举了一些常见的查询类型：</p><p>​    1.simple：简单查询，不包含子查询，不包含关联查询union。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/12.png"></p><p>再看一个包含子查询的案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--查询mysql课程老师的手机号</span><br>explain <span class="hljs-keyword">select</span> tc.phone <span class="hljs-keyword">from</span> tescher_contact tc<br><span class="hljs-keyword">where</span> tcid <span class="hljs-operator">=</span> (<br>    <span class="hljs-keyword">select</span> tcid <span class="hljs-keyword">from</span> teacher t <span class="hljs-keyword">where</span> t.tid <span class="hljs-operator">=</span> (<br>        <span class="hljs-keyword">select</span> c.tid <span class="hljs-keyword">from</span> course c <span class="hljs-keyword">where</span> c.cname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;mysql&#x27;</span><br>        )<br>    )<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/13.png"></p><p>​    2.primary：子查询sql语句中的主查询，也就是最外层的查询</p><p>​    3.subquery：子查询中所有的内层查询都是该类型。</p><p>​    4.derived：衍生查询，表示在得到最终查询结果之前会用到的临时表，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> cr.cname <span class="hljs-keyword">from</span> (<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> course <span class="hljs-keyword">where</span> tid<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">union</span><br>    <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> course <span class="hljs-keyword">where</span> tid<span class="hljs-operator">=</span><span class="hljs-number">2</span><br>) cr;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/14.png"></p><p>​    对于关联查询，先执行有便的table（union），再执行左边的table，类型是derived</p><p>​    5.union：同上例</p><p>​    6.union result：主要是显示哪些表之间存在union查询。&lt;union2,3&gt;代表id=2和id=3的查询存在union，同上例。</p><h4 id="4-2-3-Type-连接类型"><a href="#4-2-3-Type-连接类型" class="headerlink" title="4.2.3 Type 连接类型"></a>4.2.3 Type 连接类型</h4><p>​    所有连接类型中，上面的最好，越往下越差。在常用的连接类型中：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;all。这里并没有列举全部（其他: fulltext, ref_or_null, index_merger, unique_subquery, index_subquery）。以上访问类型除了all，都能用到索引。</p><p>​    <strong>1.const</strong>：主键索引或者唯一索引，只能查到一条数据的SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> talbe if_exists single_data;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> single_data(<br>id <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">primary</span> key,<br>    content <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)<br>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> single_data <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>);<br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> single_data a <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">&#x27;;</span><br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/15.png"></p><p><strong>2.system</strong>：system是const的一种特例，只有一行满足条件，对于NyISAM，Memory的表，只查询到一条记录，也是system。比如系统库的这张表（8.0的版本中系统表全部变成InnoDB存储引擎了）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> mysql.proxies_priv;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/16.png"></p><p><strong>3.eq_ref</strong>：通常出现在多表的join查询，被驱动表通过唯一性索引（unique或primary key）进行访问，此时被驱动表的访问方式就是eq_ref。eq_ref是出const之外最好的访问类型。先删除teacher表中多余的数据，teacher_contact有3条数据，teacher表有三条数据。teacher_contact表的tcid（第一个字段）创建主键索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- alert table teacher_contact drop primary key</span><br>alert <span class="hljs-keyword">table</span> teacher_contact <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary</span> key(tcid);<br><br>explain <span class="hljs-keyword">select</span> t.tcid <span class="hljs-keyword">from</span> teacher t, teacher_contact tc <span class="hljs-keyword">where</span> t.tcid<span class="hljs-operator">=</span>tc.tcid<br></code></pre></td></tr></table></figure><p>此时的执行计划（先大后小，从上往下，tc是被驱动表。Tc表是eq_ref）：被驱动表用主键进行访问</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/17.png"></p><p><strong>小结</strong>：以上三种system，const，eq_ref，都是可遇不可求的，基本上很难优化到这个状态。</p><p>​    <strong>4.ref</strong>：查询用到了非唯一性索引，或者关联操作只使用了索引的最左前缀</p><p>​    为teacher表的tcid（第三个字段）创建普通索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- alert table teacher drop primary key</span><br>alert <span class="hljs-keyword">table</span> teacher <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary</span> key(tcid);<br><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">where</span> tcid<span class="hljs-operator">=</span><span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/18.png"></p><p><strong>5.range</strong>：索引范围扫描。如果where后面是between and 或 &lt; 或 &gt; 或 &gt;= 或 &lt;= 或 in这些，type类型就为range。不走索引一定是全表扫描（ALL），所以先加上普通索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- alert table teacher drop index idx_tid</span><br>alert <span class="hljs-keyword">table</span> teacher <span class="hljs-keyword">add</span> index idx_tid(tid)<br><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">where</span> tid<span class="hljs-operator">&lt;</span><span class="hljs-number">3</span>;<br><span class="hljs-comment">-- 或</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">where</span> tid <span class="hljs-keyword">between</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/19.png"></p><p>IN查询也是range（字段上有主键索引）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher_contact <span class="hljs-keyword">where</span> tcid <span class="hljs-keyword">in</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/20.png"></p><p><strong>6.index</strong>：Full Index Scan，查询全部索引中的数据（比不走索引要快）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> tid <span class="hljs-keyword">from</span> teacher;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/21.png"></p><p><strong>7.all：</strong>Full Table Scan，如果没有索引或者没有用到索引，type就是ALL。代表全表扫描。</p><p><strong>8.Null：</strong>不用访问表或者索引就能得到结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> dual <span class="hljs-keyword">where</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>总结：一般来说，需要保证查询的type至少达到range级别，最好能达到ref。all（全表扫描）和index（查询全部索引）都是需要优化的</p><h4 id="4-2-4-Possible-key-key"><a href="#4-2-4-Possible-key-key" class="headerlink" title="4.2.4 Possible_key, key"></a>4.2.4 Possible_key, key</h4><p>​    可能用到的索引和实际用到的索引。如果是null就代表没有用到索引。Possible_key可以有一个个或者多个，可能用到索引不代表一定用到索引。反过来，possible_key为空，key可能有值吗？表上创建联合索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">alert <span class="hljs-keyword">table</span> user_innodb <span class="hljs-keyword">add</span> index name_phone(name, phone);<br>explain <span class="hljs-keyword">select</span> phone <span class="hljs-keyword">from</span> user_innodb <span class="hljs-keyword">where</span> phone <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;126&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/22.png"></p><p>结论：是有可能的（这里是覆盖索引的情况）。如果通过分析发现没有用到索引，就要检查SQL或者创建索引。</p><h4 id="4-2-5-key-len"><a href="#4-2-5-key-len" class="headerlink" title="4.2.5 key_len"></a>4.2.5 key_len</h4><p>​    索引的长度（使用的字节数）。跟索引字段的类型，长度有关。</p><p>​    表上有联合索引：KEY ‘comidx_name_phone’(‘name’, ‘phone’)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_innodb <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;qs&#x27;</span>;<br></code></pre></td></tr></table></figure><p>Key_len = 1023，为什么不是255+11=266呢？这里的索引只用到了name字段，定义长度255.utf8mb4编码一个字符4个字节。所以是255*4=1020.使用变长字段varchar需要额外增加2个字节，允许null需要额外增加1个字节。所以一共1023.</p><h4 id="4-2-6-Rows"><a href="#4-2-6-Rows" class="headerlink" title="4.2.6 Rows"></a>4.2.6 Rows</h4><p>MySQL认为扫描多少行才能返回请求的数据，是一个预估值。一般来说行数越少越好。</p><h4 id="4-2-7-Filtered"><a href="#4-2-7-Filtered" class="headerlink" title="4.2.7 Filtered"></a>4.2.7 Filtered</h4><p>​    这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，它是一个百分比。如果比例很低，说明存储引擎层返回的数据经过大量过滤，这个是会消耗性能的，需要关注。</p><h4 id="4-2-8-Ref"><a href="#4-2-8-Ref" class="headerlink" title="4.2.8 Ref"></a>4.2.8 Ref</h4><p>使用哪个列或者常数和索引一起从表中筛选数据。</p><h4 id="4-2-9-Extra"><a href="#4-2-9-Extra" class="headerlink" title="4.2.9 Extra"></a>4.2.9 Extra</h4><p>执行计划给出额外的信息说明。</p><p>​    1.using index：用到了覆盖索引，不需要回表</p><p>​    2.using where：使用了where过滤，表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤（跟是否使用索引没有关系）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_innodb <span class="hljs-keyword">where</span> phone <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1345353545&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/23.png"></p><p>​    3.using index condition：索引条件下推</p><p>​    4.using filesort：不能使用索引来排序，用到了额外的排序（跟磁盘或文件没有关系）。需要优化。（复合索引的前提）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">alert <span class="hljs-keyword">table</span> user_innodb <span class="hljs-keyword">drop</span> index comidx_name_phone;<br>alert <span class="hljs-keyword">table</span> user_innodb <span class="hljs-keyword">add</span> index comidx_name_phone(name,phone);<br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_innodb <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;qs&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/24.png"></p><p>​    5.using temporary：用到了临时表，例如（以下不是全部情况）</p><p>​       （1）distinct非索引列（确定tid字段是否有索引）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span>(tid) <span class="hljs-keyword">from</span> teacher t;<br></code></pre></td></tr></table></figure><p>​       （2）group by非索引列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> tname <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> tname;<br></code></pre></td></tr></table></figure><p>​       （3）使用join的时候，group任意列（t表的结果）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> t.tid <span class="hljs-keyword">from</span> teacher t <span class="hljs-keyword">join</span> course c <span class="hljs-keyword">on</span> t.tid <span class="hljs-operator">-</span> c.tid <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> t.tid;<br></code></pre></td></tr></table></figure><p>需要优化，比如创建复合索引。</p><p>如果需要具体的cost信息，可以用：EXPLAIN FORMAT = JSON。如果觉得explain还不够细，可以开启optimizer trace。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;optimizer_trace&#x27;</span>;<br><span class="hljs-keyword">set</span> optimizer_trace<span class="hljs-operator">=</span><span class="hljs-string">&#x27;enabled=on&#x27;</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> information_schema.optimizer_trace\G<br></code></pre></td></tr></table></figure><p>总结一下：模拟优化器执行SQL查询语句的过程，来知道MySQL是怎么处理一条SQL语句的，通过这种方式我们可以分析语句或者表的性能瓶颈。分析出问题之后，就是对SQL语句的具体优化。</p><h3 id="4-3-SQL与索引优化"><a href="#4-3-SQL与索引优化" class="headerlink" title="4.3 SQL与索引优化"></a>4.3 SQL与索引优化</h3><p>​    当我们的SQL语句比较复杂，有多个关联和子查询的时候，就要分析SQL语句有没有改写的方法。举个简单的例子，一摸一样的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 大偏移量的limit</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_innodb limit <span class="hljs-number">900000</span>,<span class="hljs-number">10</span>;<br><span class="hljs-comment">-- 改成先过滤ID，再limit</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_innodb <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">900000</span> limit <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>一个sum语句性能提升3倍的优化案例： <a href="https://gper.club/articles/7e7e7f7ff4g5egc2g63">https://gper.club/articles/7e7e7f7ff4g5egc2g63</a>   这一步是SQL语句的优化，目的是让SQL语句的cost更小。</p><h2 id="5-存储引擎与表结构优化"><a href="#5-存储引擎与表结构优化" class="headerlink" title="5  存储引擎与表结构优化"></a>5  存储引擎与表结构优化</h2><p>1.存储引擎的选择</p><p>​       为不同的业务表选择不同的存储引擎，例如：查询插入多的业务表，用MyISAM。临时数据用memory。 常规并发多更新的表用InnoDB。</p><p>​    2.分表或者分区</p><p>​       交易历史表：在年底为下一年度建立12个分区，每个月一个分区</p><p>​       渠道交易表：分成：当日表，当月表，历史表，历史表再做分区</p><p>​    3.字段定义：</p><p>​       原则：使用可以正确存储数据的最小数据类型。为每列选择合适的字段类型：</p><p>​       （1）整数类型：</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/25.png"></p><p>Int有6中类型，不同的类型的最大存储范围是不一样的，占用的存储空间也是不一样的。举       例：存储性别字段？用tinyint，因为enum也是整数存储。</p><p>​       （2）字符类型：变长情况下，varchar更节省空间，但是对于varchar字段，需要一个字节来记录长      度，比如：联系地址。固定长度的用char，不要用varchar，比如：行政区编码。</p><p>​       （3）非空：非空字段尽量定义成not null，提供默认值，或者使用特殊值，空串代替null。NULL类     型的存储，优化，使用都会存在问题。</p><p>​       （4）不要使用外键，触发器，视图：降低了可读性；影响数据库性能，应该把计算的事情交给程序，       数据库专心做存储；数据的完整性应该在程序中检查。</p><p>​       （5）大文件存储：图片和音频，视频怎么存储？不要用数据库村粗图片（比如base64编码）或者      大文件。把文件放在NAS上，数据库只存储URI（相对路径），在应用中配置NAS服务器地址。</p><p>​       （6）表拆分或者字段冗余：</p><p>​           表拆分：将不常用的字段拆分出去，避免列数过多和数据量过大。淘宝的商品表。商户信息表。      比如在业务系统中，要记录所有接收和发送的消息，这个消息是XML格式的，用blob或者text存      储，用来追踪和判断重复，可以建立一张表专门用来存储报文。</p><p>​           字段冗余：合同表的客户姓名。</p><h2 id="6-总结：优化体系"><a href="#6-总结：优化体系" class="headerlink" title="6  总结：优化体系"></a>6  总结：优化体系</h2><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/26.png"></p><p>除了对于代码，SQL语句，表定义，架构，配置优化之外，业务层面的优化也不能忽视，举几个例子：</p><p>​    （1）在某一年的双十一，为什么会做一个充值到余额宝和余额有奖金的活动？现在会推荐大家用花呗支付，而不是银行卡支付？因为使用余额或者余额宝付款是记录本地或者内部数据库中，而使用银行卡付款，需要调用接口，操作内部数据库肯定更快。</p><p>​    （2）在某一年的双十一，为什么在凌晨禁止查询今天之外的账单？为什么小鸡的饲料发放延迟了？这时一种降级措施，用来保证当前最核心的业务。</p><p>​    （3）某银行的叫记录，只能按月份查询。</p><p>​    （4）最近几年的双十一，为什么11月1日就开始了？变成了各种定金红包模式？预售分流。</p><p>​    在应用层面同样有很多其他的方案来优化，达到尽量减轻数据库的压力的目的，比如限流，或者引入MQ削锋，等等。用数据库慢，不代表数据库本身慢，有的时候还要往上层去优化。当然，如果关系型数据库解决不了的问题，我们可能需要用到搜索引擎或者大数据的方案了，并不是所有的数据都要放到关系型数据库存储。</p><h2 id="7-优化案例"><a href="#7-优化案例" class="headerlink" title="7  优化案例"></a>7  优化案例</h2><p>​    服务端状态分析：</p><p>​    如果出现连接变慢，查询被阻塞，无法获取连接的情况。</p><p>​       1.重启！</p><p>​       2.show processlist查看线程状态，连接数数量，连接时间，状态</p><p>​       3.查看锁的状态</p><p>​       4.kill有问题的线程</p><p>​    对于具体的慢SQL：</p><p>​    一，分析查询基本情况</p><p>​       涉及到的表的表结构，字段的索引情况，每张表的数据量，查询的业务含义。这个非常重要，因为    有时候你会发现SQL根本没必要这么写，或者表设计是有问题的。</p><p>​    二，找出慢的原因</p><p>​       1.查看执行计划，分析SQL的执行情况，了解表访问顺序，访问类型，索引，扫描行数等信息</p><p>​       2.如果总体的时间很长，不确定哪一个因素影响最大，通过条件的增减，顺序的调整，找出引起查    询慢的主要原因，不断的尝试验证。找到原因：比如是没有走索引引起的，还是关联查询引起的，还order     by引起的。找到原因后：</p><p>​       3.对症下药，</p><p>​       （1）创建索引或者联合索引</p><p>​       （2）改写SQL，这里需要平时积累经验，例如：a）使用小表驱动大表，b）用join代替子查询，c）         not exist转换为left join is null，d）or改成union，e）如果结果集允许重复的话，使用union         all代替union，f）大偏移的limit，先过滤再排序。</p><p>​       如果sql本身解决不了，就要上升到表结构和架构了。</p><p>​       （3）表结构（冗余，拆分，not all等），架构优化（缓存，读写分离，分表分库）</p><p>​       （4）业务层的优化，必须条件是否必要</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL事务和锁</title>
    <link href="/2023/02/16/mysql/MySQL%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/"/>
    <url>/2023/02/16/mysql/MySQL%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="1-数据库事务"><a href="#1-数据库事务" class="headerlink" title="1. 数据库事务"></a>1. 数据库事务</h2><h3 id="1-1-事务的典型场景"><a href="#1-1-事务的典型场景" class="headerlink" title="1.1 事务的典型场景"></a>1.1 事务的典型场景</h3><p>​    在项目中，什么地方使用事务？是根据业务类型来使用的还是根据数据操作类型来使用的？无论你是在方法上加@Transactional注解，还是在xml文件中配置切面，还是直接用JDBC的方法。很多时候我们需要事务是因为我们希望涉及数据库的多个操作都成功，比如客户下单，会操作订单表，资金表，物流表等等，就需要放在一个事务中执行。</p><p>​    一个非常典型的案例就是银行转账。如果我们把行内转账简化为一个账户余额减少，另一个账户余额增加的情况，那么这两个动作一定是同时成功或同时失败的，否则会造成会计科目不平衡。另一个例子：12306的连续换乘功能，两张票必须同时购买成功，只买到前半程或者只买到后半程是没有意义的。</p><h3 id="1-2事务的定义"><a href="#1-2事务的定义" class="headerlink" title="1.2事务的定义"></a>1.2事务的定义</h3><p>​    事务是数据库管理系统（DBMS）执行过程中的一个逻辑单位，有一个有限的数据库操作序列构成。这里有两个关键点，1.所谓的逻辑单位，意味着它是数据库最小的工作单位，是不可再分的。2.它可能包含了一个或者多个DML语句，包括insert delete update。（单条DDL（create drop）和DCL（grant revoke）也会有事务）。</p><h3 id="1-3-哪些存储引擎支持事务"><a href="#1-3-哪些存储引擎支持事务" class="headerlink" title="1.3 哪些存储引擎支持事务"></a>1.3 哪些存储引擎支持事务</h3><p>​    并不是所有的数据库或者所有的存储引擎都支持事务，它是作为一种特性出现的。在MySQL中除了做集群的NDB之外，只有InnoDB支持事务，这个也是它成为默认的存储引擎的一个重要原因。</p><h3 id="1-4-事务的四大特性-ACID"><a href="#1-4-事务的四大特性-ACID" class="headerlink" title="1.4 事务的四大特性(ACID)"></a>1.4 事务的四大特性(ACID)</h3><p>​    1.原子性，Atomicity，也就是不可再分，因为原子是化学上（参加化学反应）最小单位。也就意味着我们对数据库的一系列操作，要么都成功，要么都失败，不可能出现部分成功的情况。问题是如果前面一个成功了，后面的操作失败了，怎么让它全部失败？这个时候我们必须要回滚。原子性在InnoDB中是通过undo log来实现的，他记录了数据修改之前的值（逻辑日志），一旦发生异常，就可以用undo log来实现回滚操作。</p><p>​    2.隔离性，Isolation，我们有了事务的定义后，在数据库中会有很多的事务同时去操作我们的同一张表或者同一行数据，必然会产生一些并发或者干扰的操作。我们对隔离性的定义，就是这些很多个的事务，对表或者行的并发操作，应该是透明的，互相不干扰的。比如两个人给青山转账100，开启两个事务，都拿到了青山账户的余额1000，然后各自基于1000加100，最后结果是1100，就出现了数据混乱的问题。</p><p>​    3.持久性，Durability，事务的持久性是什么意思？我们对数据库的任意的操作，增删改，是要事务提交成功，那么结果就是永久性的，不可能因为数据库掉电，宕机，意外重启，又能变成原来的状态。这个就是事务的持久性。持久性是通过redo log和double write buffer（双写缓冲）来实现的，我们操作数据的时候，会先写到内存的buffer pool中，同时记录redo log，如果在刷盘之前出现异常，在重启后就可以读取到redo log的内容，写入到磁盘，保证数据的持久性。当然，恢复成功的前提是数据页本身没有损坏，是完整的，这个通过双写缓冲保证。需要注意的是，原子性，隔离性，持久性，最后都是为了实现一致性。</p><p>​    4.一致性，consistent，指的是数据库的完整性约束没有被破坏，事务执行前后都是合法的数据状态。数据库自身提供了一些约束：比如主键必须是唯一的，字段长度符合要求。另外还有用户自定义的完整性，用户自定义的完整性通常要在代码中控制，例如金额不能小于0等。</p><h3 id="1-5数据库什么时候出现事务"><a href="#1-5数据库什么时候出现事务" class="headerlink" title="1.5数据库什么时候出现事务"></a>1.5数据库什么时候出现事务</h3><p>​    当执行一条更新语句，实际上，它不仅自动开启了事务，而且还自动提交了，所以最终写入了磁盘。这个是开启事务的第一种方式，增删改的语句会自动开启事务，当然是一条SQL一个事务。注意每个事务都是有编号的，这个编号是一个整数，有递增的特性。如果把多条SQL放在一个事务中，就要手动开启事务。手动开启事务有两种方式：一种是用begin；一种是用start transaction。结束事务也有两种方式：一种是回滚事务rollback，事务结束；另一种是提交事务commit，事务结束。</p><p>​    InnoDB中有一个autocommit的参数（分为两个级别，session和global级别）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;autocommit&#x27;</span>;<br></code></pre></td></tr></table></figure><p>​    它的默认值是ON。这个参数的意义是是否自动提交。如果它的值是true/ON的话，会自动提交事务。如果设置为false/OFF的话，那么数据库的事务就需要我们手动结束，用rollback或commit。</p><p>​    还有一种情况，客户端的连接断开的时候，事务也会结束。</p><h3 id="1-6事务并发会带来哪些问题？"><a href="#1-6事务并发会带来哪些问题？" class="headerlink" title="1.6事务并发会带来哪些问题？"></a>1.6事务并发会带来哪些问题？</h3><p>​    有两个事务，一个编号2573，另一个是2674。在第一个事务中，它首先通过where id=1的条件查询一条数据，返回name=Ada，age=16的这条数据，然后第二个事务，它通过一个update的语句，把id=1的数据的age改成了18，但是没有提交。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/1.png"></p><p>​    这时，在第一个事务中，它再次执行相同的查询操作，发现数据发生了变化，获取到的数据age变成了18.那么，这种在一个事务中，由于其他的时候修改了数据并且没有提交，而导致了前后两次读取数据不一致的情况，这种事务并发的问题，我们把它定义为<strong>脏读。</strong>如果在转账的案例中，我们第一个事务基于读取到的第二个事务未提交的余额进行了操作，但是第二个事务进行了回滚，这个时候就会导致数据不一致。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/2.png"></p><p>​    同样是两个事务，第一个事务通过id=1查询到了一条数据。然后第二个事务中执行了一个update操作，执行了update以后它通过一个commit提交了修改。然后第一个事务读取到了其他事务已提交的数据导致前后两次读取数据不一致的情况，就像这里，age到底是16还是18，那么这种事务并发带来的问题，把它叫做<strong>不可重复读。</strong></p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/3.png"></p><p>​    在第一个事务中我们执行了一个范围查询，这时满足条件的数据只有一条。在第二个事务中，插入了一行数据，并且提交了。重点：插入了一条数据。在第一个事务再去查询时，它发现多了一行数据。一个事务前后两次读取数据不一致，是由于其他事务插入数据造成的，这种情况叫做<strong>幻读</strong>。</p><p>不可重复读和幻读的区别在哪里？修改或删除造成的读不一致叫做不可重复读，插入造成的读叫做幻读。</p><p>这里有两点需要说明：</p><ol><li><p>一个事务读取到其他事务最新提交的数据，这不是正常的吗？当然是正常的，所以这里讨论的是读一致性。读一致性的意义就是一个事务的select操作跟其他事务没有瓜葛，你不需要修改数据，所以不需要获取最新的数据，这样能够提高并发性能。</p></li><li><p>如果在第一个事务中，select以后，再执行一个update，就能获取到第二个事务的最新数据，这个怎么解释？同样的，这个页脱离了读一致性的讨论范畴。如果要修改数据。必然会读取到最新的数据，也会影响其他的事务。</p></li></ol><p>所以这里要不要修改，要不要读取到最新的数据，是一个区别点。目前我们讨论的都是一个事务中多次重复读取。</p><p>​    小结：无论是脏读，不可重复读，幻读，他们都是数据库的读一致性问题，都是在一个事务中前后两次读取出现了不一致的情况。读一致性的前提，必须要由数据库提供一定的事务隔离机制来解决。就像我们去饭店吃饭，基本的设施和卫生保证都是饭店提供的。那么我们使用的数据库，隔离性的问题页必须由数据库帮助我们解决。</p><h3 id="1-7SQL92标准事务隔离级别定义"><a href="#1-7SQL92标准事务隔离级别定义" class="headerlink" title="1.7SQL92标准事务隔离级别定义"></a>1.7SQL92标准事务隔离级别定义</h3><p>​    美国国家标准协会（ANSI）制定了一个SQL标准，也就是说建议数据库厂商都按照这个标准，提供一定的事务隔离级别，来解决事务并发的问题。这个SQL标准有很多版本，大家最熟悉的是SQL92标准。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/4.png"></p><p>​    这个表格里面定义了四个隔离级别，右边P1 P2 P3计师代表事务并发的3个问题，脏读，不可重复读，幻读。Possible代表在这个隔离级别下，这个问题有可能发生，换句话说就是没有解决这个问题。Not Possiable就是解决了这个问题。</p><p>我们详细的分析这4个隔离级别是怎么定义的。</p><ol><li><p>Read Uncommitted（未提交读），一个事务可以读取到其他事务为提交的数据，会出现脏读，所以叫做RU，没有解决任何问题。</p></li><li><p>Read Commited（已提交读），就是一个事务只能读取到其他事务已提交的数据，不能读取其他事务未提交的数据，解决了脏读的问题，但是会出现不可重复读的问题。</p></li><li><p>Repeatable Read（可重复读），它解决了不可重复读的问题，也就是在同一事务中多次读取的数据结果是一样的，但是没有解决幻读的问题</p></li><li><p>Serializable（串行化），这个隔离级别下，所有的事务都是串行执行的，也就是对数据的操作需要排队，已经不存在事务的并发操作了，所以它解决了所有问题。</p></li></ol><p>事务的隔离级别是可以修改的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level read uncommitted;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level read committed;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level repeatable read;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level serializable;<br></code></pre></td></tr></table></figure><p>​    这个是SQL92的标准，但是不同的数据库厂商或者存储引擎的实现有一定的差异，比如Oracle中就只有两种RC（已提交读）和Serializable（串行化）。</p><h3 id="1-8-InnoDB事务隔离级别的实现"><a href="#1-8-InnoDB事务隔离级别的实现" class="headerlink" title="1.8 InnoDB事务隔离级别的实现"></a>1.8 InnoDB事务隔离级别的实现</h3><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读(Read Uncommitted)</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>已提交读(Read Committed)</td><td><em>不可能</em></td><td>可能</td><td>可能</td></tr><tr><td>可重复读(Repeatable Read)</td><td><em>不可能</em></td><td><em>不可能</em></td><td><em><strong>对InnoDB不可能</strong></em></td></tr><tr><td>串行化(Serializable)</td><td><em>不可能</em></td><td><em>不可能</em></td><td><em>不可能</em></td></tr></tbody></table><p>​    InnoDB支持的4个隔离级别和SQL92定义的完全一致，隔离级别越高，事务的并发度越低。唯一的区别是InnoDB在RR级别就解决了幻读的问题。也就是说不需要使用串行话去解决所有问你题，既保证了数据的一致性，又支持较高的并发度，这个就是InnoDB默认使用RR作为事务隔离级别的原因。</p><h3 id="1-9-读一致性解决方案"><a href="#1-9-读一致性解决方案" class="headerlink" title="1.9 读一致性解决方案"></a>1.9 读一致性解决方案</h3><p>​    如果要解决读一致性的问题，保证一个事务中前后两次读取数据结果一致，实现事务隔离，总体上有以下两大类方案。</p><h4 id="1-9-1-LBCC"><a href="#1-9-1-LBCC" class="headerlink" title="1.9.1 LBCC"></a>1.9.1 LBCC</h4><p>​    既要保证前后两次读取数据一致，那么我读取数据时锁定我要操作的数据，不允许其他的事务修改就行了。这种方案叫做基于锁的并发控制Lock Based Concurrency Control（LBCC）。</p><p>​    如果仅仅是基于锁来实现事务隔离，一个事务读取得时候不允许其他事务修改，那就意味着不支持并发得读写操作，而我们得大多数应用都是读多写少得，这样会极大得影响操作数据得效率。</p><h4 id="1-9-2-MVCC"><a href="#1-9-2-MVCC" class="headerlink" title="1.9.2 MVCC"></a>1.9.2 MVCC</h4><p>​    第二种，如果要让一个事务前后两次读取得数据保持一致，那么我们可以在修改数据之前给它建立一个备份或者快照，后面再来读取这个快照就行了。这种方案我们叫做多版本的并发控制Multi Version Concurrency Control（MVCC）。MVCC的原则：</p><p>一个事务能看到的数据版本：</p><ol><li><p>第一次查询之前已经提交的事务的修改</p></li><li><p>本事务的修改</p></li></ol><p>一个事务不能看见的数据版本：</p><ol><li><p>在本事务第一次查询之后创建的事务（事务ID比本事务ID大）</p></li><li><p>活跃的（未提交的）事务的修改</p></li></ol><p>​    MVCC的效果：我们可以查到在我这个事务之前已经存在数据，即使它在后面被修改删除了，而在我这个事务之后新增的数据，我是查不到的。所以我们才把这个叫做快照，不管别的事务做任何增删改查的操作，它只能看到第一次查询时看到的数据版本。</p><p>​    分析一下MVCC的原理。首先，InnoDB的事务都是由编号的，而且会不断递增。InnoDB为每行记录都实现了两个隐藏字段：</p><p>​    1.DB_TRX_ID，6字节：事务id，数据是在哪个事务插入或者修改为新数据的，就记录为当前事务ID。</p><p>​    2.DB_ROLL_PTR，7字节：回滚指针，我们把它理解为删除版本号，数据被删除或记录为旧数据时，记录当前事务ID，没有修改或者删除的时候是空。</p><table><thead><tr><th>id</th><th>name</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th></tr></thead><tbody><tr><td>1</td><td>aaa</td><td>01</td><td>NULL</td></tr></tbody></table><p>当第一个事务，初始化数据（检查初始数据）</p><table><thead><tr><th>Transaction 1</th></tr></thead><tbody><tr><td>begin; <br />insert into mvcctest values(null, ‘qs’);<br />insert into mvcctest values(null, ‘hh’);<br />commit;</td></tr></tbody></table><p>此时的数据，创建版本是当前事务ID（假设事务编号是1），删除版本为空：</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>qh</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>hh</td><td>1</td><td>undefined</td></tr></tbody></table><p>第二个事务，执行第一次查询，读取到两条原始数据，这时事务ID是2：</p><table><thead><tr><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;<br />select * from mvcctest; –(1)第一次查询</td></tr></tbody></table><p>第三个事务，插入数据：</p><table><thead><tr><th>Transaction 3</th></tr></thead><tbody><tr><td>begin;<br />insert into mvcctest values(NULL, ‘tom’);<br />commit</td></tr></tbody></table><p>此时的数据，多了一条tom，它的创建版本号是当前事务编号，3：</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>qs</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>hh</td><td>1</td><td>undefined</td></tr><tr><td>3</td><td>tom</td><td>3</td><td>undefined</td></tr></tbody></table><p>第二个事务，执行第二次查询：</p><table><thead><tr><th>Transaction 2</th></tr></thead><tbody><tr><td>select * from mvcctest;  –(2)第二次查询</td></tr></tbody></table><p>​    MVCC的查找原则：只能查找创建时间小于等于当前事务ID的数据，和删除时间大于当前事务ID的行（或未删除）。也就是不能查到在我的事务开始之后插入的数据，tom的创建ID大于2，所以还是只能查到两条数据。</p><p>第四个事务，删除数据，删除了id=2 hh这条记录：</p><table><thead><tr><th>Transaction 4</th></tr></thead><tbody><tr><td>begin;<br />delete from mvcctest where id=2;<br />commit;</td></tr></tbody></table><p>此时的数据，hh的删除版本被记录为当前事务ID，4，其他数据不变：</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>qs</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>hh</td><td>1</td><td>4</td></tr><tr><td>3</td><td>tom</td><td>3</td><td>undefined</td></tr></tbody></table><p>在第二个事务中，执行第三次查询：</p><table><thead><tr><th>Transaction 2</th></tr></thead><tbody><tr><td>select * from mvcctest; (3)第三次查询</td></tr></tbody></table><p>​    查找规则：只能查找创建时间小于等于当前事务ID的数据，和删除时间大于当前事务ID的行（或未删除）。也就是，在我事务开始之后删除的数据，所以huihui依然可以查出来。所以还是查出两条数据。</p><p>​    第五个事务，执行更新操作，这个事务ID是5：</p><table><thead><tr><th>Transaction 5</th></tr></thead><tbody><tr><td>begin;<br />update mvcctest ser name = ‘盆玉艳’ where id= 1;<br />commit;</td></tr></tbody></table><p>此时的数据，更新数据时，旧数据的删除版本被记录为当前事务ID5（undo），产生了一条新数据，创建ID为当前事务ID5：</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>qs</td><td>1</td><td>5</td></tr><tr><td>2</td><td>hh</td><td>1</td><td>4</td></tr><tr><td>3</td><td>tom</td><td>3</td><td>undefined</td></tr><tr><td>1</td><td>盆玉艳</td><td>5</td><td>undefined</td></tr></tbody></table><p>第二个事务，执行第四次查询：</p><table><thead><tr><th>Transaction 2</th></tr></thead><tbody><tr><td>select * from mvcctest; (4)第四次查询</td></tr></tbody></table><p>​    查找规则：只能查找创建时间小于等于当前事务ID的数据，和删除时间大于当前事务ID的行（或未删除）。因为更新后的数据盆鱼宴创建版本大于2，代表是在事务之后增加的，查不出来。而旧数据qingshan的删除版本大于2，代表是在事务之后删除的，可以查出来。</p><p>​    通过以上演示可以看到，通过版本号的控制，无论其他事务是插入，修改，删除，第一个事务查询到的数据都没有变化。这个是MVCC的效果，当然，这里是一个简化的模型。假设一条数据修改了3次，两次提交了一次未提交，每次修改之后都有开启一个事务去查询，那么事务2，4，6查到的数据会有不一样。</p><table><thead><tr><th>trx_id</th><th>SQL</th></tr></thead><tbody><tr><td>trx1</td><td>update user_info set name = ‘penyuyan’ where id =1;<br />commit;</td></tr><tr><td>trx2</td><td>select name from user_info where id = 1;</td></tr><tr><td>trx3</td><td>update user_info set name=’wuyanzu’ where id = 1; <br />commit;</td></tr><tr><td>trx4</td><td>select name from user_info where id = 1;</td></tr><tr><td>trx5</td><td>update user_info set name=’liudehua’ where id = 1;  <br />未提交</td></tr><tr><td>trx6</td><td>select name from user_info where id = 1;</td></tr><tr><td></td><td>trx2、4、6再各查一次</td></tr></tbody></table><p>​    InnoDB中，一条数据的旧版本，是存放在undo log中。因为修改了多次，这些undo log回形成一个链条，叫做undo log链，现在undo log中有刘德华，吴彦祖，盆鱼宴。所以前面说的DB_ROLL_PTR，它其实指向undo log链的指针。</p><p>​    第二个问题，事务2，4，6最后再查一次，他们去undo log链找数据时。拿到的数据是不一样的。再这个undo log链里面，一个事务怎么判断哪个版本的数据是它应该读取的？</p><p>回想一下MVCC的规则：</p><p>一个事务能看到的数据版本：1，第一次查询之前已经提交的事务的修改；2，本事务的修改。</p><p>一个事务不能看到的数据版本：1，本事务第一次查询之后创建的事务（事务ID比我的事务ID大）；2，活跃的（未提交的）事务的修改。</p><p>​    所以，必须要有一个数据结构，把本事务ID，活跃事务ID，当前系统最大事务ID存起来，这样才能实现判断。这个数据结构叫Read View（可见性视图），每个事务都维护一个自己的Read View。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/6.png"></p><p><em>m_ids</em>：表示在生成ReadView时当前系统活跃的读写事务的事务id列表。</p><p><em>min_trx_id</em>：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务ID，也就是m_ids中的最小值。</p><p><em>mmax_trx_id</em>：表示生成ReadView时系统中应该分配给下一个事务的id值。</p><p><em>creator_trx_id</em>：表示生成该ReadView的事务的事务id。</p><p>有了这个数据结构后，事务判断可见性的规则是这样的：</p><p>0，从数据的最早版本开始判断（undo log）。</p><p>1，数据版本的trx_id = creator_trx_id，本事务修改，可以访问。</p><p>2，数据版本的trx_id &lt; min_trx_id（未提交事务的最小ID），说明这个版本是生成ReadView已经提交，可以访问。</p><p>3，数据版本的trx_id &gt; max_trx_id（下一个事务ID），这个版本是生成ReadView之后才开启的事务建立的，不能访问。</p><p>4，数据版本的trx_id在min_trx_id和max_trx_id之间，看看是否在m_ids中。如果在，不可以。如果不在，可以。</p><p>5，如果当前版本不可见，就找undo log链中的下一个版本。</p><p>​    注意：RR中ReadView是事务第一次查询时建立的。RC的ReadView是事务每次查询的时候建立的。Oracle，Postgres等等其他数据库都有MVCC实现。需要注意，在InnoDB中，MVCC和锁是协同使用的，这两种方式并不是互斥的。</p><h2 id="2-InnoDB锁的基本类型"><a href="#2-InnoDB锁的基本类型" class="headerlink" title="2 InnoDB锁的基本类型"></a>2 InnoDB锁的基本类型</h2><h3 id="2-1-锁的粒度"><a href="#2-1-锁的粒度" class="headerlink" title="2.1 锁的粒度"></a>2.1 锁的粒度</h3><p>​    InnoDB和MyISAM支持的锁的类型是不同的。InnoDB同时支持表锁和行锁，MySIAM只支持表锁，用lock table的语法加锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">lock talbes xxx read;<br>lock tables xxx write;<br>unlock tables;<br></code></pre></td></tr></table></figure><h3 id="2-2-锁的类型"><a href="#2-2-锁的类型" class="headerlink" title="2.2 锁的类型"></a>2.2 锁的类型</h3><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html</a></p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/7.png"></p><p>​    官网把锁分成了8类。把前面的两个行级别锁（Shared and Exclusive Locks），和两个表级别的锁（Intention Locks）称为锁的基本模式。后面三个Record Locks，Gap Locks，Next-Key Locks，我们把它们叫做锁的算法。</p><p>​    插入意向锁（Insert Intention Locks）：是一个特殊的间隙锁。间隙锁不允许插入数据，但是插入意向锁允许多个事务同时插入数据到同一个范围，比如（4，7），一个事务插入5，一个事务插入6，不会发生锁等待。</p><p>​    自增锁（AUTO-INC Locks）：是一种特殊的表锁，用来防止自增字段重复，数据插入以后就会释放，不需要等到事务提交才释放。如果需要选择更快的子增值生成速度或者更加连续的子增值，就要通过修改自增锁的模式改变。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_autoinc_lock_mode&#x27;</span><br></code></pre></td></tr></table></figure><p>​    0：traditional（每次都会产生表锁）</p><p>​    1：consecutive（会产生一个轻量锁，simple insert会获得批量的锁，保证连续插入，默认值）</p><p>​    2：interleaved（不会锁表，来一个处理一个，并发最高）</p><p>​    Predicate Locks for Spatial Indexes是5.7版本中新增的一种数据类型的索引的锁。</p><h3 id="2-3-共享锁"><a href="#2-3-共享锁" class="headerlink" title="2.3 共享锁"></a>2.3 共享锁</h3><p>​    第一个行级别的锁就是Shared Locks（共享锁），获取了一行数据的读锁以后，可以用来读取数据，所以也叫做读锁，注意不要在加上了读锁以后去写数据，不然的话可能会出现死锁的情况。而且多个事务可以共享一把读锁。共享锁的作用：因为共享锁会阻塞其他事务的修改，所以可以用在不允许其他事务修改数据的情况（共享锁和写锁互斥的例子后面再看）。我们可以用select …… lock in share mode；的方式手工加上一把读锁。释放锁有两种方式，只要事务结束就会自动释放锁，包括提交事务和结束事务</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from student where id =1 lock in share mode;</td><td></td></tr><tr><td></td><td>begin;</td></tr><tr><td></td><td>select * from student where id = 1 lock in share mode;  <br />//OK</td></tr></tbody></table><h3 id="2-4-排他锁"><a href="#2-4-排他锁" class="headerlink" title="2.4 排他锁"></a>2.4 排他锁</h3><p>​    第二个行级别的锁叫做Exclusive Locks（排他锁），它是用来操作数据的，所以又叫做写锁。只要一个事务获取了一行数据的排他锁，其他事务就不能再获取这一行数据的共享锁和排他锁。加锁的方式有两种，第一种是自动加排他锁，增删改都会默认加上一个排他锁。还有一种是手工加锁，我们用一个FOR UPDATE给一行数据加上一个排他锁，这个无论是在我们的代码中还是操作数据的工具中都比较常用。释放锁和前面是一样的。</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>update student set sname=’fdasfd’ where id = 1;</td><td></td></tr><tr><td></td><td>begin;</td></tr><tr><td></td><td>select * from student where id=1 lock in share mode;  //blocked <br />select * from student where id=1 for update; //blocked   <br />delete from student where id=1 //blocked</td></tr></tbody></table><h3 id="2-5-意向锁"><a href="#2-5-意向锁" class="headerlink" title="2.5 意向锁"></a>2.5 意向锁</h3><p>​    意向锁是由数据库自己维护的。也就是说，当我们给一行数据加上共享锁之前，数据库会自动在这张表上面加上意向共享锁。当我们给一行数据加上排他锁之前，数据库会自动在这张表上面加上一个意向排他锁。反过来，如果一张表上至少有一个意向共享锁，说明其他事务给其中的某些数据加上了共享锁；如果表上至少有一个意向排他锁，说明其他事务给其中的某些数据行加上了排他锁。</p><p>​    意向锁和意向锁是不冲突的，意向锁和行锁也不冲突。那么这两个表级别的锁有什么意义？如果没有意向锁的话，当我们准备给一张表加上表锁时，我们首先需要去判断有没有其他事务锁定了某些行，如果有的话，肯定不能加上表锁。那么这时我们就要去扫描整张表才能确定能不能成功加上一个表锁，如果数据量很大，那么加表锁的效率就非常低。但是我们引入意向锁后就不一样了，我们只要判断这张表上是否有意向锁，如果有直接返回失败。如果没有就可以加锁成功。所以InnoDB中的表锁，我们可以把它理解为一个标志（就像火车上卫生间有没有使用的灯），是用来提高加锁效率的。</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from student where id=1 for update;</td><td></td></tr><tr><td></td><td>beginl</td></tr><tr><td></td><td>lock tables student write; //blocked <br />unlock tables; //释放表锁的方式</td></tr></tbody></table><p>​    数据库锁跟java中的锁是一样的，是为了解决资源竞争的问题，java中的资源是对象，数据库的资源是数据表或者数据行。所以锁是用来解决事务对数据的并发访问问题的。</p><h2 id="3-行锁的原理"><a href="#3-行锁的原理" class="headerlink" title="3 行锁的原理"></a>3 行锁的原理</h2><p>​    有三张表，一张没有索引的t1，一张有主键索引的t2，一张有唯一索引的t3</p><p><strong>1.没有索引的表（假设锁住记录）</strong></p><p>​    假设InnoDB的行锁是锁住了一行数据或者一条记录。先看一下t1的表结构，它有两个字段，int类型的id和varchar类型的name。里面有4条数据1，2，3，4。</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from t1 where id = 1 for update;</td><td></td></tr><tr><td></td><td>select * from t1 where id=3 for update;  //blocked</td></tr><tr><td></td><td>insert into ‘t1’(‘id’,’name’) values(5, ‘5’);  //blocked</td></tr></tbody></table><p>​    在两个会话中手工开启两个事务。第一个事务中我们通过where id = 1锁住第一行数据。第二个事务中，我们尝试给id=3的这一行数据加锁，被阻塞。插入一条id=5的数据，被阻塞。结果第二个事务的加锁操作被阻塞了，说明<strong>InnoDB的行锁锁住的不是Record</strong>。那为啥在没有索引或者没有用到索引的情况下，会锁住整张表？这个问题后续解释。</p><p><strong>2.有主键索引的表</strong></p><p>​    t2的表结构。字段是一样的，不同的地方是id上创建了一个主键索引。里面的数据是1，4，7，10.</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from t2 where id = 1 for update;</td><td></td></tr><tr><td></td><td>select * from t2 where id=1 for update;  //blocked</td></tr><tr><td></td><td>select * from t2 where id=4 for update  //OK</td></tr></tbody></table><p>第一种情况，使用相同的id值去加锁，冲突；使用不同的id加锁，加锁成功。</p><p><strong>3.唯一索引（假设锁住字段）</strong></p><p>t3的表结构。字段还是一样的，id上创建了一个主键索引，name上创建了一个唯一索引。里面数据1，4，7，10.</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from t3 where name=’4’ for update;</td><td></td></tr><tr><td></td><td>select * from t3 where name=’4’ for update;  //blocked</td></tr><tr><td></td><td>select * from t3 where id=4 for update  //blocked</td></tr></tbody></table><p>​    第一个事务中我们通过name字段去锁定值是4的数据。第二个事务中尝试获取一样的排他锁，失败。然后用id=4去给这行数据加锁，被阻塞，说明行锁锁住字段的推测也是错的。</p><p>​    既然锁住的不是record，也不是column，InnoDB的行锁到底锁住了什么？在这三个案例中，他们的差异就在于表结构，其实答案就是索引，InnoDB的行锁是**通过锁住索引实现的。还有两个问题没有解决：</p><p>​    1.为什么表中没有索引的时候，锁住一行数据会导致锁表？因为查询没有使用索引，会进行全表扫描，然后把每一个隐藏的聚集索引都锁住了。</p><p>​    2.为什么通过唯一索引给数据行加锁，主键索引也会被锁住？因为我们通过辅助索引锁定一行数据时，它跟我们检索数据的步骤是一样的，会通过主键值找到主键索引，然后也锁定。本质上是因为锁定的是同一行数据，是相互冲突的。</p><h2 id="4-行锁的算法"><a href="#4-行锁的算法" class="headerlink" title="4  行锁的算法"></a>4  行锁的算法</h2><p>​    我们先看一下测试用表t2，其中有个主键，插入4行数据，主键id分别是1，4，7，10.</p><p>​    首先，先普及一下三种范围的概念。因为我们用主键索引加锁，我们这里划分标准就是主键索引的值。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/9.png"></p><p>​    这些数据库中存在的主键值，我们把它叫做Record，记录，那么我们这里就有4个Record。根据主键，这些存在的Record隔开的数据不存在的区间，我们叫做Gap，间隙，它是一个左开右开的区间。假如我们有N个Record，那么我们就有N+1个Gap。最后一个，间隙（Gap）连同它左边的记录（Record），我们把它叫做临键的区间，它是左开右臂=闭得区间。整型的主键索引，它是可以排序的，所以才有这种区间，如果我的主键索引不是整型，是字符怎么办？任何一个字符集，都有相应得排序规则：</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/10.png"></p><h3 id="4-1-记录锁-Record-Locks"><a href="#4-1-记录锁-Record-Locks" class="headerlink" title="4.1 记录锁(Record Locks)"></a>4.1 记录锁(Record Locks)</h3><p>​    当对于唯一性的索引（包括唯一索引和主键索引）使用等值查询，精准匹配到一条记录的时候，这时使用的就是记录锁。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/11.png"></p><p>​    使用不同的key去加锁，不会冲突，它只锁住这个record。图片上红的字就是使用这种锁的条件。</p><h3 id="4-2-间隙锁-Gap-Locks"><a href="#4-2-间隙锁-Gap-Locks" class="headerlink" title="4.2 间隙锁(Gap Locks)"></a>4.2 间隙锁(Gap Locks)</h3><p>​    当查询的记录不存在，没有命中任何一个record，无论是用等值查询还是范围查询时，它使用的都是间隙锁。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/12.png"></p><p>​    举个例子，where id &gt; 4 and id &lt; 7, where id = 6。</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from t2 where id=6 for update;</td><td></td></tr><tr><td></td><td>insert into ‘t2’(‘id’,’name’) values(5,’6’); //blocked<br />insert into ‘t2’(‘id’,’name’) values(6,’6’); //blocked <br />select * from t2 where id=6 for update; //OK</td></tr><tr><td>select * from t2 where id &gt; 20 for update;</td><td></td></tr><tr><td></td><td>insert into ‘t2’(‘id’,’name’) values(11,’6’); //blocked</td></tr></tbody></table><p>当查询不存在时使用间隙锁。注意，间隙锁主要是阻塞插入insert，相同的间隙锁之间不冲突。</p><h3 id="4-3-临键锁-Next-Key-Locks"><a href="#4-3-临键锁-Next-Key-Locks" class="headerlink" title="4.3 临键锁(Next-Key Locks)"></a>4.3 临键锁(Next-Key Locks)</h3><p>​    当我使用了范围查询，不仅仅命中了Record记录，还包含了Gap间隙，在这种情况下我们使用的就是临键锁，它是Mysql中默认的行锁算法，相当于记录锁加上间隙锁。唯一性索引，等值查询匹配到一条记录时退化为记录锁。没有匹配到记录时退化成间隙锁。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/13.png"></p><p>​    比如使用&gt;5，&lt;9，它包含了记录不存在的区间，也包含了一个Record 7.</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select from t2 where id&gt;5 and id&lt;9 for update</td><td></td></tr><tr><td></td><td>begin;</td></tr><tr><td></td><td>select * from t2 where id=4 for update;  //OK<br />insert into ‘t2’(‘id’,’name’) values(6, ‘6’); //blocked <br />insert into ‘t2’(‘id’,’name’) values(8, ‘6’); //blocked <br />select * from t2 where id=10 for update; //blocked</td></tr></tbody></table><p>​    临键锁，锁住最后一个key的下一个左开右闭区间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t2 <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">7</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>; <span class="hljs-comment">--锁住(4,7] 和(7,10]</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t2 <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">8</span> <span class="hljs-keyword">and</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>; <span class="hljs-comment">--锁住(7,10] 和(10,正无穷)</span><br></code></pre></td></tr></table></figure><p>为什么要锁住下一个左开右闭区间？就是为了解决幻读的问题。</p><h3 id="4-4-InnoDB事务隔离级别的实现"><a href="#4-4-InnoDB事务隔离级别的实现" class="headerlink" title="4.4 InnoDB事务隔离级别的实现"></a>4.4 InnoDB事务隔离级别的实现</h3><p>​    所以，InnoDB的RR级别能够解决幻读的问题，就是用临键锁实现的。</p><p>​    最后总结一下四个事务隔离级别的实现：</p><p>​    1.Read Uncommited：RU隔离级别，不加锁</p><p>​    2.Serializable：所有的select语句都会被隐式的转化为select ……in share mode，会和update，delete互斥。</p><p>​    3.Repeatable Read：RR隔离级别下，普通的select使用快照读（snapshot），底层使用MVCC来实现。加锁的select（select … in share mode/select …for update）以及更新操作update，delete等语句使用当前读（current read），底层使用记录锁，或者间隙锁或者临键锁。</p><p>​    4.Read Commited：RC隔离级别下，普通的select都是快照读（MVCC）。加锁的select都使用记录锁，因为没有Gap Lock。除了两种特殊情况——外键约束检查（foreign-key constraint checking）以及重复键检查（duplicate-key checking）时会使用间隙锁封锁区间，所以RC会出现幻读问题。</p><h2 id="5-事务隔离级别的选择"><a href="#5-事务隔离级别的选择" class="headerlink" title="5 事务隔离级别的选择"></a>5 事务隔离级别的选择</h2><p>​    RU和Serializable肯定不能使用。为什么有些公司要用RC？</p><p>​    RC和RR主要有几个区别：</p><p>​    1.RR的间隙锁会导致锁定范围的扩大。</p><p>​    2.条件列未使用到索引，RR锁表，RC锁行</p><p>​    3.RC的“半一致性”（semi-consistent）读可以增加update操作的并发性。</p><p>​    在RC中，一个update语句，如果督导一行已经加锁的记录，此时InnoDB返回记录最近提交的版本，由MySQL上层判断此版本是否满足update的where条件。若满足（需要更新），则MuSQLhi重新发起一次读操作，此时会读取行的最新版本（并加锁）。</p><p>​    实际上，如果能够正确的使用锁（避免不使用索引去加锁），只锁定需要的数据，用默认的RR级别就可以了。在我们使用锁的时候，有个问题时需要注意和避免的，我们知道，排他锁由互斥的特性。一个事务或者说一个线程持有锁时，会阻止其他的线程获取锁，这时会造成阻塞等待，如果训话等待，会有可能造成死锁。</p><h2 id="6-死锁"><a href="#6-死锁" class="headerlink" title="6 死锁"></a>6 死锁</h2><h3 id="6-1-锁的释放与阻塞"><a href="#6-1-锁的释放与阻塞" class="headerlink" title="6.1 锁的释放与阻塞"></a>6.1 锁的释放与阻塞</h3><p>​    锁是在事务结束（commit，rollback）或者客户端断开连接的时候释放。控制锁的等待时间，默认是50秒</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_lock_wait_timeout&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="6-2-死锁的发生与检测"><a href="#6-2-死锁的发生与检测" class="headerlink" title="6.2 死锁的发生与检测"></a>6.2 死锁的发生与检测</h3><p>​    在发生死锁时，InnoDB一般通过算法（wait-for graph）自动检测到。 死锁产生的条件：</p><p>​    （1）同一时刻只能有一个事务持有这把锁</p><p>​    （2）其他事务需要在这个事务释放锁之后才能获取锁，而不可以强行剥夺</p><p>​    （3）当多个事务形成等待环路的时候，即发生死锁。</p><p>​    实际上，发生死锁的原因很多，但是都满足以上3个条件这个也是表锁是不会发生死锁的原因，因为表锁的资源都是一次性获取的。</p><h3 id="6-3-查看锁信息（日志）"><a href="#6-3-查看锁信息（日志）" class="headerlink" title="6.3 查看锁信息（日志）"></a>6.3 查看锁信息（日志）</h3><p>首先，SHOW STATUS命令中，包括了一些行锁的信息。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/15.png"></p><p>Show命令是一个概要信息。InnoDB还提供了三张表来分析事务与锁的情况：</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/16.png"></p><p>更加详细的锁信息，开启标准监控和锁监控：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> innodb_status_output<span class="hljs-operator">=</span><span class="hljs-keyword">ON</span>;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> innodb_status_output_locks<span class="hljs-operator">=</span><span class="hljs-keyword">ON</span>;<br></code></pre></td></tr></table></figure><p>​    如果一个事务长时间持有锁不释放，可以kill事务对应的线程ID，也就是INNODB_TRX表中的trx_mysql_thread_id。当然，死锁的问题不能每次都靠kill解决，我们应该尽量在编码的过程中避免。</p><h3 id="6-4-死锁的避免"><a href="#6-4-死锁的避免" class="headerlink" title="6.4 死锁的避免"></a>6.4 死锁的避免</h3><p>​    （1）在程序中，操作多张表时，尽量以相同的顺序来访问（避免形成等待环路）</p><p>​    （2）批量操作单张表数据时，先对数据进行排序（避免形成等待环路）</p><p>​    （3）申请足够级别的锁，如果要操作数据，就申请排他锁</p><p>​    （4）尽量使用索引访问数据，避免没有where条件的操作，避免锁表</p><p>​    （5）如果可以，大事务化成小事务</p><p>​    （6）使用等值查询而不是范围查询查询数据，命中记录，避免间隙锁对并发的影响。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引</title>
    <link href="/2023/02/16/mysql/MySQL%E7%B4%A2%E5%BC%95/"/>
    <url>/2023/02/16/mysql/MySQL%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-索引含义"><a href="#1-索引含义" class="headerlink" title="1.索引含义"></a>1.索引含义</h2><h3 id="1-1-索引图解"><a href="#1-1-索引图解" class="headerlink" title="1.1 索引图解"></a>1.1 索引图解</h3><p>​    数据库索引是数据库管理系统（DBMS）中一个排序的数据结构，以协助快速查询，更新数据库表中数据。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/1.png"></p><p>​    数据是以文件的形式存放在磁盘上面的，每一行数据都有它的磁盘地址。如果没有索引的话，我们要从500万行数据里面检索一条数据，只能一次遍历这张表的全部数据，直到找到这条数据。但是有了索引后，只需要在索引中去检索这条数据就行了，因为它是一种特殊的专门用来快速检索的数据结构，我们找到数据存放的磁盘地址，就可以拿到数据了。</p><h3 id="1-2-索引类型"><a href="#1-2-索引类型" class="headerlink" title="1.2 索引类型"></a>1.2 索引类型</h3><p>​    打开navicat工具，右键设计表，在索引的这个选项卡里面，可以创建索引。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/2.png"></p><p>​    在InnoDB中，索引类型有三种：普通索引，唯一索引（主键索引是特殊的唯一索引），全文索引。</p><p>​    <em>普通（Normal）</em>：也叫非唯一索引，是最普通的索引，没有任何限制。</p><p>​    <em>唯一（Unique）</em>：唯一索引要求键值不能重复，另外注意的是，主键索引是一种特殊的唯一索引，它还多了一个限制条件是键值不能为空。主键索引引用primary key创建。</p><p>​    <em>全文（Fulltext）</em>：针对比较大的数据，比如我们存放的是消息内容，一篇文章，有几KB的数据的这种情况，如果要解决like查询在全文匹配时效率低的问题，可以创建全文索引。只有文本类型的字段才可以创建全文索引，比如char，varchar，text。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;fulltext_test&#x27;</span> (<br><span class="hljs-string">&#x27;content&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>    FULLTEXT KEY <span class="hljs-string">&#x27;content&#x27;</span>(<span class="hljs-string">&#x27;content&#x27;</span>)<br>)<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> fulltext_test <span class="hljs-keyword">where</span> <span class="hljs-keyword">match</span>(content) against(<span class="hljs-string">&#x27;咕泡学院&#x27;</span><span class="hljs-keyword">IN</span> <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">LANGUAGE</span> MODE)<br></code></pre></td></tr></table></figure><p>​    MyISAM和InnoDB支持全文索引。</p><h2 id="2-索引存储模型推演"><a href="#2-索引存储模型推演" class="headerlink" title="2. 索引存储模型推演"></a>2. 索引存储模型推演</h2><h3 id="2-1-二分查找（折半查找）"><a href="#2-1-二分查找（折半查找）" class="headerlink" title="2.1 二分查找（折半查找）"></a>2.1 二分查找（折半查找）</h3><p>​    每一次查找，都把候选数据缩小了一半，如果数据排过序的话，这种效率更高。所以第一个，我们可以考虑用有序数组作为索引的数据结构。有序数组的等值查询和比较查询效率非常高，但是更新数据时会出现一个问题，可能要挪动大量的数据（改变index），所以只适合存储静态的数据。为了支持频繁的修改，我们需要采用链表。链表的话，如果是单链表，它的查找效率还是不够高。所以为了解决这个问题出现二叉查找树BST（Binary Search Tree）出现了。</p><h3 id="2-2-二叉查找树"><a href="#2-2-二叉查找树" class="headerlink" title="2.2 二叉查找树"></a>2.2 二叉查找树</h3><p>​    二叉查找树的特点：左子树节点都小于父节点，右子树节点都大于父节点。投影到平面就是一个有序的线性表。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/3.png"></p><p>​    二叉查找树既能够实现快速查找，又能实现快速插入，但是它有个问题：它的查找耗时是和这棵树的深度相关的，在最坏的情况下时间复杂度会退化成O(n)。还是刚才这一批数字，如果插入的数据刚好是有序的，它就会变成链表（斜树），这种情况下不能达到加快检索速度的目的，和顺序查找效率是没有区别的。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/4.png"></p><h3 id="2-3-平衡二叉树-AVL-Tree-左旋右旋"><a href="#2-3-平衡二叉树-AVL-Tree-左旋右旋" class="headerlink" title="2.3 平衡二叉树(AVL Tree)(左旋右旋)"></a>2.3 平衡二叉树(AVL Tree)(左旋右旋)</h3><p>​    平衡二叉树解决了二叉树平衡的问题。索引必须要存你建立的字段的值，叫做键值，比如id的值。还要存完整记录在磁盘上的地址。由于AVL是二叉树，所以还要额外的存储左右子树的指针。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/5.png"></p><p>如图：</p><p>第一个是索引的键值，比如我们在id上面创建了一个索引，我在用where id = 1的条件查询时就会找到索引里面的id的这个键值。</p><p>第二个是数据的磁盘地址，因为索引的作用就是去查找数据存放的地址。</p><p>第三个，因为是二叉树，它必须还要有左右子节点的引用，这样我们能才能找到下个子节点。</p><p>​    当用树的结构了存储索引时，访问一个节点就要和磁盘间发生一次io操作。InnoDB操作磁盘的最小单位是一页（或者叫一个数据块，大小是16K）。那么，一个树的结点必须设计成16K的大小，不然就会出现读不完或者读不够的情况。如果一个节点只存一个键值+数据+引用，可能只用了十几个或者几十个字节，远远达不到16K的容量。我们基于索引查找数据时，肯定是希望一次从磁盘中加载很多的数据到内存中，如果一个节点只存1个这样的单元，就需要读更多的节点，发生更多的IO。</p><p>怎么解决这个问题？第一，  让每个节点存储更多的数据。第二，  节点上的关键字的数量越多，我们的指针数也越多，也就是有更多的分叉（路数），因为分叉越多，树的深度就会减少（根节点是0）。这样树的样子就从高瘦变成矮胖了。这时，时就变成多叉（多路）。</p><h3 id="2-4-多路平衡查找树-B-Tree-分裂合并"><a href="#2-4-多路平衡查找树-B-Tree-分裂合并" class="headerlink" title="2.4 多路平衡查找树(B Tree)(分裂合并)"></a>2.4 多路平衡查找树(B Tree)(分裂合并)</h3><p>​    Balance Tree，跟AVL树一样，B树在节点上存储键值，数据地址，节点引用。它有一个特点：分叉数（路数）永远比关键字数多1，比如下面这棵树，每个节点存储两个关键字，那么就会有三个指针指向三个子节点。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/6.png"></p><p>B Tree的查找规则是什么样的？</p><p>比如要找15：因为15&lt;17，走左边；15&gt;12，走右边，在磁盘7里找到了15，只用了3次IO。</p><p>B Tree是怎样保持平衡的，和AVL有什么区别？</p><p>当路数为3时，我们插入3的时候，本来应该在第一个磁盘块，但是如果一个节点有三个关键字，意味着有4个指针，子节点就会变成4格，所以这个时候就需要分裂。把中间数据2提上去，把1和3变成2的子节点。如果删除节点，会有相反的合并的操作（注意这里的合并和分裂跟AVL中的左右旋是不一样的）。从这里可以看到，在更新索引时会有大量的索引结构的调整，所以解释我们不要在频繁更新的列上加索引，或者不要更新主键。</p><p>节点的分裂和合并，其实就是InnoDB页的分裂和合并。如果索引键值有序，写满一页接着开辟一个新的页，如果索引值无序，存储过程中造成大量的磁盘碎片，带来频繁的page分裂和合并。</p><h3 id="2-5-B-树-加强版多平衡查找树"><a href="#2-5-B-树-加强版多平衡查找树" class="headerlink" title="2.5 B+树(加强版多平衡查找树)"></a>2.5 B+树(加强版多平衡查找树)</h3><p>B+树的存储结构。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/7.png"></p><p>B+树的特点：</p><p>1.它的关键字的数量和路数时相等的</p><p>2.B+树的根节点和枝节点都不会存储数据，只有叶子节点才存储数据，搜索到关键字不会直接返回，会到最后一层的叶子节点才会返回数据。</p><p>3.B+树的每个叶子节点增加了一个指向相邻叶子节点的指针，它的最后一个数据会指向下一个叶子节点的第一个数据，形成了一个有序链表，方便范围查询。</p><p>总结一下，InnoDB的B+tree特性带来的优势：</p><ol><li><p>它是B Tree的变种，B Tree能解决的问题，它都能解决（每个节点存储更多的关键字；路数更多），</p></li><li><p>扫库，扫表能力强（如果我们要对全表进行扫描，只需要遍历叶子节点就可以了，不需要便利整课B+树拿数据）。</p></li><li><p>B+树的磁盘读写能力比B树更强（根节点不保存数据，所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多）。</p></li><li><p>排序能力更强（因为叶子节点有下一个数据区的指针，数据形成了链表）</p></li><li><p>效率更加稳定（B+tree永远只在叶子节点拿数据，所以IO次数时稳定的）。</p></li></ol><h3 id="2-6-为什么不用红黑树？"><a href="#2-6-为什么不用红黑树？" class="headerlink" title="2.6 为什么不用红黑树？"></a>2.6 为什么不用红黑树？</h3><p>红黑树也是BST树，但是不是严格平衡的，通过变色和旋转来保持平衡，必须满足5个约束：</p><ol><li><p>节点为红色或者黑色</p></li><li><p>根节点必须是黑色的</p></li><li><p>叶子节点都是黑色的null节点</p></li><li><p>红色节点的两个子节点都是黑色（不允许两个相邻的红色节点）。</p></li><li><p>从任意节点出发，到每个叶子节点的路径中包含相同数量的黑色节点。</p></li></ol><p>基于以上节点，可以推导出：从根节点到叶子节点的最长路径（红黑相同的路径）不大于最短路径（全部是黑色节点）的2倍。</p><p>为什么不用红黑树？1，只有两路。2，不够平衡。红黑树一般在内存里运用。</p><h3 id="2-7-Hash索引"><a href="#2-7-Hash索引" class="headerlink" title="2.7 Hash索引"></a>2.7 Hash索引</h3><p>HASH：以KV的形式检索数据，也就是说，它会根据字段生成哈希码和指针，指针指向数据。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/8.png"></p><p>Hash索引的特点：</p><ol><li><p>它的时间复杂度是O(1)，查询速度比较快。因为哈希索引里面的数据不是按顺序存放的，所以不能用于排序。</p></li><li><p>我们在查询数据时要根据键值计算哈希码，所以它只能支持等值查询，不支持范围查询。</p></li><li><p>如果字段重复值很多的时候，会出现大量的哈希冲突（采用拉链法解决）效率会降低。</p></li></ol><p>​    在InnoDB中，不能显示的创建一个哈希索引（所谓的支持哈希索引指的是AHI,自适应哈希，它是InnoDB自动为buffer pool中的热点页创建的索引）。Memory存储引擎中可以使用Hash索引。</p><h2 id="3-B-Tree的落地形式"><a href="#3-B-Tree的落地形式" class="headerlink" title="3  B+Tree的落地形式"></a>3  B+Tree的落地形式</h2><p>​    MySQL的数据都是文件形式存放在磁盘的，可以找到这个目录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;datadir&#x27;</span>;<br></code></pre></td></tr></table></figure><p>​    每个数据库都有一个目录，主要关注一下最长用的两个存储引擎，MyISAM和InnoDB的索引的实现。InnoDB的表有两个文件（.frm和.ibd），MyISAM的表有三个文件（.frm，.MYD, .MYI）。其中.frm是Mysql数据库中定义表结构的文件，每一种存储引擎都有。</p><h3 id="3-1-MyISAM"><a href="#3-1-MyISAM" class="headerlink" title="3.1 MyISAM"></a>3.1 MyISAM</h3><p>在MyISAM中有另外两个文件，数据和索引是两个独立的文件：</p><p>​    1.MYD文件，D代表数据，是一个数据文件。</p><p>​    2.MYI文件，I代表index，是索引文件，存放索引</p><p>​    MyISAM的B+Tree中，叶子节点存储的是数据文件对应的磁盘地址。从索引文件中找到键值后，会到数据文件中获取相应的数据记录。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/9.png"></p><p>​    在MyISAM中，其他索引也在MYI文件中，非主键索引跟主键索引存储和检索数据的方式是没有任何区别的，一样是在索引文件中找到磁盘地址，然后到数据文件中获取数据。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/10.png"></p><h3 id="3-2-InnoDB"><a href="#3-2-InnoDB" class="headerlink" title="3.2 InnoDB"></a>3.2 InnoDB</h3><p>​    在InnoDB的某个索引的叶子节点上，直接存储了我们的数据。所以，为什么说在InnoDB中索引即数据，数据即索引，就是这个原因。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/11.png"></p><p>​    但是有一个问题，一张InnoDB表可能有很多索引，数据肯定只有一份，那数据是在哪个索引的叶子节点上呢？</p><p>​    这里要介绍一个叫做聚集索引（聚簇索引）的概念，就是索引键值的逻辑顺序和表数据行的物理存储顺序是一致的。</p><p>​    InnoDB组织数据的方式就是（聚集）索引组织表（clustered index organize table）。如果说一张表创建了主键索引，那么这个主键索引就是聚集索引，决定数据行的物理存储顺序。</p><p>​    问题来了，那聚集索引之外的索引，会不会也把完整记录在叶子节点放一份呢？并不会，因为这回带来额外的存储空间浪费和计算损耗。那他们的叶子节点上没有数据怎么检索完整的数据呢？比如我们在name字段上建立的普通索引。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/12.png"></p><p>​    InnoDB中，主键索引和辅助索引是由一个主次之分的，如果有主键索引，那么主键索引就是聚集索引，其他的索引统称为“二级索引”（secondary index）。二级索引存储的是二级索引的键值，而叶子节点存的是这条记录对应的主键的值，所以，二级索引检索数据的流程是这样的：</p><p>​    当我们用name索引查询一条记录，它会在二级索引的叶子节点找到name=qingshan，拿到主键值，也就是id=1，然后再到主键索引的叶子节点拿到数据。</p><p>​    为什么不存地址而是存键值？因为地址会变化。从这个角度来说，因为主键索引比二级索引少扫描了一棵B+Tree（避免了回表），所以它的速度相对快一些。</p><p>​    但是，如果一张表没有主键怎么办？那完整的记录放在哪个索引的叶子节点？或者这张表根本没有索引呢？数据放在哪里？</p><p>​    1.如果我们定义了主键（primary key），那么InnoDB会选择主键作为聚集索引。</p><p>​    2.如果没有显示定义主键，则InnoDB会选择第一个不包含有null值得唯一索引作为主键索引。</p><p>​    3.如果也没有这样得一个唯一索引，InnoDB会选择内置6字节长得ROWID作为隐藏得聚集索引，它会随着行记录得写入而主键递增。</p><h2 id="4-索引使用原则"><a href="#4-索引使用原则" class="headerlink" title="4 索引使用原则"></a>4 索引使用原则</h2><h3 id="4-1-列的离散度"><a href="#4-1-列的离散度" class="headerlink" title="4.1 列的离散度"></a>4.1 列的离散度</h3><p>​    列的离散度，定义公式：count(distinct(column_name)):count(*)，列的全部不同值和所有数据行的比例，数据行相同的情况下，分子越大，列的离散度越高。简单来说，如果列的重复值越多，离散度度劫越低，重复值越多，离散度就越高。我们不建议在离散度低的字段上，如果B+Tree中的重复值太多，MySQL的优化器发现走索引跟使用全表扫描差不多，就算建立了索引，也不一定会走索引。</p><h3 id="4-2-联合索引最左匹配原则"><a href="#4-2-联合索引最左匹配原则" class="headerlink" title="4.2 联合索引最左匹配原则"></a>4.2 联合索引最左匹配原则</h3><p>​    前面都是针对单列创建的索引，但有时我们的多条件查询的时候，也会建立联合索引。单列索引也可以看作是特殊的联合索引。如果我们创建三个字段的联合索引index(a, b, c)，相当于创建了三个索引：index(a), index(a, b), index(a, b, c)；</p><h3 id="4-3-覆盖索引"><a href="#4-3-覆盖索引" class="headerlink" title="4.3 覆盖索引"></a>4.3 覆盖索引</h3><p>​    回表：非主键索引，我们先通过索引找到主键索引的键值，再通过主键值查出索引中没有的数据，它比基于主键索引的查询多扫描了一棵索引树，这个过程就叫回表。在二级索引中，不管单列索引还是联合索引，如果select的数据列只用从索引中就能取得，不必从数据区中读取，这时使用的索引叫做覆盖索引，这样避免了回表。很明显，因为覆盖索引减少了IO次数，减少了数据的访问量，可以大大提高查询效率。</p><h3 id="4-4-索引条件下推（ICP）"><a href="#4-4-索引条件下推（ICP）" class="headerlink" title="4.4 索引条件下推（ICP）"></a>4.4 索引条件下推（ICP）</h3><p>​    索引条件下推（index condition pushdown），5.6后完善的功能。只适用于二级索引。ICP的目标是减少访问表的完整行的读数量从而减少IO操作。这里说的下推，其实意思是把过滤的动作在存储引擎做完，而不需要到Server层过滤。来看这么一张表。在last_name和first_name上面创建联合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> employees;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;employees&#x27;</span> (<br><span class="hljs-string">&#x27;emp_no&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-string">&#x27;birth_date&#x27;</span> <span class="hljs-type">date</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-string">&#x27;first_name&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">14</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-string">&#x27;last_name&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-string">&#x27;gender&#x27;</span> enum(<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-string">&#x27;hire_date&#x27;</span> <span class="hljs-type">date</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">primary</span> key (<span class="hljs-string">&#x27;emp_no&#x27;</span>)<br>) engine<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>latinl;<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> employees <span class="hljs-keyword">add</span> index idx_lastname_firstname(last_name,first_name);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;689&#x27;</span>,<span class="hljs-string">&#x27;liu&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;431&#x27;</span>,<span class="hljs-string">&#x27;afdu&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;3424&#x27;</span>,<span class="hljs-string">&#x27;fdasfng&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;41z&#x27;</span>,<span class="hljs-string">&#x27;fdasfg&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">5</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;41zz&#x27;</span>,<span class="hljs-string">&#x27;wfdasf&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">6</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;41zz&#x27;</span>,<span class="hljs-string">&#x27;wang&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">7</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;41zz&#x27;</span>,<span class="hljs-string">&#x27;wang&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">8</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;41zzi&#x27;</span>,<span class="hljs-string">&#x27;wang&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">9</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;41zi&#x27;</span>,<span class="hljs-string">&#x27;gda&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">10</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;4i&#x27;</span>,<span class="hljs-string">&#x27;qafd&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure><p>现在查询所有姓wang，并且最后一字是zi的员工。查询的sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> last_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;wang&#x27;</span> <span class="hljs-keyword">and</span> last_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;%zi&#x27;</span>;<br></code></pre></td></tr></table></figure><p>​    正常来说，因为字符是从左往右排序的，当你把%加在前面时，是不能基于索引去比较的，所以只有last_name这个字段能够用于索引比较和过滤。所以查询过程是这样的：</p><p>​    1）根据联合索引查出所有姓wang的二级索引数据（3个主键6，7，8）</p><p>​    2）回表，到主键索引上查询全部符合条件的数据（3条数据）</p><p>​    3）把这3台哦数据返回到Server层，在Server层过滤出名字以zi结尾的员工。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/13.png"></p><p>​    注意，索引的比较是在存储引擎中进行的，数据记录的比较是在Server中进行的。而当first_name的条件不能用于索引过滤时，Server层不会把first_name的条件传递给存储引擎，所以读取了两条没用的记录。这时，如果满足last_name=‘wang’的记录有10万条，就会有99999条没有必要读取的记录。所以，根据first_name字段过过滤的动作，能不能再存储引擎层完成呢？这是第二种查询方法：</p><p>​    1）根据联合索引查出所有姓wang的二级索引数据（3个主键值6，7，8）</p><p>​    2）然后从二级索引中筛选出first_name以zi结尾的索引（1个索引）</p><p>​    3）然后再回表，到主键索引上查询全部符合条件的数据（1条数据），返回给server层</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/14.png"></p><p>​    很明显，第二种方法到主键索引上查询的数据更少。 ICP时默认开启的，也就是说针对二级索引，只要能够把条件下推给存储引擎，它就会下推，不需要我们干预：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> optimizer_switch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;index_condition_pushdown=on&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/15.png"></p><p>关闭ICP：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> optimizer_switch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;index_condition_pushdown=off&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/16.png"></p><p>Using where代表从存储引擎返回的数据不全部满足条件，需要再server层过滤。</p><h2 id="5-索引的创建和使用"><a href="#5-索引的创建和使用" class="headerlink" title="5  索引的创建和使用"></a>5  索引的创建和使用</h2><h3 id="5-1-索引的创建"><a href="#5-1-索引的创建" class="headerlink" title="5.1 索引的创建"></a>5.1 索引的创建</h3><ol><li><p>在用于where判断order排序和join的（on），group by的字段上创建索引</p></li><li><p>索引的个数不要太多 —-浪费空间，更新变慢</p></li><li><p>过长的字段，建立前缀索引</p></li><li><p>区分度低的字段，例如性别，不要建立索引 —-离散度太低，导致扫描行数过多</p></li><li><p>频繁更新的值，不要作为主键或者索引  ——页分裂</p></li><li><p>随机无序的值，不建议建立索引，例如身份证，UUID</p></li><li><p>组合索引把离散度高的值放在前面</p></li><li><p>创建复合索引，而不是修改单列索引</p></li></ol><h3 id="5-2-索引失效的情况"><a href="#5-2-索引失效的情况" class="headerlink" title="5.2 索引失效的情况"></a>5.2 索引失效的情况</h3><ol><li><p>在索引列上使用函数，表达式</p></li><li><p>字符串不加引号，出现隐式转换</p></li><li><p>Like条件中前面带%</p></li><li><p>负向查询: NOT LIKE不能；！=  （&lt;&gt;）和not in某些情况下可以</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> emp_no <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span>(<span class="hljs-number">1</span>)<br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> emp_no <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ol><p>​    这个例子中，因为索引是有序的，只要从1之后开始顺序读取就行了。其实，用不用索引，最终都是优化器说了算。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL执行流程</title>
    <link href="/2023/02/15/mysql/SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/02/15/mysql/SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-查询SQL的执行流程"><a href="#1-查询SQL的执行流程" class="headerlink" title="1.查询SQL的执行流程"></a>1.查询SQL的执行流程</h2><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/1.png"></p><h3 id="1-1-连接"><a href="#1-1-连接" class="headerlink" title="1.1 连接"></a>1.1 连接</h3><p>​    MySQL的服务器监听端口默认时3306，客户端连接服务端的方式有很多。可以是同步的也可以是异步的，可以是长连接也可以是短连接，可以是TCP也可以是Unix Socket，MySQL有专门处理连接的模块，连接的时候需要验证权限。查看当前的连接数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;Thread%&#x27;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>Threads_cached</td><td>缓存中的线程连接数</td></tr><tr><td>Threads_connected</td><td>当前打开的连接数</td></tr><tr><td>Threads_created</td><td>未处理连接创建的线程数</td></tr><tr><td>Threads_running</td><td>非睡眠状态的连接数，通常指并发连接数</td></tr></tbody></table><p>​    客户端每产生一个连接或者一个会话，在服务端就会创建一个线程来处理。反过来，如果杀死会话，就是kill进程。既然分配进程的话，保持连接肯定会消耗服务端的资源。MySQL会把哪些长时间不活动的（sleep）连接自动断开。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;wait_timeour&#x27;</span>; <span class="hljs-comment">--非交互式超时时间，如JDBC程序</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;interactive_timeout&#x27;</span>; <span class="hljs-comment">--交互式超时时间，如数据库工具</span><br></code></pre></td></tr></table></figure><p>​    默认都是28800秒，8小时。查看mysql服务的最大连接数：5.7版本中默认是151，最大可设置成100000。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘max_connections’；<br></code></pre></td></tr></table></figure><p>​    <strong>参数级别说明：</strong></p><p>​    MySQL中的参数（变量）分为session和global级别，分别是在当前会话中生效和全局生效，但是并不是每个参数都有两个几倍，比如max_connections就只有全局级别。当没有带参数的时候，默认是session级别，包括查询和修改。比如修改了一个参数以后，在本窗口已经生效，但是其他窗口不生效：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;autocommit&#x27;</span>;<br><span class="hljs-keyword">set</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-keyword">on</span>;<br></code></pre></td></tr></table></figure><p>​    所以，如果只是临时修改，建议修改session级别。如果需要在其他会话中生效，必须显示的加上global参数。</p><h3 id="1-2-查询缓存"><a href="#1-2-查询缓存" class="headerlink" title="1.2 查询缓存"></a>1.2 查询缓存</h3><p>​    MySQL内部自带了一个缓存模块。但是MySQL的缓存默认是关闭的。在MySQL8.0中，查询缓存已经被移除了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;query_cache%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>​    默认关闭的意思是不推荐使用，因为MySQL自带的缓存的应用场景有限：第一个是它要求SQL语句必须一模一样，中间多一个空格，字母大小写都被认为是不同的SQL；第二个是表里面任何一条数据发生变化时，这张表所有缓存都会失效，所以对于大量数据更新的应用，也不适合。所以缓存这一块，我们还是交给orm框架（比如mybatis默认开启了一级缓存），或者独立的缓存服务，比如Redis来处理更合适。</p><h3 id="1-3-语法解析和预处理-Parser-amp-Preprocessor"><a href="#1-3-语法解析和预处理-Parser-amp-Preprocessor" class="headerlink" title="1.3 语法解析和预处理(Parser &amp; Preprocessor)"></a>1.3 语法解析和预处理(Parser &amp; Preprocessor)</h3><p>​    对语句基于SQL语法进行词法分析，语法分析和语义的解析。</p><h4 id="1-3-1-词法解析"><a href="#1-3-1-词法解析" class="headerlink" title="1.3.1 词法解析"></a>1.3.1 词法解析</h4><p>​    词法解析就是把一个完整的SQL语句打碎成一个个的单词</p><h4 id="1-3-2-语法解析"><a href="#1-3-2-语法解析" class="headerlink" title="1.3.2 语法解析"></a>1.3.2 语法解析</h4><p>​    语法解析会对SQL做一语法检查，比如单引号有没有闭合，然后根据MySQL定义的语法规则，根据SQL语句生成一个数据结构，这个数据结构我们把它叫做解析树（select_lex）。</p><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/2.png"></p><p>​    词法语法分析是一个非常基础的功能，java的编译器，百度搜索引擎如果要识别语句，必须也要有词法语法分析功能。任何数据库的中间件，要解析SQL完成路由功能，也必须要有词法语法功能，比如Mycat，Sharding-JDBC（用到了Druid Parser）。在市面上也有很多的开源的词法解析的工具（比如LEX，Yacc）。</p><h4 id="1-3-3-预处理器"><a href="#1-3-3-预处理器" class="headerlink" title="1.3.3 预处理器"></a>1.3.3 预处理器</h4><p>​    预处理器会检查生成的解析树，解决解析器无法解析的语义。比如它会检查表和列名是否存在，检查名字和别名，保证没有歧义。预处理后得到一个新的解析树。</p><h3 id="1-4-查询优化与查询执行计划"><a href="#1-4-查询优化与查询执行计划" class="headerlink" title="1.4 查询优化与查询执行计划"></a>1.4 查询优化与查询执行计划</h3><p>​    一条SQL语句是可以有很多执行方式的，最终返回相同的结果，他们是等价的。选择哪种执行方式就是由MySQL的查询优化器的模块（Optimizer）。查询优化器的目的是根据解析树生成不同的执行计划（Execution Plan），然后选择一种最优的执行计划，MySQL中使用的是基于开销（cost）的优化器，哪种执行计划开销最小，就用哪种。查看查询的开销：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> ‘Last_query_cost’;<br></code></pre></td></tr></table></figure><p>​    优化的细节可以查看《数据库查询优化器的艺术-原理解析与SQL性能优化》。优化器最终会把解析树变成一个查询执行计划，查询执行计划是一个数据结构。MySQL提供了一个执行计划的工具，我们在SQL语句前面加上explain，就可以看到执行计划的信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">select</span> name <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>​    如果要得到详细的信息，还可以用format=json，或者开启optimizer trace。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN FORMAT<span class="hljs-operator">=</span>JSON <span class="hljs-keyword">where</span> name <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="1-5-存储引擎"><a href="#1-5-存储引擎" class="headerlink" title="1.5 存储引擎"></a>1.5 存储引擎</h3><p>​    查看数据库存放数据的路径</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;datastr&#x27;</span>;<br></code></pre></td></tr></table></figure><p>​    默认情况下，每个数据库都有自己的一个文件夹。任何一个存储引擎都有一个frm文件，这是表结构定义文件。不同的存储引擎存放数据的方式不一样， 产生的问价也不一样，innodb是1个，memory没有，myisam是两个。</p><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/3.png"></p><h4 id="1-5-1-存储引擎的选择"><a href="#1-5-1-存储引擎的选择" class="headerlink" title="1.5.1 存储引擎的选择"></a>1.5.1 存储引擎的选择</h4><p>​    一张表的存储引擎，是在创建表的时候指定的，使用ENGINE关键字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;user_innodb&#x27;</span>(<br><span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    PRIMARY_KEY(<span class="hljs-string">&#x27;id&#x27;</span>),<br>    KEY <span class="hljs-string">&#x27;comidx_name&#x27;</span> (<span class="hljs-string">&#x27;name&#x27;</span>)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>urf8mb4;<br></code></pre></td></tr></table></figure><p>​    没有指定的话，数据库就会使用默认的存储引擎，5.5.5之前，默认的是myisam。5.5.5之后默认的是innodb。不同的业务需求对应相应的存储引擎。</p><h4 id="1-5-2-存储引擎的比较"><a href="#1-5-2-存储引擎的比较" class="headerlink" title="1.5.2 存储引擎的比较"></a>1.5.2 存储引擎的比较</h4><p>​    常见的存储引擎：<a href="https://dev.mysql.com/doc/refman/5.7/en/storage-engines.html">https://dev.mysql.com/doc/refman/5.7/en/storage-engines.html</a></p><p>​    <strong>MyISAM（3个文件）</strong></p><p>​    应用范围比较小。表级锁限制了读/写的性能，因此在web和数据仓库配置中，它通常用于只读或以读为主的工作。</p><p>​    特点：</p><p>​                1.支持表级别的锁（插入或更新会锁表）。不支持事务。</p><p>​                2.拥有较高的插入（insert）和查询（select）速度。</p><p>​                3.存储了表的行数（count速度更快）。</p><p>​    （怎么快速向数据库中插入100万条数据？我们有一种先用myisam插入数据，然后修改存储引擎为innodb的操作）</p><p>​    适合：只读之类的数据分析项目</p><p><strong>InnoDB（2个文件）</strong></p><p>​    MySQL5.7中默认的存储引擎。InnoDB是一个事务安全（与ACID兼容）的MySQL存储引擎，它具有提交，回滚和奔溃回复功能来保护用户数据。InnoDB行级锁（不升级为更粗粒度的锁）和Oracle风格的一致非锁读提高了多用户并发性和性能。InnoDB将用户数据存储在聚集索引中，以减少基于主键的常见查询的I/O。为了保持数据的完整性，InnoDB还支持外键引用完整性约束。</p><p>​    特点：</p><p>​        1.支持事务，支持外键，因此数据的玩成型，一致性更高。</p><p>​        2.支持行级锁和表级锁</p><p>​        3.支持读写并发，写不阻塞读（MVCC）</p><p>​        4.特殊的索引存放方式，可以减少IO，提升查询效率。</p><p>​    适合：经常更新的表，存在并发读写或者由事务处理的业务系统。</p><p>​    <strong>Memory（1个文件）</strong></p><p>​    将所有数据存储在RAM中，以便在需要快速查找非关键性数据的环境中快速访问。这个引擎以前被称为堆引擎。其使用案例正在减少；InnoDB及其缓存池内存区域提供了一种通用，持久的方法来将大部分或所有数据保存在内存中，而ndbcluster为大型分布式数据提供了快速的键值查找。</p><p>​    特点：把数据放在内存里面，读写速度很快。但是数据库重启或者奔溃，数据会全部消失，只适合做临时表。将表中的数据存储到内存中。</p><p>​    <strong>CSV（3个文件）</strong></p><p>​    它的表实际上是带有逗号分隔值的文本文件。Csv表允许以csv格式导入或转储数据，以便与读写相同格式的脚本和应用程序交换数据，因为csv表没有索引，所以通常在正常操作期间将数据保存在innodb中，并且只在导入或导出阶段使用csv表。</p><p>​    特点：不允许空行，不支持索引。格式通用，可以直接编辑。</p><p>​    适合：在不同数据库之间导入导出。</p><p><strong>Archive（2个文件）</strong></p><p>​    这些紧凑的未索引的表用于存储和检索大量很少引用的历史，存档或安全审计信息。</p><p>​    特点：不支持索引，不支持update delete。</p><p>​    这些是mysql中常见的一些存储引擎，不同的存储引擎提供的特性都不一样，它们由不同的存储机制。索引方式，锁定水平等功能。我们在不同的业务场景中对数据操作的要求不同，就可以选择不同的存储引擎来满足我们的需求。</p><h4 id="1-5-3-如何选择存储引擎"><a href="#1-5-3-如何选择存储引擎" class="headerlink" title="1.5.3 如何选择存储引擎"></a>1.5.3 如何选择存储引擎</h4><p>​    InnoDB：对数据一致性要求比较高，需要事务支持。</p><p>​    MyIsam：数据查询多更新少，对查询性能要求比较高。</p><p>​    Memory：需要一个用于查询的临时表。</p><p>​    还可以根据官网内部手册使用C语言开发一个存储引擎。所有的存储引擎都遵循了一定的规范，提供了相同的接口。</p><h3 id="1-6-执行引擎"><a href="#1-6-执行引擎" class="headerlink" title="1.6 执行引擎"></a>1.6 执行引擎</h3><p>​    它利用存储引擎提供相应的api来完成操作，不同功能的存储引擎实现的api是相同的。最后把数据返回给客户端。</p><h2 id="2-更新SQL执行流程"><a href="#2-更新SQL执行流程" class="headerlink" title="2. 更新SQL执行流程"></a>2. 更新SQL执行流程</h2><p>​    在数据库里，我们说的update操作其实包括了更新，插入和删除。MyBatis的源码中Executor里面只有doQuery()和doUpdate()方法，没有doDelete()和doInsert()。它和查询的基本流程是一致的，也就是说，它也要经过解析器，优化器得处理，最后交给执行器。区别在于拿到符合条件得数据之后的操作。</p><h3 id="2-1-Buffer-Pool-缓冲池"><a href="#2-1-Buffer-Pool-缓冲池" class="headerlink" title="2.1 Buffer Pool(缓冲池)"></a>2.1 Buffer Pool(缓冲池)</h3><p>​    首先，对于InnoDB存储引擎来说，数据都是放在磁盘上得，存储引擎要操作数据。必须先把磁盘里面的数据加载到内存中才能操作。这里有个问题，是不是我们需要的数据多大，我们就一次从磁盘加载多少数据到内存呢?比如我要读6个字节。</p><p>​    磁盘I/O的读写相对于内存的操作来说是很慢的。如果我们需要的数据分散在磁盘的不同的地方，那就意味着回产生很多次的I/O操作。所以，无论是操作系统也好，还是存储引擎也好，都有一个预读取的概念，也就是说，当磁盘上的一块区域被读取时，很有可能它附近的位置也回马上被读取到，这个就叫做局部性远离了，那么这样，我们干脆每次多读一些，而不是用多少都多少。</p><p>​    InnoDB设定了一个存储引擎从磁盘读取数据带内存的最小单位，叫做页。操作系统也有页的概念。操作系统的页一般是4k，而Innodb中最小的单位默认是16K。如果要修改这个值的大小，需要清空数据重新初始化服务。</p><p>​    还有一个问题，操作数据的时候，每次都要从磁盘读取到内存（再返回给Server），有没有什么办法可以提高效率？还是缓存的思想，把读取过来的数据页缓存起来。</p><p>​    InnoDB设计了一个内存的缓冲区，读取数据的时候，先判断是不是在这个内存区域里面，如果是，就直接读取，然后操作。不用再次从磁盘中加载。如果不是，读取后就写到这个内存的缓冲区。这个区域就叫Buffer Pool。</p><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/4.png"></p><p>​    修改数据的时候，也是先写入到buffer pool中，而不是直接写到磁盘。内存的数据页个磁盘数据不一致的时候，我们就叫它为脏页。InnoDB中有专门的后台线程把Buffer Pool的数据写入到磁盘，每个一段时间就一次性的把多个修改写入磁盘，这个动作叫做刷脏。</p><p>​    总结一下：Buffer Pool的作用是为了提高读写效率。</p><h3 id="2-2-Redo-Log"><a href="#2-2-Redo-Log" class="headerlink" title="2.2 Redo Log"></a>2.2 Redo Log</h3><p>​    因为刷脏不是实时的，如果Buffer Pool里面的脏页还没有刷入磁盘时，数据库宕机或者重启，这些数据就会丢失。所以内存必须要有一个持久化的措施。为了避免这个问题，InnoDB把对所有页面的修改操作专门写入一个日志文件。如果有未同步到磁盘的数据，数据库在启动的时候，回从这个日志文件进行恢复操作（实现Crash-safe）。我们说的事务的ACID中的D（持久性），就是用它来实现的。</p><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/5.png"></p><p>​    这个日志文件就是磁盘的redo log（重做日志）。 那么写日志文件和写到数据文件有什么区别？</p><p>​    我们说一下磁盘寻址的过程。这个是磁盘的构造。磁盘的盘片不停的旋转，磁头会在磁盘表面画出一个圆形轨迹，这个就叫做磁道。从内到外半径不同有很多磁道。然后又用半径线，把磁道分割成了扇区（两根射线之内的扇区组成扇面）。如果要读写数据，必须找到数据对应的扇区，这个过程就叫寻址。</p><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/6.png"></p><p>​    如果我们所需要的数据是随机分散在磁盘上不同页的不同扇区中，那么找到相应的数据需要等到磁臂旋转到指定的页，然后盘片寻找到对应的扇区，才能找到我们能所需要的一块数据，一次进行此过程知道找完所有数据。这个就是随机IO，读取数据速度较慢。</p><p>​    假设我们已经找到了第一块数据，并且其他所需的数据就在这块数据后边，那么就不需要重新寻址，可以依次拿到我们所需的数据，这个就叫顺序IO。 刷盘是随机IO，而记录日志是顺序IO，顺序IO效率更高，本质上是数据集中存储和分散存储的区别。因此先把修改写入日志文件，在保证了内存数据的安全性的情况下，可以延迟刷盘时机，进而提高系统吞吐。</p><p>​    Redo log位于/var/lib/mysql目录下的ib_logfile0和ib_logfile1，默认2个文件，每个48M。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_log%&#x27;</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>innodb_log_file_size</td><td>指定每个文件的大小，默认48M</td></tr><tr><td>innodb_log_files_in_group</td><td>指定文件的数量，默认为2</td></tr><tr><td>innodb_log_group_home_dir</td><td>指定文件所在路径，相对或绝对。如果不指定，则为datadir路径</td></tr></tbody></table><p> redo log特点？</p><ol><li><p>redo log是Innodb存储引擎实现的，并不是所有存储引擎都有。支持奔溃恢复是Innodb的一个特性。</p></li><li><p>redo log不是记录数据页更新之后的状态，而是记录的是“在某个数据也上做了什么修改”。属于物理日志。</p></li><li><p>redo log的大小是固定的，前面的内容会被覆盖，一旦写满，就会触发buffer pool到磁盘的同步，以便腾出空间记录后面的修改。</p></li></ol><p>除了redo log之外，还有一个跟修改有关的日志，叫做undo log，这两个日志和事务密切相关，统称为事务日志。</p><h3 id="2-3-Undo-Log"><a href="#2-3-Undo-Log" class="headerlink" title="2.3 Undo Log"></a>2.3 Undo Log</h3><p>​    Undo log（撤销日志或回滚日志）记录了事务发生之前的数据状态，分为insert undo log和update undo log。如果修改数据时出现异常，可以用undo log来实现回滚操作（保持原子性）。可以理解为undo log记录的是反向操作，比如insert会记录delete，update会记录update原来的值，跟redo log记录在哪个物理页做了什么操作不同，所以叫逻辑格式的日志。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>innodb_undo_directory</td><td>undo文件的路径</td></tr><tr><td>innodb_undo_log_truncate</td><td>设置为1，即开启在线回收(收缩)undo log日志文件</td></tr><tr><td>innodb_max_undo_log_size</td><td>如果innodb_undo_log_truncate设置为1，超过这个大小的时候会触发truncate回收的动作，如果page大小是16KB，truncate后空间缩小到10M，默认1073741824字节=1G</td></tr><tr><td>innodb_undo_logs</td><td>回滚段的数量，默认128，这个参数已经过时</td></tr><tr><td>innodb_undo_tablespaces</td><td>设置undo独立表空间个数，范围为0-95，默认为0，0表示不开启独立undo表空间，且undo日志存储在ibdata文件中，这个参数已经过时</td></tr></tbody></table><h3 id="2-4-更新过程"><a href="#2-4-更新过程" class="headerlink" title="2.4 更新过程"></a>2.4 更新过程</h3><p>有了这些日志之后，总结一下更新操作的流程。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;penyuyan&#x27;</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>1、 事务开始，从内存（buffer pool）或磁盘（data file）取到包含这条数据的数据页，返回给server的执行器</p><p>2、 Server的执行器修改数据页的这一行数据的值为penyuyan</p><p>3、 记录name=qingshan到undo log</p><p>4、 记录name=penyuyan到redo log</p><p>5、 调用存储引擎接口，记录数据页到buffer pool（修改name=penyuyan）</p><p>6、 事务提交</p><h3 id="2-5-Bin-log"><a href="#2-5-Bin-log" class="headerlink" title="2.5 Bin log"></a>2.5 Bin log</h3><p>​    Binlog以事件的形式记录了所有的ddl和dml语句（因为它记录的是操作而不是数据值，属于逻辑日志），可以用来做主从复制和数据恢复。跟redo log不同，它的文件内容是可以追加的，没有固定大小限制。在开启了binlog功能的情况下，我们可以把binlog导出成sql语句。把所有的操作重放一遍，来实现数据的恢复。Binlog的另一个功能就是用来实现主从复制，它的原理就是从服务器读取主服务器的binlog，然后再执行一遍。配置方式和主从复制的实现原理再Mycat第二节课中有讲述。有了这两个日志之后，一条更新语句是怎么执行的（redo不能一次写入了）</p><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/7.png"></p><p>例如一条语句：update teacher set name = ‘penyuyan’ where id = 1;</p><p>​    1.先查询到这条语句，如果有缓存，也会用到缓存</p><p>​    2.把name改成pengyuyan，然后调用引擎的API接口，写入这一行数据到内存，同时记录redo log。 这时redo log进入prepare状态，然后告诉执行器，执行完成了，可以随时提交</p><p>​    3.执行器收到通知后记录binlog，然后条用存储引擎接口，设置redo log为commit状态。</p><p>​    4.更新完成。</p><p>这张图片的重点：</p><p>​    1.先记录到内存，再写日志文件。</p><p>​    2.记录redo log分为两个阶段</p><p>​    3.存储引擎和Server记录不同的日志</p><p>​    4.先记录redo，再记录binlog</p><p>为什么需要两阶段提交：</p><p>举例：如果我们执行的是把name改成penyuyan，如果写完redo log，还没有写binlog的时候，MySQL重启了。因为redo log可以在重启时用于数据恢复，所以写入磁盘的是pengyuyan。但是binlog中没有记录这个逻辑日志，所以这时候用binlog去恢复数据或者同步到从库，就会出现数据不一致的情况。所以在写两个日志的情况下，binlog就充当了一个事务的协调者。通知InnoDB来执行prepare或者commit或者rollback。如果写入binlog失败，就不会提交。简单地说，这里有两个写日志的操作，类似于分布式事务，不同两阶段提交，就不能保证都成功或者都失败。</p><p>在奔溃恢复时，判断事务是否需要提交：</p><p>1.binlog无记录，redolog无记录：在redolog写之前crash，恢复操作，回滚事务。</p><p>2.binlog无记录，redolog状态prepare：在binlog写完之前crash，恢复操作，回滚事务。</p><p>3.binlog有记录，redolog状态prepare：在binlog写完提交事务之前crash，恢复操作，提交事务。</p><p>4.binlog有记录，redolog状态commit：正常完成事务，不需要恢复。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL架构</title>
    <link href="/2023/02/09/mysql/MySQL%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/02/09/mysql/MySQL%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>​    总体上，我们可以把mysql分成三层，跟客户端对接的连接层，真正执行操作的服务层，和硬件打交道的存储引擎层。</p><p><img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%871.png"></p><h2 id="1-连接层"><a href="#1-连接层" class="headerlink" title="1.连接层"></a>1.连接层</h2><p>​    客户端要连接到mysql服务器的3306端口，必须要跟服务器端建立连接，那么管理所有的连接，验证客户端的身份和权限，这些功能就在连接层完成。</p><h2 id="2-服务层"><a href="#2-服务层" class="headerlink" title="2.服务层"></a>2.服务层</h2><p>​    连接层会把SQL语句交给服务层，这里面又包含一系列流程：比如查询缓存的判断，根据SQL调用相应的接口，对我们的SQL语句进行次发和语法的解析，比如关键字怎么识别，语法有没有错误等等。</p><p>​    然后就是优化器，MySQL底层回根据一定的规则对我们的SQL语句进行优化，最后再交给执行器去执行。</p><h2 id="3-存储引擎"><a href="#3-存储引擎" class="headerlink" title="3.存储引擎"></a>3.存储引擎</h2><p>​    存储引擎就是我们的数据真正存放的地方，在MySQL里面支持不同的存储引擎。</p><p>​    再往下就是内存或者磁盘，具体请查看查询sql执行流程。</p><h2 id="4-InnoDB总体架构"><a href="#4-InnoDB总体架构" class="headerlink" title="4.InnoDB总体架构"></a>4.InnoDB总体架构</h2><p><img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%872.png"></p><h3 id="4-1-内存结构"><a href="#4-1-内存结构" class="headerlink" title="4.1 内存结构"></a>4.1 内存结构</h3><p>​    主要分为三个部分：Buffer Pool，Change Buffer，Adaptive Hash Index，（redo）log buffer。</p><h4 id="4-1-1-Buffer-pool"><a href="#4-1-1-Buffer-pool" class="headerlink" title="4.1.1 Buffer pool"></a>4.1.1 Buffer pool</h4><p>​    Buffer pool缓存的是页面信息，包括数据页，索引页。默认大小是128M（134217728字节），可以调整。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_buffer_pool<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>​    InnoDB用LRU算法来管理缓存池（链表实现，不是传统的LRU，分成了young和old），经过淘汰的数据就是热点数据。</p><h4 id="4-1-2-LRU算法"><a href="#4-1-2-LRU算法" class="headerlink" title="4.1.2 LRU算法"></a>4.1.2 LRU算法</h4><p>​    传统的LRU可以用Map+链表实现，value存的是在链表中的地址。</p><p><img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%873.png"></p><p>​    innodb中确实使用了一个双向链表，LRU list，但是这个list放的不是data page，而是指向缓存页的指针。如果写buffer pool的时候发现没有空闲页了，就要从buffer pool中淘汰数据页了，要根据LRU链表的数据来操作。</p><p>​    首先，innodb的数据页并不都是在访问的时候才缓存到buffer pool的，innodb由一个预读机制（read ahead），也就是说，设计者认为访问某个page数据的时候，相邻的一些page可能会很快被访问到，所以先把这些page放到buffer pool中缓存起来，能提高I/O性能。这种预读的机制分为两种：</p><p>​    <strong>1.线性预读（异步的）。</strong>为了方便管理，innodb中把64个相邻的page叫做一个extent（区）。如果顺序的访问了一个extent的56个page，这时innodb就会把下一个extent缓存到buffer pool中。顺序访问多少个page才缓存下一个extent，由一个参数控制：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_read_ahead_threshold<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>​     <strong>2.随机预读。</strong>如果buffer pool已经缓存了同一个extent的数据页的个数超过13个时，就会把这个extent剩余的所有page全部缓存到buffer pool，但是随机预读的功能默认是不启用的，由一个参数控制：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_random_read_ahead<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>​    但是预读肯定也会带来一些副作用，就是导致占用的内存空间更多，剩余的空闲页更少，如果说buffer pool的size不是很大，而预读的数据很多，很有可能那些真正的需要被缓存的热点数据被预读数据挤出buffer pool，淘汰掉了，下次访问时又要去磁盘。所以为了避免这种情况，对buffer pool进行冷热分离。靠近head的叫做new sublist，用来放热数据（热区），靠近tail的叫做old sublist，用来放冷数据（冷区）。</p><p><img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%874.png"><img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%875.png"></p><p>​    所有新数据加入到buffer pool时一律先放到冷区的head。如果有些预读的数据没有被用到，会在冷区直接被淘汰。放到冷区后如果再次被访问，都会把它移动到热区的head。如果热区的数据长时间没有被访问，会被先移动到冷区的head部，最后慢慢在tail淘汰。默认情况下，热区占了5/8的大小，冷区占了3/8，这个值由innodb_old_blocks_pct控制，它代表的是old区的大小，默认是37%也就是3/8. Innodb_old_blocks_pct的值可以调整，在5%到95%之间，这个值越大，new区越小，这个LRU算法越接近传统的LRU。如果这个值太小，old区没有被访问的速度淘汰会更快。</p><p>​    还有一个问题：假设一次加载然后被立即访问的冷区数据量非常大，导致它们全部被移到了热区的head，它会导致很多热点数据被移动到冷区甚至淘汰，造成了缓冲池的污染。这个问题的解决方法是设置一个时间窗口，只有超过这个时间之后被访问，才认为是有效访问。Innodb中通过innodb_old_blocks_time这个参数来控制，默认为1秒钟，也就是说1秒钟内被访问的不算数，继续呆在冷区。只有1秒钟之后被访问的才被移到热区。这样就可以从很大程度上避免全表扫描或者预读的数据污染真正的热数据。</p><p>​    进一步的优化，为了避免并发的问题，对于LRU链表的操作是要加锁的，也就是说每一次链表的移动，都会带来资源的竞争与等待，从这个角度来说，如果进一步提升InnoDB LRU的效率，就要尽量得减少LRU链表得移动。比如把热区一个非常靠近head得page移动到head。有没有这个必要呢？所以InnoDB对热区还有一个特殊得优化：如果一个缓存页处于热数据区域，且在热数据区域得前1/4区域（注意是热区得1/4，而不是这个链表得1/4），那么当访问这个缓存页得时候，就不用把它移动到热数据区域得头部；如果缓存页处于热区得后3/4区域，那么就得移动到热区得头部。</p><h4 id="4-1-3-Change-Buffer-写缓存"><a href="#4-1-3-Change-Buffer-写缓存" class="headerlink" title="4.1.3 Change Buffer-写缓存"></a>4.1.3 Change Buffer-写缓存</h4><p>​    Change Buffer是Buffer Pool的一部分。如果这个数据页不是唯一索引，不存在数据重复的情况，也就不需要从磁盘加载索引页判断数据是不是重复（唯一性检查）。这种情况下可以先把修改记录在内存的缓存池中，从而提升更新语句（Insert， Delete，Update）的执行速度。</p><p>​    这一块区域就是Change Buffer。5.5之前叫Insert Buffer插入缓冲，现在也支持delete和update。</p><p>​    最后把Change Buffer记录到数据页的操作叫做merge。发生merge的几种情况如下：在访问这个数据页的时候，或者通过后台线程，或者通过数据库shut down，redo log写满时触发。</p><p>​    如果数据库发部分索引都是非唯一索引，并且业务是写多读少，不会在写数据后立刻读取，就可以用Change Buffer（写缓存）</p><p>​    可以通过调大这个值来扩大Change的大小，以支持写多读少的业务场景。（代表Change Buffer占Buffer pool的比例，默认为25%）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_change_buffer_max_size<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><h4 id="4-1-4-Adaptive-Hash-Index"><a href="#4-1-4-Adaptive-Hash-Index" class="headerlink" title="4.1.4 Adaptive Hash Index"></a>4.1.4 Adaptive Hash Index</h4><p>​    查看索引模块</p><h4 id="4-1-5-Redo-Log-Buffer"><a href="#4-1-5-Redo-Log-Buffer" class="headerlink" title="4.1.5 Redo Log Buffer"></a>4.1.5 Redo Log Buffer</h4><p>​    Redo Log也不是每一次都直接写入磁盘，在Buffer Pool中有一块内存区域（Log Buffer）专门用来保存即将写入日志文件的数据，默认为16M，它同样可以节省磁盘IO。</p><p>​    <img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%876.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_log_buffer_size<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>注意：redo log的内容主要用于奔溃恢复。磁盘的数据文件，数据来自buffer pool。Redo log写入磁盘，不是写入数据文件。</p><p>​    在我们写入数据到磁盘的时候，操作系统本身是有缓冲的，flush就是把操作系统缓冲区写入到磁盘。Log buffer写入磁盘的时机由一个参数控制，默认是1。刷盘越快越安全，但是也会越消耗性能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_flush_log_at_trx_commit<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>​    <img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%877.png"></p><h3 id="4-2-磁盘结构"><a href="#4-2-磁盘结构" class="headerlink" title="4.2 磁盘结构"></a>4.2 磁盘结构</h3><p>​    表空间可以看作是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。InnoDB的表空间分为5大类。</p><h4 id="4-2-1-系统表空间-system-tablespace"><a href="#4-2-1-系统表空间-system-tablespace" class="headerlink" title="4.2.1 系统表空间-(system tablespace)"></a>4.2.1 系统表空间-(system tablespace)</h4><p>​    在默认情况下InnoDB存储引擎有一个共享表空间（/var/lib/mysql/ibdata1），也叫系统表空间。</p><p>​    InnoDB系统表空间包含InnoDB数据字典和双写缓冲区，Change Buffer和undo logs，如果没有指定file-per-table，也包含用户创建的表和索引数据。</p><p>​    1.undo log后面介绍</p><p>​    2.数据字典：由内部系统表组成，存储表和索引的元数据（定义信息）</p><p>​    3.双写缓冲（InnoDB的一个特性）</p><p>​    InnoDB的页和操作系统的页大小不一致，InnoDB页大小一般为16k，操作系统页大小为4k，InnoDB页写入磁盘中时，一个页需要分4次写。</p><p>​    <img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%878.png"></p><p>​    如果存储引擎正在写入页的数据到磁盘时发生了宕机，可能出现页只写了一部分的数据，比如只写了4k，就宕机了。这种情况叫做部分写失效（partial page write），可能会导致数据丢失。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_doublewrite<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>​    如果这个页本身已经损坏了，用它来做奔溃恢复是没有意义的。所以在对于应用redo log之前，需要一个页的副本，如果出现了写入失效，就用这个页的副本来还原这个页，然后再应用redo log。这个页的副本就是double write，InnoDB的双写技术，通过它实现了数据页的可靠性。跟redo log一样，double write由两部分组成，一部分是内存的double write，一部分是磁盘上的double write。因为double write是顺序写入的，不会带来很大的开销。在默认情况下，所有的表共享一个系统表空间这个文件会越来越大，而且它的空间不会收缩。</p><h4 id="4-2-2-独占表空间-file-per-table-tablespaces"><a href="#4-2-2-独占表空间-file-per-table-tablespaces" class="headerlink" title="4.2.2 独占表空间-(file-per-table tablespaces)"></a>4.2.2 独占表空间-(file-per-table tablespaces)</h4><p>​    我们可以让每张表独占一个表空间。这个开关通过innodb_file_per_table设置，默认开启。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_file_per_table<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>​    开启后，则每张表会开启一个表空间，这个文件就是数据目录下的ibd文件，存放表的索引和数据。但是其他类的数据，如回滚（undo）信息，插入缓冲索引页，系统事务信息，二次写缓冲（double write buffer）等还是存放在原来的共享表空间内。</p><h4 id="4-2-3-通用表空间-general-tablespaces"><a href="#4-2-3-通用表空间-general-tablespaces" class="headerlink" title="4.2.3 通用表空间-(general tablespaces)"></a>4.2.3 通用表空间-(general tablespaces)</h4><p>​    通用表空间也是一个共享的表空间，跟ibddata1类似。 可以创建一个通用表空间，用来存储不同数据库的表，数据路径和文件可以自定义，语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span>spaces ts <span class="hljs-keyword">add</span> datafile <span class="hljs-string">&#x27;/var/lib/mysql/ts.ibd&#x27;</span> file_block_size<span class="hljs-operator">=</span><span class="hljs-number">16</span>K engine<span class="hljs-operator">=</span>innodb;<br></code></pre></td></tr></table></figure><p>​    在创建表的时候可以指定表空间吗，用alert修改表空间可以转移表空间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t(id <span class="hljs-type">integer</span>) tablespace ts;<br></code></pre></td></tr></table></figure><p>​    不同的表空间的数据是可以移动的。删除表空间需要先删除里面的所有表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> t;<br><span class="hljs-keyword">drop</span> tablespace ts;<br></code></pre></td></tr></table></figure><h4 id="4-2-4-临时表空间-temporary-tablespaces"><a href="#4-2-4-临时表空间-temporary-tablespaces" class="headerlink" title="4.2.4 临时表空间-(temporary tablespaces)"></a>4.2.4 临时表空间-(temporary tablespaces)</h4><p>​    存储临时表的数据，包括用户创建的临时表，和磁盘的内部临时表。对应数据目录下的ibtmp1文件。当数据服务器正常关闭时，该表空间被删除，下次重启产生。</p><h4 id="4-2-5-Redo-Log"><a href="#4-2-5-Redo-Log" class="headerlink" title="4.2.5 Redo Log"></a>4.2.5 Redo Log</h4><p>​    在更新sql执行流程中讲述</p><h4 id="4-2-6-Undo-log-tablespaces"><a href="#4-2-6-Undo-log-tablespaces" class="headerlink" title="4.2.6 Undo log tablespaces"></a>4.2.6 Undo log tablespaces</h4><p>​    Undo log的数据默认在系统表空间ibdata1文件中，因为共享表空间不会自动收缩，页可以单独创建一个undo表空间。</p><h3 id="4-3-后台线程"><a href="#4-3-后台线程" class="headerlink" title="4.3 后台线程"></a>4.3 后台线程</h3><p>​    后台线程的主要作用是负责刷新内存池中的数据和把修改的数据页刷新到磁盘。后台线程分为：master thread，IO thread，ourge thread，page cleaner thread。</p><p>​    1.Master thread：负责刷新缓存数据到磁盘并协调调度其他后台线程。</p><p>​    2.IO thread：分为innodb buffer，log，read，write进程。分别用来处理insert buffer，重做日志，读写请求的IO回调。</p><p>​    3.Purge threadL用来回收undo页。</p><p>​    4.Page cleaner thread：用来刷新脏页。</p><p>​    除了InnoDB架构中的日志文件，MySQL的Server层也有一个日志文件，叫做binlog，它可以被所有的存储引擎使用。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
