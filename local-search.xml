<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>通信系统架构设计理论与实践</title>
    <link href="/2023/07/22/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E7%90%86%E8%AE%BA%E5%92%8C%E5%AE%9E%E8%B7%B5/%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/07/22/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E7%90%86%E8%AE%BA%E5%92%8C%E5%AE%9E%E8%B7%B5/%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="1-通信系统网络架构"><a href="#1-通信系统网络架构" class="headerlink" title="1 通信系统网络架构"></a>1 通信系统网络架构</h2><p>通信系统架构是软件架构的基础设施和系统环境，在架构实践中，软件的性能、可用性、可靠性等质量属性很大程度上，受到基础设施和环境的影响，良好的基础设施能够有效地帮助提高系统架构的性能和可用性，增强可靠性。</p><p><strong>通信网络主要形式：局域网、广域网、移动通信网。</strong></p><h3 id="1-1-局域网网络架构"><a href="#1-1-局域网网络架构" class="headerlink" title="1.1 局域网网络架构"></a>1.1 局域网网络架构</h3><p><strong>局域网</strong> 是单一机构专用计算机的网络。通常由计算机支持多种传输界等设备组成。<br><strong>特点</strong> ：是覆盖地理范围小、数据传输速率高、低误码率、可靠性高、支持多种传输介质、支持实时应用。<br><strong>局域按网络拓扑分类</strong> ：有总线型、环型、星型、树型、层次型等类型。<br><strong>按传输介质分类</strong> ：有线局域网和无线局域网。</p><p><strong>局域网网络架构有4种类型：</strong></p><p>(1)单核心架构 。使用单台核心二层或三层交换设备作为网络核心。<br>优点：结构简单，设备投资节约，接入方便。<br>缺点：地理范围受限，核心单点故障，扩展能力有限，接入设备较多时核心端口密度要求高。</p><p>(2)双核心架构 。采用两台核心三层及以上交换机作为网络核心。<br>优点：网络拓扑结构可靠性高，接入较为方便。<br>缺点：投资较单核心高，核心端口密度要求较高。</p><p>(3) 环型架构 。采用多台核心三层及以上交换机组成双动态弹性分组环(Reslient Packet Ring, RPR, 作为网络核心。<br>优点：RPR具备自愈保护， 节省光纤资源， 提供多等级、可靠的QoS服务， 有效利用带宽资源。<br>缺点：投资较高，路由冗余设计实施难度较高且易形成环路，多环智能通过业务接口互通无法直通。</p><p>(4)层次型架构 。由核心层、汇聚层、接入层三层交换设备和用户设备组成层次模型。<br>核心层：负责高速数据转发。<br>接入层：用户设备接入。<br>汇聚层：提供充足接口，与接入层间实现互访控制。<br>层次型架构的优点：易扩展，分级排查网络故障便于维护。</p><h3 id="1-2-广域网网络架构"><a href="#1-2-广域网网络架构" class="headerlink" title="1.2 广域网网络架构"></a>1.2 广域网网络架构</h3><p><strong>广域网</strong> 利用公用分组交换网、无线分组交换网、卫星通信网构建通信子网连接分布的局域网以实现资源子网的共享。广域网由骨干网、分布网、接入网组成。</p><p><strong>广域网网络架构可以分为：</strong></p><p>(1)单核心架构 。以单台核心三层交换设备作为网络核心。<br>优点：结构简单，设备投资节约，局域网互访效率高，新局域网接入方便。<br>缺点：核心单点故障，扩展能力欠佳，核心设备端口密度要求较高。</p><p>(2)双核心架构 。以两台核心三层及以上交换机作为网络核心。<br>优点：网络拓扑结构可靠，路由可热切换，可靠性高，局域网接入较为方便。<br>缺点：投资较单核心高，路由冗余设计实施难度较高，核心端口密度要求较高。</p><p>(3)环型架构 。以多台核心三层及以上交换机组成路由环路作为网络核心。<br>优点：接入方便。<br>缺点：投资较高，路由冗余设计实施难度较高且易形成环路，核心端口密度要求较高。</p><p>(4)半/全冗余架构 。以多台核心路由设备间互连组成网络核心，如任意核心存在两条以上到其他核心的链路为半冗余架构，如任何两个核心间均存在链路为全冗余架构。<br>优点：结构灵活，路由灵活，方便扩展，可靠性高。<br>缺点：结构零散，不便管理，不便排障。</p><p>(5)对等子域架构 。将半冗余核心划为两个独立子域，子域间通过一条或多条链路互连。<br>优点：路由控制灵活。<br>缺点：子域间冗余设计实施难度较高，易形成环路或存在非法路由风险，子域互连设备性能要求高。</p><p>(6)层次子域架构 。半冗余核心划为多个独立子域，子域间存在层次关系，高层次子域连接多个低层次子域。<br>优点：扩展性较好，路由控制灵活。<br>缺点：子域路由冗余设计实施难度较高，易形成环路或存在非法路由风险，子域互连设备性能要求高。</p><h3 id="1-3-移动通信网网络架构"><a href="#1-3-移动通信网网络架构" class="headerlink" title="1.3 移动通信网网络架构"></a>1.3 移动通信网网络架构</h3><p>5G系统为移动终端用户提供数据网络互连，数据网络可以是互联网、IP媒体子系统、专用网络。用户设备通过5G系统接入数据网络的方式有透明模式和非透明模式。在透明模式下5G系统通过用户面功能接口接入运营商网络， 然后通过防火墙或者代理连至Internet。非透明模式下， 5G系统可以直接或通过其他网络连接至运营商网络或Internet。</p><h3 id="1-4-5G网络边缘计算"><a href="#1-4-5G网络边缘计算" class="headerlink" title="1.4 5G网络边缘计算"></a>1.4 5G网络边缘计算</h3><p>5G网络边缘计算能为垂直行业提供诸如以时间敏感、高带宽为特征的业务就近分流服务。一来为用户提供极佳的服务体验，二来降低了移动网络后端处理的压力。</p><h3 id="1-5-软件定义网络"><a href="#1-5-软件定义网络" class="headerlink" title="1.5 软件定义网络"></a>1.5 软件定义网络</h3><p>SDN是一种新型网络创新架构， 核心思想是通过控制与转发分离，将网络中交换设备的控制逻辑集中到一个计算设备上，控制面集中管控，提升网络管理配置能力。</p><h3 id="1-6-存储网络架构"><a href="#1-6-存储网络架构" class="headerlink" title="1.6 存储网络架构"></a>1.6 存储网络架构</h3><p><strong>存储网络设计磁盘存储访问方式：直连式存储，网络附加存储，存储区域网络。</strong></p><p>(1) 直连式存储(Direct Attached Storage，DAS) ：存储设备通过IDE/AT A/SCSI接口或光纤通道直接连接到单台计算机， 计算机通过I/O访问存储设备， 存储设备可以是硬盘驱动器、RAID阵列、CD、DVD、磁带驱动器。<br>(2) 网络附加存储(Network At ached Storage， NAS) ：存储设备通过标准的网络拓扑结构连接到计算机群组， 计算机通过IP局域网或广域网TPC或UDP协议， 通过RPC接口访问NAS在存储设备。<br>(3) 存储区域网络(Storage Area Network， SAN) ：一种采用网状通道技术专门为存储建立的独立于TCP/IP网络之外的专用网络， 通过网状通道交换机连接存储阵列和服务器。</p><p><strong>3种存储网络架构的对比见表：</strong></p><table><thead><tr><th>对比项</th><th>DAS</th><th>NAS</th><th>SAN</th></tr></thead><tbody><tr><td>架构类别</td><td>单机存储架构</td><td>网络存储架构</td><td>网络存储架构</td></tr><tr><td>访问方式</td><td>I/O总线</td><td>网络</td><td>网络</td></tr><tr><td>资源利用</td><td>单机存储</td><td>共享存储</td><td>共享存储</td></tr><tr><td>访问媒介</td><td>总线</td><td>以太网</td><td>以太网/光纤通道</td></tr><tr><td>优势特点</td><td>易用易管理/设备成本低</td><td>易用易管理/设备成本低/可扩展性高</td><td>高性能/低延迟/灵活性高</td></tr></tbody></table><h2 id="2-网络构建关键技术"><a href="#2-网络构建关键技术" class="headerlink" title="2 网络构建关键技术"></a>2 网络构建关键技术</h2><h3 id="2-1-IPv4与IPv6融合组网技术"><a href="#2-1-IPv4与IPv6融合组网技术" class="headerlink" title="2.1 IPv4与IPv6融合组网技术"></a>2.1 IPv4与IPv6融合组网技术</h3><p>IPv4与IPv6融合组网技术 。目前网络演进还存在较长时间IPv4到IPv6过渡期或IPv4和IPv6网络共存期。现阶段主要存在3种过渡技术：双协议栈、隧道技术、网络地址翻译技术。</p><p>(1)双协议栈 ：两种协议在同一平台上双栈共存，同时运行。<br>(2) 隧道技术 ：包括ISATAP隧道、6to4隧道、over6隧道、6over4隧道。<br>(3) 网络地址翻译(Network Address Translator， NAT) 技术 ：将IPv4地址和IPv6地址分别看作内部地址和外部地址，或者相反，以实现地址转换。</p><h2 id="3-网络构建"><a href="#3-网络构建" class="headerlink" title="3 网络构建"></a>3 网络构建</h2><h3 id="3-1-网络需求分析"><a href="#3-1-网络需求分析" class="headerlink" title="3.1 网络需求分析"></a>3.1 网络需求分析</h3><p><strong>网络需求分析主要从业务需求、用户需求、应用需求、计算机平台需求和网络需求来进行分析。</strong></p><h3 id="3-2-网络技术遴选及设计"><a href="#3-2-网络技术遴选及设计" class="headerlink" title="3.2 网络技术遴选及设计"></a>3.2 网络技术遴选及设计</h3><p><strong>网络技术遴选及设计可以使用生成树协议、虚拟局域网(VLAN) 、无线局域网(WLAN) 、线路冗余设计、服务器冗余设计等方式。</strong></p><h3 id="3-3-广域网技术遴选"><a href="#3-3-广域网技术遴选" class="headerlink" title="3.3 广域网技术遴选"></a>3.3 广域网技术遴选</h3><p>广域网技术避选 可以采用运程接入技术、广城网互连技术， 如数字数据网络(DDN) 、同步字体系(SDH) 、多业务传送平台(MSTP) 、虚拟专用网络(VPN) 等。广域网性能优化策略有：广域网性能优化黄预留带宽、利用拨号线路、传输数据压缩、链路聚合、数据基于优先级排序、基于协议预留带宽等方式。</p><h3 id="3-4-层次化网络模型设计"><a href="#3-4-层次化网络模型设计" class="headerlink" title="3.4 层次化网络模型设计"></a>3.4 层次化网络模型设计</h3><p>层次化设计的优点是能降低成本，充分利用模块化设备/部件，网络变化或演化容易、层次化网络设计一般采用三层模型设计思路：接入层、汇聚层、核心层。 参考→点击 网络规划与设计</p><p>层次化设计的原则：</p><p>(1)控制网络层次。<br>(2)从接入层开始，向上分析规划。<br>(3)尽量采用模块化设计。<br>(4)严格控制网络结构。<br>(5)严格控制层次化结构。</p><h3 id="3-5-网络安全控制技术"><a href="#3-5-网络安全控制技术" class="headerlink" title="3.5 网络安全控制技术"></a>3.5 网络安全控制技术</h3><p>(1)防火墙 。防护墙是网络间的安全屏障，可以保护本地网络资源。防火墙可以允许拒绝/重定向数据流以及审计进出网络的访问或服务。防火墙的体系有：硬件防火墙、软件防火墙、嵌入式防火墙。防火墙的种类有包过滤、应用层网关、代理服务等。<br>(2)虚拟专用网络技术 。该技术利用公共网络建立私有专用网络，具有成本低、接入方便、可扩展性强、管理和控制方便等优点。<br>(3) 访问控制技术 。访问控制技术主要有：自主访问控制(DAC) 、强制访问控制(MAC) 、基于角色的访问控制(RBAC) 、基于任务的访问控制(TBAC) 和基于对象的访问控制(OBAC) 。<br>(4)网络安全隔离 。将攻击隔离在网络外，保证网络内信息不外泄。形式有：子网隔离、物理隔离、VLAN隔离、逻辑隔离。<br>(5)网络安全协议 。</p><h3 id="3-6-网络安全审计"><a href="#3-6-网络安全审计" class="headerlink" title="3.6 网络安全审计"></a>3.6 网络安全审计</h3><p><strong>网络安全审计用来测试，评估和分析网络脆弱性，能够实现自动响应、数据生成、分析、浏览、事件存储、事件选择等功能。</strong></p><h3 id="3-7-绿色网络设计方法"><a href="#3-7-绿色网络设计方法" class="headerlink" title="3.7 绿色网络设计方法"></a>3.7 绿色网络设计方法</h3><p><strong>绿色网络设计</strong> 采用精简设计、重用设计、回收设计的思路。<strong>设计原则有：</strong></p><ul><li>(1)<strong>标准化</strong> ：减少转换设备，兼容异构方案。</li><li>(2)<strong>集成化</strong> ：减少设备总量，降低资源需求。</li><li>(3)<strong>虚拟化</strong> ：灵活调配，按需使用。</li><li>(4)<strong>智能化</strong> ：降低人力成本，降低资源占用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>理论和实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大数据架构设计理论与实践</title>
    <link href="/2023/07/22/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E7%90%86%E8%AE%BA%E5%92%8C%E5%AE%9E%E8%B7%B5/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/07/22/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E7%90%86%E8%AE%BA%E5%92%8C%E5%AE%9E%E8%B7%B5/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="1-传统数据处理系统的问题"><a href="#1-传统数据处理系统的问题" class="headerlink" title="1 传统数据处理系统的问题"></a>1 传统数据处理系统的问题</h2><h3 id="1-1-传统数据库的数据过载问题"><a href="#1-1-传统数据库的数据过载问题" class="headerlink" title="1.1 传统数据库的数据过载问题"></a>1.1 传统数据库的数据过载问题</h3><p>传统应用的数据系统架构设计时，应用直接访问数据库系统。当用户访问量增加时，数据库无法支撑日益增长的用户请求的负载，从而导致数据库服务器无法及时响应用户请求，出现超时的错误。</p><p>关于这个问题的常用解决方法如下：<br>（1）增加异步处理队列<br>（2）建立数据库水平分区<br>（3）建立数据库分片或重新分片<br>（4）引入读写分离技术<br>（5）引入分库分表技术</p><h3 id="1-2-大数据的特点"><a href="#1-2-大数据的特点" class="headerlink" title="1.2 大数据的特点"></a>1.2 大数据的特点</h3><p>大数据具有体量大、失效性强的特点，并非构造单调，二是类型多样；处理大数据时，传统数据处理系统因数据过载，来源复杂，类型多样等诸多原因性能低下，需要采用以新式计算架构和智能算法为代表的新技术；大数据的应用重在发掘数据间的相关性，而非传统逻辑上的因果关系；因此，大数据的目的和价值就在于发现新的知识，洞悉并进行科学决策。</p><p>现代大数据处理技术，主要分为以下几种：</p><p>（1）基于分布式文件系统Hadoop。<br>（2）使用Map/Reduce或Spark数据处理技术。<br>（3）使用Kafaka数据传输消息队列及Avro二进制格式。</p><h3 id="1-3-大数据的利用过程"><a href="#1-3-大数据的利用过程" class="headerlink" title="1.3 大数据的利用过程"></a>1.3 大数据的利用过程</h3><p><strong>大数据的利用过程</strong>分为：<strong>采集、清洗、统计和挖掘</strong> 4个过程。</p><h2 id="2-大数据处理系统架构分析"><a href="#2-大数据处理系统架构分析" class="headerlink" title="2 大数据处理系统架构分析"></a>2 大数据处理系统架构分析</h2><h3 id="2-1-面临的挑战"><a href="#2-1-面临的挑战" class="headerlink" title="2.1 面临的挑战"></a>2.1 面临的挑战</h3><p>（1）如何利用信息技术等手段处理非结构化和半结构化数据。<br>（2）如何探索大数据的复杂性、不确定性特征描述的刻画方法及大数据的系统建模。<br>（3）数据异构性与决策异构性的关系对大数据知识发现与管理决策的影响。</p><h3 id="2-2-特征"><a href="#2-2-特征" class="headerlink" title="2.2 特征"></a>2.2 特征</h3><p><strong>鲁棒性和容错性、低延迟性、横向扩展（通过增强机器性能扩展）、通用、可扩展、即席查询（用户按照自己的要求进行查询）、最少维护和可调试。</strong></p><h2 id="3-典型的大数据架构"><a href="#3-典型的大数据架构" class="headerlink" title="3 典型的大数据架构"></a>3 典型的大数据架构</h2><h3 id="3-1-Lambda架构"><a href="#3-1-Lambda架构" class="headerlink" title="3.1 Lambda架构"></a>3.1 Lambda架构</h3><p><strong>Lambda架构是一种用于同时处理离线和实时数据的、可容错性、可扩展性的分布式系统。</strong></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84/1.png"></p><p><strong>Lambda架构分为以下3层：</strong><br><strong>（1）批处理层 (Batch Layer)：</strong>存储数据集， 该层核心功能是存储主数据集，Batch Layer在数据集上预先计算查询函数，并构建查询所对应的View。Batch Layer可以很好地处理离线数据，但有很多场景数据是不断实时生成且需要实时查询处理，对于这种情况， Speed Layer更为适合。</p><p><strong>（2）加速层 (Speed Layer)：</strong>Batch Layer处理的是全体数据集，该层核心功能是处理增量实时数据，而 Speed Layer处理的是最近的增量数据流。 Speed Layer 为了效率，在接收到新的数据后会不断更新Real-time View, 而Batch Layer 是根据全体离线数据集直接得到Batch View。</p><p><strong>（3）服务层 (Serving Layer)：</strong>该层核心功能是响应用户请求，Serving Layer用于合并Batch View和 Real-time View中的结果数据集到最终数据集。</p><p><strong>优点</strong><br>（1）容错性好。 Lambda 架构为大数据系统提供了更友好的容错能力，一旦发生错误，我们<br>可以修复算法或从头开始重新计算视图。<br>（2）查询灵活度高。批处理层允许针对任何数据进行临时查询。<br>（3）易伸缩。所有的批处理层、加速层和服务层都很容易扩展。因为它们都是完全分布式<br>的系统，我们可以通过增加新机器来轻松地扩大规模。<br>（4）易扩展。添加视图是容易的，只是给主数据集添加几个新的函数。</p><p><strong>缺点</strong><br>（1）全场景覆盖带来的编码开销。<br>（2）针对具体场景重新离线训练一遍益</p><h3 id="3-2-Kappa架构"><a href="#3-2-Kappa架构" class="headerlink" title="3.2 Kappa架构"></a>3.2 Kappa架构</h3><p><strong>Kappa架构是在Lamada架构的基础上进行了优化、删除了Batch Layer的架构，将数据通道以消息队列进行替代。</strong></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84/2.png"></p><p><strong>从使用场景上来看， Kappa架构与Lambda相比，主要有两点区别：</strong></p><p>（1）Kappa不是 Lambda的替代架构，而是其简化版本， Kappa放弃了对批处理的支持，更擅长业务本身为增量数据写入场景的分析需求，例如各种时序数据场景，天然存在时间窗口的概念，流式计算直接满足其实时计算和历史补偿任务需求；</p><p>（2）Lambda直接支持批处理，因此更适合对历史数据分析查询的场景，比如数据分析师需要按任意条件组合对历史数据进行探索性的分析，并且有一定的实时性需求，期望尽快得到分析结果，批处理可以更直接高效地满足这些需求。</p><p>Kappa架构的优点在于将实时和离线代码统一起来，方便维护而且统一了数据口径的问题，避免了 Lambda架构中与离线数据合并的问题，查询历史数据的时候只需要重放存储的历史数据即可。</p><p><strong>而Kappa的缺点也很明显：</strong></p><p>（1）消息中间件缓存的数据量和回溯数据有性能瓶颈。通常算法需要过去180天的数据，如果都存在消息中间件，无疑有非常大的压力。同时，一次性回溯订正180天级别的数据，对实时计算的资源消耗也非常大。</p><p>（2）在实时数据处理时，遇到大量不同的实时流进行关联时，非常依赖实时计算系统的能力，很可能因为数据流先后顺序问题，导致数据丢失。</p><p>（3）Kappa 在抛弃了离线数据处理模块的时候，同时抛弃了离线计算更加稳定可靠的特点。Lambda虽然保证了离线计算的稳定性，但双系统的维护成本高且两套代码带来后期运维困难。对于以上Kappa框架存在的几个问题，目前也存在一些解决方案，对于消息队列缓存数据性能的问题， Kappa+框架提出使用 HDFS来存储中间数据。针对 Kappa框架展示层能力不足的问题，也有人提出了混合分析系统的解决方案。</p><h3 id="3-3-Lambda与Kappa对比"><a href="#3-3-Lambda与Kappa对比" class="headerlink" title="3.3 Lambda与Kappa对比"></a>3.3 Lambda与Kappa对比</h3><table><thead><tr><th>对比内容</th><th>Lambda架构</th><th>Kappa架构</th></tr></thead><tbody><tr><td>复杂度与开发、维护成本</td><td>需要维护两套系统(引擎)，复杂度高，开发维护成本高</td><td>需要维护一套系统(引擎)，复杂度低，开发维护成本低</td></tr><tr><td>计算开销</td><td>需要一直运行批处理和实时计算，计算开销大</td><td>必要时进行全量计算，计算开销相对较小</td></tr><tr><td>实时性</td><td>满足实时性</td><td>满足实时性</td></tr><tr><td>历史数据处理能力</td><td>批式全量处理，吞吐量大，历史据处理能力强</td><td>流式全量处理，吞吐量较低，历史数据处理能力较弱</td></tr></tbody></table><p><strong>Lambda架构与Kappa架构的设计选择</strong></p><p>根据两种架构对比分析，将业务需求、技术要求、系统复杂度、开发维护成本和历史数据处理能力作为选择考虑因素。而计算开销虽然存在一定差别，但是相差不是很大，所以不作为考虑因素。</p><p>（1）业务需求与技术要求<br>用户需要根据自己的业务需求来选择架构，如果业务对于 Hadoop、Spark、Strom 等关键技术有强制性依赖，选择 Lambda架构可能较为合适；如果处理数据偏好于流式计算，又依赖Flink计算引擎，那么选择Kappa架构可能更为合适。</p><p>（2）复杂度<br>如果项目中需要频繁地对算法模型参数进行修改， Lambda架构需要反复修改两套代码，则显然不如 Kappa架构简单方便。同时，如果算法模型支持同时执行批处理和流式计算，或者希望用一份代码进行数据处理，那么可以选择Kappa 架构。在某些复杂的案例中，其实时处理和离线处理的结果不能统一，比如某些机器学习的预测模型，需要先通过离线批处理得到训练模型，再交由实时流式处理进行验证测试，那么这种情况下，批处理层和流处理层不能进行合并，因此应该选择Lambda架构。</p><p>（3）开发维护成本<br>Lambda架构需要有一定程度的开发维护成本，包括两套系统的开发、部署、测试、维护，适合有足够经济、技术和人力资源的开发者。而Kappa 架构只需要维护一套系统，适合不希望在开发维护上投入过多成本的开发者。</p><p>（4）历史数据处理能力<br>有些情况下，项目会频繁接触海量数据集进行分析，比如过往十年内的地区降水数据等，这种数据适合批处理系统进行分析，应该选择Lambda架构。如果始终使用小规模数据集，流处理系统完全可以使用，则应该选择Kappa架构。</p>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>理论和实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>层次式架构设计理论与实践</title>
    <link href="/2023/07/22/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E7%90%86%E8%AE%BA%E5%92%8C%E5%AE%9E%E8%B7%B5/%E5%B1%82%E6%AC%A1%E5%BC%8F%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/07/22/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E7%90%86%E8%AE%BA%E5%92%8C%E5%AE%9E%E8%B7%B5/%E5%B1%82%E6%AC%A1%E5%BC%8F%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="1-层次式体系结构概述"><a href="#1-层次式体系结构概述" class="headerlink" title="1 层次式体系结构概述"></a>1 层次式体系结构概述</h2><p>软件体系结构可定义为：软件体系结构为软件系统提供了结构、行为和属性的高级抽象，由构成系统的元素描述、这些元素的相互作用、指导元素集成的模式以及这些模式的约束组成。软件体系结构不仅指定了系统的组织结构和拓扑结构，并且显示了系统需求和构成系统的元素之间的对应关系，提供了一些设计决策的基本原理，是构建于软件系统之上的系统级复用。</p><p>分层式体系结构是一种最常见的架构设计方法，能有效地使设计简化，使设计的系统机构清晰，便于提高复用能力和产品维护能力。层次式体系结构设计是将系统组成一个层次结构，每一层为上层服务，并作为下层客户。在一些层次系统中，除了一些精心挑选的输出函数外，内部的层接口只对相邻的层可见。连接件通过决定层间如何交互的协议来定义，拓扑约束包括对相邻层间交互的约束。由于每一层最多只影响两层，同时只要给相邻层提供相同的接口，允许每层用不同的方法实现，同样为软件<br>重用提供了强大的支持。</p><h2 id="2-表现层框架设计"><a href="#2-表现层框架设计" class="headerlink" title="2 表现层框架设计"></a>2 表现层框架设计</h2><h3 id="2-1-MVC模式"><a href="#2-1-MVC模式" class="headerlink" title="2.1 MVC模式"></a>2.1 MVC模式</h3><p>MVC是一种软件设计模式。MVC把一个应用的输入、处理、输出流程按照视图、控制、模型的方式进行分离，形成了控制器、模型、视图3个核心模块，其中：<br>（1）控制器（Controller）：接受用户的输入，并调用模型和视图去完成用户的需求。<br>（2）模型（Model）：应用程序的主体部分，表示业务数据和业务逻辑。<br>（3）视图（View）：用户看到并与之交流的界面。</p><p>如图，三者协作关系：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E5%B1%82%E6%AC%A1%E5%BC%8F%E6%9E%B6%E6%9E%84/1.png"></p><p>使用MVC模式来设计表现层，可以有以下优点：<br>（1）允许多种用户界面的扩展。<br>（2）易于维护。<br>（3）易于构件功能强大的用户界面。<br>（4）增加应用的可拓展性、强壮性、灵活性。</p><h3 id="2-2-MVP模式"><a href="#2-2-MVP模式" class="headerlink" title="2.2 MVP模式"></a>2.2 MVP模式</h3><p>在MVP模式中Model提供数据，View负责显示，Controller/Presenter负责逻辑处理。MVP不仅仅避免了View和Model之间的耦合，还进一步降低了Presenter对View的依赖。</p><p>如图，MVP设计模式：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E5%B1%82%E6%AC%A1%E5%BC%8F%E6%9E%B6%E6%9E%84/2.png"></p><p>使用MVP模式来设计表现层，可以有以下的优点：<br>（1）模型与视图完全分离，可以修改视图而不影响模型。<br>（2）所有的交互都发生在一个地方 - Presenter内部，因此可以更高效地使用模型。<br>（3）可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。因为视图的变化总是比模型的变化频繁。<br>（4）如果把逻辑放在Presenter中，就可以脱离用户接口来测试这些逻辑（单元测试）。</p><h3 id="2-3-MVVM模式"><a href="#2-3-MVVM模式" class="headerlink" title="2.3 MVVM模式"></a>2.3 MVVM模式</h3><p>MVVM和MVC、MVP类似，主要目的都是为了实现视图和模型的分离。不同的是MVVM中，View和Model的交互通过ViewModel来实现，也就是View和Model不能直接通信，两者的通信只能通过ViewModel来实现。ViewModel是MVVM的核心，通过DataBinding实现View与Model之间的双向绑定，其内容包括数据状态处理、数据绑定及数据转换。<br>如图，MVVM设计模式：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E5%B1%82%E6%AC%A1%E5%BC%8F%E6%9E%B6%E6%9E%84/3.png"></p><h2 id="3-中间层框架设计"><a href="#3-中间层框架设计" class="headerlink" title="3 中间层框架设计"></a>3 中间层框架设计</h2><h3 id="3-1-业务逻辑层组件设计"><a href="#3-1-业务逻辑层组件设计" class="headerlink" title="3.1 业务逻辑层组件设计"></a>3.1 业务逻辑层组件设计</h3><p>业务逻辑层组件分为接口和实现类两个部分。接口用于定义业务逻辑组件，定义业务逻辑组件必须实现的方法是整个系统运行的核心。通常按模块来设计业务逻辑组件，每个模块设计一个业务逻辑组件，并且每个业务逻辑组件以多个数据访问对象（Data Access Object，DAO）组件作为基线，从而实现对外提供系统的业务逻辑服务。</p><h3 id="3-2-业务逻辑层工作流设计"><a href="#3-2-业务逻辑层工作流设计" class="headerlink" title="3.2 业务逻辑层工作流设计"></a>3.2 业务逻辑层工作流设计</h3><p>工作流管理联盟（Workflow Management Coalition，WFMC）将工作流定义为：业务流程的全部或部分自动化，在此过程中，文档、信息或任务按照一定的过程规则流转，实现组织成员间的协调工作已达到业务的整体目标。</p><p>如图，工作流参考模型：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E5%B1%82%E6%AC%A1%E5%BC%8F%E6%9E%B6%E6%9E%84/4.png"></p><h3 id="3-3-业务逻辑层实体设计"><a href="#3-3-业务逻辑层实体设计" class="headerlink" title="3.3 业务逻辑层实体设计"></a>3.3 业务逻辑层实体设计</h3><p>逻辑层实体提供对业务数据及相关功能（在某些设计中）的状态编程访问。业务逻辑层实体可以使用具有复杂架构的数据构建，这种数据通常来自数据库中的多个相关表。业务逻辑层实体数据可以作为业务过程的部分I/O参数传递。业务逻辑层实体是可序列化的以保持他们的当前状态。</p><h3 id="3-4-业务逻辑层框架"><a href="#3-4-业务逻辑层框架" class="headerlink" title="3.4 业务逻辑层框架"></a>3.4 业务逻辑层框架</h3><p>业务逻辑框架位于系统架构的中间层，是实现系统功能的核心组件。采用容器的形式，便于系统功能的开发、代码重用和管理。在业务容器中，业务逻辑是按照Domain Model-Service-Contro思想来实现的。其中：<br>（1）Domain Model是仅仅包含业务相关的属性的领域层业务对象。<br>（2）Service是业务过程实现的组成部分，是应用程序的不同功能单元，通过在这些服务之间定义良好的接口和契约联系起来。<br>（3）Control服务控制器，是服务之间的纽带，不同服务之间的切换就是通过它来实现的。</p><h2 id="4-数据访问层框架设计"><a href="#4-数据访问层框架设计" class="headerlink" title="4 数据访问层框架设计"></a>4 数据访问层框架设计</h2><h3 id="4-1-数据访问模式"><a href="#4-1-数据访问模式" class="headerlink" title="4.1 数据访问模式"></a>4.1 数据访问模式</h3><p>（1）在线访问<br>（2）Data Access Object<br>（3）Data Transfer Object<br>（4）离线数据模式<br>（5）对象/关系映射</p><h3 id="4-2-工厂模式在数据访问层的应用"><a href="#4-2-工厂模式在数据访问层的应用" class="headerlink" title="4.2 工厂模式在数据访问层的应用"></a>4.2 工厂模式在数据访问层的应用</h3><p>这就需要在实际开发过程中将这些数据库访问类再作一次封装。经过这样的封装，不仅可以达到上述的目标，还可以减少操作数据库的步骤，减少代码编写量。工厂设计模式是使用的主要方法。</p><p>工厂模式定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。这里可能会处理对多种数据库的操作，因此，需要首先定义一个操纵数据库的接口，然后根据数据库的不同，由类工厂决定实例化哪个类。</p><h3 id="4-3-ORM，Hibernate与CMP2-0设计思想"><a href="#4-3-ORM，Hibernate与CMP2-0设计思想" class="headerlink" title="4.3 ORM，Hibernate与CMP2.0设计思想"></a>4.3 ORM，Hibernate与CMP2.0设计思想</h3><p>ORM(Object-Relation Mapping) 在关系型数据库和对象之间作一个映射，这样，在具体操纵数据库时，就不需要再去和复杂的 SQL语句打交道，只要像平时操作对象一样操作即可。当开发一个应用程序的时候(不使用OR Mapping), 可能会涉及许多数据访问层的代码，用来从数据库保存、删除和读取对象信息等，然而这些代码写起来总是重复的。一个更好的办法就是引入OR Mapping。 实质上，一个 OR Mapping会生成DAL。 与其自己写DAL代码，不如用OR Mapping, 开发者只需要关心对象就好。</p><h3 id="4-4-XML-Schema"><a href="#4-4-XML-Schema" class="headerlink" title="4.4 XML Schema"></a>4.4 XML Schema</h3><p>XML Schema用来描述XML文档合法结构、内容和限制。 XML Schema由XML 1.0 自描述，并且使用了命名空间，有丰富的内嵌数据类型及其强大的数据结构定义功能，充分地改造了并且极大地扩展了 DTDs (传统描述XML文档结构和内容限制的机制)的能力，将逐步替代DTDs, 成为 XML体系中正式的类型语言，同 XML 规范、 Namespace 规范一起成为XML体系的坚实基础。</p><h3 id="4-5-事务处理设计"><a href="#4-5-事务处理设计" class="headerlink" title="4.5 事务处理设计"></a>4.5 事务处理设计</h3><p>事务是现代数据库理论中的核心概念之一。如果一组处理步骤或者全部发生或者一步也不执行，我们称该组处理步骤为一个事务。当所有的步骤像一个操作一样被完整地执行，我们称该事务被提交。由于其中的一部分或多步执行失败，导致没有步骤被提交，则事务必须回滚(回到最初的系统状态)。事务必须服从 ISO/IEC所制定的ACID原则。 ACID是原子性(Atomicity)、 一致性(Consistency)、 隔离性 (Isolation) 和持久性 (Durability) 的缩写。事务的原子性表示事务执行过程中的任何失败都将导致事务所做的任何修改失效。一致性表示当事务执行失败时，所有被该事务影响的数据都应该恢复到事务执行前的状态。隔离性表示在事务执行过程中对数据的修改，在事务提交之前对其他事务不可见。持久性表示已提交的数据在事务执行失败时，数据的状态都应该正确。</p><h3 id="4-6-连接对象管理设计"><a href="#4-6-连接对象管理设计" class="headerlink" title="4.6 连接对象管理设计"></a>4.6 连接对象管理设计</h3><p>对于共享资源，有一个很著名的设计模式——资源池。该模式正是为了解决资源频繁分配、释放所造成的问题。把该模式应用到数据库连接管理领域，就是建立一个数据库连接池，提供一套高效的连接分配、使用策略。建立连接池的第一步，就是要建立一个静态的连接池。所谓静态，是指池中的连接是在系统初始化时就分配好的，并且不能够随意关闭。有了这个连接池，下面就可以提供一套自定义的分配、释放策略。当客户请求数据库连接时，首先看连接池中是否有未分配出去的连接。如果存在空闲连接则把连接分配给客户，并作相应处理。</p><h2 id="5-数据架构规划设计"><a href="#5-数据架构规划设计" class="headerlink" title="5 数据架构规划设计"></a>5 数据架构规划设计</h2><h3 id="5-1-数据库与类的设计融合"><a href="#5-1-数据库与类的设计融合" class="headerlink" title="5.1 数据库与类的设计融合"></a>5.1 数据库与类的设计融合</h3><p>对类和类之间关系的正确识别是数据模型的关键所在。本节将讨论如何发现、识别以及描述类。要想将建模过程缩减为一个简单的、逐步进行的过程是不太可能的。从本质上讲，建模是一项艺术。对一个给定的复杂情况而言，不存在唯一正确的数据模型，然而却存在好的数据模型。一个企业或机构的某个数据模型可能会优于另一个数据模型，但就如何为一个特定的系统建立数据模型，却没有唯一的解决方案。</p><p>好模型的目标是将工程项目整个生存期内的花费减至最小，同时也会考虑到随时间的推移系统将可能发生的变化，因而设计时也要考虑能适应这些变化。因此，将目光集中在最大限度地降低开发费用上是一个错误。</p><h3 id="5-2-数据库设计与XML设计融合"><a href="#5-2-数据库设计与XML设计融合" class="headerlink" title="5.2 数据库设计与XML设计融合"></a>5.2 数据库设计与XML设计融合</h3><p>XML文档分为两类：一类是以数据为中心的文档，这种文档在结构上是规则的，在内容上是同构的，具有较少的混合内容和嵌套层次，人们只关心文档中的数据而并不关心数据元素的存放顺序，这种文档简称为数据文档，它常用来存储和传输 Web 数据。另一类是以文档为中心的文档，这种文档的结构不规则，内容比较零散，具有较多的混合内容，并且元素之间的顺序是有关的，这种文档常用来在网页上发布描述性信息、产品性能介绍和 E-mail信息等。</p><p>XML文档的存储方式有两种：基于文件的存储方式和数据库存储方式。</p><h2 id="6-物联网层次架构设计"><a href="#6-物联网层次架构设计" class="headerlink" title="6 物联网层次架构设计"></a>6 物联网层次架构设计</h2><p>（1）感知层:<br>感知层用于识别物体、采集信息。感知层包括二维码标签和识读器、 RFID标签和读写器、摄像头、 GPS、 传感器、 M2M 终端、传感器网关等，主要功能是识别对象、采集信息，与人体结构中皮肤和五官的作用类似。</p><p>（2）网络层:<br>网络层用于传递信息和处理信息。网络层包括通信网与互联网的融合网络、网络管理中心、信息中心和智能处理中心等。网络层将感知层获取的信息进行传递和处理，类似于人体结构中的神经中枢和大脑。</p><p>（3）应用层：<br>应用层实现广泛智能化。应用层是物联网与行业专业技术的深度融合，结合行业需求实现行业智能化，这类似于人们的社会分工。</p>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>理论和实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云原生架构设计理论与实践</title>
    <link href="/2023/07/22/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E7%90%86%E8%AE%BA%E5%92%8C%E5%AE%9E%E8%B7%B5/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/07/22/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E7%90%86%E8%AE%BA%E5%92%8C%E5%AE%9E%E8%B7%B5/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="1-云原生架构内涵"><a href="#1-云原生架构内涵" class="headerlink" title="1 云原生架构内涵"></a>1 云原生架构内涵</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>云原生架构 是基于云原生技术的一组架构原则和设计模式的集合，旨在讲云应用中的非业务代码部分进行最大化地剥离，从而让云设施接管应用中原有的大量非功能特性（如弹性、韧性、安全、码部分进行最大化地剥离，从而让云设施接管应用中原有的大量非功能特性（如弹性、韧性、安全、可观测性、灰度等），使业务不再有非功能性业务中断困扰的同时，具备轻量、敏捷、高度自动化的特点。</p><h3 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h3><p>基于云原生架构的应用特点包括：</p><p>（1） 代码结构发生巨大变化：不再需要掌握文件及其分布式处理技术，不再需要掌握各种复杂的网络技术，简化让业务开发变得更敏捷、更快捷。<br>（2） 非功能特性大量委托给云原生架构来解决：比如高可用能力、容灾能力、安全特性、可运维性、易用性、可测试性、灰度发布能力等。<br>（3） 高度自动化的软件交付：基于云原生的自动化软件交付可以把应用自动化部署到成千上万的节点上。</p><h3 id="1-3-云原生的原则"><a href="#1-3-云原生的原则" class="headerlink" title="1.3 云原生的原则"></a>1.3 云原生的原则</h3><p>（1） 服务化原则：通过服务化架构把不同生命周期的模块分离出来，分别进行业务迭代。<br>（2） 弹性原则：弹性是指系统的部署规模可以随着业务量的变化而自动伸缩。<br>（3） 可观测原则：通过日志、链路跟踪和度量等手段，使得多次服务调用的耗时、返回值和参数都清晰可见。<br>（4） 韧性原则：软件所依赖的软硬件组件出现各种异常时，软件表现出来的抵御能力。<br>（5） 所有过程自动化原则：让自动化工具理解交付目标和环境差异，实现整个软件交付和运维的自动化。<br>（6） 零信任原则：不应该信任网络内部和外部的任何人/设备/系统，需要基于认证和授权重构访问控制的信任基础。<br>（7） 架构持续演进原则：架构具备持续演进的能力。</p><h3 id="1-4-主要架构模式"><a href="#1-4-主要架构模式" class="headerlink" title="1.4 主要架构模式"></a>1.4 主要架构模式</h3><h4 id="1-4-1-服务化架构模式"><a href="#1-4-1-服务化架构模式" class="headerlink" title="1.4.1 服务化架构模式"></a>1.4.1 服务化架构模式</h4><p>要求以应用模块为颗粒度划分一个应用软件，以接口契约（例如IDL）定义彼此业务关系，以标准协议（HTTP、gRPC等）确保彼此的互联互通，结合领域模型驱动（Domain Driven Design，DDD）、测试驱动开发（Test Driven Design，TDD）、容器化部署提升每个接口的代码质量和迭代速度。</p><h4 id="1-4-2-Mesh化架构模式"><a href="#1-4-2-Mesh化架构模式" class="headerlink" title="1.4.2 Mesh化架构模式"></a>1.4.2 Mesh化架构模式</h4><p>Mesh化架构是把中间件框架（如RPC、缓存、异步消息等）从业务进程中分离，让中间件SDK与业务代码进一步解耦，从而使得中间件升级对业务进程没有影响，甚至迁移到另外一个平台的中间件也对业务透明。</p><h4 id="1-4-3-Serverless模式"><a href="#1-4-3-Serverless模式" class="headerlink" title="1.4.3 Serverless模式"></a>1.4.3 Serverless模式</h4><p>业务流量到来/业务事件发生时，云会启动或调度一个已启动的业务进程进行处理，处理完成后云自动会关闭/调度业务进程，等待下一次触发。开发者不用关心应用运行地点、操作系统、网络配置、CPU性能等，将应用的整个运行都委托给云。Serverless模式适合事件驱动的数据计算任务、计算时间短的请求/响应应用、没有复杂相互调用的长周期任务。</p><h4 id="1-4-4-存储计算分离模式"><a href="#1-4-4-存储计算分离模式" class="headerlink" title="1.4.4 存储计算分离模式"></a>1.4.4 存储计算分离模式</h4><p>分布式环境中的CAP困难主要是针对有状态应用，由于一致性（Consistency，C），可用性（Available，A），分区容错性（Partition Tolerance，P）三者无法同时满足，最多满足其中两个。所以无状态应用不存在一致性这个维度，可以获得很好的可用性和分区容错性，因而获得更好的弹性。</p><h4 id="1-4-5-分布式事务模式"><a href="#1-4-5-分布式事务模式" class="headerlink" title="1.4.5 分布式事务模式"></a>1.4.5 分布式事务模式</h4><p>由于业务需要访问多个微服务，所以会带来分布式事务问题，否则数据就会出现不一致。因此架构师需要根据不同的场景选择合适的分布式事务模式，常用的有：<br>（1）XA模式：由于XA规范是实现分布式事务处理的标准，通常采用两阶段提交（2 Prepare Commit，2PC）的方法，具有很强的一致性，但是由于需要两次网络交互，所以性能差。<br>（2）基于消息的最终一致性（BASE）：在可用性和一致性相冲突的情况下，为了权衡二者，BASE提出只要满足基本可用（BA）和最终一致性（E），接受数据的软状态或未确定状态（S），来优先实现性能，所以这类系统通常具备很高的性能。但是由于应用的特点，选择可用性和一致性的妥协方案，导致通用性很差。<br>（3）TCC模式：采用Try-Confirm-Cancel二阶段模式，事务隔离行可控，高效，但需要应用代码将业务模型拆成二阶段，所以对业务侵入性强，设计开发维护等成本很高。<br>（4）SAGA模式：每个正向事务都对应一个补偿事务，若正向事务执行失败，则会执行补偿事务进行回滚。所以开发维护成本高。<br>（5）开源项目SEATA的AT模式：它将TCC模式中的二阶段委托给底层代码框架，并且取消了行锁，所以非常高性能且无代码开发工作量，且可以自动化执行回滚操作，但存在一些使用场景限制。</p><h4 id="1-4-6-可观测架构"><a href="#1-4-6-可观测架构" class="headerlink" title="1.4.6 可观测架构"></a>1.4.6 可观测架构</h4><p>可观测架构包括Logging、Tracing、Metrics，其中Logging提供多个级别跟踪，例如INFO/DEBUG/WARNING/ERROR；Tracing收集一个请求从前端到后端的访问日志聚合，形成完整调用链路跟踪；Metrics则提供对系统量化的多维度度量，包括并发度、耗时、可用时长、容量等。</p><h4 id="1-4-7-事件驱动架构"><a href="#1-4-7-事件驱动架构" class="headerlink" title="1.4.7 事件驱动架构"></a>1.4.7 事件驱动架构</h4><p>事件驱动架构（Event Driven Architecture，EDA）是一种应用/组件间的集成架构模式。适用于增强服务韧性、数据变化通知、构建开放式接口、事件流处理、命令查询的责任分离（Command Query Responsibility Segregation，CQRS）把服务状态有影响的命令用事件来发起，而对服务状态没有影响的查询才使用同步调用的API接口等。</p><h3 id="1-5-典型的云原生架构的反模式"><a href="#1-5-典型的云原生架构的反模式" class="headerlink" title="1.5 典型的云原生架构的反模式"></a>1.5 典型的云原生架构的反模式</h3><p>架构设计有时候需要根据不同的业务场景选择不同的方式，常见的云原生反模式有：</p><p>（1） 庞大的单体应用：缺乏依赖隔离，代码耦合，责任和模块边界不清晰，模块间接口缺乏治理，变更影响扩散，不同模块间的开发进度和发布时间难以协调，一个子模块不稳定导致整个应用都变慢，扩容时只能整体扩容而不能达到瓶颈的模块单独扩容等。<br>（2） 单体应用“硬拆”为微服务：强行把耦合度高、代码质量少的模块进行服务化拆分；拆分后服务的数据是紧密耦合的；差分后成为分布式调用，严重影响性能。<br>（3） 缺乏自动化能力的微服务：人均负责模块数上升，人均工作量增大，也增加了软件开发成本。</p><h2 id="2-云原生架构相关技术"><a href="#2-云原生架构相关技术" class="headerlink" title="2 云原生架构相关技术"></a>2 云原生架构相关技术</h2><h3 id="2-1-容器技术"><a href="#2-1-容器技术" class="headerlink" title="2.1 容器技术"></a>2.1 容器技术</h3><p><strong>容器</strong> 作为标准化软件基础单元，他<strong>将应用及其所依赖项打包发布，由于依赖项齐备，应用不再受环境限制，在不同计算环境间快读、可靠地运行</strong>。</p><h3 id="2-2-容器编排技术"><a href="#2-2-容器编排技术" class="headerlink" title="2.2 容器编排技术"></a>2.2 容器编排技术</h3><p><strong>容器编排技术</strong> 包括<strong>资源调度、应用部署与管理、自动修复、服务发现与负载均衡、弹性伸缩、声明式API、可扩展性架构、可移植性</strong>。</p><h3 id="2-3-微服务"><a href="#2-3-微服务" class="headerlink" title="2.3 微服务"></a>2.3 微服务</h3><p>微服务模式 将后端单体应用拆分为松耦合的多个子应用，每个子应用负责一组子功能。这些子应用成为“微服务”，多个“微服务”共同形成了一个物理独立但逻辑完整的分布式微服务体系。这写微服务相对独立，通过解耦研发、测试与部署流程，提高整体迭代效率。</p><p>微服务设计约束如下：</p><p><strong>（1）微服务个体约束</strong><br>一个设计良好的微服务应用，所完成的功能在业务域划分上应是相互独立的。与单体应用强行绑定语言和技术栈相比，这样做的好处是不同业务域有不同的技术选择权，比如推荐系统采用 Python实现效率可能比Java要高效得多。从组织上来说，微服务对应的团队更小，开发效率也更高。“一个微服务团队一顿能吃掉两张披萨饼”“一个微服务应用应当能至少两周完成一次迭代”,都是对如何正确划分微服务在业务域边界的隐喻和标准。总结来说，微服务的“微”并不是为了微而微，而是按照问题域对单体应用做合理拆分。进一步，微服务也应具备正交分解特性，在职责划分上专注于特定业务并将之做好，即SOLID原则中单一职责原则 (Single Responsibility Principle,SRP)。 如果当一个微服务修改或者发布时，不应该影响到同一系统里另一个微服务的业务交互。</p><p><strong>（2）微服务与微服务之间的横向关系</strong><br>在合理划分好微服务间的边界后，主要从微服务的可发现性和可交互性处理服务间的横向关系。微服务的可发现性是指当服务A 发布和扩缩容的时候，依赖服务 A 的服务B 如何在不重新发布的前提下，如何能够自动感知到服务A 的变化?这里需要引入第三方服务注册中心来满足服务的可发现性；特别是对于大规模微服务集群，服务注册中心的推送和扩展能力尤为关键。微服务的可交互性是指服务A 采用什么样的方式可以调用服务 B。 由于服务自治的约束，服务之间的调用需要采用与语言无关的远程调用协议，比如 REST 协议很好地满足了“与语言无关”和“标准化”两个重要因素，但在高性能场景下，基于 IDL的二进制协议可能是更好的选择。另外，目前业界大部分微服务实践往往没有达到HATEOAS启发式的 REST 调用，服务与服务之间需要通过事先约定接口来完成调用。为了进一步实现服务与服务之间的解耦，微服务体系中需要有一个独立的元数据中心来存储服务的元数据信息，服务通过查询该中心来理解发起调用的细节。伴随着服务链路的不断变长，整个微服务系统也就变得越来越脆弱，因此面向失败<br>设计的原则在微服务体系中就显得尤为重要。对于微服务应用个体，限流、熔断、隔仓、负载均衡等增强服务韧性的机制成为了标配。为进一步提升系统吞吐能力、充分利用好机器资源，可以通过协程、 R x模型、异步调用、反压等手段来实现。</p><p><strong>（3）微服务与数据层之间的纵向约束</strong></p><p>在微服务领域，提侣数据存储隔离 (Data Storage Segregation,DSS) 原则，即数据是微服务的私有资产，对于该数据的访问都必须通过当前微服务提供的API来访问。如若不然，则造成数据层产生耦合，违背了高内聚低耦合的原则。同时，出于性能考虑，通常采取读写分离(CQRS) 手段。同样，由于容器调度对底层设施稳定性的不可预知影响，微服务的设计应当尽量遵循无状态设计原则，这意味着上层应用与底层基础设施的解耦，微服务可以自由在不同容器间被调度。对于有数据存取(即有状态)的微服务而言，通常使用计算与存储分离方式，将数据下沉到分布式存储，通过这个方式做到一定程度的无状态化。</p><p><strong>（4）全局视角下的微服务分布式约束</strong><br>从微服务系统设计一开始，就需要考虑以下因素：高效运维整个系统，从技术上要准备全自动化的CI/CD流水线满足对开发效率的诉求，并在这个基础上支持蓝绿、金丝雀等不同发布策略，以满足对业务发布稳定性的诉求。面对复杂系统，全链路、实时和多维度的可观测能力成为标配。为了及时、有效地防范各类运维风险，需要从微服务体系多种事件源汇聚并分析相关数据，然后在中心化的监控系统中进行多维度展现。伴随着微服务拆分的持续，故障发现时效性和根因精确性始终是开发运维人员的核心诉求。</p><h3 id="2-4-无服务技术"><a href="#2-4-无服务技术" class="headerlink" title="2.4 无服务技术"></a>2.4 无服务技术</h3><p>无服务技术的特点：</p><p>(1)全托管的计算服务，客户只需要编写代码构建应用，无需关注同质化的、负担繁重的基于服务器等基础设施的开发、运维、安全、高可用等工作；</p><p>(2)通用性，结合云 BaaSAPI的能力，能够支撑云上所有重要类型的应用；</p><p>(3)自动弹性伸缩，让用户无需为资源使用提前进行容量规划；</p><p>(4)按量计费，让企业使用成本得有效降低，无需为闲置资源付费。</p><h3 id="2-5-服务网格"><a href="#2-5-服务网格" class="headerlink" title="2.5 服务网格"></a>2.5 服务网格</h3><p>服务网格 (ServiceMesh) 是分布式应用在微服务软件架构之上发展起来的新技术，旨在将那些微服务间的连接、安全、流量控制和可观测等通用功能下沉为平台基础设施，实现应用与平台基础设施的解耦 。这个解耦意味着开发者无需关注微服务相关治理问题而聚焦于业务逻辑本身，提升应用开发效率并加速业务探索和创新。换句话说，因为大量非功能性从业务进程剥离到另外进程中，服务网格以无侵入的方式实现了应用轻量化。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%9E%B6%E6%9E%84/1.png"></p><p><strong>在这张架构图中，服务A 调用服务B 的所有请求，都被其下的服务代理截获，代理服务A 完成到服务B 的服务发现、熔断、限流等策略，而这些策略的总控是在控制平面 (Control Plane) 上配置。</strong></p>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>理论和实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安全架构设计理论与实践</title>
    <link href="/2023/07/22/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E7%90%86%E8%AE%BA%E5%92%8C%E5%AE%9E%E8%B7%B5/%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/07/22/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E7%90%86%E8%AE%BA%E5%92%8C%E5%AE%9E%E8%B7%B5/%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="1-信息安全面临的威胁"><a href="#1-信息安全面临的威胁" class="headerlink" title="1 信息安全面临的威胁"></a>1 信息安全面临的威胁</h2><h3 id="1-1-信息系统安全威胁的来源"><a href="#1-1-信息系统安全威胁的来源" class="headerlink" title="1.1 信息系统安全威胁的来源"></a>1.1 信息系统安全威胁的来源</h3><p>威胁可以来源于物理环境、通信链路、网络系统、操作系统、应用系统、管理系统。</p><h3 id="1-2-网络与信息安全风险类别"><a href="#1-2-网络与信息安全风险类别" class="headerlink" title="1.2 网络与信息安全风险类别"></a>1.2 网络与信息安全风险类别</h3><p>网络与信息安全风险类别可分为认为蓄意破坏（被动攻击，主动攻击）、灾害性攻击、系统故障、人员无意识行为。<br>如图，网络与信息安全的风险类别：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/1.png"></p><h3 id="1-3-常见的安全威胁"><a href="#1-3-常见的安全威胁" class="headerlink" title="1.3 常见的安全威胁"></a>1.3 常见的安全威胁</h3><p>(1) 信息泄露 ：信息被泄露或透露给某个非授权的实体。</p><p>(2) 破坏信息的完整性 ：数据被非授权地进行增删、修改或破坏而受到损失。</p><p>(3) 拒绝服务 ：对信息或其他资源的合法访问被无条件地阻止。</p><p>(4) 非法使用(非授权访问) :某一资源被某个非授权的人或以非授权的方式使用。</p><p>(5) 窃听 ：用各种可能的合法或非法的手段窃取系统中的信息资源和敏感信息。例如对通信线路中传输的信号进行搭线监听，或者利用通信设备在工作过程中产生的电磁泄漏截取有用信息等。</p><p>(6) 业务流分析 ：通过对系统进行长期监听，利用统计分析方法对诸如通信频度、通信的信息流向、通信总量的变化等态势进行研究，从而发现有价值的信息和规律。</p><p>(7) 假冒 ：通过欺骗通信系统(或用户)达到非法用户冒充成为合法用户，或者特权小的用户冒充成为特权大的用户的目的。黑客大多是采用假冒进行攻击。</p><p>(8) 旁路控制 ：攻击者利用系统的安全缺陷或安全性上的脆弱之处获得非授权的权利或特权。例如，攻击者通过各种攻击手段发现原本应保密，但是却又暴露出来的一些系统“特性”。利用这些“特性”,攻击者可以绕过防线守卫者侵入系统的内部。</p><p>(9) 授权侵犯 ：被授权以某一目的使用某一系统或资源的某个人，却将此权限用于其他非授权的目的，也称作“内部攻击”。</p><p>(10) 特洛伊木马 ：软件中含有一个察觉不出的或者无害的程序段，当它被执行时，会破坏用户的安全。这种应用程序称为特洛伊木马 。</p><p>(11) 陷阱门 ：在某个系统或某个部件中设置了“机关”,使得当提供特定的输入数据时，允许违反安全策略。</p><p>(12) 抵赖 ：这是一种来自用户的攻击，例如，否认自己曾经发布过的某条消息、伪造一份对方来信等。</p><p>(13) 重放 ：所截获的某次合法的通信数据备份，出于非法的目的而被重新发送。</p><p>(14) 计算机病毒 ：所谓计算机病毒，是一种在计算机系统运行过程中能够实现传染和侵害的功能程序。一种病毒通常含有两个功能：一种功能是对其他程序产生“感染”;另外一种或者是引发损坏功能或者是一种植入攻击的能力。</p><p>(15) 人员渎职 ：一个授权的人为了钱或利益、或由于粗心，将信息泄露给一个非授权的人。</p><p>(16) 媒体废弃 ：信息被从废弃的磁盘或打印过的存储介质中获得。</p><p>(17) 物理侵入 ：侵入者通过绕过物理控制而获得对系统的访问。</p><p>(18) 窃取 ：重要的安全物品，如令牌或身份卡被盗。</p><p>(19) 业务欺骗 ：某一伪系统或系统部件欺骗合法的用户或系统自愿地放弃敏感信息。</p><h2 id="2-安全体系架构的范围"><a href="#2-安全体系架构的范围" class="headerlink" title="2 安全体系架构的范围"></a>2 安全体系架构的范围</h2><h3 id="2-1-安全架构的范围"><a href="#2-1-安全架构的范围" class="headerlink" title="2.1 安全架构的范围"></a>2.1 安全架构的范围</h3><p>安全架构是架构面向安全性方向上的一种细分，比如细分领域含有运维架构、数据库架构等。如果安全性体现在产品上，那么， 通常的产品安全架构、安全技术体系架构和审计架构可组成三道安全防线 。</p><p>(1) 产品安全架构 ：构建产品安全质量属性的主要组成部分以及它们之间的关系。产品安全架构的目标是如何在不依赖外部防御系统的情况下，从源头打造自身安全的产品。</p><p>(2) 安全技术体系架构 ：构建安全技术体系的主要组成部分以及它们之间的关系。安全技术体系架构的任务是构建通用的安全技术基础设施，包括安全基础设施、安全工具和技术、安全组件与支持系统等，系统性地增强各产品的安全防御能力。</p><p>(3) 审计架构 ：独立的审计部门或其所能提供的风险发现能力，审计的范围主要包括安全风险在内的所有风险。</p><h3 id="2-2-安全架构的特性"><a href="#2-2-安全架构的特性" class="headerlink" title="2.2 安全架构的特性"></a>2.2 安全架构的特性</h3><p>安全架构应具备可用性、完整性和机密性等特性 。</p><ol><li>可用性 (Availability) 是指要防止系统的数据和资源丢失；</li><li>完整性(Integrity) 是指要防止系统的数据和资源在未经授权情况下被修改；</li><li>机密性 (Confidentiality) 是指要防止系统的数据和资源在未授权的情况下被披露。</li></ol><h3 id="2-3-安全技术架构"><a href="#2-3-安全技术架构" class="headerlink" title="2.3 安全技术架构"></a>2.3 安全技术架构</h3><p>安全架构设计可以从安全技术的角度考虑，<br>主要包括：<strong>身份鉴别、访问控制、内容安全、冗余恢复、审计响应、恶意代码防范和密码技术</strong> 等。</p><h2 id="3-与信息安全相关的国内外标准及组织"><a href="#3-与信息安全相关的国内外标准及组织" class="headerlink" title="3 与信息安全相关的国内外标准及组织"></a>3 与信息安全相关的国内外标准及组织</h2><h3 id="3-1-国外标准"><a href="#3-1-国外标准" class="headerlink" title="3.1 国外标准"></a>3.1 国外标准</h3><p>(1)可信计算机系统评估准则 (Trusted Computer System Evaluation Criteria,TCSEC), 也称为“橘皮书”,1985年12月由美国国防部公布。<br>(2)信息技术安全评估准则 (Information Technology Security Evaluation Criteria,ITSEC),英、法、德、荷四国联合编制。<br>(3)加拿大可信计算机产品评估准则 (Canadian Trusted Computer Product Evaluation Criteria,CTCPEC), 加拿大，1993年。<br>(4)美国联邦准则 (FC),TCSEC 的升级版，美国，1992年。<br>(5)信息技术安全性评价通用准则 (The Common Criteria for Information Technology Security Evaluation), 由美国国家安全局和国家技术标准研究所联合加、英、法、德、荷等国编制，1993年。<br>(6)ISO/IEC 7498-2, 信息处理系统，开放系统互联，基本参考模型。第2部分：安全结构 (Information Processing System; Open System Intercommection; base reference model;Part2:SecurityArchitecture), 由国际标准化组织 (ISO) 发布，1989年。<br>(7)信息保障技术框架 (Infornation Assurance Technical Framework,IATF), 由美国国家安全局 (NSA) 发布，1999年。<br>(8)ISO/IEC 15408-1999, 信息技术安全技术信息技术安全性评估准则，替代原C C 标准。由国际标准化组织 (ISO) 发布，1999年。<br>(9)IEC 61508-2010, 电气/电子/可编程电子安全系统的功能安全 (Functional safety of electrical/ electronic/ programmable electronic safety-related systems), 由国际电工委员会发布，2010年。</p><h3 id="3-2-国内标准"><a href="#3-2-国内标准" class="headerlink" title="3.2 国内标准"></a>3.2 国内标准</h3><p>1)标准缩写含义<br>(1)GA: 国家安全行业标准规范。由中国安全技术防范认证中心组织发布。<br>(2)GB: 国家标准规范，由中国国家标准化管理委员会组织发布。<br>(3)GJB: 国家军用标准规范。</p><p>2)主要技术标准</p><p>(1)GB 15834-1995 信息处理数据加密实体鉴别机制。<br>(2)GA163-1997 计算机信息系统安全专用产品分类原则。<br>(3)GB17859-1999计算机信息系统安全保护等级划分准则。<br>(4)GB/T 9387.2-1995 信息处理系统开放系统互连基本参考模型第2部分：安全体系结构。<br>(5)GB/T 20269-2006信息安全技术信息系统安全管理要求。<br>(6)GB/T 20270-2006信息安全技术网络基础安全技术要求。<br>(7)GB/T 20271-2006信息安全技术信息系统通用安全技术要求。<br>(8)GB/T20272-2006信息安全技术操作系统安全技术要求。<br>(9)GB/T20273-2006信息安全技术数据库管理系统安全技术要求。<br>(10)GB/T 20274.1-2006 信息安全技术信息系统安全保障评估框。<br>(11)GB/T 18231-2000信息系统低层安全。<br>(12)GB/T 18237.1-2000信息技术开放系统互联通用高层第1部分：概述、模型和记法。<br>(13)GB/T 18237.2-2000信息技术开放系统互联通用高层第2部分：安全交换服务元素服务定义。<br>(14)GB/T18336-2015 信息系统信息技术安全评估准则。<br>(15)GB/T 20438.1~7-2017 电气/电子/可编程电子安全相关系统的功能安全，由中国国家标准化管理委员会发布。</p><h3 id="3-3-相关标准化组织"><a href="#3-3-相关标准化组织" class="headerlink" title="3.3 相关标准化组织"></a>3.3 相关标准化组织</h3><ul><li>(1)国际标准化组织 (ISO)</li><li>(2)国际电工委员会 (IEC)</li><li>(3)中国国家标准化管理委员会 (SAC)</li><li>(4)全国信息技术标准化技术委员</li></ul><h2 id="4-安全模型"><a href="#4-安全模型" class="headerlink" title="4 安全模型"></a>4 安全模型</h2><h3 id="4-1-信息系统的安全目标"><a href="#4-1-信息系统的安全目标" class="headerlink" title="4.1 信息系统的安全目标"></a>4.1 信息系统的安全目标</h3><p>信息系统的安全目标是控制和管理主体(含用户和进程)对客体(含数据和程序)的访问 。作为信息系统安全目标，就是要实现：</p><ol><li>保护信息系统的可用性；</li><li>保护网络系统服务的连续性；</li><li>防范资源的非法访问及非授权访问；</li><li>防范入侵者的恶意攻击与破坏；</li><li>保护信息通过网上传输过程中的机密性、完整性；</li><li>防范病毒的侵害；</li><li>实现安全管理。</li></ol><h3 id="4-2-典型的安全模型"><a href="#4-2-典型的安全模型" class="headerlink" title="4.2 典型的安全模型"></a>4.2 典型的安全模型</h3><h4 id="4-2-1-状态机模型"><a href="#4-2-1-状态机模型" class="headerlink" title="4.2.1 状态机模型"></a>4.2.1 状态机模型</h4><p><strong>状态机模型，</strong> <strong>一个安全状态模型系统，总是从一个安全状态启动，并且在所有迁移中保持安全状态，只允许主体以和安全策略相一致的安全访问资源。</strong></p><h4 id="4-2-2-BLP模型"><a href="#4-2-2-BLP模型" class="headerlink" title="4.2.2 BLP模型"></a>4.2.2 BLP模型</h4><p><strong>BLP模型（Bell-LaPadula Model）。该模型为数据规划机密性，依据机密性划分安全级别，按安全级别强制访问控制。</strong></p><h5 id="4-2-2-1-基本原理"><a href="#4-2-2-1-基本原理" class="headerlink" title="4.2.2.1 基本原理"></a>4.2.2.1 基本原理</h5><p>（1）<strong>安全级别是“机密”的主体访问安全级别为“绝密”的客体时，主体对客体可写不可读。</strong><br>（2）<strong>安全级别是“机密”的主体访问安全级别为“机密”的客体时，主体对客体可写可读。</strong><br>（3）<strong>安全级别是“机密”的主体访问安全级别为“秘密”的客体时，主体对客体可读不可写。</strong></p><h5 id="4-2-2-2-安全规则"><a href="#4-2-2-2-安全规则" class="headerlink" title="4.2.2.2 安全规则"></a>4.2.2.2 安全规则</h5><p>（1）简单安全规则 (Simple Security Rule): 安全级别低的主体不能读安全级别高的客体(No Read Up);<br>（2）星属性安全规则 (Star Security Property): 安全级别高的主体不能往低级别的客体写(No Write Down);<br>（3）强星属性安全规则 (Strong Star Security Property): 不允许对另一级别进行读写；<br>（4）自主安全规则 (Discretionary Security Property): 使用访问控制矩阵来定义说明自由存取控制。其存取控制体现在内容相关和上下文相关。</p><h4 id="4-2-3-Biba模型"><a href="#4-2-3-Biba模型" class="headerlink" title="4.2.3 Biba模型"></a>4.2.3 Biba模型</h4><p><strong>Biba 模型不关心信息机密性的安全级别，因此它的访问控制不是建立在安全级别上，而是建立在完整性级别上。</strong></p><p>完整性的三个目标：<br>（1）<strong>保护数据不被未授权用户更改</strong> ；<br>（2）<strong>保护数据不被授权用户越权修改(未授权更改)</strong> ;<br>（3）<strong>维持数据内部和外部的一致性</strong> 。</p><h5 id="4-2-3-1-基本原理"><a href="#4-2-3-1-基本原理" class="headerlink" title="4.2.3.1 基本原理"></a>4.2.3.1 基本原理</h5><p>（1）当完整性级别为“中完整性”的主体访问完整性为“高完整性”的客体时，主体对客体可读不可写 (No Write Up), 也不能调用主体的任何程序和服务 ；</p><p>（2）当完整性级别为“中完整性”的主体访问完整性为“中完整性”的客体时，主体对客体可读读可写 ；</p><p>（3）当完整性级别为“中完整性”的主体访问完整性为“低完整性”的客体时，主体对客体可写不可读； (No Read Down) ;</p><h5 id="4-2-3-2-安全规则"><a href="#4-2-3-2-安全规则" class="headerlink" title="4.2.3.2 安全规则"></a>4.2.3.2 安全规则</h5><p>Biba模型能够防止数据从低完整性级别流向高完整性级别 ，其安全规则如下：</p><p>（1）星完整性规则(*-integrity Axiom): 表示完整性级别低的主体不能对完整性级别高的客体写数据；</p><p>（2）简单完整性规则 (Simple Integrity Axiom): 表示完整性级别高的主体不能从完整性级别低的客体读取数据；</p><p>（3）调用属性规则 (Invocation Property): 表示一个完整性级别低的主体不能从级别高的客体调用程序或服务。</p><h4 id="4-2-4-CWM模型"><a href="#4-2-4-CWM模型" class="headerlink" title="4.2.4 CWM模型"></a>4.2.4 CWM模型</h4><p>CWM模型（Clark-Wilson Model）。将完整性目标、策略、机制融为一体，提出职责分离目标，应用完整性验证过程，实现了成型的事务处理机制，常用于银行系统。CWM模型具有以下特征：</p><p>（1）包含主体、程序、客体三元素，主体只能通过程序访问客体。<br>（2）权限分离原则，功能可分为多主体，防止授权用户进行未授权修改。<br>（3）具有审计能力。</p><h4 id="4-2-5-Chinese-Wall模型"><a href="#4-2-5-Chinese-Wall模型" class="headerlink" title="4.2.5 Chinese Wall模型"></a>4.2.5 Chinese Wall模型</h4><p><strong>Chinese Wall模型，是一个混合策略模型，应用于多边安全系统，防止多安全域存在潜在的冲突。该模型为投资银行设计，常见于金融领域。</strong></p><h5 id="4-2-5-1-工作原理"><a href="#4-2-5-1-工作原理" class="headerlink" title="4.2.5.1 工作原理"></a>4.2.5.1 工作原理</h5><p><strong>通过自主访问控制（DAC）选择安全域，通过强制访问控制（MAC）完成特定安全域内访问控制。</strong></p><h5 id="4-2-5-2-安全规则"><a href="#4-2-5-2-安全规则" class="headerlink" title="4.2.5.2 安全规则"></a>4.2.5.2 安全规则</h5><p>（1）<strong>墙内客体可读取。</strong><br>（2）<strong>不同利益冲突组客体可读取。</strong><br>（3）<strong>访问其他公司客体和其他利益冲突组客体后，主体对客体写入受限。</strong></p><h2 id="5-信息安全整体架构设计（WPDRRC模型）"><a href="#5-信息安全整体架构设计（WPDRRC模型）" class="headerlink" title="5 信息安全整体架构设计（WPDRRC模型）"></a>5 信息安全整体架构设计（WPDRRC模型）</h2><h3 id="5-1-WPDRRC信息安全体系架构模型"><a href="#5-1-WPDRRC信息安全体系架构模型" class="headerlink" title="5.1 WPDRRC信息安全体系架构模型"></a>5.1 WPDRRC信息安全体系架构模型</h3><p>WPDRRC(Waring/Protect/Detect/React/Restore/Counterattack) 信息安全模型是我国“八六三”信息安全专家组提出的适合中国国情的信息系统安全保障体系建设模型。 WPDRRC是在PDRR(Protect/Detect/React/React/Restore) 信息安全体系模型的基础上前后增加了预警和反击功能。针对网络安全防护问题，美国曾提出了多个网络安全体系模型和架构，其中比较经典的包括PDRR模型、P2DR模型。</p><p>而 WPDRRC模型由中国提出。在PDRR模型中，安全的概念已经从信息安全扩展到了信息保障，信息保障内涵已超出传统的信息安全保密，它是保护 (Protect)、 检测 (Detect)、 反应 (React)、 恢复 (Restore) 的有机结合，称为 PDRR模型。PDRR模型把信息的安全保护作为基础，将保护视为活动过程，要用检测手段来发现安全漏洞，及时更正；同时采用应急响应措施对付各种入侵；在系统被入侵后，要采取相应的措施将系统恢复到正常状态，这样才能使信息的安全得到全方位的保障。该模型强调的是自动故障恢复能力。</p><p><strong>WPDRRC模型有6个环节和3大要素 。</strong></p><ol><li><strong>6个环节</strong> 包括：预警、保护、检测、响应、恢复和反击 ，它们具有较强的时序性和动态性，能够较好地反映出信息系统安全保障体系的预警能力、保护能力、检测能力、响应能力、恢复能力和反击能力。</li><li><strong>3大要素</strong> 包括：人员、策略和技术 。人员是核心，策略是桥梁，技术是保证，落实在WPDRRC 的6个环节的各个方面，将安全策 预警略变为安全现实。</li></ol><p><strong>这里，6个环节说明如下：</strong></p><p>● W : 预警主要是指利用远程安全评估系统提供的模拟攻击技术来检查系统存在的、可能被利用的薄弱环节，收集和测试网络与信息的安全风险所在，并以直观的方式进行报告，提供解决方案的建议，在经过分析后，分解网络的风险变化趋势和严重风险点，从而有效降低网络的总体风险，保护关键业务和数据。</p><p>● P : 防护通常是通过采用成熟的信息安全技术及方法来实现网络与信息的安全。主要内容有加密机制，数字签名机制，访问控制机制，认证机制，信息隐藏和防火墙技术等。</p><p>● D : 检测通过检测和监控网络以及系统，来发现新的威胁和弱点，强制执行安全策略。在这个过程中采用入侵检测、恶意代码过滤等技术，形成动态检测的制度，奖励报告协调机制，提高检测的实时性。主要内容有入侵检测，系统脆弱性检测，数据完整性检测和攻击性检测等。</p><p>● R : 响应是指在检测到安全漏洞和安全事件之后必须及时做出正确的响应，从而把系统调整到安全状态。为此需要相应的报警、跟踪、处理系统，其中处理包括了封堵、隔离、报告等能力。主要内容有应急策略、应急机制、应急手段、入侵过程分析和安全状态评估等。</p><p>● R : 恢复灾难恢复系统是当前网络、数据、服务受到黑客攻击并遭到破坏或影响后，通过必要技术手段，在尽可能短的时间内使系统恢复正常。主要内容有容错、冗余、备份、替换、修复和恢复等。</p><p>● C : 反击是指采用一切可能的高新技术手段，侦察、提取计算机犯罪分子的作案线索与犯罪证据，形成强有力的取证能力和依法打击手段。</p><h3 id="5-2-信息安全体系架构设计"><a href="#5-2-信息安全体系架构设计" class="headerlink" title="5.2 信息安全体系架构设计"></a>5.2 信息安全体系架构设计</h3><p>通过对网络应用的全面了解，按照安全风险、需求分析结果、安全策略以及网络的安全目标等方面开展安全体系架构的设计工作。具体在安全控制系统，我们可以从 物理安全、系统安全、网络安全、应用安全和管理安全 等5个方面开展分析和设计工作。</p><p>物理安全（前提）：包括环境安全、设备安全、媒体安全。<br>系统安全（基础）：包括网络结构安全、操作系统安全、应用系统安全。<br>网络安全（关键）：包括访问控制、通信保密、入侵检测、网络安全扫描、防病毒。<br>应用安全：包括资源共享、信息存储。<br>安全管理：包括健全的体制、管理平台、人员安全防范意识。</p><h2 id="6-网络安全架构设计"><a href="#6-网络安全架构设计" class="headerlink" title="6 网络安全架构设计"></a>6 网络安全架构设计</h2><h3 id="6-1-OSI安全架构"><a href="#6-1-OSI安全架构" class="headerlink" title="6.1 OSI安全架构"></a>6.1 OSI安全架构</h3><p>OSI 定义了7层协议，其中除第5层(会话层)外，每一层均能提供相应的安全服务。实际上，最适合配置安全服务的是在物理层、网络层、运输层及应用层上，其他层都不宜配置安全服务。</p><p>OSI开放系统互联安全体系的 5类安全服务 包括 鉴别、访问控制、数据机密性、数据完整性和抗抵赖性。</p><p>如下，信息安全体系结构示意图：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/2.png"></p><p><strong>如下，安全服务和安全机制的对应关系：</strong></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/3.png"></p><p><strong>OSI 定义分层多点安全技术体系架构 ，也称为 深度防御安全技术体系架构 ，它通过以下 三种方式将防御能力分布至整个信息系统中 。</strong></p><p><strong>（1）多点技术防御</strong><br>在对手可以从内部或外部多点攻击一个目标的前提下，多点技术防御通过对以下多个防御核心区域的防御达到抵御所有方式的攻击目的。<br>通过网络和基础设施，边界防御（流量过滤、控制、如前检测），计算环境等方式进行防御。<br>(1)网络和基础设施。为了确保可用性，局域网和广域网需要进行保护以抵抗各种攻击，如拒绝服务攻击等。为了确保机密性和完整性，需要保护在这些网络上传送的信息以及流量的特征以防止非故意的泄露。<br>(2)边界。为了抵御主动的网络攻击，边界需要提供更强的边界防御，例如流量过滤和控制以及入侵检测。<br>(3)计算环境。为了抵御内部、近距离的分布攻击，主机和工作站需要提供足够的访问控制。</p><p><strong>（2）分层技术防御</strong><br>即使最好的可得到的信息保障产品也有弱点，其最终结果将使对手能找到一个可探查的脆弱性，一个有效的措施是在对手和目标间使用多个防御机制。为了减少这些攻击成功的可能性和对成功攻击的可承担性，每种机制应代表一种唯一的障碍并同时包括保护和检测方法。例如，在外部和内部边界同时使用嵌套的防火墙并配合以入侵检测就是分层技术防御的一个实例。<br>外部和内部边界使用嵌套防火墙，配合入侵检测进行防御。</p><p><strong>（3）支撑性基础设施</strong><br>支撑性基础设施为网络、边界和计算环境中信息保障机制运行基础的支撑性基础设施，包括公钥基础设施以及检测和响应基础设施。<br>使用公钥基础设施以及检测和响应基础设施进行防御。<br>(1)公钥基础设施。提供一种通用的联合处理方式，以便安全地创建、分发和管理公钥证书和传统的对称密钥，使它们能够为网络、边界和计算环境提供安全服务。这些服务能够对发送者和接收者的完整性进行可靠验证，并可以避免在未获授权的情况下泄露和更改信息。公钥基础设施必须支持受控的互操作性，并与各用户团体所建立的安全策略保持一致。<br>(2)检测和响应基础设施。检测和响应基础设施能够迅速检测并响应入侵行为。它也提供便于结合其他相关事件观察某个事件的“汇总”性能。另外，它也允许分析员识别潜在的行为模式或新的发展趋势。</p><h3 id="6-2-认证框架"><a href="#6-2-认证框架" class="headerlink" title="6.2 认证框架"></a>6.2 认证框架</h3><p>鉴权(Authentication) 的基本目的是防止其他实体占用和独立操作被鉴别实体的身份。鉴别提供了实体声称其身份的保证，只有在主体和验证者的关系背景下，鉴别才是有意义的。鉴别有两种重要的关系背景：一是实体由申请者来代表，申请者与验证者之间存在着特定的通信关系(如实体鉴别);二是实体为验证者提供数据项来源。</p><p>鉴别的方式主要基于以下5种：</p><p>（1）已知的，如一个秘密的口令。<br>（2）拥有的，如 I C卡、令牌等。<br>（3）不改变的特性，如生物特征。<br>（4）相信可靠的第三方建立的鉴别(递推)。<br>（5）环境(如主机地址等)。</p><p>鉴别服务分为以下阶段：安装阶段、修改鉴别信息阶段、分发阶段、获取阶段、传送阶段、验证阶段、停活阶段、重新激活阶段、取消安装阶段。</p><h3 id="6-3-访问控制框架"><a href="#6-3-访问控制框架" class="headerlink" title="6.3 访问控制框架"></a>6.3 访问控制框架</h3><p>当发起者请求对目标进行特殊访问时，访问控制管制设备（Access Control Enforcement Facilities，AEF）就通知访问控制决策设备（Access Control Decision Facilities，ADF），ADF可以根据上下文信息（包括发起者的位置、访问时间或使用中的特殊通信路径）以及可能还有以前判决中保留下来的访问控制决策信息（Access Control Descision Information，ADI）做出允许或禁止发起者试图对目标进行访问的判决</p><h3 id="6-4-机密性框架"><a href="#6-4-机密性框架" class="headerlink" title="6.4 机密性框架"></a>6.4 机密性框架</h3><p><strong>完整性服务目的</strong>是 <strong>确保信息仅仅是对被授权者可用。</strong></p><p><strong>机密性机制</strong>包括： <strong>通过禁止访问提供机密性、通过加密提供机密性。</strong></p><h3 id="6-5-完整性框架"><a href="#6-5-完整性框架" class="headerlink" title="6.5 完整性框架"></a>6.5 完整性框架</h3><p><strong>完整性服务目的</strong>是 <strong>组织威胁或探测威胁，保护数据及其相关属性的完整性。</strong></p><p><strong>完整性服务分类</strong>有： <strong>未授权的数据创建、数据创建、数据删除、数据重放。</strong></p><p><strong>完整性机制类型</strong>分为 <strong>阻止媒体访问与探测非授权修改两种。</strong></p><h3 id="6-6-抗抵赖框架"><a href="#6-6-抗抵赖框架" class="headerlink" title="6.6 抗抵赖框架"></a>6.6 抗抵赖框架</h3><p><strong>抗抵赖服务的目的</strong>是 <strong>提供特定事件或行为的证据。</strong></p><p><strong>抗抵赖服务阶段</strong>分为： <strong>证据生成、证据传输、存储及回复、证据验证、解决纠纷这5个阶段。</strong></p><h2 id="7-数据库系统安全设计"><a href="#7-数据库系统安全设计" class="headerlink" title="7 数据库系统安全设计"></a>7 数据库系统安全设计</h2><h3 id="7-1-数据库完整性设计原则"><a href="#7-1-数据库完整性设计原则" class="headerlink" title="7.1 数据库完整性设计原则"></a>7.1 数据库完整性设计原则</h3><p>（1） 根据数据库 完整性约束的类型确定其实现的系统层次和方式 ，并提前 考虑对系统性能 的影响。一般情况下，静态约束应尽量包含在数据库模式中，而动态约束由应用程序实现。</p><p>（2）实体完整性约束、引用完整性约束是关系数据库最重要的完整性约束，在不影响系统关键性能的前提下需尽量应用。用一定的时间和空间来换取系统的易用性是值得的。</p><p>（3） 要慎用 目前主流DBMS都支持的 触发器 功能，一方面由于触发器的性能开销较大；另一方面，触发器的多级触发难以控制，容易发生错误，非用不可时，最好使用 Before型语句级触发器。</p><p>（4） 在需求分析阶段就 必须制定完整性约束的命名规范 ，尽量使用有意义的英文单词、缩写词、表名、列名及下画线等组合，使其易于识别和记忆，如CKC_EMP_REAL_INCOME_EMPLOYEE、PK_EMPLOYEE、CKT_EMPLOYEE。 如果使用CASE工具，一般有默认的规则，可在此基础上修改使用。</p><p>（5） 要根据业务规则对数据库完整性进行细致的测试，以尽早 排除隐含的完整性约束间的冲突和对性能的影响 。</p><p>（6） 要有专职的数据库设计小组 ， 自始至终负责 数据库的 分析、设计、测试、实施及早期维护 。数据库设计人员不仅负责基于DBMS 的数据库完整性约束的设计实现，还要负责对应用软件实现的数据库完整性约束进行审核。</p><p>（7） 应采用合适的 CASE工具来降低数据库设计各阶段的工作量 。好的CASE工具能够支持整个数据库的生命周期，这将使数据库设计人员的 工作效率得到很大提高，同时也容易与用户沟通 。</p><h3 id="7-2-数据库完整性的作用"><a href="#7-2-数据库完整性的作用" class="headerlink" title="7.2 数据库完整性的作用"></a>7.2 数据库完整性的作用</h3><p>（1）数据库完整性约束能够 防止 合法用户使用数据库时向数据库中 添加不合语义的数据 。</p><p>（2）利用基于DBMS 的完整性控制机制来实现业务规则，易于定义，容易理解，而且可以 降低应用程序的复杂性，提高应用程序的运行效率 。同时，基于DBMS 的完整性控制机制是集中管理的，因此比应用程序更容易实现数据库的完整性。</p><p>（3）合理的数据库完整性设计，能够同时兼顾数据库的完整性和系统的效能。例如装载大量数据时，只要在装载之前临时使基于DBMS 的数据库完整性约束失效，此后再使其生效，就能保证既不影响数据装载的效率又能保证数据库的完整性。</p><p>（4）在应用软件的 功能测试 中，完善的数据库完整性有助于 尽早发现应用软件的错误。</p><p>（5）数据库完整性约束可分为6类：列级静态约束、元组级静态约束、关系级静态约束、列级动态约束、元组级动态约束和关系级动态约束。动态约束通常由应用软件来实现。不同DBMS支持的数据库完整性基本相同。</p><h2 id="8-系统架构脆弱性分析"><a href="#8-系统架构脆弱性分析" class="headerlink" title="8 系统架构脆弱性分析"></a>8 系统架构脆弱性分析</h2><h3 id="8-1-系统架构的脆弱性组成"><a href="#8-1-系统架构的脆弱性组成" class="headerlink" title="8.1 系统架构的脆弱性组成"></a>8.1 系统架构的脆弱性组成</h3><p><strong>系统架构脆弱性</strong> 包括 <strong>物理装备脆弱性、软件脆弱性、人员管理脆弱性、规章制度脆弱性、安全策略脆弱性</strong> 等。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/4.png"></p><h3 id="8-2-典型架构的脆弱性表现"><a href="#8-2-典型架构的脆弱性表现" class="headerlink" title="8.2 典型架构的脆弱性表现"></a>8.2 典型架构的脆弱性表现</h3><p><strong>软件架构脆弱性通常与软件架构的风格和模式有关，不同风格和模式的软件架构，其脆弱性体现和特点有很大不同，且解决脆弱性问题需要考虑的因素和采取的措施也有很大不同。</strong></p><h4 id="8-2-1-分层架构"><a href="#8-2-1-分层架构" class="headerlink" title="8.2.1 分层架构"></a>8.2.1 分层架构</h4><p>分层架构被广泛应用于企业应用软件架构设计，大多数分层架构模式通常包括4个层次：即表示层、业务层、持久化层和数据库层。分层架构将应用系统正交地划分为若干层，每一层只解决问题的一部分，通过各层的协作提供整体解决方案。分层架构的脆</p><p>弱性主要表现在两个方面：</p><p>（1） 层间的脆弱性 。一旦某个底层发生错误，那么整个程序将会无法正常运行，如产生一些数据溢出，空指针、空对象的安全性问题，也有可能会得出错误的结果。</p><p>（2） 层间通信的脆弱性 。将系统隔离为多个相对独立的层，这就要求在层与层之间引入通信机制，在使用面向对象方法设计的系统中，通常会存在大量细粒度的对象，以及它们只见大量的消息交互——对象成员方法的调用。本来“直来直去”的操作现在要层层传递，势必造成性能下降。</p><h4 id="8-2-2-C-S架构"><a href="#8-2-2-C-S架构" class="headerlink" title="8.2.2 C/S架构"></a>8.2.2 C/S架构</h4><p>C/S 架构是客户机和服务器结构。 C/S分为两部分：服务器部分和客户机部分。服务器部分是多个用户共享的信息与功能，执行后台服务，如控制共享数据库的操作等；客户机部分为用户所专有，负责执行前台功能，在出错提示、在线帮助等方面都有强大的功能，并且可以在子程序间自由切换。</p><p>C/S 架构的脆弱性主要表现在以下几个方面：</p><p>（1） 客户端软件的脆弱性 。只要安装了特定客户端软件的用户才可以使用 C/S 架构系统，正因为在用户计算机上安装了客户端软件，所以这个系统就面临着程序被分析、数据被截取的安全隐患。</p><p>（2） 网络开放性的脆弱性 。目前很多传统的C/S 系统还是采用二层结构，也就是说所有客户端直接读取服务器端中的数据，在客户端包括了数据的用户名，密码等致命的信息，这样会给系统带来安全隐患。如果这样的系统放在Internet上，那么这个服务器端对于 Internet上的任何用户都是开放的。</p><p>（3） 网络协议的脆弱性 。 C/S 可以使用多种网络协议，也可以自定义协议，从这个角度来看，C/S 架构的安全性是有保障的。但是， C/S架构不便于随时与用户交流(主要是不便于数据包共享),并且 C/S 架构软件在保护数据的安全性方面有着先天的弊端。由于 C/S 架构软件的数据分布特性，客户端所发生的火灾、盗抢、地震、病毒等都将成为可怕的数据杀手。</p><h4 id="8-2-3-B-S架构"><a href="#8-2-3-B-S架构" class="headerlink" title="8.2.3 B/S架构"></a>8.2.3 B/S架构</h4><p>B/S 架构是浏览器/服务器结构模式，是一种以Web技术为基础的新型管理信息系统平台模式，它是利用通用浏览器实现了原来要用复杂专用软件才能实现的强大功能。 B/S架构的优点在于可以在任何地方进行操作而不用安装任何专门的软件，只要有一台能上网的计算机即刻，客户端零维护；系统的扩展非常容易，并且数据都集中存放在数据库服务器，所以不存在数据不一致现象。</p><p>B/S架构的脆弱性主要表现在：</p><p>系统如果使用 HTTP 协议， B/S架构相对C/S 架构而言更容易被病毒入侵 ，虽然最新的HTTP协议在安全性方面有所提升，但还是弱于 C/S</p><h4 id="8-2-4-事件驱动架构"><a href="#8-2-4-事件驱动架构" class="headerlink" title="8.2.4 事件驱动架构"></a>8.2.4 事件驱动架构</h4><p>事件驱动架构是一种流行的分布式异步架构，是一种适合高扩展工程的、较流行的分布式异构架构模式，有较高柔性，它由高度解耦、单一目的异步接收的事件处理组件和处理事件组成。事件驱动架构通常有两种拓扑结构： Mediator结构和Broker结构， Mediator结构通常适用于事件的多个步骤需要通过中间角色来指挥和协调的情形，而 Broker结构适用于事件是链式关系而不需要中间角色的情形。</p><p>事件驱动架构的脆弱性主要表现在：</p><p>（1） 组件的脆弱性 。组件削弱了自身对系统的控制能力，一个组件触发事件，并不能确定响应该事件的其他组件及各组建的执行顺序。</p><p>（2） 组件间交换数据的脆弱性 。组件不能很好地解决数据交换问题，事件触发时，一个组件有可能需要将参数传递给另一个组件，而数据量很大的时候，如何有效传递是一个脆弱性问题。</p><p>（3） 组件间逻辑关系的脆弱性 。事件架构使系统中各组件的逻辑关系变得更加复杂。</p><p>（4） 事件驱动容易进入死循环 ，这是由编程逻辑决定的。</p><p>（5） 高并发的脆弱性 。虽然事件驱动可实现有效利用 CPU 资源，但是存在高并发事件处理造成的系统响应问题，而且，高并发容易导致系统数据不正确、丢失数据等现象。</p><p>（6） 固定流程的脆弱性 。因为事件驱动的可响应流程基本都是固定的，如果操作不当，容易引发安全问题。</p><h4 id="8-2-5-MVC架构"><a href="#8-2-5-MVC架构" class="headerlink" title="8.2.5 MVC架构"></a>8.2.5 MVC架构</h4><p>MVC 架构是Model、View、Controller 的缩写，它是把一个应用的输入、处理、输出流程按照 Model、View、Controller的方式进行分离，即应用可被分成三层：模型层、视图层和控制层。</p><p>MVC架构的脆弱性主要表现在：</p><p>（1） MVC架构的复杂性带来脆弱性 。 MVC架构增加了系统结构和实现的复杂性。比如说一个简单的界面，如果严格遵循MVC方式，使得模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。</p><p>（2） 视图与控制器间紧密连接的脆弱性 。视图与控制器是相互分离但确是联系紧密的部件，没有控制器的存在，视图应用是很有限的。反之亦然，这样就妨碍了它们的独立重用。</p><p>（3） 视图对模型数据的低效率访问的脆弱性 。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问也将损害操作性能。可以说， MVC架构的脆弱性主要表现在缺少对调用者进行安全验证的方式和数据传输不够安全等两个方面，这些不足也是导致MVC存在比较大的脆弱性、容易招致攻击的主要原因。</p><h4 id="8-2-6-微内核架构"><a href="#8-2-6-微内核架构" class="headerlink" title="8.2.6 微内核架构"></a>8.2.6 微内核架构</h4><p>微内核架构是指内核的一种精简形式，将通常与内核集成在一起的系统服务层被分离出来，变成可以根据需求加入选，达到系统的可扩展性、更好地适应环境要求。微内核架构也被称为插件架构模式 (Plug-in Architecture Pattern), 通常由内核系统和插件组成。</p><p>微内核架构的脆弱性主要表现在：</p><p>（1） 微内核架构难以进行良好的整体化优化 。由于微内核系统的核心态只实现了最基本的系统操作，这样内核以外的外部程序之间的独立运行使得系统难以进行良好的整体优化。</p><p>（2） 微内核系统的进程间通信开销也较单一内核系统要大得多 。从整体上看，在当前硬件条件下，微内核在效率上的损失小于其在结构上获得的收益。</p><p>（3） 通信损失率高。微内核把系统分为各个小的功能块 ，从而降低了设计难度，系统的维护与修改也容易，但通信带来的效率损失是一个问题。</p><h4 id="8-2-7-微服务架构"><a href="#8-2-7-微服务架构" class="headerlink" title="8.2.7 微服务架构"></a>8.2.7 微服务架构</h4><p>微服务架构是一种架构模式，它提倡将单块架构的应用划分成一组小的服务，服务之间相互协调、相互配合、为用户提供最终价值。微服务架构中的每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制相互沟通。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等中。</p><p>微服务架构的脆弱性主要表现在：</p><p>（1） 开发人员需要处理分布式系统的复杂结构。</p><p>（2） 开发人员要设计服务之间的通信机制，通过写代码来处理消息传递中速度过慢或者不可用等局部实效问题。</p><p>（3） 服务管理的复杂性，在生产环境中要管理多个不同的服务实例，这意味着开发团队需要全局统筹。</p><h2 id="9-安全架构设计实践"><a href="#9-安全架构设计实践" class="headerlink" title="9 安全架构设计实践"></a>9 安全架构设计实践</h2><h3 id="9-1-电子商务系统的安全性设计"><a href="#9-1-电子商务系统的安全性设计" class="headerlink" title="9.1 电子商务系统的安全性设计"></a>9.1 电子商务系统的安全性设计</h3><p>具体的电子商务系统——高性能的RADIUS, 来阐明电子商务系统的安全设计的基本原理和设计方法。</p><p>电子商务系统的安全性设计原理介绍：</p><p>认证、授权和审计 (Authentication Authorization and Accounting,AAA) 是运行于宽带网络接入服务器上的客户端程序。 AAA提供了一个用来对认证、授权和审计三种安全功能进行配置的一致的框架，实际上是对网络安全的一种管理。这里的网络安全主要指访问控制，包括哪些用户可以访问网络服务器?如何对正在使用网络资源的用户进行记账?下面简单介绍验证、授权和记账的作用。</p><p>（1）认证 (Authentication): 验证用户是否可以获得访问权，认证信息包括用户名、用户密码和认证结果等。<br>（2）授权 (Authorization): 授权用户可以使用哪些服务，授权包括服务类型及服务相关信息等。<br>（3）审计 (Accounting): 记录用户使用网络资源的情况，用户IP地址、 MAC 地址掩码等。</p><p>远程认证拨号用户服务（Remote Authentication Dial-In User Service，RADIUS）</p><p>RADIUS是应用最广泛的高安全级别的 认证、授权、审计协议（Authentication，Authorization，Accounting，AAA），具有高性能和高可扩展性 ，且可用多种协议实现 。</p><p>RADIUS通常由 协议逻辑层，业务逻辑层和数据逻辑层3 层组成层次式架构。</p><p>（1） 协议逻辑层 ：起到分发处理功能，相当于转发引擎。<br>（2） 业务逻辑层 ：实现认证、授权、审计三种类型业务及其服务进程间的通信。<br>（3） 数据逻辑层 ：实现统一的数据访问代理池，降低数据库依赖，减少数据库压力，增强系统的数据适应能力。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/5.png"></p><h3 id="9-2-基于混合云的工业安全架构设计"><a href="#9-2-基于混合云的工业安全架构设计" class="headerlink" title="9.2 基于混合云的工业安全架构设计"></a>9.2 基于混合云的工业安全架构设计</h3><p><strong>混合云融合了公有云和私有云</strong> 。在基于混合云的工业安全生产管理系统中，工厂内部的产品设计、数据共享、生产集成使用私有云实现。公有云则用于公司总部与智能工厂间的业务管理、协调和统计分析等。 <strong>整个生产管理系统架构采用层次式架构，分为设备层、控制层、设计/管理层、应用层</strong> 。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/6.png"></p><p>（1） 设备层 ：包括智能工厂生产设备，包括智能传感器、智能仪器仪表、工业机器人、其他生产设备。<br>（2） 控制层 ：包括智能设备控制用自动控制系统，包括采集与监视控制系统（SCADA）、分布式控制系统（FCS）、可编程控制器（PLC）、人机接口（HMI），其他现场控制程序。<br>（3） 设计/管理层 ：包括智能工厂所有控制开发，业务控制和数据管理相关系统及其功能的集合，实现了数据集成和应用。<br>（4） 应用层 ：云平台上的信息处理，包括数据处理与管理、数据与行业应用相结合，如定制业务、协同业务、产品服务。</p>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>理论和实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向服务架构设计理论与实践</title>
    <link href="/2023/07/22/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E7%90%86%E8%AE%BA%E5%92%8C%E5%AE%9E%E8%B7%B5/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/07/22/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E7%90%86%E8%AE%BA%E5%92%8C%E5%AE%9E%E8%B7%B5/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="1-SOA相关概念"><a href="#1-SOA相关概念" class="headerlink" title="1 SOA相关概念"></a>1 SOA相关概念</h2><h3 id="1-1-SOA的定义"><a href="#1-1-SOA的定义" class="headerlink" title="1.1 SOA的定义"></a>1.1 SOA的定义</h3><p>从软件的基本原理定义，可以认为SOA是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的 需接口和契约 联系起来。接口是采用中立的方式进行定义的，它应该独立与实现服务的硬件平台、操作系统和编程语言。这使得构建在各种这样的系统中的服务可以一种统一和通用的方式进行交互。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/1.png"></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/2.png"></p><h3 id="1-2-业务流程与业务流程执行语言"><a href="#1-2-业务流程与业务流程执行语言" class="headerlink" title="1.2 业务流程与业务流程执行语言"></a>1.2 业务流程与业务流程执行语言</h3><p><strong>业务流程与业务流程执行语言（Business Process Execution Language，BPEL）</strong> 。业务流程是指为了实现某种业务目的行为所进行的流程或一系列动作。使用BPEL，用户可以通过组合、编排和协调Web服务自上而下地实现面向服务的体系结构。BPEL目前用于整合现有的Web Services，将现有的Web Service按照要求的业务流程整理成为一个新的Web Service，在这个基础上，形成一个从外界看来和单个Service一样的Service。</p><h2 id="2-SOA的发展史"><a href="#2-SOA的发展史" class="headerlink" title="2 SOA的发展史"></a>2 SOA的发展史</h2><p>（1） 萌芽阶段 ：这种广泛使用XML，允许组织定义文档的元数据，实现企业内部和企业之间的电子数据交换，规定了服务之间以及服务内部数据交换的格式和结构。</p><p>（2） 标准化阶段 ：国际标准和规范 - 简单对象访问协议（Simple Objec Access Protocol，SOAP）、Web服务描述语言（Web Service Description，UDDI）。</p><p>（3） 成熟阶段 ：3个重量级规范 - SCA、SDO、WS-Policy。SCA和SDO构成了SOA编程模型的基础，而WS-Policy建立了SOA组件之间安全交互的规范。</p><h2 id="3-SOA与微服务的区别"><a href="#3-SOA与微服务的区别" class="headerlink" title="3 SOA与微服务的区别"></a>3 SOA与微服务的区别</h2><p>（1） 微服务相比于SOA更加精细，微服务更多地以独立的进程的方式存在，相互之间并无影响。</p><p>（2） 微服务提供的接口方式更加通用化，例如HTTP Restful方式，各种终端都可以调用，无关语言、平台限制。</p><p>（3） 微服务更倾向于分布式去中心化的部署方式，在互联网业务场景下更适合。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/3.png"></p><table><thead><tr><th>微服务</th><th>SOA</th></tr></thead><tbody><tr><td>能拆分的就拆分</td><td>是整体的，能放一起的都放一起</td></tr><tr><td>纵向业务划分</td><td>水平分多层</td></tr><tr><td>由单一组织负责</td><td>按层级划分不同部门的组织负责</td></tr><tr><td>细粒度</td><td>粗粒度</td></tr><tr><td>两句话可以解释明白</td><td>几百字只相当于SOA的目录</td></tr><tr><td>独立的子公司</td><td>类似大公司里面划分了一些业务单元（BU）</td></tr><tr><td>组件小</td><td>存在较复杂的组件</td></tr><tr><td>业务逻辑存在于每一个服务中</td><td>业务逻辑横跨多个业务领域</td></tr><tr><td>使用轻量级的通过方式，如HTTP</td><td>企业服务总线（ESB）充当了服务之间通信的角色</td></tr></tbody></table><table><thead><tr><th>微服务架构实现</th><th>SOA实现</th></tr></thead><tbody><tr><td>团队级，自底向上开展实施</td><td>企业级，自顶向下开展实施</td></tr><tr><td>一个系统被拆分成多个服务，粒度细</td><td>服务由多个子系统组成，粒度大</td></tr><tr><td>无集中式总线，松散的服务架构</td><td>企业服务总线，集中式的服务架构</td></tr><tr><td>集成方式简单（HTTP/REST/JSON）</td><td>集成方式复杂（ESB/WS/SOAP）</td></tr><tr><td>服务能独立部署</td><td>单块架构系统，相互依赖，部署复杂</td></tr></tbody></table><h2 id="4-SOA的参考架构"><a href="#4-SOA的参考架构" class="headerlink" title="4 SOA的参考架构"></a>4 SOA的参考架构</h2><p>IBM的Websphere业务集成参考架构是典型的以服务为中心的企业集成架构，它可划分为6大类：</p><p>（1） 业务逻辑服务（Business Logic Service）。<br>（2） 控制服务（Control Service）。<br>（3） 连接服务（Connectivity Service）。<br>（4） 业务创新和优化服务（Business Innovation and Optimization Service）。<br>（5） 开发服务（Development Service）。<br>（6） IT服务管理（IT Service Management）。</p><h2 id="5-SOA的主要协议规范"><a href="#5-SOA的主要协议规范" class="headerlink" title="5 SOA的主要协议规范"></a>5 SOA的主要协议规范</h2><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/5.png"></p><p>（1） UDDI协议 ：统一描述、发现和集成协议。包含了服务描述与发现的标准规范，它使得商业实体能够彼此发现；定义它们怎样在Internet上相互作用，并在一个全球的注册体系架构中共享信息。</p><p>（2） Web服务描述语言（Web Service Description Language, WSDL） :WSDL是一个用来描述Web服务和说明如何与Web服务通信的XML语言。描述了Web服务的3个基本属性：</p><blockquote><p>服务做些什么 - 服务所提供的操作（方法）。<br>如何访问服务 - 和服务交互的数据格式以及必要协议。<br>服务位于何处 - 协议相关的地址，如URL。</p></blockquote><p>（3） SOAP协议 ：SOAP是在分散或分布式的环境中交换信息的简单协议，是一个基于XML的协议。<br>（4） REST规范 ：为了让不同的软件或者应用程序在任何网络环境下都可以进行信息的互相传递。微服务对外就是以REST API的形式暴露给调用者。RESTful即REST形式的，是对遵循REST设计思想同时满足设计约束的一类架构设计或应用程序的统称，这一类都可称为RESTful，可以理解为资源表述性状态转移：</p><blockquote><p>资源 ：将在互联网中一切暴露给客户端的事务都可以看做是一种资源。<br>表述 ：REST中用表述描述资源在Web中某一个时间的状态。<br>状态转移 ：分为两种，<br>应用状态 - 对某个时间内用户请求会话相关信息的快照，保存在客户端。<br>资源状态 - 在服务端保存，是对某个时间资源请求表述的快照。<br>超链接 ： 通过在页面中嵌入链接和其他资源建立联系。</p></blockquote><h2 id="6-SOA的设计标准要求"><a href="#6-SOA的设计标准要求" class="headerlink" title="6 SOA的设计标准要求"></a>6 SOA的设计标准要求</h2><p><strong>（1） 文档标准化。</strong><br>SOA服务具有平台独立的自我描述XML文档。Web服务描述语言是用于描述服务的标准语言。</p><p><strong>（2） 通信协议标准。</strong><br>SOA服务用消息进行通信，该消息通常使用XML Schema来定义（也称作XML schema Definition，XSD）。<br><strong>（3） 应用程序统一登记与集成。</strong><br>在一个企业内部，SOA服务通过一个扮演目录列表（Director Listing）角色的登记（Registry）来进行维护。应用程序在登记处（Registry）寻找并调用某项服务。统一描述、定义和集成是服务登记的标准。<br><strong>（4） 服务质量（Qos）。主要包括：</strong></p><blockquote><ol><li>可靠性：服务消费者和服务提供者之间传输文档时的传输特性（且仅仅传送一次、最多传送一次、重复消息过滤、保证消息传送）</li><li>安全性：Web服务安全规范用来保证消息的安全性。</li><li>策略：服务提供者有时候会要求服务消费者与某种策略通信。例如，服务提供商可能会要求消费者提供Kerberos安全标示才能取得某项服务。</li><li>控制：在SOA中，进程是使用一组离散的服务创建的。BPEL4WS或者WSBPEL（Web Service Business Process Execution Language）是用来控制这些服务的语言。</li><li>管理：针对运行在多种环境下的所有服务，必须有一个统一管理系统，以便系统管理员能够有效管理。任何根据WSDM实现的服务都可以由一个WSDM适应（WSDM-companyliant）的管理方案来管理。</li></ol></blockquote><h2 id="7-SOA的作用与设计原则"><a href="#7-SOA的作用与设计原则" class="headerlink" title="7 SOA的作用与设计原则"></a>7 SOA的作用与设计原则</h2><p>（1） SOA的主要作用：打破信息孤岛，把应用和资源转换成服务。以及把这些服务变成标准的服务，形成资源的共享。<br>（2） SOA的设计原则 主要有：</p><ol><li><strong>无状态 。</strong>以避免服务请求者依赖于服务提供者的状态。</li><li><strong>单一实例</strong> 。以高内聚的实现方法，来避免功能冗余。</li><li><strong>明确定义的接口</strong> 。服务的接口由WSDL定义，用于指明服务的公共接口与其内部专用实现之间的界限。</li><li><strong>自包含和模块化</strong> 。服务封装了那些在业务上稳定、重复出现的活动和组件，实现服务的功能实体是完全独立自主的，独立进行部署、版本控制、自我管理和恢复。</li><li><strong>粗粒度</strong> 。服务数量不应该太大，依靠消息交互而不是远程过程调用（Remote Procedure Call，RPC），通常消息量较大，但是服务之间的交互频度较低。</li><li><strong>服务之间的松耦合性</strong> 。服务使用者看到的是服务的接口，其位置、实现技术和当前状态等对使用者是不可见的，服务私有数据对服务使用者是不可见的。</li><li><strong>互操作性、兼容和策略声明</strong> 。为了确保服务规约的全面和明确，利用策略来定义可配置的互操作语义，来描述特定服务的期望、控制其行为。利用策略声明确保服务期望和语义兼容性方面的完整和明确。</li></ol><h2 id="8-SOA的设计模式"><a href="#8-SOA的设计模式" class="headerlink" title="8 SOA的设计模式"></a>8 SOA的设计模式</h2><h3 id="8-1-服务注册表模式"><a href="#8-1-服务注册表模式" class="headerlink" title="8.1 服务注册表模式"></a>8.1 服务注册表模式</h3><p>服务注册表支持驱动SOA治理的服务合同、策略和元数据的开发、发布和管理。<br>（1） 服务注册 ：应用开发者，也叫服务提供者，向注册表公布它们的功能。<br>（2） 服务位置 ：也就是服务应用的开发者，帮助他们查询注册服务，寻找符合自身要求的服务。<br>（3） 服务绑定 ：服务的消费者利用检索到的服务合同来开发代码，开发的代码与注册的服务绑定、调用注册的服务以及它们实现互动。</p><h3 id="8-2-企业服务总线模式（EBS）"><a href="#8-2-企业服务总线模式（EBS）" class="headerlink" title="8.2 企业服务总线模式（EBS）"></a>8.2 企业服务总线模式（EBS）</h3><p>企业服务总线模式提供一种标准的软件底层架构，各种程序组件能够以服务单元的方式“插入”到该平台上运行，并且组件之间能够以标准的消息通信方式来进行交互。其核心功能如下：</p><p>（1）提供位置透明性的消息路由和寻址服务。程序组件之间无须关注对方的路由和寻址。<br>（2）提供服务注册和命名的管理功能。<br>（3）支持多种消息传递规范（如请求 / 响应、发布订阅）。<br>（4）支持多种可以广泛使用的传输协议。<br>（5）支持多种数据格式及其相互转换。<br>（6）提供日志和监控功能</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/6.png"></p><h3 id="8-3-微服务模式"><a href="#8-3-微服务模式" class="headerlink" title="8.3 微服务模式"></a>8.3 微服务模式</h3><p>微服务架构 将 一个大型的单个应用或服务拆分成多个微服务，可扩展单个组件而不是整个应用程序堆栈，从而满足服务等级协议。微服务架构围绕业务领域将服务进行拆分，每个服务可以独立进行开发、管理和迭代，彼此之间使用统一接口进行交流，实现了在分散组件中的部署、管理与服务功能，使产品交付变得更加简单，从而达到有效拆分应用，实现敏捷开发与部署的目的。 微服务模式的特点如下：<br>（1） 复杂应用解耦 ：微服务架构将单一模块应用分解为多个微服务，同时保持总体功能不变。<br>（2） 独立 ：微服务在系统软件生命周期中是独立开发、测试及部署的。<br>（3） 技术选型灵活 ：微服务架构下系统应用的技术选型是去中心化的，每个开发团队可根据自身应用的业务需求发展状况选择合适的体系架构与技术。<br>（4） 容错 ：各个微服务相互独立，故障会被隔离在单个服务中，并且系统其他微服务可以通过重试、平稳退化等机制实现应用层的容错，从而提高系统应用的容错性。<br>（5） 松耦合，易扩展 ：微服务架构中每个服务之间都是松耦合的，可以根据实际需求实现独立扩展，体现微服务架构的灵活性。单体应用架构与微服务架构的，示意图如下：</p><h3 id="8-4-微服务架构模式方案"><a href="#8-4-微服务架构模式方案" class="headerlink" title="8.4 微服务架构模式方案"></a>8.4 微服务架构模式方案</h3><p>微服务架构模式 方案主要包括：<br>（1） 聚合器微服务 ：聚合器充当流程指挥者，调用多个微服务实现系统应用程序所需功能。<br>（2） 链式微服务 ：客户端或服务器在收到请求后，会发生多个服务间的嵌套递归调用，返回经过处理的响应。<br>（3） 数据共享微服务 ：该模式适用于在单体架构应用到微服务架构的过渡阶段，服务之间允许存在强耦合关系，例如存在多个微服务共享缓存与数据库存储的现象。<br>（4） 异步消息传递微服务 ：对于一些不必要以同步方式运行的业务逻辑，可以使用消息队列代替REST实现请求、响应，加快服务调用的响应速度。</p><h3 id="8-5-微服务架构面临的问题和挑战"><a href="#8-5-微服务架构面临的问题和挑战" class="headerlink" title="8.5 微服务架构面临的问题和挑战"></a>8.5 微服务架构面临的问题和挑战</h3><p>（1） <strong>服务发现与服务调用链跟踪变得困难。</strong><br>（2） <strong>很难实现传统数据库的强一致性，转而追求最终一致性。</strong></p><h2 id="9-构建SOA架构时应该注意的问题"><a href="#9-构建SOA架构时应该注意的问题" class="headerlink" title="9 构建SOA架构时应该注意的问题"></a>9 构建SOA架构时应该注意的问题</h2><p>（1） 原有系统架构中的集成需求 包括：应用程序集成的需求、终端用户界面集成的需求、流程集成的需求以及已有系统信息集成的需求。</p><p>（2） 服务粒度的控制以及无状态服务的设计 的表述如下：</p><blockquote><ol><li>服务粒度的控制 ：对于将暴露在整个系统外部的服务推荐使用粗粒度的接口，而相对较细粒度的服务接口通常用于企业系统架构的内部。</li><li>无状态服务的设计 ：SOA系统架构中的具体服务应该都是独自的、自包含的请求，在实现这些服务的时候不需要前一个请求的状态，也就是说服务不应该依赖于其他服务的上下文和状态，即SOA架构中的服务应该是无状态的服务。</li></ol></blockquote><h2 id="10-SOA实施过程"><a href="#10-SOA实施过程" class="headerlink" title="10 SOA实施过程"></a>10 SOA实施过程</h2><p>（1） 选择SOA解决方案 主要从以下3个方面进行：</p><ol><li>尽量选择能进行全局规划的方案。</li><li>选择时充分考虑企业自身的需求。</li><li>从平台、实施等技术方面进行考察。</li></ol><p>（2） 业务流程分析 主要关注：</p><ol><li>建立服务模型：</li><li>自顶向下分解法、业务目标分析法、自底向上分析法。</li><li>建立业务流程：</li><li>建立业务对象（实体、过程、事件等业务对象）、建立服务接口、建立服务流程。</li></ol>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>理论和实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL安装</title>
    <link href="/2023/07/17/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E5%AE%89%E8%A3%85/"/>
    <url>/2023/07/17/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>下载安装包，上传至服务器</p><p>cd mysql安装tar包所在文件夹</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 解压</span><br>tar xvf mysql...<br><br><span class="hljs-comment"># 重命名</span><br><span class="hljs-built_in">mv</span> mysql... mysql<br><br><span class="hljs-built_in">cd</span> mysql<br><br><span class="hljs-comment"># 创建data文件夹存储文件</span><br><span class="hljs-built_in">mkdir</span> data<br><span class="hljs-comment"># 创建用户组以及用户和密码</span><br>groupadd mysql<br>useradd -g mysql mysql<br><span class="hljs-comment"># 授权用户</span><br><span class="hljs-built_in">chown</span> -R mysql.mysql /opt/mysql/mysql<br><br><span class="hljs-built_in">cd</span> bin<br><span class="hljs-comment"># 注意，记得保存临时密码，之后第一次登录需要用</span><br>./mysqld --user=mysql --basedir=/opt/mysql/mysql --datadir=/opt/mysql/mysql/data --initialize<br></code></pre></td></tr></table></figure><p>编辑 vim /etc/my.cnf 文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">[mysql]</span><br><span class="hljs-attr">default-character-set</span>=<span class="hljs-string">utf8mb4</span><br><span class="hljs-attr">[client]</span><br><span class="hljs-comment">#port=3306</span><br><span class="hljs-attr">socket</span>=<span class="hljs-string">/var/lib/mysql/mysql.sock</span><br><br><span class="hljs-attr">[mysqld]</span><br><span class="hljs-comment">#port=3306</span><br><span class="hljs-comment">#server-id=3306</span><br><span class="hljs-attr">user</span>=<span class="hljs-string">mysql</span><br><span class="hljs-attr">general_log</span>=<span class="hljs-string">1</span><br><span class="hljs-attr">general_log_file</span>=<span class="hljs-string">/var/log/mysql/mysql.log</span><br><span class="hljs-attr">socket</span>=<span class="hljs-string">/var/lib/mysql/mysql.sock</span><br><span class="hljs-attr">basedir</span>=<span class="hljs-string">/opt/mysql/mysql</span><br><span class="hljs-attr">datadir</span>=<span class="hljs-string">/opt/mysql/mysql/data</span><br><span class="hljs-attr">log-bin</span>=<span class="hljs-string">/opt/mysql/mysql/data/mysql-bin</span><br><span class="hljs-attr">innodb_data_home_dir</span>=<span class="hljs-string">/opt/mysql/mysql/data</span><br><span class="hljs-attr">innodb_log_group_home_dir</span>=<span class="hljs-string">/opt/mysql/mysql/data/</span><br><span class="hljs-attr">character-set-server</span>=<span class="hljs-string">utf8mb4</span><br><span class="hljs-attr">lower_case_table_names</span>=<span class="hljs-string">0</span><br><span class="hljs-attr">autocommit</span>=<span class="hljs-string">1</span><br><span class="hljs-attr">defalut_authentication_plugin</span>=<span class="hljs-string">mysql_native_password</span><br><br><span class="hljs-attr">[mysqld_safe]</span><br><span class="hljs-attr">log-error</span>=<span class="hljs-string">/opt/mysql/mysql/data/mysql.log</span><br><span class="hljs-attr">pid-file</span>=<span class="hljs-string">/opt/mysql/mysql/data/mysql.pid</span><br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /var/log<br><span class="hljs-built_in">mkdir</span> mysql<br><span class="hljs-built_in">cd</span> /var/lib<br><span class="hljs-built_in">mkdir</span> mysql<br><span class="hljs-built_in">chmod</span> 777 -R /var/log/mysql<br><span class="hljs-built_in">chmod</span> 777 -R /var/lib/mysql<br></code></pre></td></tr></table></figure><p>添加mysqld服务到系统，这里要切换到安装目录下执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /opt/mysql/mysql/bin<br><span class="hljs-built_in">cp</span> -a ../support-files/mysql.server /etc/init.d/mysql<br></code></pre></td></tr></table></figure><p>授权以及添加服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">chmod</span> +x /etc/init.d/mysql<br>chkconfig --add mysql<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 启动mysql服务</span><br>service mysql start<br><span class="hljs-comment"># 查看启动状态</span><br>service mysql status<br><br><span class="hljs-comment"># 将mysql命令添加到服务</span><br><span class="hljs-built_in">ln</span> -s /opt/mysql/mysql/bin/mysql /usr/bin/<br><span class="hljs-comment"># 如果存在了，覆盖就行</span><br><span class="hljs-built_in">ln</span> -sf /opt/mysql/mysql/bin/mysql /usr/bin/<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 用临时密码登录</span><br>mysql -u root -p<br><span class="hljs-comment"># 密码填写刚才生成的临时密码，到此就说明安装成功了</span><br><span class="hljs-comment"># 修改root密码</span><br>alter user <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> identified with mysql_native_password by <span class="hljs-string">&#x27;Qq123321&#x27;</span>;<br><span class="hljs-comment"># 执行，使得密码生效</span><br>flush privileges;<br><br><span class="hljs-comment"># 选择数据库</span><br>use mysql;<br><span class="hljs-comment"># 修改远程连接并生效，退出</span><br>update user <span class="hljs-built_in">set</span> host=<span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-built_in">where</span> user=<span class="hljs-string">&#x27;root&#x27;</span>;<br>flush privileges;<br><span class="hljs-built_in">exit</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>安装文档</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统质量属性与架构评估</title>
    <link href="/2023/07/15/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E9%AB%98%E7%BA%A7%E6%8A%80%E8%83%BD/%E7%B3%BB%E7%BB%9F%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/"/>
    <url>/2023/07/15/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E9%AB%98%E7%BA%A7%E6%8A%80%E8%83%BD/%E7%B3%BB%E7%BB%9F%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-软件系统质量属性的概念"><a href="#1-软件系统质量属性的概念" class="headerlink" title="1 软件系统质量属性的概念"></a>1 软件系统质量属性的概念</h2><h3 id="1-1-开发期的质量属性"><a href="#1-1-开发期的质量属性" class="headerlink" title="1.1 开发期的质量属性"></a>1.1 开发期的质量属性</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>易理解性</td><td>指设计开发人员理解的难易程度</td></tr><tr><td>可扩展性</td><td>软件因适应新需求变化而增加新功能的能力，也称为灵活性</td></tr><tr><td>可重用性</td><td>指重用软件系统或其一部分的难易程度</td></tr><tr><td>可测试性</td><td>当软件测试以证明其满足需求规范的难易程度</td></tr><tr><td>可维护性</td><td>当需要修改缺陷、增加功能、提高质量属性时，识别修改点并实施修改的难易程度</td></tr><tr><td>可移植性</td><td>将软件系统从一个运行环境转移到另一个不同的运行环境的难易程度</td></tr></tbody></table><h3 id="1-2-运行期的质量属性"><a href="#1-2-运行期的质量属性" class="headerlink" title="1.2 运行期的质量属性"></a>1.2 运行期的质量属性</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>性能</td><td>软件系统即时提供相应的服务能力，如速度、吞吐量和容量等</td></tr><tr><td>安全性</td><td>软件系统同时兼顾向合法用户提供服务，以及组织非授权使用的能力</td></tr><tr><td>可伸缩性</td><td>当用户数和数据量增加时，软件系统维持高服务质量的能力</td></tr><tr><td>互操作性</td><td>软件系统与其他系统交换数据和相互调用服务的难易程度</td></tr><tr><td>可靠性</td><td>软件系统在一定时间内持续无故障运行的能力</td></tr><tr><td>可用性</td><td>系统在一定时间内正常工作的时间所占比例</td></tr><tr><td>健壮性</td><td>软件系统在非正常情况（用户非法操作、相关软硬件系统发生故障）下仍正常运行的能力，也称容错性</td></tr></tbody></table><h2 id="2-面向架构评估的质量属性"><a href="#2-面向架构评估的质量属性" class="headerlink" title="2 面向架构评估的质量属性"></a>2 面向架构评估的质量属性</h2><h3 id="2-1-性能"><a href="#2-1-性能" class="headerlink" title="2.1 性能"></a>2.1 性能</h3><p>性能（performance）是指系统的响应能力，即要经过多长时间才能对某个事件做出响应，或者在某段时间内系统所能处理的事件的个数。例如：同时支持1000并发；响应时间小于1s；显示分辨率达到4K</p><p><strong>提升性能的策略（性能战术）可以从以下几个方面考虑：</strong></p><ol><li>资源需求 ：<br> ①提高计算效率、②减少计算开销、③管理（减少处理事件数量）事件率、④控制采样频率（控制资源的使用）</li><li>资源管理 ：<br> ①引入并发机制、②维持多个副本、③增加可用资源</li><li>资源仲裁 ：<br> 资源调度策略：①先进先出、②固定优先级、③动态优先级、④静态调式</li></ol><h3 id="2-2-可用性"><a href="#2-2-可用性" class="headerlink" title="2.2 可用性"></a>2.2 可用性</h3><p>可用性（availability）是系统能够正常运行的时间比例。经常用两次故障之间的时间长度或在出现故障时系统能够恢复正常的速度来表示。例如：主服务器故障，1分钟内切换至备用服务器；系统故障，1小时内修复；系统支持7×24小时工作</p><p><strong>提升可用性的策略（可用性战术）可以从以下几个方面考虑：</strong></p><ol><li>错误检测 ：<br> ①命令/响应【Ping/Echo】、②心跳、③异常</li><li>错误恢复 ：<br> ①表决、②冗余【主动/被动】、③备份【重新同步、内测、检查点/回滚】</li><li>错误避免 ：<br> ①进程监视器、②事务、③从服务器删除【服务下线】</li></ol><h3 id="2-3-安全性"><a href="#2-3-安全性" class="headerlink" title="2.3 安全性"></a>2.3 安全性</h3><p>安全性（security）是指系统在向合法用户提供服务的同时能够阻止非授权用户使用的企图或拒绝服务的能力。安全性又可划分为机密性、完整性、不可否认性及可控性等特性。例如：可抵御SQL注入攻击；对计算机的操作都有完整记录（日志，审计追踪）；用户信息数据库授权必须保证99.9%可用</p><p><strong>提升安全性的策略（安全性战术）可以从以下几个方面考虑：</strong></p><ol><li>抵抗攻击 ：<br> ①用户身份验证、②用户授权、③维护数据机密性和完整性、④限制暴露、⑤限制访问</li><li>检测攻击 ：<br> ①入侵系统检测</li><li>从攻击中恢复 ：<br> ①识别攻击者：审计追踪、②恢复状态：冗余【与可用性重叠】</li></ol><h3 id="2-4-可修改性"><a href="#2-4-可修改性" class="headerlink" title="2.4 可修改性"></a>2.4 可修改性</h3><p>可修改性（modifiability）是指能够快速地以较高的性能价格比对系统进行变更的能力。通常以某些具体的变更为基准，通过考察这些变更的代价衡量可修改性。例如：更改系统报表模块，必须在2人周内完成；对Web界面风格进行修改，修改必须在4人月内完成</p><p><strong>可修改性分为四个子属性：</strong><br>可维护性：局部修复使故障对架构的负面影响最小化。<br>可扩展性：因松散的耦合更易实现新特性/功能，不影响架构。<br>结构重组：不影响主体进行的灵活配置。<br>可移植性：适用于多样的环境（硬件平台、语言、操作系统等）。</p><p><strong>提升性能的策略（可修改行战术）可以从以下几个方面考虑：</strong></p><ol><li>局部化修改 ：<br> ①高内聚低耦合、②预测变更、③使模块通用、④泛化模块、⑤维持语义的一致性、⑥限制可能的选择、⑦抽象通用服务</li><li>防止连锁反应 ：<br> ①隐藏信息、②维持现有接口、③限制通信路径、④使用仲裁者</li><li>推迟绑定时间 ：<br> ①运行时注册、②配置文件、③多态、④组件更换、⑤遵守已定义的协议</li></ol><h3 id="2-5-易用性"><a href="#2-5-易用性" class="headerlink" title="2.5 易用性"></a>2.5 易用性</h3><p>易用性关注的是对用户来说完成某个期望任务的容易程度和系统所提供的用户支持的种类。例如：</p><ul><li><strong>界面友好</strong></li><li><strong>新用户学习使用系统时间不超过2小时</strong></li></ul><h3 id="2-6-可测试性"><a href="#2-6-可测试性" class="headerlink" title="2.6 可测试性"></a>2.6 可测试性</h3><p>软件可测试性是指通过测试揭示软件缺陷的容易程度。例如：</p><ul><li><strong>提供远程调试接口，支持远程调试</strong></li></ul><h3 id="2-7-可靠性"><a href="#2-7-可靠性" class="headerlink" title="2.7 可靠性"></a>2.7 可靠性</h3><p>分为两个子属性：<br><strong>容错性</strong>：出错后仍能保证系统争取运行，且自行修正错误。<br><strong>健壮性</strong>：错误不对系统产生影响，按既定程序忽略错误。</p><h3 id="2-8-功能性"><a href="#2-8-功能性" class="headerlink" title="2.8 功能性"></a>2.8 功能性</h3><p>需求的满足程度。</p><h3 id="2-9-可变性"><a href="#2-9-可变性" class="headerlink" title="2.9 可变性"></a>2.9 可变性</h3><p>总体架构可变。</p><h3 id="2-10-互操作性"><a href="#2-10-互操作性" class="headerlink" title="2.10 互操作性"></a>2.10 互操作性</h3><p>通过可视化或接口方式提供更好的交互操作体验。</p><h2 id="3-质量属性场景描述"><a href="#3-质量属性场景描述" class="headerlink" title="3 质量属性场景描述"></a>3 质量属性场景描述</h2><p>质量属性场景是一种面向特定质量属性的需求，由刺激源、刺激、环境、制品、响应、响应度量组成。<br>（1）刺激源（Source）：某个生成该刺激源的实体（人、计算机系统或者任何其他刺激器）。<br>（2）刺激（Stimulus）：指当刺激到达系统时需要考虑的条件。<br>（3）环境（Environment）：指该刺激在某些条件内发生。当激励发生时，系统可能处于过载、运行或者其他情况。<br>（4）制品（Artifact）：某个制品被激励，可能是整个系统，也可能是系统的一部分。<br>（5）响应（Response）：指在激励到达后所采取的行动。<br>（6）响应度量（Measurement）：当响应发生时，应当能够以某种方式对其进行度量，以对需求进行测试。</p><h2 id="4-系统架构评估"><a href="#4-系统架构评估" class="headerlink" title="4 系统架构评估"></a>4 系统架构评估</h2><h3 id="4-1-重要概念"><a href="#4-1-重要概念" class="headerlink" title="4.1 重要概念"></a>4.1 重要概念</h3><h4 id="4-1-1-敏感点、权衡点、风险点、非风险点"><a href="#4-1-1-敏感点、权衡点、风险点、非风险点" class="headerlink" title="4.1.1 敏感点、权衡点、风险点、非风险点"></a>4.1.1 敏感点、权衡点、风险点、非风险点</h4><p><strong>敏感点（Sensitivity Point）</strong> ：是一个或多个构件（和/或构件之间的关系）的特性。</p><p><strong>权衡点（Tradeoff Point）</strong> ：是影响多个质量属性的特性，是多个质量属性的敏感点。</p><p><strong>风险点（Risk Point ）</strong> ：是指架构设计中潜在的、存在问题的架构决策所带来的隐患。</p><p><strong>非风险点（Non-Risk Point ）</strong> ：是指不会带来隐患，一般以“XXX要求是可以实现（或接受）的”方式表达。</p><p>例如：</p><ol><li>对交易请求处理时间的要求将影响系统的数据传输协议和处理过程的设计<strong>（敏感点）</strong></li><li>假设每秒中用户交易请求的数量是10个，处理请求的时间为30毫秒，则“在1秒内完成用户的交易请求”这一要求是可以实现的 <strong>（非风险点）</strong></li><li>目前对系统信用卡支付业务逻辑的描述尚未达成共识，这可能导致部分业务功能模块的重复，影响系统的可修改性 <strong>（风险点）</strong></li><li>更改加密的级别将对安全性和性能产生影响 <strong>（权衡点）</strong></li></ol><h4 id="4-1-2-风险承担者或者相关利益人"><a href="#4-1-2-风险承担者或者相关利益人" class="headerlink" title="4.1.2 风险承担者或者相关利益人"></a>4.1.2 风险承担者或者相关利益人</h4><p>影响体系结构或被体系结构影响的群体。</p><h4 id="4-1-3-场景"><a href="#4-1-3-场景" class="headerlink" title="4.1.3 场景"></a>4.1.3 场景</h4><p>确定架构质量评估目标的交互机制，一般采用触发机制（刺激）、环境和影响三方面来考虑。</p><h3 id="4-2-系统架构评估方法"><a href="#4-2-系统架构评估方法" class="headerlink" title="4.2 系统架构评估方法"></a>4.2 系统架构评估方法</h3><ol><li><p>基于调查问卷或检查表的评估方法<br> 是指组织相关人员进行评估，这种方式最简单易行，但是主观性强。</p></li><li><p>基于度量的评估方法<br> 强调量化指标，最客观，但是这种方式实施难度大，因为需要评估者对系统非常熟悉，不然很难量化清楚各项指标。</p></li><li><p>基于场景的评估方法<br> 筛选出系统的关键场景，根据系统在不同场景中的表现进行评估，这种方式客观程度介于2者之间，这也是目前较为流行的结构评估方法。</p></li></ol><p><strong>基于场景的方式主要有三种（前2种方式用得比较多）：</strong></p><p><strong>软件架构分析法（SAAM，Software Architecture Analysis Method）</strong><br><strong>架构权衡分析法（ATAM，Architecture Tradeoff Analysis Method）</strong><br><strong>成本效益分析法（CBAM，the Cost Benefit Analysis Method）</strong></p><h4 id="4-2-1-基于场景-软件架构分析法SAAM"><a href="#4-2-1-基于场景-软件架构分析法SAAM" class="headerlink" title="4.2.1 基于场景 - 软件架构分析法SAAM"></a>4.2.1 基于场景 - 软件架构分析法SAAM</h4><p>SAAM，最初用于分析架构可修改性，后扩展到其它质量属性。<br><strong>SAAM分析评估架构的过程包括5个步骤</strong> ，如下图：<br>（1）<strong>场景开发</strong><br>（2）<strong>架构描述</strong><br>（3）<strong>单个场景评估</strong><br>（4）<strong>场景交互评估</strong><br>（5）<strong>整体评估</strong></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%B3%BB%E7%BB%9F%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/1.png"></p><h4 id="4-2-2-基于场景-架构权衡分析法ATAM"><a href="#4-2-2-基于场景-架构权衡分析法ATAM" class="headerlink" title="4.2.2 基于场景 - 架构权衡分析法ATAM"></a>4.2.2 基于场景 - 架构权衡分析法ATAM</h4><p>架构权衡分析法（ATAM，Architecture Tradeoff Analysis Method）是 在SAAM上发展而来。核心是结合质量属性效用树对系统进行评价 ，确定风险点、敏感点、权衡点，并对系统架构做出决策和折中。整个评估过程 强调以质量属性作为评估核心，主要针对性能、实用性、安全性和可修改性，在系统开发之前，对这些质量属性进行评价和折中。</p><p><strong>ATAM分成4个阶段，如下图：</strong><br><strong>（1）场景和需求收集</strong><br><strong>（2）架构视图和场景实现</strong><br><strong>（3）质量模型构造和分析</strong><br><strong>（4）质量模型折中</strong></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%B3%BB%E7%BB%9F%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/2.png"></p><h4 id="4-2-3-质量属性效用树"><a href="#4-2-3-质量属性效用树" class="headerlink" title="4.2.3 质量属性效用树"></a>4.2.3 质量属性效用树</h4><p><strong>质量属性效用树：识别质量属性并排序，主要包含性能、可用性、可修改性、安全性四个方面。</strong></p><p><strong>性能</strong>：性能延时（将用户数据库存储延迟到了最小值300ms，提供了实时的视频图像），交易吞吐量（使认证服务器的平均吞吐量最大化）。</p><p><strong>可修改性</strong>：新增产品目录，商业产品修改（已小于20人月的工作量添加CORBA中间件，以小于4人周的工作量更改web界面）。</p><p><strong>可用性</strong>：硬件故障（若站点A断电，要求在3秒内将任务重定向到站点B，若磁盘出现故障，要求在5分钟内重新启动，要在1-5分钟之内检测并恢复网络故障），商业软件故障。</p><p><strong>安全性</strong>：数据机密性（信用卡交易在99.999%的时间内是安全的，客户数据库z认证在99.999%的时间内能正常工作），数据完整性。</p><p><strong>质量属性效用树</strong>，示例图如下：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%B3%BB%E7%BB%9F%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/3.png"></p>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>高级技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件可靠性分析与设计</title>
    <link href="/2023/07/15/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E9%AB%98%E7%BA%A7%E6%8A%80%E8%83%BD/%E8%BD%AF%E4%BB%B6%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/07/15/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E9%AB%98%E7%BA%A7%E6%8A%80%E8%83%BD/%E8%BD%AF%E4%BB%B6%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="1-可靠性基本概念"><a href="#1-可靠性基本概念" class="headerlink" title="1 可靠性基本概念"></a>1 可靠性基本概念</h2><p><strong>系统可靠性</strong> 是系统在规定的时间内及规定的环境条件下，完成规定功能的能力，也就是系统无故障运行的概率。也就是软件系统在应用或系统错误面前，在意外或错误使用的情况下维持软件系统的功能特性的基本能力。<br><strong>系统可用性</strong> 是指在某个给定时间点上系统能够按照需求执行的概率，也就是系统能够正常运行的时间比例。</p><p><strong>软件可靠性 ≠ 硬件可靠性，其区别：</strong></p><ol><li>复杂性 ，软件复杂性比硬件高， 大部分失效来自于软件失效 。</li><li>物理退化 ，硬件失效主要是物理退化所致，软件不存在物理退化 。</li><li>唯一性，软件是唯一的 ，每个COPY版本都一样，而两个硬件不可能完全一样。</li><li>版本更新周期，硬件较慢，软件较快 。</li></ol><p><strong>软件可靠性的定量描述 ：</strong>软件的可靠性是在软件使用条件、在规定时间内、系统的输入/输出、系统的使用等变量构成的数据表达式。<br>（1）规定时间：自然时间、运行时间、执行时间，度量软件的可靠性效果最好<br>（2）失效概率：软件从运行开始算起，运行到某一时间t，出现失效的概率是一个随机函数，称为失效概率。<br>（3）可靠度：是如软件在规定条件下、规定时间内不失效的概率。<br>（4）失效强度：单位时间内软件失效的概率。<br>（5）失效率：也称风险函数或条件失效强度，在运行系统未出现失效的情况下，单位时间软件系统出现失效的概率。<br>（6）平均无失效时间：软件运行后，到下一次失效的平均时间。更直观地反应软件的可靠度。</p><p><strong>可靠性的目标 ：</strong><br>软件可靠性是指用户对所使用的软件的性能满意程度的期望。可以用可靠性、平均失效时间和故障强度等来描述。</p><p><strong>软件可靠性测试的意义 ：</strong><br>（1）软件失效可能造成灾难性的后果。<br>（2）软件的失效在整个计算机系统失效中的比例较高。<br>（3）相比硬件可靠性技术，软件可靠性技术不成熟。<br>（4）软件可靠性问题会造成软件费用增长。<br>（5）系统对软件的依赖性强，对生产活动和社会生活影响日益增大。</p><p><strong>软件可靠性测试的目的 ：</strong><br>（1）发现软件系统的缺陷【需求分析、软件设计、系统编码、测试实施】<br>（2）为软件的使用和维护提供可靠性依据<br>（3）确认软件是否达到可靠性的定量要求</p><p><strong>广义软件可靠性测试</strong> 是为了最终评价软件系统的可靠性而运用的建模、统计试验、分析和评价等一系列手段对软件系统实施一种测试。</p><p><strong>狭义软件可靠性测试</strong> 指为了获取可靠性数据，按预先确定好的测试用例，在软件预期使用环境中，对软件实施的一种测试。</p><h2 id="2-可靠性建模"><a href="#2-可靠性建模" class="headerlink" title="2 可靠性建模"></a>2 可靠性建模</h2><p><strong>软件可靠性模型</strong>是指 <strong>为预计或估算软件的可靠性所建立的可靠性框图和数学模型</strong> 。</p><p><strong>一个软件可靠性模型通常（但不是绝对）由以下几部分组成：</strong></p><ol><li><p>模型假设：模型是实际情况的简化或规范化，总要包含若干假设，例如测试的选取代表实际运行剖面，不同软件失效独立发生等。</p></li><li><p>性能度量：软件可靠性模型的输出量就是性能度量，如失效强度、残留缺陷数等。在软件可靠性模型中性能度量通常以数学表达式给出。</p></li><li><p>参数估计方法：某些可靠性度量的实际值无法直接获得，例如残留缺陷数，这时需通过一定的方法估计参数的值，从而间接确定可靠性度量的值。</p></li><li><p>数据要求：一个软件可靠性模型要求一定的输入数据，即软件可靠性数据。</p></li></ol><p><strong>绝大多数的模型包含3个共同假设 ：</strong></p><ol><li><p>代表性假设：是指可以用测试产生的软件可靠性数据预测运行阶段的软件可靠性行为。</p></li><li><p>独立性假设：此假设认为软件失效是独立发生于不同时刻，一个软件失效的发生不影响另一个软件失效的发生。</p></li><li><p>相同性假设：此假设认为所有软件失效的后果（等级）相同，即建模过程只考虑软件失效的具体发生时刻，不区分软件的失效严重等级。</p></li></ol><p><strong>软件可靠性（模型分类）模的方法包括 ：</strong></p><ol><li>种子法模型：利用捕获一再捕获抽样技术估计程序中的错误数，在程序中预先有意“播种”一些设定的错误“种子”，然后根据测试出的原始错误数和发现的诱导错误的比例，来估计程序中残留的错误数。</li><li>失效率类模型：用来研究程序的失效率</li><li>曲线拟合类模型：用回归分析的方法研究软件复杂性、程序中的缺陷数、失效率、失效间隔时间。</li><li>可靠性增长模型：这类模型预测软件在检错过程中的可靠性改进，用增长函数来描述软件的改进过程。</li><li>程序结构分析模型：是根据程序、子程序及其相互间的调用关系，形成一个可靠性分析网络。</li><li>输入域分类模型：选取软件输入域中的某些样本“点”运行程序，根据这些样本点在“实际”使用环境中的使用概率的测试运行时的成功/失效率，推断软件的使用可靠性。</li><li>执行路径分析方法模型：分析方法与上面的模型相似，先计算程序各逻辑路径的执行概率和程序中错误路径的执行概率，再综合出该软件的使用可靠性。</li><li>非齐次泊松过程模型：是以软件测试过程中单位时间的失效次数为独立泊松随机变量，来预测在今后软件的某使用时间点的累计失效数。</li><li>马尔可夫过程模型</li><li>贝叶斯模型：是利用失效率的试验前分布和当前的测试失效信息，来评估软件的可靠性。</li></ol><h2 id="3-可靠性管理"><a href="#3-可靠性管理" class="headerlink" title="3 可靠性管理"></a>3 可靠性管理</h2><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/1.png"></p><h2 id="4-可靠性分析"><a href="#4-可靠性分析" class="headerlink" title="4 可靠性分析"></a>4 可靠性分析</h2><h3 id="4-1-可靠性指标"><a href="#4-1-可靠性指标" class="headerlink" title="4.1 可靠性指标"></a>4.1 可靠性指标</h3><ul><li><strong>平均无故障时间，MTTF = 1 / λ，λ为失效率</strong></li><li><strong>平均故障修复时间，MTTR = 1 / μ，μ为修复率</strong></li><li><strong>平均故障间隔时间，MTBF = MTTR + MTTF</strong></li><li><strong>系统可用性，MTTF / MTBF = MTTF / (MTTR + MTTF) × 100%</strong></li></ul><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/2.png"></p><h3 id="4-2-串联系统"><a href="#4-2-串联系统" class="headerlink" title="4.2 串联系统"></a>4.2 串联系统</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/3.png"></p><h3 id="4-3-并联系统"><a href="#4-3-并联系统" class="headerlink" title="4.3 并联系统"></a>4.3 并联系统</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/4.png"></p><h3 id="4-4-混合系统"><a href="#4-4-混合系统" class="headerlink" title="4.4 混合系统"></a>4.4 混合系统</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/5.png"></p><p>R * ( 1 - ( 1- R ) ^ 3 ) * ( 1 - ( 1 - R) ^ 2 )</p><h2 id="5-可靠性设计"><a href="#5-可靠性设计" class="headerlink" title="5 可靠性设计"></a>5 可靠性设计</h2><h3 id="5-1-影响可靠性的主要因素"><a href="#5-1-影响可靠性的主要因素" class="headerlink" title="5.1 影响可靠性的主要因素"></a>5.1 影响可靠性的主要因素</h3><p>从技术的角度来看，影响软件的可靠性的因素包括：<strong>运行环境、软件规模、软件的内部结构、软件的开发方法和开发环境、软件的可靠性投入</strong> 。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/6.png"></p><h3 id="5-2-可靠性设计技术"><a href="#5-2-可靠性设计技术" class="headerlink" title="5.2 可靠性设计技术"></a>5.2 可靠性设计技术</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/7.png"></p><h4 id="5-2-1-容错设计技术"><a href="#5-2-1-容错设计技术" class="headerlink" title="5.2.1 容错设计技术"></a>5.2.1 容错设计技术</h4><h5 id="5-2-1-1-冗余设计"><a href="#5-2-1-1-冗余设计" class="headerlink" title="5.2.1.1 冗余设计"></a>5.2.1.1 冗余设计</h5><p>在一套完整的软件系统之外，设计一种不同路径、不同算法或不同的实现方式方法的模块或系统作为备份，再出现故障时可用冗余部分进行替换。<strong>N版本程序设计和恢复块方法都是基于设计冗余的思想</strong></p><h5 id="5-2-1-2-N版本程序设计"><a href="#5-2-1-2-N版本程序设计" class="headerlink" title="5.2.1.2 N版本程序设计"></a>5.2.1.2 N版本程序设计</h5><p>通过设计多个模块或不同的版本，对相同初始条件和相同输入的操作结果，实行多数表决，防止其中某一个模块/版本的故障提供错误的服务。<strong>N版本程序设计是一种静态的故障屏蔽技术，采用前向恢复的策略。</strong></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/8.png"></p><ul><li>与通常软件开发过程不同的是，N版本程序设计增加了三个新的阶段：<strong>相异成分规范评审、相异性确认、背对背测试</strong> 。</li><li><strong>N版本程序的同步、N版本程序之间的通信、表决算法(全等表决、非精确表决、Cosmetie表决）、—致比较问题、数据相异性。</strong></li></ul><h5 id="5-2-1-3-恢复块方法"><a href="#5-2-1-3-恢复块方法" class="headerlink" title="5.2.1.3 恢复块方法"></a>5.2.1.3 恢复块方法</h5><p>选择一组操作作为容错设计单元，把普通的程序块变成恢复快。<strong>恢复块方法是一种动态的故障屏蔽技术，采用后向恢复策略。</strong></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/9.png"></p><ul><li>设计时应保证<strong>实现主块和后备块之间的独立性</strong> ，避免相关错误的产生，使主块和备份块之间的共性错误降到最低程度。</li><li><strong>必须保证验证测试程序的正确性。</strong></li></ul><p><strong>N版本程序设计和恢复块方法对比</strong></p><table><thead><tr><th>对比</th><th>N版本程序设计</th><th>恢复块方法</th></tr></thead><tbody><tr><td>硬件运行环境</td><td>表决</td><td>单机</td></tr><tr><td>错误检测方法</td><td>多机</td><td>验证测试程序</td></tr><tr><td>恢复策略</td><td>前向恢复</td><td>后向恢复</td></tr><tr><td>实时性</td><td>好</td><td>差</td></tr></tbody></table><ul><li><strong>前向恢复</strong> ：使当前的计算继续下去，把系统恢复成连贯的正确状态，弥补当前状态的不连贯情况。</li><li><strong>后向恢复</strong> ：系统恢复到前一个正确状态，继续执行。</li></ul><h5 id="5-2-1-4-防卫式程序设计"><a href="#5-2-1-4-防卫式程序设计" class="headerlink" title="5.2.1.4 防卫式程序设计"></a>5.2.1.4 防卫式程序设计</h5><p>N版本程序设计和恢复块方法都是基于设计冗余的思想，这给程序员和处理机都增加了许多工作，而且它们的结构本身又带来了一些问题和困难，例如，多版本程序设计中的相关性错误问题和恢复块方法中的验证测试的设计等。</p><p><strong>防卫式程序设计</strong> 是一种不采用任何传统的容错技术就能实现软件容错的方法，对于程序中存在的错误和不一致性，防卫式程序设计的 <strong>基本思想</strong> 是 通过在程序中包含错误检查代码和错误恢复代码，使得一旦发生错误，程序就能撤消错误状态，恢复到一个已知的正确状态中去 。</p><p>实现策略包括：<strong>错误检测、破坏估计和错误恢复三个方面。</strong></p><h4 id="5-2-2-检错设计技术"><a href="#5-2-2-检错设计技术" class="headerlink" title="5.2.2 检错设计技术"></a>5.2.2 检错设计技术</h4><ul><li>检错技术 <strong>代价低于容错技术和冗余技术，但是不能自动解决故障，需要人工干预</strong> 。</li><li>检错技术注重考虑：<strong>检测对象、检测延时、实现方式、处理方式四个要素。</strong></li></ul><h4 id="5-2-3-降低复杂度设计技术"><a href="#5-2-3-降低复杂度设计技术" class="headerlink" title="5.2.3 降低复杂度设计技术"></a>5.2.3 降低复杂度设计技术</h4><p><strong>降低复杂度设计设计思想</strong> ：在保证软件功能基础上，简化软件结构、缩短软件结构、缩短程序代码长度、优化软件数据流向、降低软件复杂度、提高软件可靠性</p><h4 id="5-2-4-系统配置技术"><a href="#5-2-4-系统配置技术" class="headerlink" title="5.2.4 系统配置技术"></a>5.2.4 系统配置技术</h4><h5 id="5-2-4-1-双机容错技术"><a href="#5-2-4-1-双机容错技术" class="headerlink" title="5.2.4.1 双机容错技术"></a>5.2.4.1 双机容错技术</h5><p>双机容错技术 是一种软硬件结合的容错应用方案。该方案是由两台服务器和一个外接共享磁盘阵列及相应的双机软件组成在双机容错系统中，两台服务器一般区分为主系统和从系统（备用系统），两台服务器互为主从关系。每台服务器都有自己的系统盘（本地盘），安装操作系统和应用程序。每台服务器至少安装两块网卡，一块连接到网络上，对外提供服务；另一块与另一台服务器连接，用以侦测对方的工作状况。同时，每台服务器都连接在共享磁盘阵列上，用户数据存放在共享磁盘阵列中，当一台服务器出现故障时，另一台服务器主动替代工作，保证网络服务不间断。整个网络系统的数据通过磁盘阵列集中管理，极大地保护了数据的安全性和保密性。</p><p><strong>双机容错系统根据两台服务器的工作方式不同，可以有三种不同的工作模式，分别是双机热备模式、双机互备模式和双机双工模式</strong>。<strong>采用心跳的方法保证主系统与备用系统的联系</strong> 。</p><ol><li><p>双机热备模式 - （一台工作，一台后备）<br> 正常情况下，一台服务器处于工作状态（主系统），另一台服务器处于监控准备状态（备用系统）。如果没有采用共享磁盘阵列，则用户数据同时往两台服务器中写入，以保证数据的即时同步。当主系统出现故障时，通过双机软件将备用系统激活，保证应用在短时间内完全恢复正常使用。当主系统修复后，可重新接入系统要回自己的应用。<br> 双机热备模式是目前采用较多的一种模式，典型应用有证券资金服务器或行情服务器等。<br> 双机热备模式的主要缺点在于，备用系统长期处于后备的状态，存在一定的计算资源浪费。</p></li><li><p>双机互备模式 - （两台运行相对独立应用，互为后备）<br> 两台服务器均处于工作状态，为前端客户机提供各自不同的应用服务，并互相检测对方的运行情况。也就是说，两台服务器同时运行，但彼此均设为备用系统。当某一台服务器出现故障时，另一台服务器可以在短时间内将故障服务器的应用接管过来，从而保证了应用的持续性。双机互备模式的主要缺点是对服务器的性能要求比较高。</p></li><li><p>双机双工模式 - （两台同时运行相同的应用，互为后备）<br> 双机双工模式是集群（cluster）技术的一种形式，两台服务器均处于工作状态，同时为前端客户机提供相同的应用服务，以保证整体系统的性能，实现负载均衡和互为备份。</p></li></ol><h5 id="5-2-4-2-服务器集群技术"><a href="#5-2-4-2-服务器集群技术" class="headerlink" title="5.2.4.2 服务器集群技术"></a>5.2.4.2 服务器集群技术</h5><p>集群技术就是将多台计算机组织起来进行协同工作，它是提高系统可用性和可靠性的一种技术。在集群系统中，每台计算机均承担部分计算任务和容错任务，当其中一台计算机出现故障时，系统使用集群软件将这台计算机从系统中隔离出去，通过各计算机之间的负载转嫁机制完成新的负载分担，同时向系统管理人员发出警报。集群系统通过功能整合和故障过渡，实现了系统的高可用性和可靠性。</p><p><strong>集群内个节点服务器通过内部局域网相互通信，若某节点服务器发生故障，这台服务器运行的应用被另一个节点服务器自动接管。</strong></p><ol><li><p>高性能计算集群<br> 指以提高科学计算能力为目的计算机集群技术，它是一种并行计算集群的实现方法。并行计算是指将一个应用程序分割成多块可以并行执行的部分，并指定到多个处理器上执行的方法。</p></li><li><p>负载均衡集群<br> 负载均衡集群在多节点之间按照一定的策略（算法）分发负载。负载均衡建立在现有网络结构之上，它提供了一种廉价有效的方法来扩展服务器带宽，增加吞吐量，提高数据处理能力。负载均衡是一种动态均衡，它通过一些工具实时地分析数据包，掌握网络中的数据流量状况，把任务合理分配出去。<br> 比较常用的负载均衡实现技术主要有以下几种：<br> 1）基于特定软件的负载均衡（应用层)：很多网络协议都支持重定向功能，例如，基于HTTP重定向服务，其主要原理是服务器使用HTTP重定向指令，将一个客户端重新定位到另一个位置。服务器返回一个重定向响应，而不是返回请求的对象。客户端确认新地址然后重发请求，从而达到负载均衡的目的。<br> 2）基于DNS的负载均衡属于传输层负载均衡技术：其主要原理是在DNS服务器中为同一个主机名配置多个地址，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同的节点上去，使得不同的客户端访问不同的节点，从而达到负载均衡的目的。<br> 3）基于NAT的负载均衡：将一个外部IP地址映射为多个内部IP地址，对每次连接需求动态地转换为一个内部节点的地址，将外部连接请求引到转换得到地址的那个节点，上从而达到负载均衡的目的。<br> 4）反向代理负载均衡：将来自Internet上的连接请求以反向代理的方式动态地转发给内部网络上的多个节点进行处理，从而达到负载均衡的目的。<br> 5）混合型负载均衡</p></li><li><p>高可用性集群<br> 在高可用性集群系统中，多台计算机一起工作，各自运行一个或几个服务，各为服务定义一个或多台备用计算机。当某台计算机出现故障时，备用计算机便立即接管该故障计算机的应用，继续为前端的用户提供服务。</p></li></ol><h2 id="6-可靠性测试"><a href="#6-可靠性测试" class="headerlink" title="6 可靠性测试"></a>6 可靠性测试</h2><ul><li><strong>软件可靠性测试包括：</strong><br>  可靠性目标的确定、运行剖面的开发、测试用例的设计、测试实施、测试结果的分析等。</li><li><strong>测试步骤：</strong><br>  定义软件运行剖面(为软件的使用行为建模)一个 =&gt; 设计可靠性测试用例 =&gt; 实施可靠性测试。</li></ul><h2 id="7-可靠性评价"><a href="#7-可靠性评价" class="headerlink" title="7 可靠性评价"></a>7 可靠性评价</h2><p><strong>软件可靠性评价3个过程：</strong><br>选择可靠性模型、收集可靠性数据、可靠性评估和预测。</p><p><strong>选择可靠性模型考虑因素：</strong><br>模型假设的适用性、预测的能力与质量、模型输出值能否满足可靠性评价需求、模型使用的简便性。</p><p><strong>可靠性数据的收集：</strong><br>可靠性数据主要是指软件失效数据，是软件可靠性评价的基础，主要是在软件测试、实施阶段收集的。应采用的解决方法:及早确定所采用的的可靠性模型、制订可实施性较强的可靠性数据收集计划、重视软件测试数据的整理和分析、充分利用数据库来完成可靠性数据的存储和统计分析。</p><p><strong>可靠性评估和预测：</strong><br>判断是否达到了可靠性目标；如未能达到要再投入多少；在软件系统投入实际运行一年或若干时间后，经过维护、升级和修改，软件能否达到交付或部分交付用户使用的可靠性水平。辅助方法：失效数据的图形分析法、试探性数据分析技术。</p>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>高级技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构件与中间件技术</title>
    <link href="/2023/07/15/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E9%AB%98%E7%BA%A7%E6%8A%80%E8%83%BD/%E6%9E%84%E4%BB%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/07/15/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E9%AB%98%E7%BA%A7%E6%8A%80%E8%83%BD/%E6%9E%84%E4%BB%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="1-构件的定义"><a href="#1-构件的定义" class="headerlink" title="1 构件的定义"></a>1 构件的定义</h2><p><strong>定义1</strong>： 软件构件是一种组装单元，它具有规范的接口规约和显式的语境依赖。软件构件可以被独立地部署并由第三方任意地组装。<br><strong>定义2</strong>： 构件是某系统中有价值的、几乎独立的并可替换的一个部分，它在良好定义的体系结构语境内满足某清晰的功能。<br><strong>定义3</strong>： 构件是一个独立发布的功能部分，可以通过其接口访问它的服务。</p><p><strong>构件是一组通常需要同时部署的原子构件。</strong></p><p><strong>构件和原子构件之间的区别</strong>： 在于大多数原子构件永远都不会被单独部署，尽管它们可以被单独部署。相反，大多数原子构件都属于一个构件家族，一次部署往往涉及整个家族。</p><p><strong>一个原子构件是一个模块和一组资源。</strong><br><strong>原子构件是部署、版本控制和替换的基本单位</strong>。 原子构件通常成组地部署，但是它也能够被单独部署。<strong>一个模块是不带单独资源的原子构件</strong> (在这个严格定义下， Java包不是模块 ― 在Java中部署的原子单元是类文件。一个单独的包被编译成多个单独的类文件 一 每个公共类都有一个)。</p><p><strong>模块是一组类和可能的非面向对象的结构体，比如过程或者函数。</strong></p><p><strong>模块、对象、构件的区别：</strong></p><p>构件的特性是：(1)独立部署单元；(2)作为第三方的组装单元；(3)没有(外部的)可见状态。（可以用容器管理自身对外的可见状态）<br>一个构件可以包含多个类元素，但是一个类元素只能属于一个构件。将一个类拆分进行部署通常没什么意义。<br>对象的特性是：(1)一个实例单元，具有唯一的标志。(2)可能具有状态，此状态外部可见。(3)封装了自己的状态和<br>行为。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%9E%84%E4%BB%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/1.png"></p><h2 id="2-构件系统架构特性"><a href="#2-构件系统架构特性" class="headerlink" title="2 构件系统架构特性"></a>2 构件系统架构特性</h2><p><strong>口</strong> 构件系统体系结构由一组平台决策、一组构件框架和构件框架之间的互操作设计组成。</p><p><strong>口</strong> 构件框架是一种专用的体系结构(通常围绕一些关键的机制)，同时，也是一组固定地作用于构件层次机制的策略。</p><p><strong>口</strong> 概念框架的互操作设计包括系统体系结构连接的所有框架间的互操作的规则。</p><p><strong>口</strong> 构件是一组通常需要同时部署的原子构件。构件和原子构件之间的区别在于，大多数原子构件永远都不会被单独部署，尽管它们可以被单独部署。</p><p><strong>口</strong> 一个原子构件是一个模块和一组资源。</p><p><strong>口</strong> 模块是一组类和可能的非面向对象的结构体，比如过程或者函数。</p><p><strong>口</strong> 资源是一个类型化的项的固定集合。</p><p><strong>口</strong> 资源这个概念可以包含代码资源，进而包含模块。问题在于除了编译器编译一个模块或包生成的资源外，还可能存在其他的资源。在“纯对象”的方法中，资源是外部化的不可改变的对象――不可改变是因为构件没有持久化的标志，而且复制不能被区分。</p><p><strong>如果把软件系统看成是构件的集合，那么从构件的外部形态来看，构成一个系统的构件可分为 【五类】：</strong></p><p>(1) 独立而成熟的构件。 独立而成熟的构件得到了实际运行环境的多次检验，该类构件隐藏了所有接口，用户只需用规定好的命令进行使用。例如，数据库管理系统和操作系统等。<br>(2) 有限制的构件。 有限制的构件提供了接口，指出了使用的条件和前提，这种构件在装配时，会产生资源冲突、覆盖等影响，在使用时需要加以测试。 例如，各种面向对象程序设计语言中的基础类库等。<br>(3) 适应性构件。 适应性构件进行了包装或使用了接口技术，把 不兼容性、资源冲突等进行了处理，可以直接使用。这种构件可以不加修改地使用在各种环境中。 例如ActiveX等。<br>(4) 装配的构件。 装配(assemble) 的构件在安装时， 已经装配在操作系统、数据库管理系统或信息系统不同层次上， 使用胶水代码(gluecode) 就可以进行连接使用。目前一些软件商提供的大多数软件产品都属这一类。<br>(5) 可修改的构件。 可修改的构件可以进行版本替换。如果对原构件修改错误、增加新功能， 可以利用重新“包装”或写接口来实现构件的替换。 这种构件在应用系统开发中使用得比较多。</p><h2 id="3-中间件概述"><a href="#3-中间件概述" class="headerlink" title="3 中间件概述"></a>3 中间件概述</h2><p>中间件 是一种独立的系统软件或服务程序，可以帮助分布式应用软件在不同的技术之间共享资源。中间件可以：<br>1、负责客户机与服务器之间的连接和通信，以及客户机与应用层之间的高效率通信机制。<br>2、提供应用的负载均衡和高可用性、安全机制与管理功能，以及交易管理机制，保证交易的一致性。<br>3、提供应用层不同服务之间的互操作机制，以及应用层与数据库之间的连接和控制机制。<br>4、提供多层架构的应用开发和运行的平台，以及应用开发框架，支持模块化的应用开发。<br>5、屏蔽硬件、操作系统、网络和数据库的差异。<br>6、提供一组通用的服务去执行不同的功能，避免重复的工作，使应用之间可以协作。<br>中间件是一类构件。<br>中间件是一类系统软件。</p><p><strong>简化结构、屏蔽差异、利于复用。</strong></p><p><strong>采用中间件技术的优点：</strong></p><p>(1) 面向需求。 即设计师集中精力于业务逻辑本身。<br>(2) 业务的分隔和包容性。 应用开发人员可以按照不同的业务进行功能的划分，体现为不同的接口或交互模式。<br>(3) 设计与实现隔离。 构件对外发生作用或构件间的交互，都是通过接口进行的，构件使用者只需要知道构件的接口，而不必关心其内部实现，这是设计与实现分离的关键。<br>(4) 隔离复杂的系统资源。 架构很重要的一个功能就是将系统资源与应用构件隔离，这是保证构件可复用甚至“即插即用”的基础，与中间件的意图也是一致的。<br>(5) 符合标准的交互模型。 中间件则实现了架构的模型，实现了标准的协议。<br>(7) 软件复用。 中间件提供了构件封装、交互规则、与环境的隔离等机制，这些都为软件复用提供了方便的解决方案。<br>(8) 提供对应用构件的管理。 基于中间件的软件可以方便地进行管理，因为构件总可以通过标识机制进行划分。</p><h2 id="4-CBSD基于构件的模型（构件组装模型-基于构件的软件开发）"><a href="#4-CBSD基于构件的模型（构件组装模型-基于构件的软件开发）" class="headerlink" title="4 CBSD基于构件的模型（构件组装模型/基于构件的软件开发）"></a>4 CBSD基于构件的模型（构件组装模型/基于构件的软件开发）</h2><p>构件（Component，组件）是一个具有可重用价值的、功能相对独立的软件单元。基于构件的软件开发（ComponentBased Software Development，CBSD）模型是利用模块化方法，将整个系统模块化，并在一定构件模型的支持下，复用构件库中的一个或多个软件构件，通过组合手段高效率、高质量地构造应用软件系统的过程。</p><p>基于构件的开发模型融合了螺旋模型的许多特征，本质上是演化型的，开发过程是迭代的。基于构件的开发模型由软件的需求分析和定义、体系结构设计、构件库建立（其中构件库包括了构件获取和构件管理）、应用软件构建、测试和发布5个阶段组成。如图：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%9E%84%E4%BB%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/2.png"></p><p>CBSE的构件应该具备的特征：</p><blockquote><p>可组装性：所有外部交互必须通过公开定义的接口进行。<br>可部署性：构件总是二进制形式的，能作为一个独立实体在平台上运行。<br>文档化：用户根据文档来判断构件是否满足需求。<br>独立性：可以在无其他特殊构件的情况下进行组装和部署。<br>标准化：符合某种标准化的构件模型。</p></blockquote><p>CBSE的构件的组装顺序：</p><blockquote><p>顺序组装：按顺序调用己经存在的构件，可以用两个已经存在的构件来创造一个新的构件。<br>层次组装：被调用构件的“提供”接口必须和调用构件的“请求”接口兼容。<br>叠加组装：多个构件合并形成新构件，新构件整合原构件的功能，对外提供新的接口。</p></blockquote><p>构件作为重要的软件技术和工具得到了极大的发展，这些新技术标准和工具有Microsoft的DCOM/COM，Sun的EJB，OMG的CORBA等。基于构件的开发活动从标识候选构件开始，通过搜索已有构件库，确认所需要的构件是否已经存在，如果已经存在，就从构件库中提取出来复用；如果不存在，就采用面向对象方法开发它。在提取出来的构件通过语法和语义检查后，将这些构件通过胶合代码组装到一起实现系统，这个过程是迭代的。</p><p>基于构件的开发方法使得软件开发不再一切从头开始，开发的过程就是构件组装的过程，维护的过程就是构件升级、替换和扩充的过程，其优点是构件组装模型导致了软件的复用，提高了软件开发的效率；构件可由一方定义其规格说明，被另一方实现，然后供给第三方使用；构件组装模型允许多个项目同时开发，降低了费用，提高了可维护性，可实现分步提交软件产品。<br>缺点是由于采用自定义的组装结构标准，缺乏通用的组装结构标准，引入具有较大的风险；可重用性和软件高效性不易协调，需要精干的、有经验的分析人员和开发人员，一般的开发人员插不上手，客户的满意度低；过分依赖于构件，构件库的质量影响着产品质量。</p><p><strong>构件组装是指将构件库中的构件经过适当修改后相互连接，或者将它们与当前开发项目中的构件元素相连接，最终构成新的目标软件。</strong></p><p><strong>构件组装技术大致可分为基于功能的组装技术、基于数据的组装技术和面向对象的组装技术。</strong></p><h2 id="5-构件的复用"><a href="#5-构件的复用" class="headerlink" title="5 构件的复用"></a>5 构件的复用</h2><p>层次对应于构件组装过程中的不同任务。复用的维度</p><ol><li>水平复用：不分行业领域，通用。</li><li>垂直复用：分行业领域，专用。</li></ol><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%9E%84%E4%BB%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/3.png"></p><h3 id="5-1-检索与提取构件"><a href="#5-1-检索与提取构件" class="headerlink" title="5.1 检索与提取构件"></a>5.1 检索与提取构件</h3><p>已有的 构件分类方法 可以分为三大类，分别是 <strong>关键字分类法、刻面分类法和超文本组织方法</strong>。</p><ol><li><p>关键字分类法： 是一种最简单的构件库组织方法，其基本思想是：根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树状或有向无回路图结构。每个概念用一个描述性的关键字表示。不可分解的原子级关键字包含隶属于它的某些构件。</p></li><li><p>刻面分类法： 在刻面分类机制中， 定义若干用于刻画构件特征的“面”(facet) ， 每个面包含若干概念， 这些概念表述构件在面上的特征。刻画可以描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征。</p></li><li><p>超文本组织方法： 超文本组织方法与基于数据库系统的构件库组织方法不同，它基于全文检索技术，主要思想是：所有构件必须辅以详尽的功能或行为说明文档；说明中出现的重要概念或构件以网状链接方式相互连接；检索者在阅读文档的过程中可按照人类的联系思维方式任意跳转到包含相关概念或构件的文档；全文检索系统将用户给出的关键字与说明文档中的文字进行匹配，实现构件的浏览式检索。</p></li></ol><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%9E%84%E4%BB%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/4.png"></p><h3 id="5-2-理解与评价构件"><a href="#5-2-理解与评价构件" class="headerlink" title="5.2 理解与评价构件"></a>5.2 理解与评价构件</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%9E%84%E4%BB%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/5.png"></p><h3 id="5-3-修改构件"><a href="#5-3-修改构件" class="headerlink" title="5.3 修改构件"></a>5.3 修改构件</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%9E%84%E4%BB%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/6.png"></p><h3 id="5-4-组装构件"><a href="#5-4-组装构件" class="headerlink" title="5.4 组装构件"></a>5.4 组装构件</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%9E%84%E4%BB%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/7.png"></p><p><strong>系统构件组装分为三个不同的层次：定制(Customization) 、集成(Integration) 、扩展(Extension) 。这三个层次对应于构件组装过程中的不同任务。</strong></p><h2 id="6-构件标准"><a href="#6-构件标准" class="headerlink" title="6 构件标准"></a>6 构件标准</h2><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%9E%84%E4%BB%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/8.png"></p><h2 id="7-主要中间件"><a href="#7-主要中间件" class="headerlink" title="7 主要中间件"></a>7 主要中间件</h2><p><strong>伺服对象(Servant) ：</strong> CORBA对象的真正实现， 负责完成客户端请求。<br><strong>对象适配器(Object Adapter) ：</strong> 用于屏蔽ORB内核的实现细节， 为服务器对象的实现者提供抽象接口， 以便他们使用ORB内部的某些功能。<br><strong>对象请求代理(Object Request Broker) ：</strong> 解释调用并负责查找实现该请求的对象， 将参数传给找到的对象，并调用方法返回结果。客户方不需要了解服务对象的位置、通信方式、实现、激活或存储机制。</p><p><strong>CORBA体系的主要内容包括以下几部分：</strong></p><p>(1) 对象请求代理(Object Request Broker， ORB) 。 负责对象在分布环境中透明地收发请求和响应，它是构建分布对象应用、在异构或同构环境下实现应用间互操作的基础。<br>(2) 对象服务(Object Services) 。 为使用和实现对象而提供的基本对象集合， 这些服务应独立于应用领域。<br>(3) 公共设施(Common Facili tites) 。 向终端用户提供一组共享服务接口， 例如：系统管理、组合文档和电子邮件等。<br>(4) 应用接口(Application Interfaces) 。 由销售商提供的可控制其接口的产品，相应于传统的应用层表示，处于参考模型的最高层。<br>(5) 领域接口(Domain Interfaces) 。 为应用领域服务而提供的接口， 如OMG组织为PDM系统制定的规范。</p>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>高级技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件架构概念、架构风格、ABSD、架构复用、DSSA</title>
    <link href="/2023/07/15/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E9%AB%98%E7%BA%A7%E6%8A%80%E8%83%BD/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5%E3%80%81%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E3%80%81ABSD%E3%80%81%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8%E3%80%81DSSA/"/>
    <url>/2023/07/15/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E9%AB%98%E7%BA%A7%E6%8A%80%E8%83%BD/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5%E3%80%81%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E3%80%81ABSD%E3%80%81%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8%E3%80%81DSSA/</url>
    
    <content type="html"><![CDATA[<h2 id="1-软件架构的概念"><a href="#1-软件架构的概念" class="headerlink" title="1 软件架构的概念"></a>1 软件架构的概念</h2><h3 id="1-1-软件架构的定义"><a href="#1-1-软件架构的定义" class="headerlink" title="1.1 软件架构的定义"></a>1.1 软件架构的定义</h3><p><strong>软件架构概念</strong></p><p>软件架构（Software Architecture） = 软件体系结构<br>指系统的一个或者多个结构，结构包括：<br>（1）结构 - 软件的构件（可能是程序的模块、类、或者中间件）<br>（2）属性 - 构件的外部可见属性<br>（3）交互作用 - 构件之间的相互关系</p><p><strong>软件架构的本质</strong></p><p>软件架构为软件系统提供了一个 结构、行为和属性的高级抽象。<br>软件架构风格是特定应用领域的 惯用模式，架构定义 一个词汇表和一组约束。</p><p><strong>软件架构的作用</strong></p><p>软件架构是 项目干系人进行交流的手段。<br>软件架构是 可传递和可复用的模型，通过研究软件架构可能预测软件的质量。<br>软件架构使推理和控制的更改更加简单， 有助于循序渐进的原型设计，可以作为培训的基础。</p><p><strong>需求分析 → 架构（弥补需求到设计的鸿沟）→ 软件设计</strong><br>架构设计就是需求分配，既 将满足的需求的职责分配到组件上。</p><p>软件架构设计通过多种视图全面描述  4 + 1 视图。</p><h3 id="1-2-软件架构设计4-1视图"><a href="#1-2-软件架构设计4-1视图" class="headerlink" title="1.2 软件架构设计4+1视图"></a>1.2 软件架构设计4+1视图</h3><p>视角与视图：从不同的视角来检查，所以会有不同的视图。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5%E3%80%81%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E3%80%81ABSD%E3%80%81%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8%E3%80%81DSSA/1.png"></p><p><strong>逻辑视图</strong>：主要支持系统的功能需求，即系统提供给最终用户的服务。逻辑视图设计中要注意的主要问题是要保持一个单一的、内聚的对象模型贯穿整个系统，且描述对象模型和对象之间的关系。</p><p><strong>开发视图</strong>：也称为模块视图，主要侧重于软件模块的组织和管理。开发视图通过系统输入输出关系的模型图和子系统图来描述。可以在确定了软件包含的所有元素之后描述完整的开发角度，也可以在确定每个元素之前，列出开发视图原则。</p><p><strong>进程视图</strong>：也称为过程视图。侧重于系统的运行特性，主要关注一些非功能性的需求，例如系统的性能和可用性。进程视图强调并发性、分布性、系统集成性和容错能力，以及逻辑视图中的主要抽象的进程结构。进程视图可以描述成多层抽象，每个级别分别关注不同的方面。</p><p><strong>物理视图</strong>：主要考虑如何把软件映射到硬件上，它通常要考虑到解决系统拓扑结构、系统安装、通信等问题。</p><p><strong>场景</strong>：可以看作是那些重要系统活动的抽象，它使四个视图有机地联系起来，从某种意义上说，场景是最重要的需求抽象。在开发架构时，它可以帮助设计者找到架构的构件和它们之间的作用关系。同时，也可以用场景来分析一个特定的视图，或描述不同视图构件间是如何相互作用的。场景可以用文本表示，也可以用图形表示。</p><p><strong>逻辑视图和开发视图描述系统的静态结构</strong>，而<strong>进程视图和物理视图描述系统的动态结构</strong>。对于不同的软件系统来说，侧重的角度也有所不同。例如，对于管理信息系统来说，比较侧重于从逻辑视图和开发视图来描述系统，而对于实时控制系统来说，则比较注重于从进程视图和物理视图来描述系统。</p><h3 id="1-3-软件架构设计与生命周期"><a href="#1-3-软件架构设计与生命周期" class="headerlink" title="1.3 软件架构设计与生命周期"></a>1.3 软件架构设计与生命周期</h3><p><strong>软件架构是贯穿整个生命周期的，不同阶段的作用和意义不同</strong>，各阶段架构工作表现表：</p><table><thead><tr><th>阶段</th><th>作用和意义</th></tr></thead><tbody><tr><td>需求分析阶段</td><td><strong>有利于各阶段参与者的交流，也易于维护各阶段的可追踪性。</strong><br/>软件需求模型向软件架构模型转换关注两个问题：<br/>1）如何根据需求模型构建软件架构模型<br/>2）如何保证模型转换的可追踪性</td></tr><tr><td>设计阶段</td><td><strong>关注最早和最多的阶段</strong>。<br/>这一阶段的研究主要包括：<br/>1）软件架构模型的描述<br/>2）软件架构模型的设计与分析方法<br/>3）软件架构设计经验的总结与复用<br/>架构模型的描述研究包括：<br/>①组成SA（软件架构）模型 - 构件和连接的建模<br/>②架构描述语言（Architecture Describe Language，ADL）<br/>③多视图 - 4 + 1视图<br/>ADL三个基本元素：<br/>1）构件：计算或数据存储单元，包括构件和相应的构件接口<br/>2）连接件：用于构件之间交互建模的体系结构构造块及其支配这些交互的规则<br/>3）架构配置：描述体系结构的构件和连接件的连接图<br/>ADL是建模用的，是一些伪代码</td></tr><tr><td>实现阶段</td><td><strong>有效实现从软件架构设计向实现的转换。</strong><br/>这一阶段架构研究包括：<br/>1）基于架构开发过程的支持<br/>2）寻求从架构向实现过渡的途径<br/>3）研究基于架构的测试技术</td></tr><tr><td>构件组装阶段</td><td><strong>可复用构件组装的设计能够提高系统实现的效率。</strong><br/>这一阶段的研究内容包括：<br/>1）如何支持可复用构件的互联，即对架构设计模型中规约的连接子的实现提供支持<br/>2）组装过程中，如何检测并消除架构失配问题<br/>适配问题主要包括：<br/>①构件本身适配<br/>②连接子（互联机制）的失配<br/>③部分和整体的失配</td></tr><tr><td>部署阶段</td><td><strong>组织和展示部署阶段的软硬件架构、评估分析部署方案。</strong><br/>部署阶段的软件架构对软件部署的作用：<br/>1）提供高层的体系结构视图描述部署阶段的软硬件模型<br/>2）基于软件架构模型可以分析部署方案的质量属性从而选择合理的部署方案</td></tr><tr><td>后开发阶段</td><td><strong>主要围绕维护、演化、复用进行。</strong><br/>部署安装后（后开发阶段）的系统架构研究方向包括：<br/>1）动态软件体系结构<br/>2）体系结构恢复与重建</td></tr></tbody></table><h3 id="1-4-软件架构的重要性"><a href="#1-4-软件架构的重要性" class="headerlink" title="1.4 软件架构的重要性"></a>1.4 软件架构的重要性</h3><p>软件架构设计是降低成本、改进质量、按时和按需交付产品的关键因素。</p><h2 id="2-软件架构的风格-★★★★★"><a href="#2-软件架构的风格-★★★★★" class="headerlink" title="2 软件架构的风格 ★★★★★"></a>2 软件架构的风格 ★★★★★</h2><ul><li>架构风格定义了用于描述系统的术语表和一组指导构建系统的规则。</li><li>架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个构件有效地组织成一个完整的系统。</li><li>软件架构风格是特定应用领域的惯用模式，架构定义一个词汇表和一组约束。</li></ul><h3 id="2-1-经典五大风格"><a href="#2-1-经典五大风格" class="headerlink" title="2.1 经典五大风格"></a>2.1 经典五大风格</h3><table><thead><tr><th>五大架构风格</th><th>子风格</th></tr></thead><tbody><tr><td>数据流风格</td><td>批处理、管道-过滤器</td></tr><tr><td>调用/返回风格</td><td>程序/子程序、面向对象、层次结构</td></tr><tr><td>以数据为中心风格</td><td>数据库系统、黑板系统、超文本系统</td></tr><tr><td>虚拟机风格</td><td>解释器、规则系统</td></tr><tr><td>独立构件风格</td><td>进程通信、事件驱动系统（隐式调用）</td></tr></tbody></table><h4 id="2-1-1-数据流体系结构风格"><a href="#2-1-1-数据流体系结构风格" class="headerlink" title="2.1.1 数据流体系结构风格"></a>2.1.1 数据流体系结构风格</h4><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5%E3%80%81%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E3%80%81ABSD%E3%80%81%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8%E3%80%81DSSA/2.png"></p><table><thead><tr><th>优点</th><th>缺点</th><th>典型实例</th></tr></thead><tbody><tr><td>1、松耦合【高内聚-低耦合】<br/>2、良好的重用性/可维护性<br/>3、可扩展性【标准接口适配】<br/>4、良好的隐蔽性<br/>5、支持并行</td><td>1、交互性较差<br/>2、复杂性高<br/>3、性能较差（每个过滤器都需要解析与合成数据）</td><td>传统编译器<br/>网络报文处理</td></tr></tbody></table><h5 id="2-1-1-1-批处理风格"><a href="#2-1-1-1-批处理风格" class="headerlink" title="2.1.1.1 批处理风格"></a>2.1.1.1 批处理风格</h5><p>批处理风格的每一步处理都是独立的，并且每一步是顺序执行的。数据必须是完整的，以整体的方式传递。</p><h5 id="2-1-1-2-管道-过滤器风格"><a href="#2-1-1-2-管道-过滤器风格" class="headerlink" title="2.1.1.2 管道/过滤器风格"></a>2.1.1.2 管道/过滤器风格</h5><p>在管道/过滤器风格的软件架构中，每个构件都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生输出数据流。</p><h4 id="2-1-2-调用-返回体系结构风格"><a href="#2-1-2-调用-返回体系结构风格" class="headerlink" title="2.1.2 调用/返回体系结构风格"></a>2.1.2 调用/返回体系结构风格</h4><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5%E3%80%81%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E3%80%81ABSD%E3%80%81%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8%E3%80%81DSSA/3.png"></p><h5 id="2-1-2-1-主程序-子程序风格"><a href="#2-1-2-1-主程序-子程序风格" class="headerlink" title="2.1.2.1 主程序/子程序风格"></a>2.1.2.1 主程序/子程序风格</h5><p>主程序/子程序风格是结构化开发时期的经典架构风格。这种风格一般采用单线程控制，把问题划分为若干处理步骤，构件即为主程序和子程序。子程序通常可合成为模块。过程调用作为交互机制，即充当连接件。</p><h5 id="2-1-2-2-面向对象风格"><a href="#2-1-2-2-面向对象风格" class="headerlink" title="2.1.2.2 面向对象风格"></a>2.1.2.2 面向对象风格</h5><p>这种风格的构件是对象，或者说是抽象数据类型的实例。对象是一种被称作管理者的构件，它负责保持资源的完整性。对象是通过函数和过程的调用来交互的。</p><h5 id="2-1-2-3-层次结构风格"><a href="#2-1-2-3-层次结构风格" class="headerlink" title="2.1.2.3 层次结构风格"></a>2.1.2.3 层次结构风格</h5><p>层次系统组织成一个层次结构，每一层为上层服务，并作为下层客户。在一些层次系统中，除了一些精心挑选的输出函数外，内部的层只对相邻的层可见</p><h4 id="2-1-3-以数据为中心体系结构风格"><a href="#2-1-3-以数据为中心体系结构风格" class="headerlink" title="2.1.3 以数据为中心体系结构风格"></a>2.1.3 以数据为中心体系结构风格</h4><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5%E3%80%81%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E3%80%81ABSD%E3%80%81%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8%E3%80%81DSSA/4.png"></p><h5 id="2-1-3-1-仓库结构风格"><a href="#2-1-3-1-仓库结构风格" class="headerlink" title="2.1.3.1 仓库结构风格"></a>2.1.3.1 仓库结构风格</h5><p>数据库系统是仓库风格最常见的形式。在数据库系统中，构件主要有两大类，一类是中央共享数据源，保存当前系统的数据状态；另一类是多个独立处理单元，处理单元对数据元素进行操作。</p><h5 id="2-1-3-2-黑板结构风格"><a href="#2-1-3-2-黑板结构风格" class="headerlink" title="2.1.3.2 黑板结构风格"></a>2.1.3.2 黑板结构风格</h5><p>黑板系统包括知识源、黑板和控制三个部分。知识源包括若干独立计算的不同单元，提供解决问题的知识。知识源响应黑板的变化，也只修改黑板；黑板是一个全局数据库，包含问题域解空间的全部状态，是知识源相互作用的唯一媒介；知识源响应是通过黑板状态的变化来控制的。黑板系统通常应用在对于解决问题没有确定性算法的软件中，例如，信号处理、问题规划和编译器优化等。语音识别、知识推理。</p><h5 id="2-1-3-3-超文本系统风格"><a href="#2-1-3-3-超文本系统风格" class="headerlink" title="2.1.3.3 超文本系统风格"></a>2.1.3.3 超文本系统风格</h5><p>超文本系统中出现的构件以网状链接方式相互连接，用户可以在构件之间进行按照人类的联想思维方式任意跳转到相关构件。超文本是一种非线性的网状信息组织方法，它以结点为基本单位，链作为结点之间的联想式关联。超文本系统通常应用在互联网领域。</p><h4 id="2-1-4-虚拟机体系结构风格"><a href="#2-1-4-虚拟机体系结构风格" class="headerlink" title="2.1.4 虚拟机体系结构风格"></a>2.1.4 虚拟机体系结构风格</h4><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5%E3%80%81%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E3%80%81ABSD%E3%80%81%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8%E3%80%81DSSA/5.png"></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5%E3%80%81%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E3%80%81ABSD%E3%80%81%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8%E3%80%81DSSA/6.png"></p><h5 id="2-1-4-1-解释器风格"><a href="#2-1-4-1-解释器风格" class="headerlink" title="2.1.4.1 解释器风格"></a>2.1.4.1 解释器风格</h5><p>解释器通常包括一个完成解释工作的解释引擎、一个包含将被解释的代码的存储区、一个记录解释引擎当前工作状态的数据结构，以及一个记录源代码被解释执行的进度的数据结构。具有解释器风格的软件中含有一个虚拟机，可以仿真硬件的执行过程和一些关键应用，其缺点是执行效率比较低。</p><h5 id="2-1-4-2-规则系统风格"><a href="#2-1-4-2-规则系统风格" class="headerlink" title="2.1.4.2 规则系统风格"></a>2.1.4.2 规则系统风格</h5><p>基于规则的系统包括规则集、规则解释器、规则/数据选择器和工作内存，一般用在人工智能领域和DSS中。</p><h4 id="2-1-5-独立构件体系结构风格"><a href="#2-1-5-独立构件体系结构风格" class="headerlink" title="2.1.5 独立构件体系结构风格"></a>2.1.5 独立构件体系结构风格</h4><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5%E3%80%81%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E3%80%81ABSD%E3%80%81%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8%E3%80%81DSSA/7.png"></p><h5 id="2-1-5-1-进程间通信风格"><a href="#2-1-5-1-进程间通信风格" class="headerlink" title="2.1.5.1 进程间通信风格"></a>2.1.5.1 进程间通信风格</h5><p>构件是独立的过程，连接件是消息传递，构件通常是命名过程，消息传递的方式可以是点对点，异步或者同步的方式，以及远程过程方法调用等。</p><h5 id="2-1-5-2-事件驱动系统风格（隐式风格）"><a href="#2-1-5-2-事件驱动系统风格（隐式风格）" class="headerlink" title="2.1.5.2 事件驱动系统风格（隐式风格）"></a>2.1.5.2 事件驱动系统风格（隐式风格）</h5><p>构件不直接调用一个过程，而是触发或广播一个或多个事件。这种风格中的构件是匿名的过程，它们之间交互的连接件往往是以过程之间的隐式调用（implicit invocation）来实现的。基于事件的隐式调用风格的主要优点是为软件复用提供了强大的支持，为构件的维护和演化带来了方便，其缺点是构件放弃了对系统计算的控制。</p><h3 id="2-2-C2风格"><a href="#2-2-C2风格" class="headerlink" title="2.2 C2风格"></a>2.2 C2风格</h3><p>C2风格通过连接件连接构件或某个构件组，构件与构件之间无连接。</p><p>软件体系结构设计的一个核心问题就是能否使用重复的体系结构模式，即能否达到体系结构级的软件重用。</p><p>C2 = EBI（基于事件的集成）+ LCS（分层客户端服务器）</p><p>C2是一种基于构件和消息的架构风格，可用于创建灵活的，可伸缩的软件系统。可以将架构看作是按照一定规则由连接件如消息路由设备连接的许多构件组成的层次网络系统中的构件和连接件都有一个“顶部”和“底部”;一个构件的“顶部”或“底部”可以连接到一个连接件的“底部”或“顶部”;对于一个连接件，和其相连的构件或连接件的数量没有限制，但是构件和构件之间不能直接相连。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5%E3%80%81%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E3%80%81ABSD%E3%80%81%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8%E3%80%81DSSA/8.png"></p><p><strong>C2架构的基本规则：</strong></p><ul><li><strong>构件和连接件都有一个顶部和一个底部。</strong></li><li>构件的顶部要连接到连接件的底部，构件的底部要连接到连接件的顶部，构件之间不允许直连。</li><li>一个连接件可以和任意数目的其他构件和连接件连接。</li><li>当两个连接件进行直接连接时，必须由其中一个的底部到另一个的顶部。</li></ul><h3 id="2-3-闭环风格"><a href="#2-3-闭环风格" class="headerlink" title="2.3 闭环风格"></a>2.3 闭环风格</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5%E3%80%81%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E3%80%81ABSD%E3%80%81%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8%E3%80%81DSSA/9.png"></p><ul><li>适用于嵌入式系统，<strong>用于解决简单闭环控制问题。</strong></li><li><strong>经典应用：空调温控，定速巡航。</strong></li></ul><h2 id="3-基于架构的软件开发方法（ABSD）★★★★"><a href="#3-基于架构的软件开发方法（ABSD）★★★★" class="headerlink" title="3 基于架构的软件开发方法（ABSD）★★★★"></a>3 基于架构的软件开发方法（ABSD）★★★★</h2><h3 id="3-1-体系架构设计的方法概述"><a href="#3-1-体系架构设计的方法概述" class="headerlink" title="3.1 体系架构设计的方法概述"></a>3.1 体系架构设计的方法概述</h3><p><strong>基于架构的软件设计（ABSD，Architecture-Based Software Design）是一种架构驱动方法</strong>，架构驱动也就是说架构先行，需求获取和分析还没有完成就开始架构设计，需求获取和分析与架构设计并行，例如产品线系统和长期运行的系统，我们不可能开始就能决定所有的需求。</p><p><strong>ABSD强调由业务、质量和功能需求的组合驱动架构设计</strong> ，强调采用 <strong>视角和视图</strong> 来描述软件架构 ，采用 <strong>用例（功能需求）</strong>和<strong>质量场景（质量需求）</strong> 来描述需求 。</p><p><strong>ABSD方法有三个基础：</strong></p><p>第一个基础是功能的分解。在功能分解中，ABSD方法使用已有的基于模块的内聚和耦合技术。<br>第二个基础是通过选择架构风格来实现质量和业务需求。<br>第三个基础是软件模板的使用。</p><h3 id="3-2-基于架构的开发模型（ABSD）"><a href="#3-2-基于架构的开发模型（ABSD）" class="headerlink" title="3.2 基于架构的开发模型（ABSD）"></a>3.2 基于架构的开发模型（ABSD）</h3><p>传统的软件开发过程是问题定义，需求分析，软件设计，实现，测试。ABSD把整个软件过程分成六个部分，架构需求，设计，文档化，复审，实现，演化六个步骤。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5%E3%80%81%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E3%80%81ABSD%E3%80%81%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8%E3%80%81DSSA/10.png"></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5%E3%80%81%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E3%80%81ABSD%E3%80%81%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8%E3%80%81DSSA/11.png"></p><h2 id="4-特定领域的软件架构（DSSA）"><a href="#4-特定领域的软件架构（DSSA）" class="headerlink" title="4 特定领域的软件架构（DSSA）"></a>4 特定领域的软件架构（DSSA）</h2><p>DSSA（Domain Specific Software Architecture）特定领域软件架构，可以看做开发产品线的一个方法或理论，目标就是支持一个特定领域中多应用的生成。</p><h3 id="4-1-基本活动"><a href="#4-1-基本活动" class="headerlink" title="4.1 基本活动"></a>4.1 基本活动</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5%E3%80%81%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E3%80%81ABSD%E3%80%81%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8%E3%80%81DSSA/12.png"></p><p>（1）建立领域模型，一个严格定义的问题域或解决域。其中，垂直域是在相同领域中深入；水平域是在不同领域中平移。<br>（2）具有普遍性，使其可以用于领域中某个特定应用的开发。<br>（3）对整个领域的合适程序的抽象。<br>（4）具备该领域固定的、典型的在开发过程中的。可复用元素。</p><h3 id="4-2-领域分析机制"><a href="#4-2-领域分析机制" class="headerlink" title="4.2 领域分析机制"></a>4.2 领域分析机制</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5%E3%80%81%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E3%80%81ABSD%E3%80%81%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8%E3%80%81DSSA/13.png"></p><h3 id="4-3-建立过程"><a href="#4-3-建立过程" class="headerlink" title="4.3 建立过程"></a>4.3 建立过程</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A6%82%E5%BF%B5%E3%80%81%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E3%80%81ABSD%E3%80%81%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8%E3%80%81DSSA/14.png"></p><h2 id="5-软件架构的复用-★★★"><a href="#5-软件架构的复用-★★★" class="headerlink" title="5 软件架构的复用 ★★★"></a>5 软件架构的复用 ★★★</h2><ol><li>软件架构复用的定义及分类<br> 软件架构复用是系统化的软件开发过程：开发一组基本的软件构件模块，以覆盖不同的需求/体系结构之间的相似性，提高系统开发的效率、质量和性能。</li><li>软件架构复用的原因<br> 减少开发工作、减少开发时间、降低开发成本、提高生产力、提高产品质量，更好的互操作性。</li><li>软件架构复用的对象及形式<br> 可复用的资产包括：需求、架构设计、元素、建模分析、测试、项目规划、过程+方法+工具、人员、样本系统、缺陷消除。<br> 一般形式的复用包括：函数的复用、库的复用、面向对象开发中的类、接口和包的复用。</li><li>软件架构复用的基本过程<br> （1） 首先构建/获取可复用的软件资产（复用前提）；<br> （2） 管理可复用资产；<br> （3） 使用可复用资产。</li></ol>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>高级技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty高性能理解</title>
    <link href="/2023/07/13/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/netty/Netty%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    <url>/2023/07/13/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/netty/Netty%E9%AB%98%E6%80%A7%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="1-异步非阻塞通信"><a href="#1-异步非阻塞通信" class="headerlink" title="1 异步非阻塞通信"></a>1 异步非阻塞通信</h2><p>在IO 编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者IO 多路复用技术进行处理。IO 多路复用技术通过把多个IO 的阻塞复用到同一个select 的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，I/O 多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源。</p><p>JDK1.4 提供了对非阻塞IO（NIO）的支持，JDK1.5_update10 版本使用epoll 替代了传统的select/poll，极大的提升了NIO 通信的性能。</p><p>与Socket 类和ServerSocket 类相对应，NIO 也提供了SocketChannel 和ServerSocketChannel 两种不同的套接字通道实现。这两种新增的通道都支持阻塞和非阻塞两种模式。阻塞模式使用非常简单，但是性能和可靠性都不好，非阻塞模式正好相反。开发人员一般可以根据自己的需要来选择合适的模式，一般来说，低负载、低并发的应用程序可以选择同步阻塞IO以降低编程复杂度。但是对于高负载、高并发的网络应用，需要使用NIO 的非阻塞模式进行开发。Netty 架构按照Reactor模式设计和实现，</p><p>服务端通信序列图如下：</p><p><img src="/image/Netty/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%80%9A%E4%BF%A1%E5%BA%8F%E5%88%97%E5%9B%BE.jpg"></p><p>客户端通信序列图如下：</p><p><img src="/image/Netty/%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1%E5%BA%8F%E5%88%97%E5%9B%BE.jpg"></p><p>Netty 的IO线程NioEventLoop聚合了多路复用器Selector，可以同时并发处理成百上千个客户端Channel，由于读写操作都是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁IO阻塞导致的线程挂起。另外，由于Netty采用了异步通信模式，一个IO线程可以并发处理N个客户端连接和读写操作，这从根本上解决了传统同步阻塞IO一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p><h2 id="2-零拷贝"><a href="#2-零拷贝" class="headerlink" title="2 零拷贝"></a>2 零拷贝</h2><p>Netty 的“零拷贝”主要体现在如下三个方面：</p><ol><li><p>Netty 的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM 会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p></li><li><p>Netty 提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。</p></li></ol><ol start="3"><li>Netty 的文件传输采用了transferTo()方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write()方式导致的内存拷贝问题。</li></ol><h2 id="3-内存池"><a href="#3-内存池" class="headerlink" title="3 内存池"></a>3 内存池</h2><p>随着JVM虚拟机和JIT即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓冲区Buffer，情况却稍有不同，特别是对于堆外直接内存的分配和回收，是一件耗时的操作。为了尽量重用缓冲区，Netty 提供了基于内存池的缓冲区重用机制。</p>]]></content>
    
    
    <categories>
      
      <category>网络通信</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>NIO</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty重构RPC</title>
    <link href="/2023/07/12/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/netty/Netty%E9%87%8D%E6%9E%84RPC/"/>
    <url>/2023/07/12/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/netty/Netty%E9%87%8D%E6%9E%84RPC/</url>
    
    <content type="html"><![CDATA[<h2 id="1-RPC概述"><a href="#1-RPC概述" class="headerlink" title="1 RPC概述"></a>1 RPC概述</h2><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本, 通常会采用单一应用架构。之后出现了ORM 框架，主要用于简化增删改查工作流的，数据访问框架ORM 是关键。</p><p>随着用户量增加，当访问量逐渐增大，单一应用增加机器，带来的加速度越来越小，需要将应用拆分成互不干扰的几个应用，以提升效率，于是就出现了垂直应用架构。MVC 架构就是一种非常经典的用于加速前端页面开发的架构。</p><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服逐渐形成稳定的服务中心，使前端应用能更快速的响应，多变的市场需求，就出现了分布式服务架构。分布式架构下服务数量逐渐增加，为了提高管理效率，RPC 框架应运而生。RPC 用于提高业务复用及整合的，分布式服务框架下RPC 是关键。</p><p>下一代框架，将会是流动计算架构占据主流。当服务越来越多，容量的评估，小服务的资源浪费等问题，逐渐明显。此时，需要增加一个调度中心，基于访问压力实时管理集群容量，提高集群利用率。SOA架构就是用于提高及其利用率的，资源调度和治理中心SOA是关键。</p><p>Netty 基本上是作为架构的技术底层而存在的，主要完成高性能的网络通信。</p><h2 id="2-环境预设"><a href="#2-环境预设" class="headerlink" title="2 环境预设"></a>2 环境预设</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io,netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.6.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.16.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>主要模块包括：</p><p>​    api：主要用来定义对外开放的功能与服务接口。</p><p>​    protocol：主要定义自定义传输协议的内容。</p><p>​    registry：主要负责保存所有可用的服务名称和服务地址。</p><p>​    provider：实现对外提供的所有服务的具体功能。</p><p>​    consumer：客户端调用。</p><p>​    monitor：完成调用链监控。</p><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h2><h3 id="3-1-API模块"><a href="#3-1-API模块" class="headerlink" title="3.1 API模块"></a>3.1 API模块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用来确认服务是否可用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IRpcHelloService</span> &#123;<br>    String <span class="hljs-title function_">hello</span><span class="hljs-params">(String name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//模拟业务加、减、乘、除运算</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IRpcService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mult</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-创建自定义协议"><a href="#3-2-创建自定义协议" class="headerlink" title="3.2 创建自定义协议"></a>3.2 创建自定义协议</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InvokerProtocol</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> String className; <span class="hljs-comment">//类名</span><br>    <span class="hljs-keyword">private</span> String methodName; <span class="hljs-comment">//函数名</span><br>    <span class="hljs-keyword">private</span> Class&lt;?&gt;[] params; <span class="hljs-comment">//参数类型</span><br>    <span class="hljs-keyword">private</span> Object[] values; <span class="hljs-comment">//参数列表</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-实现Provider服务端业务逻辑"><a href="#3-3-实现Provider服务端业务逻辑" class="headerlink" title="3.3 实现Provider服务端业务逻辑"></a>3.3 实现Provider服务端业务逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcHelloServicceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRpcHelloService</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello &quot;</span> + name + <span class="hljs-string">&quot;!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRpcService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> a - b;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mult</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> a * b;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> a / b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-Registry服务注册"><a href="#3-4-Registry服务注册" class="headerlink" title="3.4 Registry服务注册"></a>3.4 Registry服务注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcRegistry</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RpcRegistry</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span>&#123;<br>        <span class="hljs-built_in">this</span>.port = port;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;()&#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>                        <span class="hljs-comment">//自定义协议解码器</span><br>                        <span class="hljs-comment">/** 入参有5个</span><br><span class="hljs-comment">                         maxFrameLength: 框架的最大长度，如果帧的长度大于此值，则抛出TooLongFrameException</span><br><span class="hljs-comment">                         lengthFieldOffset: 长度字段的偏移量，即对应的长度字段在整个消息数据中的位置</span><br><span class="hljs-comment">                         lengthFieldLength: 长度字段的长度。如：长度字段是int型表示，那么这个值就是4(long就是8)</span><br><span class="hljs-comment">                         lengthAdjustment: 要添加到长度字段值的补偿值</span><br><span class="hljs-comment">                         initialBytesToStrip: 从解码帧中去除的第一个字节数</span><br><span class="hljs-comment">                        */</span><br>                        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LenthFieldBasedFrameDecoder</span>(Integer.MAX_VALUE, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>));<br>                        <span class="hljs-comment">//自定义协议编码器</span><br>                        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LenthFieldPrepender</span>(<span class="hljs-number">4</span>));<br>                        <span class="hljs-comment">//对象参数类型编码器</span><br>                        pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectEncoder</span>());<br>                        <span class="hljs-comment">//对象参数类型解码器</span><br>                        pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectDecoder</span>(Integer.MAX_VALUE, ClassResolvers.cacheDisabled(<span class="hljs-literal">null</span>)));<br>                        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RegistryHandler</span>());<br>                    &#125;<br>                &#125;)<br>                .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>                .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>);<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> b.bind(port).sync();<br>            System.out.println(<span class="hljs-string">&quot;RPC Registry start listen at &quot;</span> + port);<br>            future.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            bossGroup.shutdownGraceFully();<br>            workerGroup.shutdownGraceFully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegistryHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br>    <span class="hljs-comment">//用于保存所有可用的服务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConcurrentHashMap&lt;String, Object&gt; registryMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">//保存所有相关的服务类</span><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; classNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RegistryHandler</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//完成递归扫描</span><br>        scannerClass(<span class="hljs-string">&quot;com.test.netty.rpc.provider&quot;</span>);<br>        doRegister();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-type">InvokerProrocol</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (InvokerProrocol) msg;<br>        <span class="hljs-comment">//当客户端建立连接时，需要从自定义协议中获取消息，拿到具体的服务和实参</span><br>        <span class="hljs-comment">//使用反射调用</span><br>        <span class="hljs-keyword">if</span>(registryMap.containsKey(request.getClassName()))&#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> registryMap.get(request.getClassName());<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getClass().getMethod(request.getMethodName(), requet.getParams());<br>            result = method.invoke(clazz, request.getValues());<br>        &#125;<br>        ctx.write(result);<br>        ctx.flush();<br>        ctx.close();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>    <br>    <span class="hljs-comment">//递归扫描</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scannereClass</span><span class="hljs-params">(String packageName)</span>&#123;<br>        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClass().getClassLoadere().getResource(packageName.replaceAll(<span class="hljs-string">&quot;\\.&quot;</span>. <span class="hljs-string">&quot;/&quot;</span>));<br>        <span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(url.getFile());<br>        <span class="hljs-keyword">for</span>(File file : dir.listFiles())&#123;<br>            <span class="hljs-comment">//如果是一个文件夹，继续递归</span><br>            <span class="hljs-keyword">if</span>(file.isDirectory())&#123;<br>                scannerClass(packageName + <span class="hljs-string">&quot;.&quot;</span> + file.getName);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                classNames.add(packageName + <span class="hljs-string">&quot;.&quot;</span> + file.getName().replace(<span class="hljs-string">&quot;.class&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).trim());<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//完成注册</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRegistry</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(classNames.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span>(String className : classNames)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Class&lt;?&gt; clazz = Class.forName(className);<br>                Class&lt;?&gt; i = clazz.getInterfaces()[<span class="hljs-number">0</span>];<br>                registryMap.put(i.getName(), clazz.newInstance());<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-Consumer远程调用"><a href="#3-5-Consumer远程调用" class="headerlink" title="3.5 Consumer远程调用"></a>3.5 Consumer远程调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcProxy</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">create</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span>&#123;<br>        <span class="hljs-comment">//clazz传进来本身就是interface</span><br>        <span class="hljs-type">MethodProxy</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodProxy</span>(clazz);<br>        Class&lt;?&gt;[] interfaces = clazz.isInterface() ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;clazz&#125; : clazz.getInterfaces();<br>        <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T) Proxy.newProxyInnstance(clazz.getClassLoader, interfaces, proxy);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>        <span class="hljs-keyword">private</span> Class&lt;?&gt; clazz;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MethodProxy</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span>&#123;<br>            <span class="hljs-built_in">this</span>.clazz = clazz;<br>        &#125;<br>        <br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method mehtod, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable&#123;<br>            <span class="hljs-comment">//如果传进来是一个已实现的具体类，忽略</span><br>            <span class="hljs-keyword">if</span>(Object.class.equals(method.getDeclaringClass()))&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-built_in">this</span>, args);<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable t)&#123;<br>                    t.printStackTrace();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//传进来的是一个接口（核心）</span><br>                <span class="hljs-keyword">return</span> rpcInvoke(proxy, method, args);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//实现接口的核心方法</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">rpcInvoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span>&#123;<br>            <span class="hljs-comment">//传输协议封装</span><br>            <span class="hljs-type">InvokerProtocol</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerProtocol</span>();<br>            msg.setClassName(<span class="hljs-built_in">this</span>.clazz.getName());<br>            msg.setMethodName(method.getName());<br>            msg.setValues(args);<br>            msg.setParams(method.getParameterTypes());<br>            <br>            <span class="hljs-keyword">final</span> <span class="hljs-type">RpcProxyHandler</span> <span class="hljs-variable">consumerHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcProxyHandler</span>();<br>            <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>                b.group(group)<br>                    .channel(NioSocketChannel.class)<br>                    .option(ChannelOption.TCP_NODELAY, <span class="hljs-literal">true</span>)<br>                    .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;()&#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>                            pipelien.addLast(<span class="hljs-string">&quot;frameDecoder&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LengthFieldBasedFrameDecoder</span>(Interger.MAX_VALUE, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>));<br>                            pipeline.addLast(<span class="hljs-string">&quot;frameEncoder&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LengthFieldPrepender</span>(<span class="hljs-number">4</span>));<br>                            pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectEncoder</span>());<br>                            pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectDecoder</span>(Integer.MAX_VALUE, ClassResolvers.cacheDisabled(<span class="hljs-literal">null</span>)));<br>                            pipeline.addLast(<span class="hljs-string">&quot;handler&quot;</span>, consumerHandler);<br>                        &#125;<br>                    &#125;);<br>                <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> b.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>).sync();<br>                future.channel().writeAndFlush(msg).sync();<br>                future.channel().closeFuture().sync();<br>            &#125; <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span>&#123;<br>                group.shutdownGracefully();<br>            &#125;<br>            <span class="hljs-keyword">return</span> consumerHandler.getResponse();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcProxyHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br>    <span class="hljs-keyword">private</span> Object response;<br>    <span class="hljs-keyword">public</span> object <span class="hljs-title function_">getResponse</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        response = msg;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;client exception is genneral&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成客户端调用代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcConsumer</span>&#123;<br>    <span class="hljs-type">IRpcHelloService</span> <span class="hljs-variable">rpcHello</span> <span class="hljs-operator">=</span> RpcProxy.create(IRpcHelloService.class);<br>    System.out.println(rpcHello.hello(<span class="hljs-string">&quot;test&quot;</span>));<br>    <span class="hljs-type">IRpcService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> RpcProxy.create(IRpcService.class);<br>    System.out.println(<span class="hljs-string">&quot;8 + 2 = &quot;</span> + service.add(<span class="hljs-number">8</span>, <span class="hljs-number">2</span>));<br>    System.out.println(<span class="hljs-string">&quot;8 - 2 = &quot;</span> + service.sub(<span class="hljs-number">8</span>, <span class="hljs-number">2</span>));<br>    System.out.println(<span class="hljs-string">&quot;8 * 2 = &quot;</span> + service.mult(<span class="hljs-number">8</span>, <span class="hljs-number">2</span>));<br>    System.out.println(<span class="hljs-string">&quot;8 / 2 = &quot;</span> + service.div(<span class="hljs-number">8</span>, <span class="hljs-number">2</span>));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络通信</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>NIO</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO与Netty初识</title>
    <link href="/2023/07/10/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/netty/NIO%E4%B8%8ENetty%E5%88%9D%E8%AF%86/"/>
    <url>/2023/07/10/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/netty/NIO%E4%B8%8ENetty%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Java-NIO"><a href="#1-Java-NIO" class="headerlink" title="1 Java NIO"></a>1 Java NIO</h2><p>在NIO 中有几个核心对象需要掌握：缓冲区（Buffer）、选择器（Selector）、通道（Channel）。</p><h3 id="1-1-缓冲区–Buffer"><a href="#1-1-缓冲区–Buffer" class="headerlink" title="1.1 缓冲区–Buffer"></a>1.1 缓冲区–Buffer</h3><h4 id="1-1-1-基本API"><a href="#1-1-1-基本API" class="headerlink" title="1.1.1 基本API"></a>1.1.1 基本API</h4><p>缓冲区实际上是一个容器对象，更直接的说，其实就是一个数组，在NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，它也是写入到缓冲区中的；任何时候访问NIO 中的数据，都是将它放到缓冲区中。而在面向流I/O 系统中，所有数据都是直接写入或者直接将数据读取到Stream 对象中。在NIO 中，所有的缓冲区类型都继承于抽象类Buffer，最常用的就是ByteBuffer，对于Java 中的基本类型，基本都有一个具体Buffer 类型与之相对应。下面是一个简单的使用IntBuffer 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntBufferDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//分配新的int缓冲区，参数为缓冲区容量</span><br>        <span class="hljs-comment">//新缓冲区的当前位置为0，其界限(限制位置)为其容量，有一个底层实现数组，偏移量为0</span><br>        <span class="hljs-type">IntBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> IntBuffer.allocate(<span class="hljs-number">8</span>);<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; buffer.capacity(); ++i)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * (i + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//将给定整数写入此缓冲区的当前位置，当前位置递增</span><br>            buffer.put(j);<br>        &#125;<br>        <span class="hljs-comment">//重设此缓冲区，将限制设置为当前位置，然后将当前位置设置为0</span><br>        buffer.flip();<br>        <span class="hljs-keyword">while</span> (buffer.hasRemaining())&#123;<br>            <span class="hljs-comment">//读取此缓冲区当前位置的整数，然后当前位置递增</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> buffer.get();<br>            System.out.println(j + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-1-2-Buffer的基本原理"><a href="#1-1-2-Buffer的基本原理" class="headerlink" title="1.1.2 Buffer的基本原理"></a>1.1.2 Buffer的基本原理</h4><p>缓冲区其实是一个特殊的数组，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况，如果使用get()方法从缓冲区获取数据或者使用put()方法把数据写入缓冲区，都会引起缓冲区状态的变化。</p><p>在缓冲区中，最重要的属性有下面三个，它们一起合作完成对缓冲区内部状态的变化跟踪：</p><p>position：指定下一个将要被写入或者读取的元素索引，它的值由get()/put()方法自动更新，在新创建一个Buffer 对象时，position 被初始化为0。</p><p>limit：指定还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。</p><p>capacity：指定了可以存储在缓冲区中的最大数据容量，实际上，它指定了底层数组的大小，或者至少是指定了准许我们使用的底层数组的容量。</p><p>以上三个属性值之间有一些相对大小的关系：0 &lt;= position &lt;= limit &lt;= capacity。如果创建一个新的容量大小为10 的ByteBuffer 对象，在初始化的时候，position 设置为0，limit 和capacity 被设置为10，在以后使用ByteBuffer对象过程中，capacity 的值不会再发生变化，而其它两个将会随着使用而变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;E://test.txt&quot;</span>);<br>        <span class="hljs-comment">//创建文件的操作管道</span><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> fin.getChannel();<br>        <br>        <span class="hljs-comment">//分配一个10个大小缓冲区，就是分配了一个10个大小的byte数组</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">10</span>);<br>        output(<span class="hljs-string">&quot;初始化&quot;</span>， buffer);<br>        <span class="hljs-comment">//先读一下</span><br>        fc.read(buffer);<br>        output(<span class="hljs-string">&quot;调用read()&quot;</span>， buffer);<br>        <span class="hljs-comment">//准备操作之前，先锁定操作范围</span><br>        buffer.flip();<br>        output(<span class="hljs-string">&quot;调用flip()&quot;</span>， buffer);<br>        <span class="hljs-comment">//判断有没有可读数据</span><br>        <span class="hljs-keyword">while</span> (buffer.remaining() &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> buffer.get();<br>        &#125;<br>        output(<span class="hljs-string">&quot;调用get()&quot;</span>， buffer);<br>        <br>        <span class="hljs-comment">//可以理解为解锁</span><br>        buffer.clear();<br>        output(<span class="hljs-string">&quot;调用clear()&quot;</span>， buffer);<br>        <br>        fin.close();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">output</span><span class="hljs-params">(String step, Buffer buffer)</span>&#123;<br>        System.out.println(step + <span class="hljs-string">&quot; : &quot;</span>);<br>        <span class="hljs-comment">//容量，数组大小</span><br>        System.out.print(<span class="hljs-string">&quot;capacity: &quot;</span> + buffer.capacity() + <span class="hljs-string">&quot;, &quot;</span>);<br>        <span class="hljs-comment">//当前操作数据所在的位置，也可以叫做游标</span><br>        System.out.print(<span class="hljs-string">&quot;position: &quot;</span> + buffer.position() + <span class="hljs-string">&quot;, &quot;</span>);<br>        <span class="hljs-comment">//锁定值，flip，数据操作范围索引只能在position - limit之间</span><br>        System.out.println(<span class="hljs-string">&quot;limit: &quot;</span> + buffer.limit());<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对以上运行代码进行图解，四个属性值分别如图所示：</p><p><img src="/image/Netty/1.png"></p><p>可以从通道中读取一些数据到缓冲区中，注意从通道读取数据，相当于往缓冲区中写入数据。如果读取4 个字节的数据，则此时position 的值为4，即下一个将要被写入的字节索引为4，而limit 仍然是10，如下图所示：</p><p><img src="/image/Netty/2.png"></p><p>下一步把读取的数据写入到输出通道中，相当于从缓冲区中读取数据，在此之前，必须调用flip()方法，该方法将会完成两件事情：</p><p>​    1. 把limit 设置为当前的position 值</p><p>​    2. 把position 设置为0</p><p>由于position 被设置为0，所以可以保证在下一步输出时读取到的是缓冲区中的第一个字节，而limit 被设置为当前的position，可以保证读取的数据正好是之前写入到缓冲区中的数据，如下图所示：</p><p><img src="/image/Netty/3.png"></p><p>现在调用get()方法从缓冲区中读取数据写入到输出通道，这会导致position 的增加而limit 保持不变，但position 不会超过limit 的值，所以在读取之前写入到缓冲区中的4 个字节之后，position 和limit 的值都为4，如下图所示：</p><p><img src="/image/Netty/4.png"></p><p>在从缓冲区中读取数据完毕后，limit 的值仍然保持在调用flip()方法时的值，调用clear()方法能够把所有的状态变化设置为初始化时的值，如下图所示：</p><p><img src="/image/Netty/5.png"></p><h4 id="1-1-3-缓冲区的分配"><a href="#1-1-3-缓冲区的分配" class="headerlink" title="1.1.3 缓冲区的分配"></a>1.1.3 缓冲区的分配</h4><p>在创建一个缓冲区对象时，会调用静态方法allocate()来指定缓冲区的容量，其实调用allocate()相当于创建了一个指定大小的数组，并把它包装为缓冲区对象。或者也可以直接将一个现有的数组，包装为缓冲区对象，如下示例代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferWrap</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer1</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">10</span>);<br>        <br>        <span class="hljs-type">byte</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer2</span> <span class="hljs-operator">=</span> ByteBuffer.wrep(array);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-1-4-缓冲区分片"><a href="#1-1-4-缓冲区分片" class="headerlink" title="1.1.4 缓冲区分片"></a>1.1.4 缓冲区分片</h4><p>在NIO 中，除了可以分配或者包装一个缓冲区对象外，还可以根据现有的缓冲区对象来创建一个子缓冲区，即在现有缓冲区上切出一片来作为一个新的缓冲区，但现有的缓冲区与创建的子缓冲区在底层数组层面上是数据共享的，也就是说，子缓冲区相当于是现有缓冲区的一个视图窗口。调用slice()方法可以创建一个子缓冲区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferSlice</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">10</span>);<br>        <br>        <span class="hljs-comment">//缓冲区中的数据是0-9</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; buffer.capacity(); ++i)&#123;<br>            buffer.put((<span class="hljs-type">byte</span>) i);<br>        &#125;<br>        <span class="hljs-comment">//创建子缓冲区</span><br>        buffer.position(<span class="hljs-number">3</span>);<br>        buffer.limit(<span class="hljs-number">7</span>);<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">slice</span> <span class="hljs-operator">=</span> buffer.slice();<br>        <span class="hljs-comment">//改变子缓冲区的内容</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; slice.capacity(); ++i)&#123;<br>            <span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> slice.get(i);<br>            b *= <span class="hljs-number">10</span>;<br>            slice.put(i, b);<br>        &#125;<br>        buffer.position(<span class="hljs-number">0</span>);<br>        buffer.limit(buffer.capacity());<br>        <span class="hljs-keyword">while</span>(buffer.remaining() &gt; <span class="hljs-number">0</span>)&#123;<br>            System.out.println(buffer.get());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在该示例中，分配了一个容量大小为10 的缓冲区，并在其中放入了数据0-9，而在该缓冲区基础之上又创建了一个子缓冲区，并改变子缓冲区中的内容，从最后输出的结果来看，只有子缓冲区“可见的”那部分数据发生了变化，并且说明子缓冲区与原缓冲区是数据共享的。</p><h4 id="1-1-5-只读缓冲区"><a href="#1-1-5-只读缓冲区" class="headerlink" title="1.1.5 只读缓冲区"></a>1.1.5 只读缓冲区</h4><p>只读缓冲区可以读取，但是不能写入数据。可以通过调用缓冲区的asReadOnlyBuffer()方法，将任何常规缓冲区转换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区，并与原缓冲区共享数据，只不过它是只读的。如果原缓冲区的内容发生了变化，只读缓冲区的内容也随之发生变化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadOnlyBuffer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">//缓冲区中的数据是0-9</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; buffer.capacity(); ++i)&#123;<br>            buffer.put((<span class="hljs-type">byte</span>) i);<br>        &#125;<br>        <span class="hljs-comment">//创建只读缓冲区</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">readonly</span> <span class="hljs-operator">=</span> buffer.asReadOnlyBuffer();<br>        <span class="hljs-comment">//改变原缓冲区的内容</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; buffer.capacity(); ++i)&#123;<br>            <span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> buffer.get(i);<br>            b *= <span class="hljs-number">10</span>;<br>            buffer.put(i, b);<br>        &#125;<br>        readonly.position(<span class="hljs-number">0</span>);<br>        readonly.limit(buffer.capacity());<br>        <span class="hljs-comment">//只读缓冲区的内容也随之改变</span><br>        <span class="hljs-keyword">while</span>(readonly.remaining() &gt; <span class="hljs-number">0</span>)&#123;<br>            System.out.println(readonly.get());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果尝试修改只读缓冲区的内容，则会报ReadOnlyBufferException 异常。只读缓冲区对于保护数据很有用。在将缓冲区传递给某个对象的方法时，无法知道这个方法是否会修改缓冲区中的数据。创建一个只读的缓冲区可以保证该缓冲区不会被修改。只可以把常规缓冲区转换为只读缓冲区，而不能将只读的缓冲区转换为可写的缓冲区。</p><h4 id="1-1-6-直接缓冲区"><a href="#1-1-6-直接缓冲区" class="headerlink" title="1.1.6 直接缓冲区"></a>1.1.6 直接缓冲区</h4><p>直接缓冲区是为加快I/O 速度，使用一种特殊方式为其分配内存的缓冲区，JDK 文档中的描述为：给定一个直接字节缓冲区，Java虚拟机将尽最大努力直接对它执行本机I/O 操作。也就是说，它会在每一次调用底层操作系统的本机I/O 操作之前(或之后)，尝试避免将缓冲区的内容拷贝到一个中间缓冲区中或者从一个中间缓冲区中拷贝数据。要分配直接缓冲区，需要调用allocateDirect()方法，而不是allocate()方法，使用方式与普通缓冲区并无区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectBuffer</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">infile</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;E://test.txt&quot;</span>;<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(infile);<br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fcin</span> <span class="hljs-operator">=</span> fin.getChannel();<br>        <br>        <span class="hljs-comment">//把刚才读取的内容写入到一个新的文件中</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">outfile</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;E://testcopy.txt&quot;</span>);<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(outfile);<br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fcout</span> <span class="hljs-operator">=</span> fout.getChannel();<br>        <br>        <span class="hljs-comment">//使用allocateDirect</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffere.allocateDirect(<span class="hljs-number">1024</span>);<br>        whilt(<span class="hljs-literal">true</span>)&#123;<br>            buffer.clear();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> fcin.read(buffer);<br>            <span class="hljs-keyword">if</span>(r==-<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            buffer.flip();<br>            fcout.write(buffer);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-1-7-内存映射"><a href="#1-1-7-内存映射" class="headerlink" title="1.1.7 内存映射"></a>1.1.7 内存映射</h4><p>内存映射是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的I/O 快的多。内存映射文件I/O 是通过使文件中的数据出现为内存数组的内容来完成的，这其初听起来似乎不过就是将整个文件读到内存中，但是事实上并不是这样。一般来说，只有文件中实际读取或者写入的部分才会映射到内存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MappedBuffer</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;E://test.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> raf.getChannel();<br>        <br>        <span class="hljs-comment">//把缓冲区个文件系统进行一个映射关联</span><br>        <span class="hljs-comment">//只要操作缓冲区中的内容，文件内容也会随着改变</span><br>        <span class="hljs-type">MappedByteBuffer</span> <span class="hljs-variable">mbb</span> <span class="hljs-operator">=</span> fc.map(FileChannel.MapMode.READ_WRITE, start, size);<br>        mbb.put(<span class="hljs-number">0</span>, (<span class="hljs-type">byte</span>) <span class="hljs-number">97</span>);<br>        mbb.put(<span class="hljs-number">1023</span>, (<span class="hljs-type">byte</span>) <span class="hljs-number">122</span>);<br>        raf.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-选择器–Selector"><a href="#1-2-选择器–Selector" class="headerlink" title="1.2 选择器–Selector"></a>1.2 选择器–Selector</h3><p>传统的 Server/Client 模式会基于 TPR（Thread per Request）,服务器会为每个客户端请求建立一个线程，由该线程单独负责处理 一个客户请求。这种模式带来的一个问题就是线程数量的剧增，大量的线程会增大服务器的开销。大多数的实现为了避免这个问题， 都采用了线程池模型，并设置线程池线程的最大数量，这又带来了新的问题，如果线程池中有 200 个线程，而有 200 个用户都在进行大文件下载，会导致第 201 个用户的请求无法及时处理，即便第 201 个用户只想请求一个几 KB 大小的页面。传统的 Server/Client 模式如下图所示：</p><p><img src="/image/Netty/6.png"></p><p>NIO 中非阻塞 I/O 采用了基于 Reactor 模式的工作方式，I/O 调用不会被阻塞，相反是注册感兴趣的特定 I/O 事件，如可读数据到达，新的套接字连接等等，在发生特定事件时，系统再通知。NIO 中实现非阻塞 I/O 的核心对象就是 Selector，Selector 就是注册各种 I/O 事件地方，而且当那些事件发生时，就是这个对通知所发生的事件，如下图所示：</p><p><img src="/image/Netty/7.png"></p><p>从图中可以看出，当有读或写等任何注册的事件发生时，可以从Selector中获得相应的SelectionKey，同时从SelectionKey中可以找到发生的事件和该事件所发生的具体的SelectableChannel，以获得客户端发送过来的数据。使用NIO中非阻塞I/O编写服务器处理程序，大体上可以分为下面三个步骤：</p><ol><li><p>向 Selector对象注册感兴趣的事件。</p></li><li><p>从 Selector中获取感兴趣的事件。</p></li><li><p>根据不同的事件进行相应的处理。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//向Selector对象注册感兴趣的事件</span><br><span class="hljs-keyword">private</span> Selector <span class="hljs-title function_">getSelector</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//创建Selector对象</span><br>    <span class="hljs-type">Selector</span> <span class="hljs-variable">sel</span> <span class="hljs-operator">=</span> Selector.open();<br>    <span class="hljs-comment">//创建可选择通道，并配置为非阻塞模式</span><br>    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>    server.configureBlocking(<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">//绑定通道到指定端口</span><br>    <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> server.socket();<br>    <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(port);<br>    socket.bind(address);<br>    <span class="hljs-comment">//向Selector中注册感兴趣的事件</span><br>    server.register(sel, SelectionKey.OP_ACCEPT);<br>    <span class="hljs-keyword">return</span> sel;<br>&#125;<br><br><span class="hljs-comment">//从Selector中获取感兴趣的事件，即开始监听，进入内部循环</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listen</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;listen on: &quot;</span> + port);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//该调用会阻塞，直到至少有一个事件发生</span><br>            selector.select();<br>            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>            Iterator&lt;SelectionKey&gt; iter = keys.iterator();<br>            <span class="hljs-keyword">while</span>(iter.hasNext())&#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (SelectionKey) iter.next();<br>                iter.remove();<br>                process(key);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//根据不同的事件，编写相应的处理代码</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-comment">//接收请求</span><br>    <span class="hljs-keyword">if</span>(key.isAcceptable())&#123;<br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> server.accept();<br>        channel.configureBlocking(<span class="hljs-literal">false</span>);<br>        channel.register(selector, SelectionKey.OP_READ);<br>    &#125;<br>    <span class="hljs-comment">//读请求</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key.isReadable())&#123;<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> channel.read(buffer);<br>        <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>)&#123;<br>            buffer.flip();<br>            contest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array(), <span class="hljs-number">0</span>, len);<br>            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">sKey</span> <span class="hljs-operator">=</span> channel.register(selector, SelectionKey_OP_WRITE);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            channel.close();<br>        &#125;<br>        buffer.clear();<br>    &#125;<br>    <span class="hljs-comment">//写事件</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key.isWritable())&#123;<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> (String) key.attachment();<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">block</span> <span class="hljs-operator">=</span> ByteBuffer.wrap((<span class="hljs-string">&quot;输出内容：&quot;</span> + content).getBytes());<br>        <span class="hljs-keyword">if</span>(block != <span class="hljs-literal">null</span>)&#123;<br>            channel.write(block);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            channel.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-通道–Channel"><a href="#1-3-通道–Channel" class="headerlink" title="1.3 通道–Channel"></a>1.3 通道–Channel</h3><p>通道是一个对象，通过它可以读取和写入数据，当然了所有数据都通过 Buffer 对象来处理。永远不会将字节直接写入通道中，相反是将数据写入包含一个或者多个字节的缓冲区。同样不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</p><h4 id="1-3-1-读取数据"><a href="#1-3-1-读取数据" class="headerlink" title="1.3.1 读取数据"></a>1.3.1 读取数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileInputDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;E://test.txt&quot;</span>);<br>        <span class="hljs-comment">//获取通道</span><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> fin.getChannel();<br>        <span class="hljs-comment">//创建缓冲区</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        <span class="hljs-comment">//读取数据到缓冲区</span><br>        fc.read(buffer);<br>        buffer.flip();<br>        <span class="hljs-keyword">while</span>(buffer.remaining() &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> buffer.get();<br>            System.out.println((<span class="hljs-type">char</span>) b);<br>        &#125;<br>        fin.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-2-写入数据"><a href="#1-3-2-写入数据" class="headerlink" title="1.3.2 写入数据"></a>1.3.2 写入数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileOutputDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> message[] = &#123;<span class="hljs-number">83</span>,<span class="hljs-number">11</span>,<span class="hljs-number">109</span>,<span class="hljs-number">101</span>,<span class="hljs-number">323</span>,<span class="hljs-number">98</span>,<span class="hljs-number">121</span>,<span class="hljs-number">116</span>,<span class="hljs-number">101</span>,<span class="hljs-number">116</span>,<span class="hljs-number">46</span>&#125;;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;E://test.txt&quot;</span>);<br>        <span class="hljs-type">FilChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> fout.getChannel();<br>        <span class="hljs-type">ByteBUffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; message.length; ++i)&#123;<br>            buffer.put(message[i]);<br>        &#125;<br>        buffer.flip();<br>        fc.write(buffer);<br>        fout.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-3-IO多路复用"><a href="#1-3-3-IO多路复用" class="headerlink" title="1.3.3 IO多路复用"></a>1.3.3 IO多路复用</h4><p>目前流行的多路复用 IO 实现主要包括四种：select、poll、epoll、kqueue。下表是他们的一些重要特性的比较：</p><table><thead><tr><th>IO模型</th><th>相对性能</th><th>关键思路</th><th>操作系统</th><th>JAVA支持</th></tr></thead><tbody><tr><td>select</td><td>较高</td><td>Reactor</td><td>windows/linux</td><td>支持，Reacotr模式(反应器设计模式)。Linux操作系统的kernels2.4内核版本之前，默认使用select，而目前windows下对同步IO的支持，都是select模型。</td></tr><tr><td>poll</td><td>较高</td><td>Reactor</td><td>linux</td><td>Linux下的JAVA NIO模型，Linux kernels 2.6内核版本之前使用poll进行支持，也是使用的Reactor模型。</td></tr><tr><td>epoll</td><td>高</td><td>Reactor/Proactor</td><td>linux</td><td>linux kernels2.6内核版本及以后使用epoll进行支持，由于Linux下没有windows下的IOCP技术提供真正的异步IO支持，所以Linux下使用epoll模拟异步IO。</td></tr><tr><td>kqueue</td><td>高</td><td>Proactor</td><td>linux</td><td>目前JAVA版本不支持。</td></tr></tbody></table><p>select/poll模型：</p><p><img src="/image/Netty/Select_Poll%E6%A8%A1%E5%9E%8B.jpg"></p><p>epoll模型</p><p><img src="/image/Netty/epoll%E6%A8%A1%E5%9E%8B.jpg"></p><h2 id="2-NIO源码"><a href="#2-NIO源码" class="headerlink" title="2 NIO源码"></a>2 NIO源码</h2><p><img src="/image/Netty/Server%E7%AB%AF%E5%90%AF%E5%8A%A8.jpg"></p><p><img src="/image/Netty/Server-run.jpg"></p><h2 id="3-Netty初识"><a href="#3-Netty初识" class="headerlink" title="3 Netty初识"></a>3 Netty初识</h2><p>按照定义来说，Netty是一个异步、事件驱动的用来做高性能、高可靠性的网络应用框架。主要的优点：</p><ol><li><p>框架设计优雅，底层模型随意切换适应不同的网络协议要求。</p></li><li><p>提供很多标准的协议、安全、编码解码的支持。</p></li><li><p>解决了很多NIO不易用的问题。</p></li><li><p>社区更为活跃，在很多开源框架中使用，如Dubbo、RocketMQ、Spark等。</p></li></ol><p><strong>Netty采用NIO而非AIO的理由</strong></p><p>1.Netty不看重Windows上的使用，在Linux系统上，AIO的底层实现仍使用EPOLL，没有很好实现AIO，因此在性能上没有明显的优势，而且被JDK封装了一层不容易深度优化</p><p>2.Netty整体架构是reactor模型, 而AIO是proactor模型, 混合在一起会非常混乱,把AIO也改造成 reactor模型看起来是把epoll绕个弯又绕回来</p><p>3.AIO 还有个缺点是接收数据需要预先分配缓存, 而不是NIO那种需要接收时才需要分配缓存, 所以对连接数量非常大但流量小的情况, 内存浪费很多</p><p>4.Linux上AIO不够成熟，处理回调结果速度跟不到处理需求，比如外卖员太少，顾客太多，供不应求，造成处理速度有瓶颈</p>]]></content>
    
    
    <categories>
      
      <category>网络通信</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>NIO</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UML建模设计</title>
    <link href="/2023/07/09/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/UML%E5%BB%BA%E6%A8%A1%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/07/09/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/UML%E5%BB%BA%E6%A8%A1%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="1-UML图"><a href="#1-UML图" class="headerlink" title="1 UML图"></a>1 UML图</h2><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/UML%E5%BB%BA%E6%A8%A1%E8%AE%BE%E8%AE%A1/1.png"></p><h2 id="2-用例图"><a href="#2-用例图" class="headerlink" title="2 用例图"></a>2 用例图</h2><h3 id="2-1-用例图相关关系（包含，扩展，泛化）"><a href="#2-1-用例图相关关系（包含，扩展，泛化）" class="headerlink" title="2.1 用例图相关关系（包含，扩展，泛化）"></a>2.1 用例图相关关系（包含，扩展，泛化）</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/UML%E5%BB%BA%E6%A8%A1%E8%AE%BE%E8%AE%A1/2.png"></p><p><strong>包含关系（必然的）：</strong> 其中这个提取出来的公共用例称为抽象用例，而把原始用例称为基本用例或基础用例。当可以从两个或两个以上的用例中提取公共行为时，应该使用包含关系来表示它们。</p><p><strong>扩展关系（可选的）：</strong> 如果一个用例明显地混合了两种或两种以上的不同场景，即根据情况可能发生多种分支，则可以将这个用例分为一个基本用例和一个或多个扩展用例，这样使描述可能更加清晰。</p><p><strong>泛化关系（父子）：</strong> 当多个用例共同拥有一种类似的结构和行为的时候，可以将它们的共性抽象成为父用例，其他的用例作为泛化关系中的子用例。在用例的泛化关系中，子用例是父用例的一种特殊形式，子用例继承了父用例所有的结构、行为和关系。</p><h3 id="2-2-用例图"><a href="#2-2-用例图" class="headerlink" title="2.2 用例图"></a>2.2 用例图</h3><ul><li><strong>用例图描述一组用例、参与者及它们之间的关系。</strong></li><li><strong>用户角度描述系统功能；</strong></li><li><strong>参与者是外部触发因素；</strong>(包括用户、组织、外部系统，时间)</li><li><strong>用例是功能单元。</strong></li></ul><p><strong>关系包括：包含关系、扩展关系、泛化关系</strong></p><p><strong>用例建模的流程：</strong><br><strong>★</strong> 识别参与者(必须)<br><strong>★</strong> 合并需求获得用例(必须)<br><strong>★</strong> 细化用例描述(必须)<br><strong>★</strong> 调整用例模型(可选)</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/UML%E5%BB%BA%E6%A8%A1%E8%AE%BE%E8%AE%A1/3.png"></p><h2 id="3-类图和对象图"><a href="#3-类图和对象图" class="headerlink" title="3 类图和对象图"></a>3 类图和对象图</h2><h3 id="3-1-类图和对象图相关关系（依赖，泛化，关联-聚合-组合，实现）"><a href="#3-1-类图和对象图相关关系（依赖，泛化，关联-聚合-组合，实现）" class="headerlink" title="3.1 类图和对象图相关关系（依赖，泛化，关联-聚合/组合，实现）"></a>3.1 类图和对象图相关关系（依赖，泛化，关联-聚合/组合，实现）</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/UML%E5%BB%BA%E6%A8%A1%E8%AE%BE%E8%AE%A1/4.png"></p><h3 id="3-2-类图和对象图"><a href="#3-2-类图和对象图" class="headerlink" title="3.2 类图和对象图"></a>3.2 类图和对象图</h3><p>类图(class diagram) ： 类图描述一组类、接口、协作和它们之间的关系。</p><p>对象图(object diagram) ： 对象图描述一组对象及它们之间的关系。对象图描述了在类图中所建立的事物实例的静态快照。</p><p>◆ 类名，方法名，属性名<br>◆ 多重度（对应关系数1、0…*）<br>◆ 关系</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/UML%E5%BB%BA%E6%A8%A1%E8%AE%BE%E8%AE%A1/5.png"></p><h2 id="4-顺序图（序列图）"><a href="#4-顺序图（序列图）" class="headerlink" title="4 顺序图（序列图）"></a>4 顺序图（序列图）</h2><p><strong>顺序图(sequence diagram， 序列图)</strong> 。顺序图是一种交互图(interaction diagram)它强调对象之间消息发送的顺序，同时显示对象之间的交互。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/UML%E5%BB%BA%E6%A8%A1%E8%AE%BE%E8%AE%A1/6.png"></p><h2 id="5-通信图（协作图）"><a href="#5-通信图（协作图）" class="headerlink" title="5 通信图（协作图）"></a>5 通信图（协作图）</h2><p><strong>通信图(communication diagram)</strong> 。通信图也是一种交互图， 它强调对象之间存在的消息收发关系，而不专门突出这些消息发送的时间顺序。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/UML%E5%BB%BA%E6%A8%A1%E8%AE%BE%E8%AE%A1/7.png"></p><h2 id="6-状态图"><a href="#6-状态图" class="headerlink" title="6 状态图"></a>6 状态图</h2><p><strong>状态图(state diagram)</strong> 是对类描述的补充。用于展现此类对象所具有的可能状态，以及某些事件发生时其状态转移情况。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/UML%E5%BB%BA%E6%A8%A1%E8%AE%BE%E8%AE%A1/8.png"></p><p>在订单处理的过程中，会员可以点击“取消订单”取消该订单。如果 支付失败 ，该订单将被标记为 挂起状态 ，可后续重新支付，如果挂起超时30分钟未支付，系统将自动取消该订单。订单支付成功后，系统判断订单类型：<br>(1)对于常规订单，标记为 备货状态 ，订单信息发送到货运部，完成打包后 交付快递 发货；<br>(2)对于定制订单，会自动进入 定制状态 ，定制完成后 交付快递 发货。会员在系统中点击“ 收货 ”按钮变为 收货状态 ，结束整个订单的处理流程。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/UML%E5%BB%BA%E6%A8%A1%E8%AE%BE%E8%AE%A1/9.png"></p><h2 id="7-活动图"><a href="#7-活动图" class="headerlink" title="7 活动图"></a>7 活动图</h2><p><strong>活动图(activity diagram)</strong> 是一种特殊的状态图。活动图描述一个操作中要进行的各项活动的执行流程。同时，也常被用来描述一个用例的处理流程或者某种交互流程。活动图将进程或其他计算结构展示为计算内部一步步的控制流和数据流。它强调对象间的控制流程。<br><strong>活动图与流程图的区别是可以并行。</strong></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/UML%E5%BB%BA%E6%A8%A1%E8%AE%BE%E8%AE%A1/10.png"></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/UML%E5%BB%BA%E6%A8%A1%E8%AE%BE%E8%AE%A1/11.png"></p><h2 id="8-定时图"><a href="#8-定时图" class="headerlink" title="8 定时图"></a>8 定时图</h2><p><strong>定时图</strong> 也叫计时图，也是一种交互图，用于展示交互过程中的真实时间信息，具体描述对象状态变化的时间点以及维持特定状态的时间段。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/UML%E5%BB%BA%E6%A8%A1%E8%AE%BE%E8%AE%A1/12.png"></p><h2 id="9-构建图和包图"><a href="#9-构建图和包图" class="headerlink" title="9 构建图和包图"></a>9 构建图和包图</h2><p><strong>构件图(component diagram)</strong> 。构件图描述一个封装的类和它的接口、端口， 以及由内嵌的构件和连接件构成的内部结构。构件图用于表示系统的静态设计实现视图。对于由小的部件构建大的系统来说，构件图是很重要的。构件图是类图的变体。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/UML%E5%BB%BA%E6%A8%A1%E8%AE%BE%E8%AE%A1/13.png"></p><p><strong>包图</strong> ，包的图标像是一个带标签的文件夹，包的基本思想是把共同工作的元素放到一个文件夹中。例：多个类或构件组成了一个子系统，就可以将它们放到一个包中。</p><h2 id="10-部署图"><a href="#10-部署图" class="headerlink" title="10 部署图"></a>10 部署图</h2><p><strong>部署图(deployment diagram)</strong> 。部署图描述对运行时的处理节点及在其中生存的构件的配置。部署图给出了架构的静态部署视图，通常一个节点包含一个或多个部署图。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/UML%E5%BB%BA%E6%A8%A1%E8%AE%BE%E8%AE%A1/14.png"></p>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>基础技能</category>
      
      <category>软件工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统分析与设计</title>
    <link href="/2023/07/09/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/07/09/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="1-系统设计"><a href="#1-系统设计" class="headerlink" title="1 系统设计"></a>1 系统设计</h2><p>系统设计是系统分析的延伸与拓展。系统分析阶段解决“做什么”的问题，而系统设计阶段解决“怎么做”的问题。同时，它也是系统实施的基础，为系统实施工作做好铺垫。合理的系统设计方案既可以保证系统的质量，也可以提高开发效率，确保系统实施工作的顺利进行。</p><p><strong>系统设计阶段又称为物理设计阶段，它是信息系统开发过程中一个非常重要的阶段。其任务是根据系统规格说明书中规定的功能要求，考虑实际条件，具体设计实现逻辑模型的技术方案，也就是设计新系统的物理模型，为下一阶段的系统实施工作奠定基础。</strong></p><p>系统设计的主要内容包括<strong>概要设计</strong>和<strong>详细设计</strong>。概要设计又称为系统总体结构设计，它是系统开发过程中很关键的一步，其主要任务是将系统的功能需求分配给软件模块，确定每个模块的功能和调用关系，形成软件的模块结构图，即系统结构图。在概要设计中，将系统开发的总任务分解成许多个基本的、具体的任务，为每个具体任务选择适当的技术手段和处理方法的过程称为详细设计。根据任务的不同，详细设计又可分为多种，例如，网络设计、代码设计、输入/输出设计、处理流程设计、数据存储设计、用户界面设计、安全性和可靠性设计等。</p><h2 id="2-软件设计"><a href="#2-软件设计" class="headerlink" title="2 软件设计"></a>2 软件设计</h2><p>软件设计包括体系结构设计、接口设计、数据设计和过程设计。</p><ol><li>结构设计：定义软件系统各主要部件之间的关系，开发一个模块化的程序结构，并表示出模块间的控制关系。</li><li>数据设计：将模型转换成数据结构的定义。高质量数据设计将改善程序结构和模块划分，降低过程复杂性。</li><li>接口设计（人机界面设计）：软件内部、软件和操作系统间以及软件和人之间如何通信。</li><li>过程设计：系统结构部件转换成软件的过程描述。</li></ol><h3 id="2-1-软件架构设计"><a href="#2-1-软件架构设计" class="headerlink" title="2.1 软件架构设计"></a>2.1 软件架构设计</h3><p>软件架构 = 软件体系结构</p><p>架构设计就是需求分配，即将满足需求的职责分配到组件上。</p><h3 id="2-2-用户界面设计-人机界面设计"><a href="#2-2-用户界面设计-人机界面设计" class="headerlink" title="2.2 用户界面设计/人机界面设计"></a>2.2 用户界面设计/人机界面设计</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/1.png"></p><h3 id="2-3-结构化设计"><a href="#2-3-结构化设计" class="headerlink" title="2.3 结构化设计"></a>2.3 结构化设计</h3><p>结构化设计（Structured Design，SD）是一种面向数据流的方法，它以SRS和SA阶段所产生的数据流图和数据字典等文档为基础，是一个自顶向下、逐步求精和模块化的过程。SD方法的基本思想是将软件设计成由相对独立且具有单一功能的模块组成的结构，分为概要设计和详细设计两个阶段，其中概要设计的主要任务是确定软件系统的结构，对系统进行模块划分，确定每个模块的功能、接口和模块之间的调用关系；详细设计的主要任务是为每个模块设计实现的细节。</p><p><strong>概要设计</strong><br>概要设计又称为系统总体结构设计，它是系统开发过程中很关键的一步，其主要任务是将系统的功能需求分配给软件模块，确定每个模块的功能和调用关系，形成软件的模块结构图，即系统结构图。</p><p>系统结构图（Structure Chart，SC）又称为模块结构图，它是软件概要设计阶段的工具，反映系统的功能实现和模块之间的联系与通信，包括各模块之间的层次结构，即反映了系统的总体结构。</p><p>人们在解决复杂问题时使用的一个很重要的原则，就是将它分解成多个小问题分别处理，在处理过程中，需要根据系统总体要求，协调各业务部门的关系。在SD中，这种功能分解就是将系统划分为模块，模块是组成系统的基本单位，它的特点是可以自由组合、分解和变换，系统中任何一个处理功能都可以看成一个模块。</p><p><strong>模块的四个要素：</strong></p><ol><li>输入和输出，模块的输入来源和输出去向都是同一个调用者，即一个模块从调用者那儿取得输入，进行加工后再把输出返回调用者。</li><li>处理功能，指模块把输入转换成输出所做的工作。</li><li>内部数据，指仅供该模块本身引用的数据。</li><li>程序代码，指用来实现模块功能的程序。</li></ol><p>前两个要素是模块的外部特性，即反映了模块的外貌；后两个要素是模块的内部特性。在结构化设计中，主要考虑的是模块的外部特性，其内部特性只做必要了解，具体的实现将在系统实施阶段完成。</p><p>在SD方法中，系统由多个逻辑上相对独立的模块组成，在模块划分时需要遵循如下原则：保持模块大小适中；尽可能减少调用的深度，宽度也不宜过高；扇入/扇出系数合理，多扇入少扇出，单入口单出口；模块的作用域应该在模块内，功能应该是可预测的；模块独立性原则（高内聚，低耦合）</p><p><strong>内聚类型与耦合类型</strong></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/2.png"></p><h3 id="2-4-面向对象的设计"><a href="#2-4-面向对象的设计" class="headerlink" title="2.4 面向对象的设计"></a>2.4 面向对象的设计</h3><p>面向对象的设计OOD是面向对象的分析OOA的延续，其基本思想包括抽象、封装和可扩展性，其中可扩展性主要通过继承和多态来实现。在OOD中，数据结构和在数据结构上定义的操作算法封装在一个对象之中。由于现实世界中的事物都可以抽象出对象的集合，所以OOD方法是一种更接近现实世界、更自然的系统设计方法。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/3.png"></p><h4 id="2-4-1-类的分类"><a href="#2-4-1-类的分类" class="headerlink" title="2.4.1 类的分类"></a>2.4.1 类的分类</h4><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/4.png"></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">对象问的关系有：组合，聚合，继承等<br><span class="hljs-keyword">Use</span>-A依赖关系<br><span class="hljs-keyword">IS</span>-A继承关系<br><span class="hljs-keyword">IS</span>-PART-<span class="hljs-keyword">OF</span>聚合（组合一种），聚合对应的语义是“<span class="hljs-keyword">is</span> a member <span class="hljs-keyword">of</span>”<br></code></pre></td></tr></table></figure><p><strong>设计原则</strong></p><p>在OOD中，可维护性的复用是以设计原则为基础的。常用的OOD中原则包括单一原则、幵闭原则、里氏替换原则、依赖倒置原则、组合/聚合复用原则、接口隔离原则和最少知识原则等。这些设计原则首先都是面向复用的原则，遵循这些设计原则可以有效地提高系统的复用性，同时提高系统的可维护性。</p><ol><li>单一职责原则，设计目的单一的类。</li><li>开放-封闭原则，对扩展开放，对修改封闭。即尽量在不修改原有代码的情况下进行扩展。</li><li>里氏替换原则，子类可以替换父类（父类可以替换成子类），程序的行为没有变化。软件实体如果使用的是一个基类对象，那么一定适用于其子类对象，而且觉察不出基类对象和子类对象的区别。</li><li>依赖倒置原则，抽象不应该依赖于细节，细节要依赖于抽象，而不是具体实现。针对接口编程，不要针对实现编程。</li><li>组合/聚合复用原则，又称为合成复用原则，要尽景使用组合/聚合关系，少用继承。</li><li>接口隔离原则，使用多个专门的接口，而不使用单一的总接口。</li><li>最少知识原则，也称为迪米特法则，是指一个软件实体应当尽可能少地与其他实体发生相互作用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>基础技能</category>
      
      <category>软件工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据流图</title>
    <link href="/2023/07/09/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E7%BB%93%E6%9E%84%E5%8C%96%E9%9C%80%E6%B1%82%E8%AE%BE%E8%AE%A1-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE/"/>
    <url>/2023/07/09/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E7%BB%93%E6%9E%84%E5%8C%96%E9%9C%80%E6%B1%82%E8%AE%BE%E8%AE%A1-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="1-数据流图基本概念"><a href="#1-数据流图基本概念" class="headerlink" title="1 数据流图基本概念"></a>1 数据流图基本概念</h2><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE/1.png"></p><p><strong>实体</strong><br>(1)人物角色： 如客户、管理员、主管、经理、老师、学生<br>(2)组织机构：如银行、供应商、募捐机构<br>(3)外部系统： 如银行系统、工资系统、后台数据库(当要开发的是中间件时)<br><strong>存储</strong><br>存储的文字方面特征：“文件”、“表”、“库”、“清单”、“档案”<br><strong>数据流</strong><br>1、数据平衡原则<br>(1)顶层图与0层图对比，是否有顶层图有，但0层图无的数据流，或反之。<br>(2)检查图中每个加工，是否存在只有入没有出，或只有出没有入，或根据输入的数据无法产生对应的输出的情况。<br>2、按需求题目说明与图进行匹配<br>说明中的每一句话，都能与图中有对应关系，当把说明中的实体与数据流标识出来之后，容易缩小对应范围，找出纰漏。<br><strong>加工名</strong><br>加工是用于处理数据流的，所以要补充加工名，可以把该加工涉及到的数据流，在说明中标识出来，再在数据流名称所在的句子中，找 “动词+名词” 的结构，分析是否可作为加工。<br>“动词+名词” 如：生成报告、发出通知、批改作业、记录分数，当然这只是普遍情况，也有例外，如物流跟踪、用户管理。</p><h2 id="2-需求分析（SA）-数据流图（DFD）"><a href="#2-需求分析（SA）-数据流图（DFD）" class="headerlink" title="2 需求分析（SA）- 数据流图（DFD）"></a>2 需求分析（SA）- 数据流图（DFD）</h2><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE/2.png"></p><h2 id="3-数据流图平衡原则"><a href="#3-数据流图平衡原则" class="headerlink" title="3 数据流图平衡原则"></a>3 数据流图平衡原则</h2><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE/3.png"></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE/4.png"></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE/5.png"></p>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>基础技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>需求工程</title>
    <link href="/2023/07/08/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/"/>
    <url>/2023/07/08/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-需求工程概述"><a href="#1-需求工程概述" class="headerlink" title="1 需求工程概述"></a>1 需求工程概述</h2><p>软件需求是指用户对系统在功能、行为、性能、设计约束等方面的期望。</p><p>需求工程（Requirement Engineering，RE） 是指应用已证实有效的原理、方法，通过合适的工具和记号，系统地描述待开发系统及其行为特征和相关约束。</p><p>需求工程由需求获取、需求分析、形成需求规格（或称为需求文档化）、需求确认与验证、需求管理5个阶段，如图：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/1.png"></p><p><strong>软件需求规格说明书（Software Requirement Specification，SRS）</strong><br>SRS具体包括功<strong>能需求、非功能需求和约束</strong>。约束包括设计约束和过程约束。批准的SRS是需求开发和需求管理之间的桥梁。</p><p><strong>需求管理</strong><br>需求管理是一个对系统需求变更、了解和控制的过程，包括变更控制、版本控制、需求跟踪等活动</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/2.png"></p><h2 id="2-需求开发-主线、目标"><a href="#2-需求开发-主线、目标" class="headerlink" title="2 需求开发(主线、目标)"></a>2 需求开发(主线、目标)</h2><h3 id="2-1-需求分类"><a href="#2-1-需求分类" class="headerlink" title="2.1 需求分类"></a>2.1 需求分类</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/3.png"></p><p><strong>需求分类</strong><br>（1）业务需求：业务需求是指反映企业或客户对系统高层次的目标要求，通常来自项目投资人、购买产品的客户、客户单位的管理人员、市场营销部门或产品策划部门等。通过业务需求可以确定项目视图和范围。</p><p>（2）用户需求：用户需求描述的是用户的具体目标，或用户要求系统必须能完成的任务。也就是说，用户需求描述了用户能使用系统来做些什么。通常采取用户访谈和问卷调查等方式，对用户使用的场景（scenarios）进行整理，从而建立用户需求</p><p>（3）系统需求：系统需求是从系统的角度来说明软件的需求，包括功能需求、非功能需求和设计约束等。</p><p><strong>质量功能部署QFD</strong><br>它是一种将用户要求转化成软件需求的技术，其目的是最大限度地提升软件工程过程中用户的满意度。为了达到这个目标，QFD将软件需求分为三类，分别是常规需求、期望需求和意外需求。</p><p>（1）基本需求：也叫常规需求，用户认为系统应该做到的功能或性能，实现越多用户会越满意。</p><p>（2）期望需求：用户想当然认为系统应具备的功能或性能，但并不能正确描述自己想要得到的这些功能或性能需求。如果期望需求没有得到实现，会让用户感到不满意。</p><p>（3）意外需求：意外需求也称为兴奋需求，是用户要求范围外的功能或性能（但通常是软件开发人员很乐意赋予系统的技术特性），实现这些需求用户会更高兴，但不实现也不影响其购买的决策。</p><h3 id="2-2-需求获取"><a href="#2-2-需求获取" class="headerlink" title="2.2 需求获取"></a>2.2 需求获取</h3><table><thead><tr><th>方法</th><th>特点</th></tr></thead><tbody><tr><td>收集资料</td><td>把与系统有关的、对系统开发有益的信息收集起来。</td></tr><tr><td>阅读历史文档</td><td>对收集数据性的信息较为有用。</td></tr><tr><td>用户访谈</td><td>1对1-3，有代表性的用户，了解主观想法，交互好。成本高，要有领域知识支撑</td></tr><tr><td>问卷调查</td><td>用户多，无法一一访谈，成本低。</td></tr><tr><td>现场观摩</td><td>针对较为复杂的流程和操作。</td></tr><tr><td>参加业务实践</td><td>有效地发现问题的本质和寻找解决问题的办法。</td></tr><tr><td>联合需求计划(JRP)</td><td>高度组织的群体会议，各方参与，了解想法，消除分歧，交互好，成本高。</td></tr><tr><td>情节串联板(原型法)</td><td>一系列图片，通过这些图片来讲故事。</td></tr><tr><td>抽样调查/采样</td><td>基于数理统计，降低成本，快速获取。<br/>样本大小=a*(可信度系数/可接受的错误)2<br/>注:a一般取0.25</td></tr></tbody></table><h3 id="2-3-需求分析"><a href="#2-3-需求分析" class="headerlink" title="2.3 需求分析"></a>2.3 需求分析</h3><p>需求分析：一个好的需求应该具有无二义性、完整性、一致性、可测试性、确定性、可跟踪性、正确性、必要性等特性，因此，需要分析人员把杂乱无章的用户要求和期望转化为用户需求，这就是需求分析的工作。</p><p>需求分析的任务：<br>（1）绘制系统上下文范围关系图<br>（2）创建用户界面原型<br>（3）分析需求的可行性<br>（4）确定需求的优先级<br>（5）为需求建立模型<br>（6）创建数据字典<br>（7）使用QFD（质量功能部署)</p><h4 id="2-3-1-结构化分析方法-SA"><a href="#2-3-1-结构化分析方法-SA" class="headerlink" title="2.3.1 结构化分析方法-SA"></a>2.3.1 结构化分析方法-SA</h4><p><strong>结构化分析方法SA的核心是数据字典</strong>。围绕这个核心有三个层次的模型，分别是<strong>数据模型，功能模型，行为模型（状态模型）</strong>。</p><p>结构化分析的步骤，如下：<br>（1）分析业务情况，做出反映当前物理模型的数据流图（Data Flow DiagramDFD）。<br>（2）推导出等价的逻辑模型的DFD。<br>（3）设计新的逻辑系统，生成数据字典和基元描述。<br>（3）建立人机接口，提出可供选择的目标系统物理模型的DFD。<br>（5）确定各种方案的成本和风险等级，据此对各种方案进行分析。<br>（6）选择一种方案。<br>（7）建立完整的需求规约。</p><p>结构化分析方法SA是数据流和控制流，常用手段是数据流图（DFD）和数据字典。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/4.png"></p><h5 id="2-3-1-1-数据字典DD"><a href="#2-3-1-1-数据字典DD" class="headerlink" title="2.3.1.1 数据字典DD"></a>2.3.1.1 数据字典DD</h5><p>数据字典是需求分析建立模型的核心。是为数据流图中的每个数据流、文件、加工，以及组成数据流或文件的数据项做出说明。</p><p>数据字典有4类条目：数据流、数据项、数据存储和基本加工。包括了数据元素，数据结构，数据流，加工逻辑和外部实体。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/5.png"></p><h5 id="2-3-1-2-数据流图DFD"><a href="#2-3-1-2-数据流图DFD" class="headerlink" title="2.3.1.2 数据流图DFD"></a>2.3.1.2 数据流图DFD</h5><p>数据流图DFD是用数据流图表示功能模型，DFD说明系统所完成功能，从数据传递和加工的角度，利用图形符号通过逐层细分描述系统的各个部件的功能和数据在他们之间传递的情况，来说明系统所完成的功能。如下图：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/6.png"></p><p>其中，DFD还会有“顶层DFD图”和“0层DFD图”。如下图，有如下几种“图元”描述：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/7.png"></p><p>另附一个错误的DFD图，如下：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/8.png"></p><p>如上图错误：加工3.1.2有输入但是没有输出，称之为“黑洞”。加工3.1.3有输出但没有输入。称之为“奇迹”。加工3.1.1中输入不足以产生输出，我们称之为“灰洞”。</p><h5 id="2-3-1-3-状态转换图STD"><a href="#2-3-1-3-状态转换图STD" class="headerlink" title="2.3.1.3 状态转换图STD"></a>2.3.1.3 状态转换图STD</h5><p>用状态转换图表示行为模型，STD通过描述系统的状态和引起系统状态转换的事件，来表示系统的行为，指出做为特定事件的结果将执行哪些动作。如下图：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/9.png"></p><h5 id="2-3-1-4-E-R图-实体联系图"><a href="#2-3-1-4-E-R图-实体联系图" class="headerlink" title="2.3.1.4 E-R图/实体联系图"></a>2.3.1.4 E-R图/实体联系图</h5><p>ER图主要描述实体属性，以及实体之间的关系。另外，ER模型是结构化时代的模型与产物，在面向对象和UML中是没有的。如下图：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/10.png"></p><p><strong>什么是弱实体？</strong><br><strong>举例说明：在人事管理系统中，职工子女的信息就是以职工的存在为前提的，子女实体是弱实体，子女与职工的联系是一种依赖联系。所以，职工是实体，也可以成为强实体。强实体与弱实体的联系只能是1：1或1：N。</strong></p><h4 id="2-3-2-面向对象的分析方法-OOA"><a href="#2-3-2-面向对象的分析方法-OOA" class="headerlink" title="2.3.2 面向对象的分析方法-OOA"></a>2.3.2 面向对象的分析方法-OOA</h4><table><thead><tr><th>对象</th><th>属性[数据]+方法[操作]+对象ID/标识ID</th></tr></thead><tbody><tr><td>类【详细见下】</td><td>实体类/控制类/边界类<br/>实体类：往往和数据库有对应的关系，是不是数据类型<br/>控制类：衔接实体类和边界类的类<br/>边界类：在一个系统的边界上和外部进行沟通的类<br/>这三个类似于MVC模型之间的关系，它们的思想是一样的</td></tr><tr><td>继承和泛化</td><td>复用机制，它是一种紧耦合。因为当父类变的时候子类不得不变。继承是对已有实例</td></tr><tr><td>封装</td><td>隐藏对象的属性和实现细节仅对外公开接口</td></tr><tr><td>多态</td><td>不同对象收到同样的信息产生不同的结果</td></tr><tr><td>接口</td><td>一种特殊的类，它只有方法定义没有对方法的实现</td></tr><tr><td>重载</td><td>一个类可以有多个同名的参数类型不同的方法，函数同名但参数不一样是其特点</td></tr><tr><td>消息和消息通信</td><td>消息是异步通信的</td></tr><tr><td>覆盖和重写</td><td>子类的同名方法覆盖父类的同名方法</td></tr><tr><td>组合与聚合</td><td>聚合关系：汽车部件和整车的关系（整体与部分生命周期不同）<br/>组合关系：部门与公司的关系。公司倒闭的话部门也完完（整体与部分生命周期相同）</td></tr></tbody></table><p><strong>OOA大致上遵循如下5个基本步骤：</strong></p><p>（1）确定对象和类：这里所说的对象是对数据及其处理方式的抽象，它反映了系统保存和处理现实世界中某些事物的信息的能力。类是多个对象的共同属性和方法集合的描述，它包括如何在一个类中建立一个新对象的描述。<br>（2）确定结构：结构是指问题域的复杂性和连接关系。类成员结构反映了泛化-特化关系，整体-部分结构反映整体和局部之间的关系。<br>（3）确定主题：主题是指事物的总体概貌和总体分析模型。<br>（4）确定属性：属性就是数据元素，可用来描述对象或分类结构的实例，可在图中给出，并在对象的存储中指定。<br>（5）确定方法：方法是在收到消息后必须进行的一些处理方法:方法要在图中定义，并在对象的存储中指定。对于每个对象和结构来说，那些用来增加、修改、删除和选择的方法本身都是隐含的（虽然它们是要在对象的存储中定义的，但并不在图上给出），而有些则是显示的。</p><h5 id="2-3-2-1-UML"><a href="#2-3-2-1-UML" class="headerlink" title="2.3.2.1 UML"></a>2.3.2.1 UML</h5><p>OOA需求分析的UML（统一建模语言，与平台和语言无关）由基本构造块，规则和公共机制构成。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/11.png"></p><p><strong>UML基本构造块之事物【重要组成部分】</strong></p><table><thead><tr><th>事务</th><th>描述</th></tr></thead><tbody><tr><td>结构事务</td><td>最静态的部分，包括类，接口，协作用例，活动类，构件和节点</td></tr><tr><td>行为事务</td><td>代表时间和空间上的动作，包括消息，动作次序，连接</td></tr><tr><td>分组事务</td><td>看成是个盒子，如包和构件</td></tr><tr><td>注释事务</td><td>UML模型的解释部分。描述，说明，和标注模型的元素</td></tr></tbody></table><p><strong>UML基本构造块之关系【把事物紧密联系在一起】</strong></p><table><thead><tr><th>关系</th><th>描述</th></tr></thead><tbody><tr><td>依赖关系</td><td>一个事物发生变化影响另一个事物，包含关系和扩展关系都属于依赖</td></tr><tr><td>泛化关系</td><td>特殊一般关系，特殊元素的对象可替换一般元素的对象</td></tr><tr><td>关联关系</td><td>描述了一个链，链是对象之间的连接</td></tr><tr><td>实现关系</td><td>接口与类之间的关系，一个类指定了由另一个类保证执行的契约</td></tr></tbody></table><p><strong>UML基本构造块之图【多个相互关联的事物的集合】</strong></p><table><thead><tr><th>图</th><th>描述</th></tr></thead><tbody><tr><td>静态图</td><td>结构图</td></tr><tr><td>类图</td><td>描述一组类，接口协作和它们之间的关系</td></tr><tr><td>对象图</td><td>描述一组对象以及它们之间的关系。对象图往往只在需要描述复杂算法时才会使用，画出来的对象图往往不会只有一个对象。</td></tr><tr><td>构件图</td><td>也叫组件图，是描述软件内部物理组成的一种图。系统里有哪些构件 构件之间有啥联系。描述一个封装的类和它的接口，端口，以及由内嵌的构件和连接件构成的内部结构。强调由小的部件构件大的系统。</td></tr><tr><td>部署图</td><td>表示为软件和硬件之间的映射。为了完成系统需要什么样配置的操作系统，内存，CPU等不在它范畴内，它只解决开发的系统如何去部署的问题。</td></tr><tr><td>制品图</td><td>描述计算机中一个系统的物理结构。制品包括文件，数据库，和类似的物理比特集合。</td></tr><tr><td>包图</td><td>将某些类放入“包”中，通过包图来组织业务概念图。</td></tr><tr><td>组合结构图</td><td>展示该部分内容“内部”参与者的配置情况。这个图不常用。</td></tr><tr><td>动态图</td><td>行为图</td></tr><tr><td>用例图</td><td>系统与外部参与者的交互。描述一组用例，参与者及他们之间的关系的图。</td></tr><tr><td>顺序图</td><td>强调按时间顺序。顺序图和通信图我们又称其为交互图。顺序图能够表达用户与系统的复杂交互过程</td></tr><tr><td>通信图</td><td>也叫协作图，它强调的是相互之间关系，是顺序图的另外一种表达。</td></tr><tr><td>定时图</td><td>消息跨越不同对象或角色的实际时间。交互图的一种。</td></tr><tr><td>交互概览图</td><td>活动图与顺序图的结合。这个图不常用。</td></tr><tr><td>活动图</td><td>类似程序流程图，表示流程性的东西和并行的行为。它将进程或其他计算结构展示为计算内部一步步的控制流和数据流，它专注于系统的动态视图，它对系统功能建模和业务流程建模特别重要；并强调对象间的控制流程。</td></tr><tr><td>状态图</td><td>从某个物品的状态是如何变化的角度来展示流程。</td></tr></tbody></table><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/12.png"></p><p><strong>UML规则</strong></p><p>是构造块如何放在一起的规定，包括为构造块命名；给一个名字以特定含义的语境，即范围；怎样使用或看见名字，即可见性；事物如何正确、一致地相互联系，即完整性；运行或模拟动态模型的含义是什么，即执行。</p><p><strong>UML公共机制</strong></p><p>是指达到特定H标的公共UML方法，主要包括规格说明（详细说明）、修饰、公共分类（通用划分）和扩展机制4种。规格说明是事物语义的细节描述，它是模型真正的核心：UML为每个事物设置了一个简单的记号，还可以通过修饰来表达更多的信息；UML包括两组公共分类：类与对象（类表示概念，而对象表示具体的实体)、接门与实现（接口用来定义契约，而实现就是具体的内容)；扩展机制包括约束（扩展了UML构造块的语义，允许增加新的规则或修改现有的规则）、构造型（扩展UML的词汇，用于定义新的构造块）和标记值（扩展了UML构造块的特性，允许创建新的特殊信息来扩展事物的规格说明）。</p><p><strong>UML中的概念</strong></p><ol><li>类：是描述具有相同属性、方法、关系和语义的对象的集合，一个类实现一个或多个接口。</li><li>接口：是指类或构件提供特定服务的一组操作的集合，接口描述了类或构件的对外的可见的动作。</li><li>构件：是物理上或可替换的系统部分，它实现了一个接口集合。提供一组接口的实现，是组成事物的元素。</li><li>包：是用于把元素组织成组的通用机制，它一个构件的抽象化的概念，是把类元按照一定的规则分成组（或称为模块）。</li><li>用例：是描述一系列的动作，产生有价值的结果。</li><li>协作：定义了交互的操作，是一些角色和其它事物一起工作，提供一些合作的动作，这些动作比事物的总和要大。</li><li>节点：是一个物理元素，它在运行时存在，代表一个可计算的资源，通常占用一些内存和具有处理能力。</li></ol><h5 id="2-3-2-2-UML-4-1视图"><a href="#2-3-2-2-UML-4-1视图" class="headerlink" title="2.3.2.2 UML 4+1视图"></a>2.3.2.2 UML 4+1视图</h5><p>UML采用4+1视图来描述软件和软件的开发过程，其中进程视图绘制了所设计的并发与同步结构；部署视图表示软件到硬件的映射和分布结构；UML中的类图可以用来表示4+1视图中逻辑视图；最终形成用例视图，用来得到需求分析模型。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/13.png"></p><p>“4+1”视图模型是从不同的视角、使用多个并发的视图来组织[软件架构的描述。</p><p>“4+1”视图模型具有普遍适用性，实践证明能在许多大型项目中成功运用。</p><h5 id="2-3-2-3-用例模型与分析模型"><a href="#2-3-2-3-用例模型与分析模型" class="headerlink" title="2.3.2.3 用例模型与分析模型"></a>2.3.2.3 用例模型与分析模型</h5><p>在OOA的需求分析中，图的应用是经常被用到的。大部分的以用例模型和分析模型的建立为主线，其中用例模型采用用例图来构建，分析模型用类型表示。其它细节情况，也可以建立其它交互图。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/14.png"></p><h3 id="2-4-需求定义（形成需求规格）"><a href="#2-4-需求定义（形成需求规格）" class="headerlink" title="2.4 需求定义（形成需求规格）"></a>2.4 需求定义（形成需求规格）</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/15.png"></p><p>需求定义的过程也就是形成需求规格说明书SRS的过程，通常有两种需求定义的方法，分别是严格定义方法和原型方法。</p><p>严格定义法的特点：所有需求都能够被严格定义；开发人员和用户之间能够准确而清晰的交流；采用图形文字能够充分体现最终系统。</p><p>原型法：并非所有的需求都能在开发前被准确的说明；项目参加者之间通常存在交流上的困难；需要实际的可供用户参与的系统模型；有合适的系统开发环境；反复是完全需要和值得提倡的，需求一旦确定就应该遵从严格的方法。</p><h3 id="2-5-需求确认与验证"><a href="#2-5-需求确认与验证" class="headerlink" title="2.5 需求确认与验证"></a>2.5 需求确认与验证</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/16.png"></p><p>需求规格说明书SRS的需求验证也称为需求确认，其活动是为了确定以下几个方面的内容：</p><p>（1）SRS正确地描述了预期的、满足项目干系人需求的系统行为和特征。<br>（2）SRS中的软件需求是从系统需求、业务规格和其他来源中正确推导而来的。<br>（3）需求是完整的和高质量的。<br>（4）需求的表示在所有地方都是一致的。<br>（5）需求为继续进行系统设计、实现和测试提供了足够的基础。</p><p>需求验证包括了需求评审和需求测试。</p><ol><li><p>需求评审包括了：正式评审和非正式评审。需求验证是需要做用户签字确认，但往往实施起来比较困难，因为需求验证时签字就要负责任，它是验收的标准之一（此时的规格说明书SRS就是需求基线）。需求的评审需要用户的参与。</p></li><li><p>需求测试，不是运行类的测试而是设计测试用例进行测试，比如告诉你输入是什么输出是什么，所以更加接近于想像性测试，它是验证方向对不对该不该做的过程。需求测试仅仅是基于文本需求进行“概念”上的测试。然而，以功能需求为基础（SA方法）或者从用例派生出来（OO方法）的测试用例，可以使项目干系人更清楚地了解系统的行为。虽然没有在系统上执行测试用例，但是涉及测试用例的简单动作可以解释需求的许多问题。这种测试用例通常称为概念测试用例，即不是真正执行的测试用例，它们可以发现SRS中的错误、二义性和遗漏，还可以进行模型分析，以及作为用户验收测试的基础。在正式的系统测试中，还可以将它们细化成测试用例。</p></li></ol><h2 id="3-需求管理（支持、保障）"><a href="#3-需求管理（支持、保障）" class="headerlink" title="3 需求管理（支持、保障）"></a>3 需求管理（支持、保障）</h2><p>在软件需求工程中，需求管理贯穿于整个过程中，它的最基本的任务就是明确需求，并使项目团队和用户达成共识，即建立需求基线。另外，还要建立需求跟踪能力联系链，确保所有用户需求都被正确地应用，并且在需求发生变更时，能够完全地控制其影响范围，始终保持产品与需求的一致性。</p><p>需求管理是可重复级的一个关键过程域，其目标是为软件需求建立一个基线，供软件开发及其管理使用，使软件计划、产品和活动与软件需求保持一致。从软件需求工程的角度来看，需求管理包括在软件开发过程中维持需求一致性和精确性的所有活动，包括控制需求基线，保持项目计划与需求一致，控制单个需求和需求文档的版本情况，管理需求和联系链之间的联系，或管理单个需求和项目其他可交付物之间的依赖关系，跟踪基线中需求的状态。</p><h3 id="3-1-定义需求基线"><a href="#3-1-定义需求基线" class="headerlink" title="3.1 定义需求基线"></a>3.1 定义需求基线</h3><p>需求开发的结果应该有项目视图和范围文档、用例文档和SRS，以及相关的分析模型。经评审批准，这些文档就定义了开发工作的需求基线。这个基线在用户和开发人员之间就构成了软件需求的一个约定，它是需求开发和需求管理之间的桥梁。</p><p>基线是一个软件配置管理的概念，它帮助开发人员在不严重阻碍合理变化的情况下来控制变化。根据IEEE的定义，基线是指已经通过正式评审和批准的规约或产品，它可以作为进一步开发的基础，并且只能通过正式的变更控制系统进行变化。在软件工程范围内，基线是软件开发中的里程碑，其标志是有一个或多个软件配置项的交付，且已经经过正式技术评审而获得认可。例如，SRS文档通过评审，其中的错误已经被发现并纠正，则就变成了一个基线。根据国家标准《计算机软件配置管理计划规范》（GB/T 12505-1990）的规定，基线可以分为功能基线、指派基线和产品基线三种，通过评审后的SRS（软件需求规格说明书）属于指派基线。</p><h3 id="3-2-需求的状态"><a href="#3-2-需求的状态" class="headerlink" title="3.2 需求的状态"></a>3.2 需求的状态</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/17.png"></p><p>在需求状态的变化中，项目管理人员首先需要关注的是那些被拒绝和被丢弃的需求。因为这些需求有可能是应该被接受和并被实现的需求，如果不是通过有管理的处理过程，就有可能因为疏忽而被遗漏。同时，也应关注被交付的需求，因为可交付物是项目的成果体现，而可交付物的主要内容就是对需求的实现。</p><h3 id="3-3-需求变更管理"><a href="#3-3-需求变更管理" class="headerlink" title="3.3 需求变更管理"></a>3.3 需求变更管理</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/18.png"></p><p>CCB，变更控制委员会，也成配置控制委员会。<br>要让变更有序进行，首先需要有一个统一的单位来负责，这个单位一般叫变更控制委员会（Change<br>Control Board），也叫配置控制委员会（Configuration Control<br>Board）。CCB由项目干系人中有代表性的人员组成，人数没有限制，一个人也可以。CCB有能力在管理上做出承诺，对建议的配置项变更做出评价、审批及监督已批准变更的实施。CCB是决策机构，一般不参与具体的变更执行工作。</p><h3 id="3-4-需求变更管理过程"><a href="#3-4-需求变更管理过程" class="headerlink" title="3.4 需求变更管理过程"></a>3.4 需求变更管理过程</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/19.png"></p><p>（1）问题分析和变更描述。当提出一份变更提议后，需要对该提议做进一步的问题分析，检查它的有效性，从而产生一个更明确的需求变更提议。<br>（2）变更分析和成本计算。当接受该变更提议后，需要对需求变更提议进行影响分析和评估。变更成本计算应该包括对该变更所引起的所有改动的成本，例如修改需求文档、相应的设计、实现等工作成本。一旦分析完成并且被确认，应该进行是否执行这一变更的决策。<br>（3）变更实现。当确定执行该变更后，需要根据该变更的影响范围，按照开发的过程模型执行相应的变更。在计划驱动过程模型中，往往需要回溯到需求分析阶段开始，重新作对应的需求分析、设计和实现等步骤;在敏捷开发模型中，往往会将需求变更纳入到下一次迭代的执行过程中。</p><p>常见的需求变更策略：</p><p>（1）所有需求变更必须遵循变更控制过程。<br>（2）对于未获得批准的变更，不应该做设计和实现工作。<br>（3）变更应该由项目变更控制委员会决定实现哪些变更。<br>（4）项目风险承担者应该能够了解变更的内容。<br>（5）绝不能从项目配置库中删除或者修改变更请求的原始文档。<br>（6）每一个集成的需求变更必须能跟踪到一个经核准的变更请求，以保持水平可追踪性。</p><h3 id="3-5-需求风险"><a href="#3-5-需求风险" class="headerlink" title="3.5 需求风险"></a>3.5 需求风险</h3><p>带有风险的做法有：①无足够用户参与。②忽略了用户分类。③用户需求的不断增加。④模凌两可的需求。⑤不必要的特征。⑥过于精简的SRS。⑦不准确的估算。</p><p>变更产生的原因：①外部环境的变化。②需求和设计做的不够完整。③新技术的出现。④公司机构重组造成业务流程的变化。</p><h3 id="3-6-需求跟踪"><a href="#3-6-需求跟踪" class="headerlink" title="3.6 需求跟踪"></a>3.6 需求跟踪</h3><p>SRS中的每个软件配置项的需求到其涉及的系统（或子系统）需求都要具有双向可追踪性。所谓双向跟踪，包括正向跟踪和反向跟踪，正向跟踪是指检查SRS中的每个需求是否都能在后继工作成果中找到对应点；反向跟踪也称为逆向跟踪，是指检查设计文档、代码、测试用例等工作成果是否都能在SRS中找到出处。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/20.png"></p>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>基础技能</category>
      
      <category>软件工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>过程开发模型</title>
    <link href="/2023/07/08/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BF%87%E7%A8%8B%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/07/08/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BF%87%E7%A8%8B%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-软件工程概念"><a href="#1-软件工程概念" class="headerlink" title="1 软件工程概念"></a>1 软件工程概念</h2><p><strong>软件开发生命周期：</strong></p><ol><li>软件定义时期 ：包括可行性研究和详细需求分析过程，任务是确定软件开发工程必须完成的总目标，具体可分成问题定义、可行性研究、需求分析等。</li><li>软件开发时期 ：就是软件的设计与实现，可分成概要设计、详细设计、编码、测试等。</li><li>软件运行和维护 ：就是把软件产品移交给用户使用。</li></ol><p><strong>软件系统的文档：</strong>软件系统的文档可以分为用户文档和系统文档两类，用户文档主要描述系统功能和使用方法，并不关系这些功能是怎样实现的；系统文档描述系统设计、实现和测试等各方面的内容。</p><p><strong>软件工程过程是指为获得软件产品包括以下4个方面活动（PDCA）：</strong></p><blockquote><p>P(Plan)——软件规格说明 ：规定软件的功能及其运行时的限制。<br>D(Do)—―软件开发 ：开发出满足规格说明的软件。<br>C(Check)——软件确认 ：确认开发的软件能够满足用户的需求。<br>A(Action)―—软件演进 ：软件在运行过程中不断改进以满足客户新的需求。</p></blockquote><p><strong>软件系统工具通常可以按软件过程活动将软件工具分为：</strong></p><ol><li>软件开发工具 ：需求分析工具、设计工具、编码与排错工具、测试工具等。</li><li>软件维护工具 ：版本控制工具、文档分析工具、开发信息库工具、逆向工程工具、再工程工具。</li><li>软件管理和软件支持工具 ：项目管理工具、配置管理工具、软件评价工具、软件开发工具的评价和选择。</li></ol><p><strong>软件设计四个活动</strong>：数据设计、架构（体系结构）设计、人机界面（接口）设计、过程设计。</p><h2 id="2-软件能力成熟度模型"><a href="#2-软件能力成熟度模型" class="headerlink" title="2 软件能力成熟度模型"></a>2 软件能力成熟度模型</h2><p><strong>软件能力成熟度模型（Capability Maturity Model for Software，CMM）</strong></p><table><thead><tr><th>能力等级</th><th>特点</th><th>关键过程域</th></tr></thead><tbody><tr><td>初始级</td><td>软件过程的特点是杂乱无章，有时甚至很混乱，几乎没有明确定义的步骤，项目的成功完全依赖个人的努力和英雄式核心人物的作用。</td><td></td></tr><tr><td>可重复级</td><td>建立了基本的项目管理过程和实践来跟踪项目费用、进度和功能特性，有必要的过程准则来重复以前在同类项目中的成功。</td><td>软件配置管理、软件质量保证、软件子合同管理、软件项目跟踪与监督、软件项目策划、软件需求管理</td></tr><tr><td>已定义级</td><td>管理和工程两方面的软件过程已经文档化、标准化，并综合成整个软件开发组织的标准软件过程。所有项目都采用根据实际情况修改后得到的标准软件过程来发和维护软件。</td><td>同行评审、组间协调、软件产品工程、集成软件管理、培训大纲、组织过程定义、组织过程集点</td></tr><tr><td>已管理级</td><td>制定了软件过程和产品质量的详细度量标准。对软件过程和产品质量有定量的理解和控制。</td><td>软件质量管理和定量过程管理</td></tr><tr><td>优化级</td><td>加强了定量分析,通过来自过程质量反馈和来自新观念、新技术的反馈使过程能不断持续地改进。</td><td>过程更改管理、技术改革管理和缺陷预防</td></tr></tbody></table><p><strong>软件能力成熟度模型集成（Capability Maturity Model Integration for Software，CMMI）</strong>阶段式模型，CMMI是在CMM的基础上发展而来的，它关注组织的成熟度。</p><table><thead><tr><th>能力等级</th><th>特点</th><th>关键过程域</th></tr></thead><tbody><tr><td>初始级</td><td>过程不可预测且缺乏控制</td><td></td></tr><tr><td>可重复级</td><td>过程为项目服务</td><td>需求管理、项目计划、配置管理、项目监督与控制、供应商合同管理、度量和分析、过程和产品质量保证</td></tr><tr><td>已定义级</td><td>过程为组织服务</td><td>需求开发、技术解决方案、产品集成、验证、确认组织级过程焦点、组织级过程定义、组织级培训、集成项目管理、风险管理、集成化的团队、决策分析和解决方案、组织级集成环境</td></tr><tr><td>已管理级</td><td>过程已度量和控制</td><td>组织过程性能、定量项目管理</td></tr><tr><td>优化级</td><td>集中于过程改进与优化</td><td>组织级改革与实施、因果分析和解决方案</td></tr></tbody></table><h2 id="3-软件过程模型"><a href="#3-软件过程模型" class="headerlink" title="3 软件过程模型"></a>3 软件过程模型</h2><h3 id="3-1-瀑布模型"><a href="#3-1-瀑布模型" class="headerlink" title="3.1 瀑布模型"></a>3.1 瀑布模型</h3><p>瀑布模型（SDLC）也称为生命周期法，是生命周期法中最常用的开发模型，一般将软件开发分为：可行性分析（计划）、需求分析、软件设计（概要设计、详细设计）、编码（含单元测试）、测试、运行维护等几个阶段，规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落。如图：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BF%87%E7%A8%8B%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/1.png"></p><p><strong>瀑布模型特点：</strong></p><ol><li>从上一项开发活动接受该项活动的工作对象作为输入。</li><li>利用这一输入，实施该项活动应完成的工作内容。</li><li>给出该项活动的工作成果，作为输出传给下一项开发活动。</li><li>对该项活动的实施工作成果进行评审。若其工作成果得到确认，则继续进行下一项开发活动;否则返回前一项，甚至更前项的活动。尽量减少多个阶段间的反复。以相对来说较小的费用来开发软件。</li></ol><p>瀑布模型有利于大型软件开发过程中人员的组织与管理，有利于软件开发方法和工具的研究与使用，从而提高了大型软件项目开发的质量和效率。然而软件开发的实践表明，上述各项活动之间并非完全是自上而下的，而是呈线性图示，因此，<strong>瀑布模型存在严重的缺陷：</strong></p><ol><li>由于开发模型呈线性，所以当开发成果尚未经过测试时，用户无法看到软件的效果。这样，软件与用户见面的时间间隔较长，也增加了一定的风险。</li><li>在软件开发前期未发现的错误传到后面的开发活动中时，可能会扩散，进而可能导致整个软件项目开发失败。</li><li>在软件需求分析阶段，完全确定用户的所有需求是比较困难的，甚至可以说是不太可能的。</li></ol><h3 id="3-2-原型模型"><a href="#3-2-原型模型" class="headerlink" title="3.2 原型模型"></a>3.2 原型模型</h3><p>原型化模型主要针对事先不能完整定义需求的软件开发，是在快速开发一个原型的基础上，根据用户在调用原型的过程中提出的反馈意见和建议，对原型进行改进，获得原型的新版本，重复这一过程，直到演化成最终的软件产品。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BF%87%E7%A8%8B%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/2.png"></p><p>原型法认为在很难一下子全面准确地提出用户需求的情况下，原型应当具备的特点如下：</p><ul><li>实际可行。</li><li>具有最终系统的基本特征。</li><li>构造方便、快速，造价低。原型法的特点在于原型法对用户的需求是动态响应、逐步纳入的。</li></ul><p>有关原型化方法/模型的内容：</p><p>软件原型是所提出的新产品的部分实现，建立原型的主要目的是为了解决在产品开发的早期阶段的需求不确定的问题，其目的是明确并完善需求、探索设计选择方案、发展为最终的产品。<strong>原型模型比较适合需求不够明确的项目</strong>。</p><p>原型有很多种分类方法。从原型是否实现功能来分，软件原型可分为<strong>水平原型</strong>和垂直原型两种。水平原型也称为行为原型，用来探索预期系统的一些特定行为，并达到细化需求的目的。水平原型通常只是功能的导航，但并未真实实现功能。水平原型主要用在界面上。垂直原型也称为结构化原型，实现了一部分功能。垂直原型主要用在复杂的算法实现上。</p><p>从原型的最终结果来分，软件原型可分为 <strong>抛弃型原型</strong>和 <strong>演化型原型</strong>。抛弃型原型也称为探索型原型，是指达到预期目的后，原型本身被抛弃。 抛弃型原型主要用在解决需求不确定性、二义性、不完整性、含糊性等。演化型原型为开发增量式产品提供基础，是螺旋模型的一部分，也是面向对象软件开发过程的一部分。演化型原型主要用在必须易于升级和优化的项目，适用于Web项目。</p><p>有些文献把原型分为<strong>实验型、探索型和演化型</strong>。探索型原型的目的是要弄清对目标系统的要求，确定所希望的特性，并探讨多种方案的可行性。实验型原型用于大规模开发和实现之前，考核方案是否合适，规格说明是否可靠。进化型原型的目的不在于改进规格说明，而是将系统建造得易于变化，在改进原型的过程中，逐步将原型进化成最终系统。</p><p>还有些文献也把原型分为<strong>抛弃式原型、演化式原型和递增式原型</strong>。</p><p>原型法适合于用户没有肯定其需求的明确内容的时候。它是先根据已给的和分析的需求，建立一个原始模型，这是一个可以修改的模型（在生命周期法中，需求分析成文档后一般不再多修改）。在软件开发的各个阶段都把有关信息相互反馈，直至模型的修改，使模型渐趋完善。在这个过程中，用户的参与和决策加强了，最终的结果是更适合用户的要求。这种原型技术又可分为三类：抛弃式、演化式和递增式。这种原型法成败的关键及效率的高低在于模型的建立及建模的速度。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BF%87%E7%A8%8B%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/3.png"></p><h3 id="3-3-增量模型"><a href="#3-3-增量模型" class="headerlink" title="3.3 增量模型"></a>3.3 增量模型</h3><p>增量模型融合了瀑布模型的基本成分（重复的应用）和原型实现的迭代特征。增量模型采用随着时间的进展而交错的线性序列，每一个线性序列产生软件的一个可发布的”增量“。当使用增量模型时，第一个增量往往是核心的产品，也就是说第一个增量实现了基本的需求，但很多补充的特征还没有发布。客户对每一个增量的使用和评估，都作为下一个增量发布的新特征和功能。这个过程在每一个增量发布后不断重复，直到产生最终的完善产品。</p><p>增量模型强调每一个增量均发布一个可操作的产品。如图：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BF%87%E7%A8%8B%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/4.png"></p><p>增量模型像原型实现模型和其他演化方法一样，本质上是迭代的。但与原型实现不同的是增量模型强调每一个增量均发布一个可操作产品。早期的增量是最终产品的”可拆卸”版本，但它们确实提供了为用户服务的功能，并且提供了给用户评估的平台。增量模型的特点是引进了增量包的概念，无须等到所有需求都出来，只要某个需求的增量包出来即可进行开发。虽然某个增量包可能还需要进一步适应客户的需求，还需要更改，但只要这个增量包足够小，其影响对整个项目来说是可以承受的。</p><p>采用增量模型的优点是人员分配灵活，刚开始不用投入大量人力资源，如果核心产品很受欢迎，则可以增加人力实现下一个增量；当配备的人员不能在设定的期限内完成产品时，它提供了一种先推出核心产品的途径，这样就可以先发布部分功能给客户，对客户起到镇静剂的作用。此外，增量能够有计划地管理技术风险。增量模型的缺点是如果增量包之间存在相交的情况且不能很好地处理，就必须做全盘的系统分析，不能很好的进行模块划分。增量模型将功能细化、分别开发的方法适用于需求经常改变的软件开发过程。</p><h3 id="3-4-螺旋模型"><a href="#3-4-螺旋模型" class="headerlink" title="3.4 螺旋模型"></a>3.4 螺旋模型</h3><p>螺旋模型将瀑布模型和原型化（演化）模型相结合，它综合了两者的优点，并增加了风险分析。它以原型为基础，沿着螺线自内向外旋转，每旋转一圈都要经过制订计划、风险分析、实施工程、客户评价等活动，并开发原型的一个新版本。</p><p>螺旋模型强调了风险分析，特别适用于庞大而复杂的、高风险的系统。经过若干次螺旋上升的过程，得到最终的系统，如图：（需求在项目刚开始的时候往往会比较模糊，而随着项目的进行会慢慢的明确下来，也就是需求有渐进明细的特点。）</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BF%87%E7%A8%8B%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/5.png"></p><h3 id="3-5-V模型"><a href="#3-5-V模型" class="headerlink" title="3.5 V模型"></a>3.5 V模型</h3><p>在开发模型中，测试常常作为亡羊补牢的事后行为，但也有以测试为中心的开发模型，那就是V模型。V模型只得到软件业内比较模糊的认可。V模型宣称测试并不是一个事后弥补行为，而是一个同开发过程同样重要的过程，如图：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BF%87%E7%A8%8B%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/6.png"></p><p>V模型是最具有代表意义的测试模型，它是瀑布模型的变种，它在瀑布模型的基础上加强了测试，反映了测试活动与分析和设计的关系。V模型中，左边下降的是开发过程阶段，右边上升部分是测试过程的各个阶段。V模型的软件测试策略既包括低层测试又包括了高层测试，低层测试是为了源代码的正确性，高层测试是为了使整个系统满足用户的需求。V模型存在一定的局限性，它仅仅把测试过程作为在需求分析、概要设计、详细设计及编码之后的一个阶段。让测试工作贯穿于始终。</p><p>V模型强调软件幵发的协作和速度，将软件实现和验证有机地结合起来，在保证较高的软件质M情况下缩短开发周期。V模型适合企业级的软件幵发，它更淸楚地揭示了软件开发过程的特性及其本质。</p><p>V模型的价值在于它非常明确地表明了测试过程中存在的不同级别，并且清楚地描述了这些测试阶段和开发过程期间各阶段的对应关系：</p><ol><li>单元测试的主要目的是针对编码过程中可能存在的各种错误。例如：用户输入验证过程中的边界值的错误。</li><li>集成测试的主要目的是针对详细设计中可能存在的问题，尤其是检查各单元与其他程序部分之间的接口上可能存在的错误。</li><li>系统测试主要针对概要设计，检查系统作为一个整体是否有效地得到运行。例如：在产品设置中是否达到了预期的高性能。</li><li>验收测试通常由业务专家或用户进行，以确认产品能真正符合用户业务上的需要。</li></ol><h3 id="3-6-喷泉模型"><a href="#3-6-喷泉模型" class="headerlink" title="3.6 喷泉模型"></a>3.6 喷泉模型</h3><p>喷泉模型对软件复用和生命周期中多项开发活动的集成提供了支持，主要支持面向对象的开发方法，是一种以用户需求为动力，以对象作为驱动的模型。”喷泉”一词本身体现了迭代和无间隙特性。系统某个部分常常重复工作多次，相关功能在每次迭代中随之加入演进的系统。所谓无间隙是指在开发活动中，分析、设计和编码之间不存在明显的边界，如图：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BF%87%E7%A8%8B%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/7.png"></p><h3 id="3-7-CVSD基于构件的模型-构件组装模型-基于构件的软件开发"><a href="#3-7-CVSD基于构件的模型-构件组装模型-基于构件的软件开发" class="headerlink" title="3.7 CVSD基于构件的模型(构件组装模型/基于构件的软件开发)"></a>3.7 CVSD基于构件的模型(构件组装模型/基于构件的软件开发)</h3><p>构件（Component，组件）是一个具有可重用价值的、功能相对独立的软件单元。基于构件的软件开发（ComponentBased Software Development，CBSD）模型是利用模块化方法，将整个系统模块化，并在一定构件模型的支持下，复用构件库中的一个或多个软件构件，通过组合手段高效率、高质量地构造应用软件系统的过程。</p><p>基于构件的开发模型融合了螺旋模型的许多特征，本质上是演化型的，开发过程是迭代的。基于构件的开发模型由软件的需求分析和定义、体系结构设计、构件库建立（其中构件库包括了构件获取和构件管理）、应用软件构建、测试和发布5个阶段组成。如图：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BF%87%E7%A8%8B%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/8.png"></p><p>CBSE的构件应该具备的特征：</p><ul><li>可组装性：所有外部交互必须通过公开定义的接口进行。</li><li>可部署性：构件总是二进制形式的，能作为一个独立实体在平台上运行。</li><li>文档化：用户根据文档来判断构件是否满足需求。</li><li>独立性：可以在无其他特殊构件的情况下进行组装和部署。</li><li>标准化：符合某种标准化的构件模型。</li></ul><p>CBSE的构件的组装顺序：</p><ul><li>顺序组装：按顺序调用己经存在的构件，可以用两个已经存在的构件来创造一个新的构件。</li><li>层次组装：被调用构件的“提供”接口必须和调用构件的“请求”接口兼容。</li><li>叠加组装：多个构件合并形成新构件，新构件整合原构件的功能，对外提供新的接口。</li></ul><p>构件作为重要的软件技术和工具得到了极大的发展，这些新技术标准和工具有Microsoft的DCOM/COM，Sun的EJB，OMG的CORBA等。基于构件的开发活动从标识候选构件开始，通过搜索已有构件库，确认所需要的构件是否已经存在，如果已经存在，就从构件库中提取出来复用；如果不存在，就采用面向对象方法开发它。在提取出来的构件通过语法和语义检查后，将这些构件通过胶合代码组装到一起实现系统，这个过程是迭代的。</p><p>基于构件的开发方法使得软件开发不再一切从头开始，开发的过程就是构件组装的过程，维护的过程就是构件升级、替换和扩充的过程，其优点是构件组装模型导致了软件的复用，提高了软件开发的效率；构件可由一方定义其规格说明，被另一方实现，然后供给第三方使用；构件组装模型允许多个项目同时开发，降低了费用，提高了可维护性，可实现分步提交软件产品。<br>缺点是由于采用自定义的组装结构标准，缺乏通用的组装结构标准，引入具有较大的风险；可重用性和软件高效性不易协调，需要精干的、有经验的分析人员和开发人员，一般的开发人员插不上手，客户的满意度低；过分依赖于构件，构件库的质量影响着产品质量。</p><h3 id="3-8-敏捷模型"><a href="#3-8-敏捷模型" class="headerlink" title="3.8 敏捷模型"></a>3.8 敏捷模型</h3><p>开发宣言：个体和交互胜过过程和工具、可以工作的软件胜过面面俱到的文档、客户合作胜过合同谈判、响应变化胜过遵循计划。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BF%87%E7%A8%8B%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/9.png"></p><p><strong>敏捷开发方法</strong></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BF%87%E7%A8%8B%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/10.png"></p><p>敏捷方法区别与其他方法的两个特点：<br>（1）是”适应性“而非“预设性”。<br>（2）是“面向人的”而非“面向过程的”。<br>敏捷开发核心思想：<br>（1）敏捷开发是适应型，而非可预测型。拥抱变化，适应变化。<br>（2）敏捷开发是以人为本，而非以过程为本。发挥人的特性。<br>（3）迭代增量式的开发过程。以原型开发思想为基础，采用法代替增量式开发，发行版本小型化。</p><h4 id="3-8-1-XP极限编程"><a href="#3-8-1-XP极限编程" class="headerlink" title="3.8.1 XP极限编程"></a>3.8.1 XP极限编程</h4><p>XP是一种轻量（敏捷）、高效、低风险、柔性、可预测、科学而且充满乐趣的软件开发方式。与其他方法论相比，其最大的不同在于：</p><p>（1）以代码驱动的规则，其重要的文档是源代码。<br>（2）在更短的周期内，更早地提供具体、持续的反馈信息。<br>（3）迭代地进行计划编制，首先在最开始迅速生成一个总体计划，然后在整个项目开发过程中不断地发展它。<br>（4）依赖于自动测试程序来监控开发进度，并及早地捕获缺陷。<br>（5）依赖于口头交流、测试和源程序进行沟通。<br>（6）倡导持续的演化式的设计。<br>（7）依赖于开发团队内部的紧密协作。<br>（8）尽可能达到程序员短期利益和项目长期利益的平衡。</p><p>四大价值观：</p><p>沟通，加强面对面沟通<br>简单，不过度设计<br>反馈，及时反馈<br>勇气，接受变更的勇气<br>XP是一种近螺旋式的开发方法，它将复杂的开发过程分解为一个个相对比较简单的小周期:通过积极的交流、反馈以及其他一系列的方法，开发人员和客户可以非常清楚开发进度、变化待解决的问题和潜在的困难等，并根据实际情况及时地调整开发过程。</p><p>XP提倡测试先行，为了将以后出现bug的几率降到最低。XP一些对费用控制严格的公司中的使用，非常有效。</p><h4 id="3-8-2-水晶方法"><a href="#3-8-2-水晶方法" class="headerlink" title="3.8.2 水晶方法"></a>3.8.2 水晶方法</h4><p>水晶系列方法与XP方法一样，都有以人为中心的理念，但在实践上有所不同。其目的是发展一种提倡“机动性的”方法，包含具有共性的核心元素，每个都含有独特的角色、过程模式、工作产品和实践。</p><p>水晶方法：探索了用最少纪律约束而仍能成功的方法，从而在产出效率与易于运作上达到一种平衡。</p><h4 id="3-8-3-开放式源码"><a href="#3-8-3-开放式源码" class="headerlink" title="3.8.3 开放式源码"></a>3.8.3 开放式源码</h4><p>开放式源码：程序开发人员在地域上分布很广【其他方法强调集中办公】。</p><h4 id="3-8-4-并列争求法"><a href="#3-8-4-并列争求法" class="headerlink" title="3.8.4 并列争求法"></a>3.8.4 并列争求法</h4><p>并列争球法（SCRUM）是一种迭代的增量化过程，把每段时间（如30天）一次的迭代称为一个“冲刺”（Sprint），并按需求的优先级别来实现产品，多个自组织和自治的小组并行地递增实现产品。</p><p>并列争求法（SCRUM）：明确定义了的可重复的方法过程，侧重于项目管理。</p><h4 id="3-8-5-特征驱动开发方法（FDD）"><a href="#3-8-5-特征驱动开发方法（FDD）" class="headerlink" title="3.8.5 特征驱动开发方法（FDD）"></a>3.8.5 特征驱动开发方法（FDD）</h4><p>特征驱动开发方法（FDD）是一个迭代的开发模型。认为有效的软件开发需要3个要素：人、过程和技术。有5个核心过程：开发整体对象模型、构造特征列表、计划特征开发、特征设计和特征构建。定义了6种关键的项目角色：项目经理、首席架构设计师、开发经理、主程序员、程序员和领域专家。</p><p>功用驱动开发方法（FDD）：编程开发人员分成两类：首席程序员和“类”程序员。</p><h4 id="3-8-6-ASD方法"><a href="#3-8-6-ASD方法" class="headerlink" title="3.8.6 ASD方法"></a>3.8.6 ASD方法</h4><p>ASD方法：其核心是三个非线性的、重叠的开发阶段：猜测、合作与学习。</p><h4 id="3-8-7-动态系统开发方法"><a href="#3-8-7-动态系统开发方法" class="headerlink" title="3.8.7 动态系统开发方法"></a>3.8.7 动态系统开发方法</h4><p>动态系统开发方法（DSDM）：倡导以业务为核心。</p><h3 id="3-9-RAD模型-快速应用开发模型"><a href="#3-9-RAD模型-快速应用开发模型" class="headerlink" title="3.9 RAD模型(快速应用开发模型)"></a>3.9 RAD模型(快速应用开发模型)</h3><p>快速应用开发（Rapid Application Development，RAD）模型是一个增量型的软件开发过程模型，强调极短的开发周期。RAD模型是瀑布模型的一个“高速”变种，通过大量使用可复用构件，采用基于构件的建造方法赢得快速开发。如果需求理解得好且约束了项目的范围，利用这种模型可以很快地创建出功能完善的“信息系统“。其流程从业务建模开始，随后是数据建模、过程建模、应用生成、测试及反复。瀑布模型和CBSD（Component-Based Software Development基于构建的软件开发模型）的综合开发模型，如图：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BF%87%E7%A8%8B%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/11.png"></p><p>RAD模型各个活动期所要完成的任务如下：</p><ol><li>业务建模：以什么信息驱动业务过程运作？要生成什么信息？谁生成它？信息流的去向是哪里？由谁处理？可以辅之以数据流图。</li><li>数据建模：为支持业务过程的数据流，找数据对象集合，定义数据对象属性，与其他数据对象的关系构成数据模型，可辅之以E-R图。</li><li>过程建模：使数据对象在信息流中完成各业务功能。创建过程以描述数据对象的增加、修改、删除、查找，即细化数据流图中的处理框。</li><li>应用程序生成：利用第四代语言（4GL）写出处理程序，重用已有构件或创建新的可重用构件，利用环境提供的工具自动生成并构造出整个应用系统。</li><li>测试与交付，由于大量重用，一般只做总体测试，但新创建的构件还是要测试的。</li></ol><p>与瀑布模型相比，RAD模型不采用传统的第三代程序设计语言来创建软件，而是采用基于构件的开发方法，复用已有的程序结构（如果可能的话）或使用可复用构件，或创建可复用的构件（如果需要的话）。在所有情况下，均使用自动化工具辅助软件创造。很显然，加在一个RAD模型项目上的时间约束需要“一个可伸缩的范围”。如果一个业务能够被模块化使得其中每一个主要功能均可以在不到三个月的时间内完成，那么它就是RAD的一个候选者。每一个主要功能可由一个单独的RAD组来实现，最后再集成起来形成一个整体。</p><p>RAD模型通过大量使用可复用构件加快了开发速度，对信息系统的开发特别有效。但是像所有其他软件过程模型一样，RAD方法也有其缺陷：</p><ol><li>并非所有应用都适合RAD。RAD模型对模块化要求比较高，如果有哪一项功能不能被模块化，那么建造RAD所需要的构件就会有问题；如果高性能是一个指标，且该指标必须通过调整接口使其适应系统构件才能赢得，RAD方法也有可能不能奏效。</li><li>开发者和客户必须在很短的时间完成一系列的需求分析，任何一方配合不当都会导致RAD项目失败。</li><li>RAD只能用于信息系统开发，不适合技术风险很高的情况。当一个新应用要采用很多新技术或当新软件要求与已有的计算机程序有较高的互操作性时，这种情况就会发生。</li></ol><h3 id="3-10-统一过程模型-RUP-UP"><a href="#3-10-统一过程模型-RUP-UP" class="headerlink" title="3.10 统一过程模型(RUP/UP)"></a>3.10 统一过程模型(RUP/UP)</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BF%87%E7%A8%8B%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/12.png"></p><p><strong>RUP的特点</strong></p><p>（1）用例驱动：需求分析、设计、实现和测试等活动都是用例驱动的。<br>（2）以架构为中心：包括系统的总体组织和全局控制、通信协议等。是一个多维的结构，会采用多个视图（4 + 1 视图） 来描述。<br>（3）迭代与增量：把整个项目开发分为多个迭代过程。在每次选代中，只考虑系统的一部分需求，进行分析、设计、实现、测试和部署等过程;每次迭代是在己完成部分的基础上进行的，每次增加一些新的功能实现，以此进行下去，直至最后项目的完成。</p><p><strong>RUP中有4个阶段</strong>：统一软件开发过程定义了四种开发阶段，它们按照过程顺序分别是起始阶段，细化阶段，构建阶段和交付阶段，其中在构建阶段主要产生的文档有设计模型。</p><p>初始阶段：项目蓝图文档（核心需求，关键特征，主要约束），用例模型，项目计划</p><p>细化阶段：完成架构设计，淘汰高风险元素</p><p>构造阶段：UML模型，测试用例</p><p>交付阶段：可运行的软件产品，用户手册，用户支持计划。</p><p><strong>RUP软件开发生命周期是一个二维的软件开发模型，RUP中有9个核心工作流，如下：</strong></p><ol><li>业务建模：理解待开发系统所在的机构及其商业运作，确保所有参与人员对待开发系统所在的机构有共同的认识，评估待开发系统对所在机构的影响。</li><li>需求：定义系统功能及用户界面，使客户知道系统的功能，使开发人员理解系统的需求，为项目预算及计划提供基础。</li><li>分析与设计：把需求分析的结果转化为分析与设计模型。</li><li>实现：把设计模型转换为实现结果，对开发的代码做单元测试，将不同实现人员开发的模块集成为可执行系统。</li><li>测试：检查各子系统之间的交互、集成，验证所有需求是否均被正确实现，对发现的软件质量上的缺陷进行归档，对软件质量提出改进建议。</li><li>部署：打包、分发、安装软件，升级旧系统；培训用户及销售人员，并提供技术支持。</li><li>配置与变更管理：跟踪并维护系统开发过程中产生的所有制品的完整性和一致性。</li><li>项目管理：为软件开发项目提供计划、人员分配、执行、监控等方面的指导，为风险管理提供框架。</li><li>环境：为软件开发机构提供软件开发环境，即提供过程管理和工具的支持。</li></ol><h2 id="4-逆向工程"><a href="#4-逆向工程" class="headerlink" title="4 逆向工程"></a>4 逆向工程</h2><p>逆向工程的特点是从已有的程序中抽取数据结构，体系结构和程序设计信息。</p><p>它的流程为：现有系统 → 逆向工程 → 考虑新需求 → 正向工程 → 新系统。</p><p>软件的逆向工程是一个恢复设计的过程，从现有的程序中抽取数据，体系结构和过程设计信息。逆向工程的完备性可以用在某一个抽象层次上提供信息的详细程度来描述，在大多数情况下，抽象层次越高，完备性就越低。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BF%87%E7%A8%8B%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/13.png"></p><p>领域级抽象级别最高，完备性最低，实现级抽象级别最低，完备性最高。</p><p>与逆向工程相关的概念有重构、设计恢复、再工程和正向工程：</p><ol><li>重构（restructuring），重构是指在同一抽象级别上转换系统描述形式。</li><li>设计恢复（design recovery），设计恢复是指借助工具从已有程序中抽象出有关数据设计、总体结构设计和过程设计等方面的信息。</li><li>逆向工程（reverse engineering），逆向工程是分析程序，力图在比源代码更高抽象层次上建立程序的表示过程，逆向工程是设计的恢复过程。</li><li>正向工程（forward engineering），正向工程是指不仅从现有系统中恢复设计信息，而且使用该信息去改变或重构现有系统，以改善其整体质量。</li><li>再工程（re-engineering），再工程是对现有系统的重新开发过程，包括逆向工程、新需求的考虑过程和正向工程三个步骤。</li></ol><p><strong>逆向工程恢复信息的方法:</strong></p><table><thead><tr><th>方法</th><th>导出信息</th></tr></thead><tbody><tr><td>用户指导下的搜索和变换方法</td><td>实现级、结构级</td></tr><tr><td>变换式方法</td><td>实现级、结构级、功能级</td></tr><tr><td>基于领域知识的方法</td><td>功能级、领域级</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>基础技能</category>
      
      <category>软件工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件测试与维护</title>
    <link href="/2023/07/08/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%BB%B4%E6%8A%A4/"/>
    <url>/2023/07/08/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%BB%B4%E6%8A%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="1-软件测试"><a href="#1-软件测试" class="headerlink" title="1 软件测试"></a>1 软件测试</h2><h3 id="1-1-测试类型"><a href="#1-1-测试类型" class="headerlink" title="1.1 测试类型"></a>1.1 测试类型</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%BB%B4%E6%8A%A4/1.png"></p><h3 id="1-2-测试阶段"><a href="#1-2-测试阶段" class="headerlink" title="1.2 测试阶段"></a>1.2 测试阶段</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%BB%B4%E6%8A%A4/2.png"></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%BB%B4%E6%8A%A4/3.png"></p><h3 id="1-3-软件调试"><a href="#1-3-软件调试" class="headerlink" title="1.3 软件调试"></a>1.3 软件调试</h3><p>测试是发现错误，调试是找出错误的代码和原因。</p><p>调试需要确定错误的准确位置；确定问题的原因并设法改正；改正后要进行回归测试。</p><p>调试的方法有：蛮力法、回溯法（从出错的地方开始，向回找）、原因排除法（找出所有可能的原因，逐一进行排除，具体包括演绎法、归纳法、二分法）。</p><h3 id="1-4-软件度量"><a href="#1-4-软件度量" class="headerlink" title="1.4 软件度量"></a>1.4 软件度量</h3><p>软件的两种属性：外部属性指面向管理者和用户的属性，可直接测量，一般为性能指标。内部属性指软件产品本身的的属性，如可靠性等，只能间接测量。</p><p>McCabe度量法：又称为环路复杂度，假设有向图中有向边数为m，节点数为n，则此有向图的环路复杂度为m-n+2。</p><p>注意m和n代表的含义不能混淆，可以用一个最简单的环路来做特殊值记忆此公式，另外，针对一个程序流程图，每一个分支边（连线）就是一条有向边，每一条语句（语句框）就是一个顶点。</p><h2 id="2-软件维护"><a href="#2-软件维护" class="headerlink" title="2 软件维护"></a>2 软件维护</h2><h3 id="2-1-遗留系统演化策略"><a href="#2-1-遗留系统演化策略" class="headerlink" title="2.1 遗留系统演化策略"></a>2.1 遗留系统演化策略</h3><p>遗留系统（Legacy System）是指任何基本上不能进行修改和演化以满足新的变化了的业务需求的信息系统。</p><p>对遗留系统评价的目的是为了获得对遗留系统的更好的理解，这是遗留系统演化的基础，是任何遗留系统演化项目的起点。主要评价方法包括度量系统技术水准、商业价值和与之关联的企业特征，其结果作为选择处理策略的基础。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%BB%B4%E6%8A%A4/4.png"></p><ol><li><strong>改造策略，高水平、高价值区</strong>，即遗留系统的技术含量较高，本身还有极大的生命力。系统具有较高的业务价值，基本上能够满足企业业务运作和决策支持的需要。这种系统可能建成的时间还很短，称这种遗留系统的演化策略为改造。改造包括系统功能的增强和数据模型的改造两个方面。系统功能的增强是指在原有系统的基础上增加新的应用要求，对遗留系统本身不做改变；数据模型的改造是指将遗留系统的旧的数据模型向新的数据模型的转化。</li><li><strong>继承策略，低水平、高价值区</strong>，即遗留系统的技术含量较低，已经满足企业运作的功能或性能要求，但具有较高的商业价值，目前企业的业务尚紧密依赖该系统。称这种遗留系统的演化策略为继承。在开发新系统时，需要完全兼容遗留系统的功能模型和数据模型。为了保证业务的连续性，新老系统必须并行运行一段时间，再逐渐切换到新系统上运行。</li><li><strong>集成策略，高水平、低价值区</strong>，即遗留系统的技术含量较高，但其业务价值较低，可能只完成某个部门（或子公司）的业务管理。这种系统在各自的局部领域里工作良好，但对于整个企业来说，存在多个这样的系统，不同的系统基于不同的平台、不同的数据模型，形成了一个个信息孤岛，对这种遗留系统的演化策略为集成。</li><li><strong>淘汰策略，低水平、低价值区</strong>，即遗留系统的技术含量较低，且具有较低的业务价值。对这种遗留系统的演化策略为淘汰，即全面重新开发新的系统以代替遗留系统。完全淘汰是一种极端性策略，一般是企业的业务产生了根本变化，遗留系统已经基本上不再适应企业运作的需要；或者是遗留系统的维护人员、维护文档资料都丢失了。经过评价，发现将遗留系统完全淘汰，开发全新的系统比改造旧系统从成本上考虑更合算。</li></ol><h3 id="2-2-新旧系统的转换策略"><a href="#2-2-新旧系统的转换策略" class="headerlink" title="2.2 新旧系统的转换策略"></a>2.2 新旧系统的转换策略</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%BB%B4%E6%8A%A4/5.png"></p><p>在实施新旧系统转换时，转换的策略通常有三种：</p><ol><li><strong>直接转换策略</strong>，适用于新系统不太复杂或现有系统完全不能使用的场合，新系统在转换之前必须经过详细而严格的测试。</li><li><strong>并行转换策略</strong>，新系统和现有系统并行工作一段时间，经过这段时间的试运行后，再用新系统正式替换下现有系统。</li><li><strong>分段转换策略</strong>，分段转换策略也称为逐步转换策略，这种转换方式是直接转换方式和并行转换方式的结合，采取分期分批逐步转换。一般比较大的系统采用这种方式较为适宜，它能保证平稳运行，费用也不太高；或者现有系统比较稳定，能够适应自身业务发展需要，或新旧系统转换风险很大（例如，在线订票系统、银行的中间业务系统等），也可以采用分段转换策略。分段转换策略的优点是，新旧系统的转换震动比较小，用户容易接受。但由于是采用渐进方式，导致新旧系统的转换周期过长，同时由于需求的变化，给新系统的稳定造成比较大的影响。而且，分段转换策略对系统的设计和实现都有一定的要求，在转换过程中，需要开发新旧系统之间的接口，还需要制订阶段性的转换目标和计划。</li></ol><h3 id="2-3-数据转换和迁移"><a href="#2-3-数据转换和迁移" class="headerlink" title="2.3 数据转换和迁移"></a>2.3 数据转换和迁移</h3><p>数据迁移的主要方法大致有三种，分别是系统切换前通过工具迁移、系统切换前采用手工录入和系统切换后通过新系统生成。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%BB%B4%E6%8A%A4/6.png"></p><p>数据迁移的实施可以分为三个阶段，分别是数据迁移前的准备、数据转换与迁移和数据迁移后的校验。其中准备工作要做好以下7个方面的工作：</p><p>（1）待迁移数据源的详细说明，包括数据的存放方式、数据量和数据的时间跨度。<br>（2）建立新旧系统数据库的数据字典，对现有系统的历史数据进行质量分析，以及新旧系统数据结构的差异分析。<br>（3）新旧系统代码数据的差异分析。<br>（4）建立新旧系统数据库表的映射关系，对无法映射字段的处理方法。<br>（5）开发或购买、部署ETL工具。<br>（6）编写数据转换的测试计划和校验程序。<br>（7）制定数据转换的应急措施。</p><p>在数据迁移完成后，需要对迁移后的数据进行校验。数据迁移后的校验是对迁移质量的检查，同时数据校验的结果也是判断新系统能否正式启用的重要依据。可以通过以下两种方式对迁移后的数据进行校验：<br>（1）对迁移后的数据进行质量分析。<br>（2）新旧系统查询数据对比检查。</p><h3 id="2-4-影响软件可维护性的因素"><a href="#2-4-影响软件可维护性的因素" class="headerlink" title="2.4 影响软件可维护性的因素"></a>2.4 影响软件可维护性的因素</h3><p>【可理解性】是指通过阅读源代码和相关文档，了解软件的功能和如何运行的容易程度。<br>【可修改性】是指修改软件的难易程度。<br>【可测试性】是指验证软件程序正确的难易程度。<br>可测试性好的软件，通常意味着软件设计简单，复杂性低。因为软件的复杂性越大，测试的难度也就越大。<br>【可靠性】一个软件的可靠性越高，需要维护的概率就会越低。<br>【可移植性】是指将软件从一个环境移植到新的的环境下正确运行的难易程度。<br>软件运行环境的变化是软件维护的一种常见情形，可移植性好的软件会降低维护的概率</p><h3 id="2-5-软件维护类型"><a href="#2-5-软件维护类型" class="headerlink" title="2.5 软件维护类型"></a>2.5 软件维护类型</h3><p>软件的维护并不只是修正错误，为了满足用户提出的增加新功能，修改现有功能以及一般性的改进要求和建议，需要进行完善性维护，他是软件维护的重要组成部分。</p><p>改正性维护【修BUG】：也称正确性维护，指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误【修正bug、错误】。<br>适应性维护【应变】：指使应用软件适应环境变化【外部环境、数据环境】而进行的修改。<br>完善性维护【新需求】：扩充功能和改善性能而进行的修改。<br>预防性维护【针对未来】：为了适应未来的软硬件环境的变化，应主动增加预防性的新的功能，以使系统适应各类变化而不被淘汰。如将专用报表功能改成通用报表生成功能，以适应将来报表格式的变化。</p>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>基础技能</category>
      
      <category>软件工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java IO演进</title>
    <link href="/2023/07/07/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/Java%20IO%E6%BC%94%E8%BF%9B/"/>
    <url>/2023/07/07/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/Java%20IO%E6%BC%94%E8%BF%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><h3 id="1-1-阻塞-Block-和非阻塞-Non-Block"><a href="#1-1-阻塞-Block-和非阻塞-Non-Block" class="headerlink" title="1.1 阻塞(Block)和非阻塞(Non-Block)"></a>1.1 阻塞(Block)和非阻塞(Non-Block)</h3><p>阻塞和非阻塞是进程在访问数据的时候，数据是否准备就绪的一种处理方式，当数据没有准备的时候。</p><p>阻塞：往往需要等待缓冲区中的数据准备好过后才处理其他的事情，否则一直等待在那里。</p><p>非阻塞：当进程访问数据缓冲区的时候，如果数据没有准备好则直接返回，不会等待。如果数据已经准备好，也直接返回。</p><h3 id="1-2-同步-Synchronization-和异步-Asynchronous"><a href="#1-2-同步-Synchronization-和异步-Asynchronous" class="headerlink" title="1.2 同步(Synchronization)和异步(Asynchronous)"></a>1.2 同步(Synchronization)和异步(Asynchronous)</h3><p>同步和异步都是基于应用程序和操作系统处理IO事件所采用的方式。比如同步：是应用程序要直接参与IO读写的操作。异步，所有的IO读写叫给操作系统去处理，应用程序至需要等待通知。</p><p>同步方式在处理IO事件的时候，必须阻塞在某个方法上面等待IO事件完成（阻塞IO事件或者通过轮询IO事件的方式），对于异步来说，所有的IO读写都交给了操作系统。这个时候，可以去做其他的事情，并不需要去完成真正的IO操作，当操作完成IO后，会给应用程序一个通知。</p><p>同步：阻塞到IO事件，阻塞到read或者write。这个时候就完全不能做自己的事情。让读写方法加入到线程中，然后阻塞线程来实现，对线程的性能开销比较大。</p><h2 id="2-BIO与NIO对比"><a href="#2-BIO与NIO对比" class="headerlink" title="2 BIO与NIO对比"></a>2 BIO与NIO对比</h2><table><thead><tr><th>IO模型</th><th>BIO</th><th>NIO</th></tr></thead><tbody><tr><td>通信</td><td>面向流 —— 乡村公路</td><td>面向缓冲 —— 高速公路，多路复用技术</td></tr><tr><td>处理</td><td>阻塞IO —— 多线程</td><td>非阻塞IO —— 反应堆Reactor</td></tr><tr><td>触发</td><td>无</td><td>选择器 —— 轮询机制</td></tr></tbody></table><h3 id="2-1-面向流和面向缓冲"><a href="#2-1-面向流和面向缓冲" class="headerlink" title="2.1 面向流和面向缓冲"></a>2.1 面向流和面向缓冲</h3><p>Java NIO和BIO之间第一个最大的区别是，BIO是面向流的，NIO是面向缓冲区的。java BIO面向流意味着每次从流中读一个或者多个字节，直至读取所有字节，它们没有被缓冲在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓冲到一个缓冲区。Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区中尚未处理的数据。</p><h3 id="2-2-阻塞和非阻塞"><a href="#2-2-阻塞和非阻塞" class="headerlink" title="2.2 阻塞和非阻塞"></a>2.2 阻塞和非阻塞</h3><p>Java BIO的各种流是阻塞的。这意味着，当一个线程调用read() 或write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。Java NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。线程通常将非阻塞IO 的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p><h3 id="2-3-选择器"><a href="#2-3-选择器" class="headerlink" title="2.3 选择器"></a>2.3 选择器</h3><p>Java NIO 的选择器(Selector)允许一个单独的线程来监视多个输入通道，可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p><h3 id="2-4-NIO和BIO影响应用程序的设计"><a href="#2-4-NIO和BIO影响应用程序的设计" class="headerlink" title="2.4 NIO和BIO影响应用程序的设计"></a>2.4 NIO和BIO影响应用程序的设计</h3><p>无论选择BIO或NIO工具箱，可能会影响应用程序设计的以下几个方面：</p><p><strong>1.API调用</strong></p><p>使用NIO的API调用时看起来与使用BIO时有所不同，因为并不是仅从一个InputStream逐字节读取，而是数据必须先读入缓冲区再处理。</p><p><strong>2.数据处理</strong></p><p>在BIO 设计中，从InputStream 或Reader 逐字节读取数据。假设正在处理一基于行的文本数据流，例如：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Name:</span>Test<br><span class="hljs-symbol">Age:</span><span class="hljs-number">18</span><br><span class="hljs-symbol">Email:</span>test@qq.com<br><span class="hljs-symbol">Phone:</span><span class="hljs-number">138888888</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;d://info.txt&quot;</span>);<br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(input));<br><span class="hljs-type">String</span> <span class="hljs-variable">nameLine</span> <span class="hljs-operator">=</span> reader.readLine();<br><span class="hljs-type">String</span> <span class="hljs-variable">ageLine</span> <span class="hljs-operator">=</span> reader.readLine();<br><span class="hljs-type">String</span> <span class="hljs-variable">emailLine</span> <span class="hljs-operator">=</span> reader.readLine();<br><span class="hljs-type">String</span> <span class="hljs-variable">phoneLine</span> <span class="hljs-operator">=</span> reader.readLine();<br></code></pre></td></tr></table></figure><p>请注意处理状态由程序执行多久决定。换句话说，一旦reader.readLine()方法返回，就知道肯定文本行就已读完，readline()阻塞直到整行读完，这就是原因。也知道此行包含名称；同样，第二个readline()调用返回的时候，知道这行包含年龄等。正如可以看到，该处理程序仅在有新数据读入时运行，并知道每步的数据是什么。一旦正在运行的线程已处理过读入的某些数据，该线程不会再回退数据（大多如此)。(Java BIO: 从一个阻塞的流中读数据） 而一个NIO 的实现会有所不同，下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">48</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">bytesRead</span> <span class="hljs-operator">=</span> inChannel.read(buffer);<br></code></pre></td></tr></table></figure><p>注意第二行，从通道读取字节到ByteBuffer。当这个方法调用返回时，你不知道你所需的所有数据是否在缓冲区内。你所知道的是，该缓冲区包含一些字节，这使得处理有点困难。</p><p>假设第一次read(buffer)调用后，读入缓冲区的数据只有半行，例如，“Name:An”，你能处理数据吗？显然不能，需要等待，直到整行数据读入缓存，在此之前，对数据的任何处理毫无意义。</p><p>所以，怎么知道是否该缓冲区包含足够的数据可以处理呢？发现的方法只能查看缓冲区中的数据。其结果是，在知道所有数据都在缓冲区里之前，必须检查几次缓冲区的数据。这不仅效率低下，而且可以使程序设计方案杂乱不堪。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">48</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">bytesRead</span> <span class="hljs-operator">=</span> inChannel.read(buffer);<br><span class="hljs-keyword">while</span>(!bufferFull(byteRead))&#123;<br>    bytesRead = inChannel.read(buffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>bufferFull()方法必须跟踪有多少数据读入缓冲区，并返回真或假，这取决于缓冲区是否已满。换句话说，如果缓冲区准备好被处理，那么表示缓冲区满了。bufferFull()方法扫描缓冲区，但必须保持在bufferFull()方法被调用之前状态相同。如果没有，下一个读入缓冲区的数据可能无法读到正确的位置。这是不可能的，但却是需要注意的又一问题。如果缓冲区已满，它可以被处理。如果它不满，并且在实际案例中有意义，或许能处理其中的部分数据。但是许多情况下并非如此。</p><p><strong>3.设置处理线程数</strong></p><p>NIO 可只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，实现NIO 的服务器可能是一个优势。同样，如果需要维持许多打开的连接到其他计算机上，如P2P网络中，使用一个单独的线程来管理所有出站连接，可能是一个优势。Java NIO: 单线程管理多个连接。</p><p>如果有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的IO 服务器实现可能非常契合。Java BIO: 一个典型的IO 服务器设计- 一个连接通过一个线程处理。</p><h2 id="3-AIO"><a href="#3-AIO" class="headerlink" title="3 AIO"></a>3 AIO</h2><p>jdk1.7 (NIO2)才是实现真正的异步AIO、把IO 读写操作完全交给操作系统，学习了linux epoll 模式。</p><h3 id="3-1-AIO基本原理"><a href="#3-1-AIO基本原理" class="headerlink" title="3.1 AIO基本原理"></a>3.1 AIO基本原理</h3><p>服务端:AsynchronousServerSocketChannel</p><p>客服端:AsynchronousSocketChannel</p><p>用户处理器:CompletionHandler 接口,这个接口实现应用程序向操作系统发起IO 请求,当完成后处理具体逻辑，否则做自己该做的事情，“真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。</p><h3 id="3-2-AIO初体验"><a href="#3-2-AIO初体验" class="headerlink" title="3.2 AIO初体验"></a>3.2 AIO初体验</h3><p>服务端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AIOServer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> port;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">8000</span>;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AIOServer</span>(port);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AIOServer</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span>&#123;<br>        <span class="hljs-built_in">this</span>.port = port;<br>        listen();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listen</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>            <span class="hljs-type">AsynchronousChannelGroup</span> <span class="hljs-variable">threadGroup</span> <span class="hljs-operator">=</span> AsynchronousChannelGroup.withCachedThreadPool(executorService, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">AsyncronousServerSocketChannel</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> AsynchronousServerSocketChannel.open(threadGroup);<br>            server.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(port));<br>            System.out.println(<span class="hljs-string">&quot;服务已启动，监听端口：&quot;</span> + port);<br>            <br>            server.accept(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletionHandle</span>&lt;AsynchronousServerSocketChannel, Object&gt;()&#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">1024</span>);<br>                <span class="hljs-keyword">public</span> voidd <span class="hljs-title function_">completed</span><span class="hljs-params">(AsynchronousSocketChannel result, Obkect attchment)</span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;IO操作成功，开始获取数据&quot;</span>);<br>                    <span class="hljs-keyword">try</span>&#123;<br>                        buffer.clear();<br>                        result.read(buffer).get();<br>                        buffer.flip();<br>                        result.write(buffer);<br>                        buffer.flip();<br>                    &#125; <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>                        System.out.println(e.toString());<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            result.close();<br>                            server.accept(<span class="hljs-literal">null</span>, <span class="hljs-built_in">this</span>);<br>                        &#125; <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>                            System.out.println(e.toString());<br>                        &#125;<br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;操作完成&quot;</span>);<br>                &#125;<br>                <br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, Object Attachment)</span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;Io操作失败：&quot;</span> + exc);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(Integer.MAX_VALUE);<br>            &#125; <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>                System.out.println(e);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            System.out.println(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IOClient</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AsynchronousSocketChannel client;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AIOClient</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        client = AsynchronousSocketChannel.open();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(String host, <span class="hljs-type">int</span> port)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        client.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(host, port), <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletionHandler</span>&lt;Void, Void&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(Void result, Void attchment)</span>&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    client.write(ByteBuffer.wrap(<span class="hljs-string">&quot;这是一条测试数据&quot;</span>.getBytes())).get();<br>                    System.out.println(<span class="hljs-string">&quot;已发送至服务器&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, Void attchment)</span>&#123;<br>                exc.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        client.read(bb, <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletionHandler</span>&lt;Integer, Object&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complated</span><span class="hljs-params">(Integer result, Object attchment)</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;IO操作完成&quot;</span> + result);<br>                System.out.println(<span class="hljs-string">&quot;获取反馈结果：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bb.array()));<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, Void attchment)</span>&#123;<br>                exc.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(Integer.MAX_VALUE);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            System.out.println(e);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AIOClient</span>().connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-IO模型对比与总结"><a href="#4-IO模型对比与总结" class="headerlink" title="4 IO模型对比与总结"></a>4 IO模型对比与总结</h2><table><thead><tr><th>属性</th><th>BIO</th><th>伪异步IO</th><th>NIO</th><th>AIO</th></tr></thead><tbody><tr><td>客户端 : IO线程数</td><td>1 : 1</td><td>M : N (M&gt;=N)</td><td>M : 1</td><td>M : 0</td></tr><tr><td>阻塞类型</td><td>阻塞</td><td>阻塞</td><td>非阻塞</td><td>非阻塞</td></tr><tr><td>同步</td><td>同步</td><td>同步</td><td>同步（多路复用）</td><td>异步</td></tr><tr><td>API使用难度</td><td>简单</td><td>简单</td><td>复杂</td><td>一般</td></tr><tr><td>调试难度</td><td>简单</td><td>简单</td><td>复杂</td><td>一般</td></tr><tr><td>可靠性</td><td>非常差</td><td>差</td><td>高</td><td>高</td></tr><tr><td>吞吐量</td><td>低</td><td>中</td><td>高</td><td>高</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>网络通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库设计</title>
    <link href="/2023/07/03/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/07/03/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="1-数据库概念"><a href="#1-数据库概念" class="headerlink" title="1 数据库概念"></a>1 数据库概念</h2><h3 id="1-1-数据模型"><a href="#1-1-数据模型" class="headerlink" title="1.1 数据模型"></a>1.1 数据模型</h3><p>数据模型分为：层次模型、网状模型、面向对象模型、关系模型。数据模型三要素：数据结构、数据操作、数据的约束条件。</p><p>数据的约束条件包括：<br>（1）实体完整性：<br>（2）参照完整性：<br>（3）用户定义完整性：</p><h3 id="1-2-数据库视图"><a href="#1-2-数据库视图" class="headerlink" title="1.2 数据库视图"></a>1.2 数据库视图</h3><p>视图（View）并不在数据库中实际存在，而是一种虚拟表。</p><h2 id="2-数据库模式"><a href="#2-数据库模式" class="headerlink" title="2 数据库模式"></a>2 数据库模式</h2><p>数据库一般采用三级模式，系统开发人员需要通过视图层、逻辑层和物理层三个层次上抽象来降低用户屏蔽系统的复杂性，简化用户与系统的交互。从数据库管理系统的角度，数据库也分为为外模式、概念模式和内模式。</p><p>数据库系统在三级模式之间提供了两级映像：概念模式/内模式映像、外模式/概念模式映像。这两级映像保证了数据库中的数据具有较高的逻辑独立性和物理独立性。</p><p><strong>数据库三级模式</strong></p><table><thead><tr><th>外模式</th><th>概念模式</th><th>内模式</th></tr></thead><tbody><tr><td>又叫子模式或用户模式，用以描述用户看到或使用的那部分数据的逻辑结构，用户根据外模式用数据操作语句或应用程序去操作数据库中的数据</td><td>是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图</td><td>是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式，定义所有的内部记录类型、索引和文件的组织方式等</td></tr></tbody></table><p><strong>数据库两级映像</strong></p><table><thead><tr><th>逻辑独立性</th><th>物理独立性</th></tr></thead><tbody><tr><td>对应外模式和概念模式之间的映像。指应用程序与数据库中的逻辑结构独立，当数据的逻辑结构改变时，应用程序不变</td><td>对应概念模式和内模式之间的映像。指应用程序与磁盘中的数据互相独立。当数据的物理存储改变时，应用程序不变</td></tr></tbody></table><h2 id="3-关系数据库"><a href="#3-关系数据库" class="headerlink" title="3 关系数据库"></a>3 关系数据库</h2><h3 id="3-1-关系模型"><a href="#3-1-关系模型" class="headerlink" title="3.1 关系模型"></a>3.1 关系模型</h3><p>数据模型三要素：数据结构、数据操作、数据的约束条件。</p><p>基本概念：<br>目或度：关系模式中属性的个数。<br>候选码（候选键）：关系中的某一属性或属性组的值，且唯一地标识一个元组。<br>主码（主键）：若一个关系中有多个候选码，则选定其中一个作为主码。<br>主属性与非主属性：组成候选码的属性就是主属性，其它的就是非主属性。<br>外码（外键）：其他关系的码，就是外键。<br>全码：关系模式的所有属性组是这个关系的候选码。</p><p>完整性约束：</p><ul><li>实体完整性约束：规定基本关系的主属性不能取空值。</li><li>参照完整性约束：关系与关系间的引用，其他关系的主键或空值。</li><li>用户自定义完整性约束：应用环境决定。</li></ul><h3 id="3-2-关系运算"><a href="#3-2-关系运算" class="headerlink" title="3.2 关系运算"></a>3.2 关系运算</h3><p><strong>并（∪）</strong>: 关系R与S的并是由属于或属于S的元组构成的集合。</p><p><strong>交（∩）</strong>: 关系R与S的交是由属于R同时又属于S的元组的集合。</p><p><strong>差（—）</strong>: 关系R与S的差是由属于R但不属于S的元组的集合。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/1.png"></p><p><strong>笛卡尔积（X）</strong>: 两个关系分别为n列和m列的关系R和S的笛卡尔积是一个（n + m）列的元组的集合。其中的前n列是关系R的一个元组，后m列是关系S的一个元组，记作R X S，如果R和S有相同的属性名，可在属性名前加关系名作为限定，以示区别。若R有K1个元组，S有K2个元组，则R和S的笛卡尔积有K1 X K2个元组。</p><p><strong>选择（σ）</strong>：取得关系R中符合条件的行。</p><p><strong>投影（π）</strong>：取得关系R中符合条件的列。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/2.png"></p><p><strong>连接（Φ）</strong>:<br>等值连接：选取关系R、S，取两者笛卡尔积中属性值相等的元组。<br>自然连接：一种特殊的等值连接，它要求比较属性列必须相同的属性组，并且把结果中重复属性去掉。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/3.png"></p><h3 id="3-3-关系数据设计的基本理论"><a href="#3-3-关系数据设计的基本理论" class="headerlink" title="3.3 关系数据设计的基本理论"></a>3.3 关系数据设计的基本理论</h3><p>关系数据库设计的目标是生成一组合适的、性能良好的关系模式，以减少系统中信息存储的冗余度，但又可以方便地获取信息。</p><h4 id="3-3-1-函数依赖"><a href="#3-3-1-函数依赖" class="headerlink" title="3.3.1 函数依赖"></a>3.3.1 函数依赖</h4><p>设R（U，F）是属性U上的一个关系模式，X和Y是U的子集，r为R的任意关系，如果对于r中的任意两个元组u，v，只要有u[Y] = v[Y]，则称X函数决定于Y，或称Y函数依赖于X，记X → Y，称为函数依赖。<br>例如：<strong>学号→ 系号， 系号 → 系名</strong></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/4.png"></p><h4 id="3-3-2-键-候选键"><a href="#3-3-2-键-候选键" class="headerlink" title="3.3.2 键/候选键"></a>3.3.2 键/候选键</h4><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/5.png"></p><p>主属性与非主属性：组成候选码的属性就是主属性，其它就是非主属性。<br>求候选键实例</p><ol><li>将关系模式的函数依赖关系用”有向图“的方式表示。</li><li>找入度为0的属性，并以该属性集合为起点，尝试遍历有向图，若能正常遍历图中所有结点，则该属性集即为关系模式的候选键。</li><li>若入度为0的属性集不能遍历图中所有节点，则需要尝试性的将一些中间节点（既有入度，也有出度的结点）并入入度为0的属性集合中，直至该集合能遍历所有结点，集合为候选键。</li></ol><h4 id="3-3-3-函数依赖的公理（Armstrong公理）"><a href="#3-3-3-函数依赖的公理（Armstrong公理）" class="headerlink" title="3.3.3 函数依赖的公理（Armstrong公理）"></a>3.3.3 函数依赖的公理（Armstrong公理）</h4><p>从已知的函数依赖，可以推导出另外一些函数依赖，这就需要一系列的推理规则，这些规则常被称为”Armstrong 公理“。</p><p>设定关系式R（U， F），U是关系模式R的属性集，F是U的一组函数依赖，则有以下三条推理规则：<br>（1） 自反律：若Y ⊆ X ⊆ U， 则X → Y为F所蕴含。<br>（2） 增广律：若Z ⊆ U且X → Y为F所蕴含，则XZ → YZ为F所蕴含。<br>（3） 传递律：X → Y，Y → Z为F所蕴含，则X → Z为F所蕴含。</p><p>根据上面的推理规则，又可以推出下面三条规则：<br>（1） 合并规则：若X → Y，X → Z，则X → YZ为F所蕴含。<br>（2） 伪传递规则：若X → Y，WY → Z，则XW → Z为F所蕴含。<br>（3） 分解规则：若X → Y，Z ⊆ Y，则X → Z为F所蕴含。</p><h4 id="3-3-4-规范化理论"><a href="#3-3-4-规范化理论" class="headerlink" title="3.3.4 规范化理论"></a>3.3.4 规范化理论</h4><p>关系数据库设计的方法之一就是满足适当范式模式，通常可以通过判断分解后的模式达到几范式来评价模式的规范化程度。范式包括：1NF、2NF、3NF、BCNF、4NF、5NF。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/6.png"></p><p>（1）<strong>第一范式（1NF）</strong>：<strong>在关系模式R中，当且仅当所有域只包含原子值，既每个属性都是不可再分的数据项，则关系模式R属于第一范式。例如：以下不满足1NF，高级职称人数可以再分教授和副教授</strong>。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/7.png"></p><p>（2）<strong>第二范式（2NF）</strong>：<strong>若关系模式R ∈ 1NF，且每个非主属性完全依赖主码时（不存在部分依赖），则关系模式R属于第二范式</strong>。</p><p><strong>例如：以下不满足2NF，课程号可以包含学分</strong>。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/8.png"></p><p>（3）<strong>第三范式（3NF）</strong>：<strong>若关系模式R ∈ 2NF，且没有非主属性对主码的传递函数依赖。则关系模式R属于第三范式</strong>。</p><p><strong>例如：以下不满足3NF，系名和系位置依赖系号</strong>。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/9.png"></p><p>（4）<strong>BC范式（BCNF）</strong>：<strong>设R是一个关系模式，F是它的依赖集，R属于BCNF当且仅当其F中每个依赖的决定因素必定包含R的某个候选码</strong>。</p><h2 id="4-数据库设计"><a href="#4-数据库设计" class="headerlink" title="4 数据库设计"></a>4 数据库设计</h2><p>数据库设计的基本步骤，可以分为用户需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库实施阶段（应用程序设计)、运行维护。数据库设计过程：</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/10.png"></p><h3 id="4-1-概念结构设计"><a href="#4-1-概念结构设计" class="headerlink" title="4.1 概念结构设计"></a>4.1 概念结构设计</h3><h4 id="4-1-1-E-R模型"><a href="#4-1-1-E-R模型" class="headerlink" title="4.1.1 E-R模型"></a>4.1.1 E-R模型</h4><p>ER模型简称E-R图 ，是描述概念世界、建立概念模型的实用工具。E-R图的三个要素：<br>（1）实体：用矩形表示，框内标注实体名称。<br>（2）属性：用椭圆图形表示，并用连线与实体连接起来。<br>（3）实体之间的联系：用菱形框表示，框内标注联系名称，用连线将菱形框分别与有关实体相连，并在连线上注明联系类型。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/11.png"></p><h4 id="4-1-2-概念结构设计的过程"><a href="#4-1-2-概念结构设计的过程" class="headerlink" title="4.1.2 概念结构设计的过程"></a>4.1.2 概念结构设计的过程</h4><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/12.png"></p><p>集成的方法：<br>多个局部ER图一次集成<br>逐步集成，用累加的方式一次集成两个局部ER。</p><p>集成产生的冲突及解决办法：<br>属性冲突：包括属性域冲突和属性取值冲突<br>命名冲突：包括同名异议和异名同义<br>结构冲突：包括统一对象在不同应用中具有不同的抽象，以及同一实体在不同局部ER图中所包含的属性个数和属性排列次序不完全相同。</p><h3 id="4-2-逻辑结构设计"><a href="#4-2-逻辑结构设计" class="headerlink" title="4.2 逻辑结构设计"></a>4.2 逻辑结构设计</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/13.png"></p><h2 id="5-NoSQL数据库"><a href="#5-NoSQL数据库" class="headerlink" title="5 NoSQL数据库"></a>5 NoSQL数据库</h2><table><thead><tr><th></th><th>关系数据库模式</th><th>NoSQL模式</th></tr></thead><tbody><tr><td>并发支持</td><td>支持并发、效率低</td><td>并发性能高</td></tr><tr><td>存储与查询</td><td>关系表方式存储、SQL查询</td><td>海量数据存储、查询效率高</td></tr><tr><td>扩展方式</td><td>向上扩展</td><td>向外扩展</td></tr><tr><td>索引方式</td><td>B树、哈希等</td><td>键值索引</td></tr><tr><td>应用领域</td><td>面向通用领域</td><td>特定应用领域</td></tr></tbody></table><table><thead><tr><th>分类</th><th>典型应用场景</th><th>数据模型</th><th>缺点</th><th>优点</th><th>举例</th></tr></thead><tbody><tr><td>键值(K-V)</td><td>内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等</td><td>key指向value的键值对，通常用hash table来实现</td><td>数据五结构化，通常只被当作字符串或者二进制数据</td><td>查找速度快</td><td>Redis</td></tr><tr><td>列式存储数据库</td><td>分布式的文件系统</td><td>以列簇式存储，将同一列数据存在一起</td><td>功能相对局限</td><td>查找速度快，可扩展性强，更容易进行分布式扩展</td><td>HBase</td></tr><tr><td>文档型数据库</td><td>web应用，与k-v类似，value是结构化的，不同的是数据库能够了解value的内容</td><td>k-v对应的键值对，value为结构化数据</td><td>查询性能不高，而且缺乏统一的查询语法</td><td>数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td><td>MongoDB</td></tr><tr><td>图形数据库(Graph)</td><td>社交网络，推荐系统等，专注于构建关系图谱</td><td>图结构</td><td>很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案</td><td>利用图结构相关算法，比如最短路径寻址，N度关系查找等</td><td>Graph</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>基础技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统功能与系统性能</title>
    <link href="/2023/07/03/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E4%B8%8E%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD/"/>
    <url>/2023/07/03/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E4%B8%8E%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="1-系统工程"><a href="#1-系统工程" class="headerlink" title="1 系统工程"></a>1 系统工程</h2><h3 id="1-1-系统工程概念"><a href="#1-1-系统工程概念" class="headerlink" title="1.1 系统工程概念"></a>1.1 系统工程概念</h3><p>【系统工程】 是一种组织管理技术。<br>【系统工程】 是为了最好的实现系统的目的，对系统的组成要素、组织结构、信息流、控制机构进行分析研究的科学方法。<br>【系统工程】 从整体出发、从系统观念出发、以求 整体最优。<br>【系统工程】 利用计算机作为工具，对系统的结构、元素、信息和反馈等进行分析，以达到最优规划、最优设计、最优管理和最优控制的目的。<br>【系统工程】 是一种现代的科学决策方法。</p><h3 id="1-2-系统工程方法"><a href="#1-2-系统工程方法" class="headerlink" title="1.2 系统工程方法"></a>1.2 系统工程方法</h3><p><strong>系统工程是运用系统方法，对系统进行规划、研究、设计、制造、试验和使用的组织管理技术，是人们用科学法解决复杂问题的一门技术</strong>。<strong>系统工程方法的特点</strong>：<strong>整体性、综合性、协调性、科学性和实践性</strong>。<strong>系统工程方法分为</strong>：<strong>霍尔的三维结构、切克兰德法、并行工程、综合集成法、WSR系统方法</strong>。</p><table><thead><tr><th>系统工程方法</th><th>关键点</th></tr></thead><tbody><tr><td>霍尔三维结构–硬科学方法论</td><td>逻辑维：解决问题的逻辑过程 <br/>时间维：工作进程 <br/>知识维：专业科学知识<br/>应用场景：组织和管理大型工程建设项目</td></tr><tr><td>切克兰德方法–软科学方法论</td><td>核心不是最优化，而是比较和探寻。7步骤：认识问题、根底定义、建立概念模型、比较及探寻、选择、设计与实施、评估与反馈</td></tr><tr><td>并行工程方法</td><td>制造过程与支持过程并行，强调三个方面：产品设计开发期间，最快速度按质完成；各项工作问题协调解决；适当的信息系统工具</td></tr><tr><td>综合集成法</td><td>钱学森命名，简单系统和巨系统。四原则：整体论原则、相互联系原则、有序性原则、动态原则</td></tr><tr><td>WSR系统方法</td><td>实践准则：懂物理，明事理，通人理</td></tr></tbody></table><h4 id="1-2-1-霍尔三维结构"><a href="#1-2-1-霍尔三维结构" class="headerlink" title="1.2.1 霍尔三维结构"></a>1.2.1 霍尔三维结构</h4><p><strong>时间维：分为规划、拟定方案、研制、生产、安装、运行、更新7个时间阶段</strong>；<br><strong>逻辑维：包括明确问题、确定目标、系统综合、系统分析、优化、决策、实施7个逻辑步骤</strong>；<br><strong>知识维：包括工程、医学、建筑、商业、法律、管理、社会科学、艺术等知识和技能</strong>。</p><h4 id="1-2-2-切克兰德方法"><a href="#1-2-2-切克兰德方法" class="headerlink" title="1.2.2 切克兰德方法"></a>1.2.2 切克兰德方法</h4><p><strong>切克兰德方法</strong> 的核心 <strong>不是“最优化”而是“比较”与“探寻”</strong> 。将工作过程分为 <strong>认识问题、根底定义、建立概念模型、比较及探寻、选择、设计与实施、评估与反馈7个步骤</strong> 。</p><h4 id="1-2-3-并行工程"><a href="#1-2-3-并行工程" class="headerlink" title="1.2.3 并行工程"></a>1.2.3 并行工程</h4><p><strong>并行工程方法</strong> 是对产品及其相关 <strong>过程（包括制造过程和支持过程）进行并行</strong> 、集成化处理的系统方法和综合技术，目标是提高质量、减低成本、缩短产品开发周期和产品上市时间。</p><h4 id="1-2-4-综合集成法"><a href="#1-2-4-综合集成法" class="headerlink" title="1.2.4 综合集成法"></a>1.2.4 综合集成法</h4><p>钱学森等提出从系统的本质出发可以把系统分为 <strong>简单系统和巨系统</strong> 两大类。开放复杂巨系统的一般<strong>基本原则</strong>： <strong>整体论、相互联系、有序性、动态</strong> ，主要性质是开放性、复杂性、进化与涌现性、层次性和巨量性。</p><h4 id="1-2-5-WSR系统方法"><a href="#1-2-5-WSR系统方法" class="headerlink" title="1.2.5 WSR系统方法"></a>1.2.5 WSR系统方法</h4><p><strong>WSR系统方法</strong> 是 <strong>物理 - 事理 - 人理</strong> 方法论的简称。具有中国传统哲学的思辨思想，是多种方法的综合统一，属于定性与定量分析综合集成的东方系统思想。一般工作过程可理解为理解意图、制定目标、调查分析、构造策略、选择方案、协调关系和实现构想7步。</p><h3 id="1-3-系统工程生命周期"><a href="#1-3-系统工程生命周期" class="headerlink" title="1.3 系统工程生命周期"></a>1.3 系统工程生命周期</h3><p><strong>对系统工程生命周期进行定义的目的是以有序而且高效的方式建立一个满足利益有关者的需求框架。</strong></p><p><strong>系统工程的生命周期阶段</strong> 包括<strong>探索研究、概念阶段、开发阶段、生产阶段、使用阶段、保障阶段和退役阶段。</strong></p><p><strong>生命周期方法</strong> 有：<strong>计划驱动方法、渐进迭代式开发、精益开发和敏捷开发。</strong></p><h3 id="1-4-基于模型的系统工程"><a href="#1-4-基于模型的系统工程" class="headerlink" title="1.4 基于模型的系统工程"></a>1.4 基于模型的系统工程</h3><p>基于模型的系统工程（Model-Based Systems Engineering, MBSE） ，MBSE是建模方法的形式化应用，以使建模支持系统需求、分析、设计、验证和确认等活动，持续贯穿到所有生命周期阶段。</p><p>产物包括 ：<br>在需求分析阶段，产生需求图、用例图以及包图；<br>在功能分析与分配阶段，产生顺序图、活动图及状态机图；<br>在设计综合阶段，产生模块定义图、内部块图及参数图等；</p><p>系统工程的三大支柱 ：建模语言、建模工具和建模思路。</p><h2 id="2-系统性能"><a href="#2-系统性能" class="headerlink" title="2 系统性能"></a>2 系统性能</h2><h3 id="2-1-系统性能指标（评价）"><a href="#2-1-系统性能指标（评价）" class="headerlink" title="2.1 系统性能指标（评价）"></a>2.1 系统性能指标（评价）</h3><p>系统性能评价指标是软件、硬件的性能指标的集成。其中：</p><ol><li><p>评价计算机主要性能指标有 时钟频率（主频）、运算速度、运算精度、数据处理速率（Processing Data Rate，PDR）、吞吐率 等。</p></li><li><p>评价路由器的主要性能指标有设备吞吐量、端口吞吐量、全双工线速准发能力、路由表能力、背板能力、 丢包率、时延、时延抖动、协议支持 等。评价交换机所依据的性能指标有端口速率、背板吞吐量、缓冲区大小、MAC地址表大小等。</p></li><li><p>评价网络性能指标有 设备性能指标、网络级性能指标、应用级性能指标、用户级性能指标和吞吐量 。</p></li><li><p>评价操作系统的性能指标有 系统上下文切换、系统响应时间、系统的吞吐率（量）、系统资源利用率、可靠性和可移植性 。</p></li><li><p>衡量数据库管理系统主要的性能指标有 最大并发事务处理能力、负载均衡能力、最大连接数 等。</p></li><li><p>评价Web服务器的主要性能指标有 最大并发连接数、响应延迟和吞吐量 。</p></li></ol><h3 id="2-2-性能计算"><a href="#2-2-性能计算" class="headerlink" title="2.2 性能计算"></a>2.2 性能计算</h3><p>主频又称为CPU时钟频率，时钟周期是时钟频率的倒数。<br>如主频为1GHz，则说明1秒钟有1G个时钟周期，每个时钟周期为1ns。<br>主频 = 外频 * 倍频<br>总线周期：</p><p>也就是一个访存储器或IO端口操作所用的时间<br>指令周期：</p><p>取出并执行一条指令的时间，若干个机器周期组成<br>平均执行周期数：</p><p>CPI表示每条计算机指令执行所需的时钟周期，有时简称为指令的平均周期数<br>CPI平均执行周期数 = 执行程序所需要的时钟周期数 / 所执行的指令条数<br>MIPS指令平均运算执行速度：</p><p>每秒处理的百万级的机器语言指令数，主要用于衡量标量机性能<br>MFLOPS：</p><p>每秒百万个浮点操作，不能反映整体情况，只能反映浮点运算情况<br>主要用于衡量向量机性能<br>指令平均时钟数 ＝（指令条目数 × 指令时钟数）/ 总指令条目数<br>指令平均运算（执行）速度 ＝ 1/指令平均时钟数 × 时钟频率，注，单位MIPS</p><h3 id="2-3-性能设计"><a href="#2-3-性能设计" class="headerlink" title="2.3 性能设计"></a>2.3 性能设计</h3><h4 id="2-3-1-性能调整"><a href="#2-3-1-性能调整" class="headerlink" title="2.3.1 性能调整"></a>2.3.1 性能调整</h4><p>性能调整查找和消除瓶颈组成。</p><p>对于数据库系统：<br>性能调整主要包括CPU/内存使用状况、优化数据库设计、优化数据库管理以及进程/线程状态、硬盘I/O及剩余空间、日志文件大小等。</p><p>对于应用系统：<br>性能调整主要包括应用系统的可用性、响应时间、并发用户数以及特定应用的系统资源占用等。</p><h4 id="2-3-2-阿姆达尔解决方案"><a href="#2-3-2-阿姆达尔解决方案" class="headerlink" title="2.3.2 阿姆达尔解决方案"></a>2.3.2 阿姆达尔解决方案</h4><p>阿姆达尔定律：计算机系统中对某一部件采用某种更快的执行方式所获得的系统性能改变程度，取决于这种方式所占总执行时间的比例。</p><p>加速比 = 使用增强部件时完成整个任务的时间 / 不使用增强部件时完成整个任务的时间</p><p>新的执行时间 = 原来的执行时间 X [ (1 - 增强比例) + 增强比例 / 增强加速比 ]</p><p>总加速比 = 原来的执行时间 / 新的执行时间 = 1 / [ (1 - 增强比例) + 增强比例 / 增强加速比 ]</p><h3 id="2-4-性能评估"><a href="#2-4-性能评估" class="headerlink" title="2.4 性能评估"></a>2.4 性能评估</h3><p>（1）基准测试程序</p><p>大多数情况下，为测试新系统的性能，用户必须依靠评价程序来评价机器的性能。</p><p>基准测试程序（Benchmark）的定义:应用程序中用的最多、最频繁的那部分核心程序 作为评价计算机性能的标准程序。</p><p>下面列出4种评价程序，它们的评测的准确度依次递减：真实的程序、核心程序、小型基准程序和合成基准程序。</p><p>基准测试程序有：整数测试程序Dhrystone、浮点测试程序Linpack、Whetsone基准测试程序、SPEC基准测试程序和TPC基准程序。</p><p>（2）Web服务器的性能评估</p><p>Web服务器的性能评测方法有:<br>基准性能测试、压力测试和可靠性测试。</p><p>（3）系统监视</p><p>系统监视的方法通常有 ：<br>系统内置命令、查阅系统日志、可视化技术3种方式。</p>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>基础技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息系统基础</title>
    <link href="/2023/07/03/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/07/03/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="1-信息系统概述"><a href="#1-信息系统概述" class="headerlink" title="1 信息系统概述"></a>1 信息系统概述</h2><h3 id="1-1-信息系统的定义"><a href="#1-1-信息系统的定义" class="headerlink" title="1.1 信息系统的定义"></a>1.1 信息系统的定义</h3><p><strong>信息系统是由计算机软硬件、网络和通信设备、信息资源、用户和规章制度组成的以处理信息流为目的的人机一体化系统</strong>。<br>信息系统的<strong>功能</strong>有： <strong>输入、存储、处理、输出和控制</strong> 。<br>信息系统 <strong>发展道路划分</strong>为： <strong>初始、传播、控制、集成、数据管理和成熟</strong> 6个阶段。</p><h3 id="1-2-信息系统的分类"><a href="#1-2-信息系统的分类" class="headerlink" title="1.2 信息系统的分类"></a>1.2 信息系统的分类</h3><p>信息系统分为<strong>业务（数据）处理系统、管理信息系统、决策支持系统、专家系统、办公自动化系统、综合信息系统</strong>等6类。</p><h3 id="1-3-信息系统生命周期"><a href="#1-3-信息系统生命周期" class="headerlink" title="1.3 信息系统生命周期"></a>1.3 信息系统生命周期</h3><p><strong>信息系统的生命周期</strong>分为 <strong>产生、开发、运行和消亡</strong> 4个阶段。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/1.png"></p><h3 id="1-4-信息系统建设原则"><a href="#1-4-信息系统建设原则" class="headerlink" title="1.4 信息系统建设原则"></a>1.4 信息系统建设原则</h3><p>信息系统建设原则可以分为 高层管理人员介入原则、用户参与开发原则、自顶向下规划原则、工程化原则 等。</p><ol><li>高层管理人员介入原则 ：如CIO介入</li><li>用户参与开发原则 ：用户确定范围、核心用户全程参与、用户深度参与</li><li>自顶向下规划原则 ：以此减少信息不一致的现象</li><li>工程化原则 ：引入【软件工程】</li><li>其它原则 ：创新性原则、整体性原则、发展性原则、经济性原则</li></ol><h3 id="1-5-信息系统的开发方法"><a href="#1-5-信息系统的开发方法" class="headerlink" title="1.5 信息系统的开发方法"></a>1.5 信息系统的开发方法</h3><p><strong>信息系统开发方法</strong>主要有： <strong>结构化方法、原型法、面向对象法、面向服务法、敏捷法、构件化开发法</strong> 。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/2.png"></p><p><strong>其他信息系统开发方法 :</strong></p><ul><li><strong>形式化方法，建立在严格的数学模型化基础上，如净室软件工程</strong></li><li><strong>统一过程方法【UP/RUP】</strong></li><li><strong>敏捷方法</strong></li><li><strong>基于架构的开发方法【ABSD】</strong></li></ul><h2 id="2-信息化的典型应用"><a href="#2-信息化的典型应用" class="headerlink" title="2 信息化的典型应用"></a>2 信息化的典型应用</h2><p>从低级到高级、从局部到全局、从简单到复杂的过程。</p><table><thead><tr><th>信息系统的分类</th><th>关键点</th></tr></thead><tbody><tr><td>业务员处理系统【TPS】</td><td>早期最初级的信息系统，功能：数据输入，数据处理【批处理、OLTP】，数据库维护，文件报表产生</td></tr><tr><td>管理信息系统【MIS】</td><td>高度集成化的人机信息系统，金字塔结构：分多个层级</td></tr><tr><td>决策支持系统【DSS】</td><td>由语言系统、知识系统和问题处理系统组成。用于辅助决策、支持决策</td></tr><tr><td>专家系统【ES】</td><td>知识+推理=专家系统。人工智能的一个重要分支</td></tr><tr><td>办公自动化系统【OAS】</td><td>由计算机设备、办公设备、数据通信及网络设备、软件系统组成</td></tr><tr><td>企业资源计划【ERP】</td><td>打通供应链，集成，整合</td></tr></tbody></table><h3 id="2-1-业务处理系统（TPS）"><a href="#2-1-业务处理系统（TPS）" class="headerlink" title="2.1 业务处理系统（TPS）"></a>2.1 业务处理系统（TPS）</h3><p>业务处理系统（Transaction Processing System，TPS）又可称为电子数据处理系统（Electronic Data Processing System，EDP） ，是计算机在管理方面早期应用的最初级形式的信息系统。TPS是服务于组织管理层次中最低层、最基础的信息系统。TPS是服务于组织管理层次中最低层、最基础的信息系统。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/3.png"></p><h3 id="2-2-电子数据处理系统（EDPS）"><a href="#2-2-电子数据处理系统（EDPS）" class="headerlink" title="2.2 电子数据处理系统（EDPS）"></a>2.2 电子数据处理系统（EDPS）</h3><p>管理信息系统（Manage Information System，MIS） 是由业务处理系统发展而成的，是 在TPS基础上引进大量管理方法对企业整体信息进行处理 ，并利用信息进行预测、控制、计划、辅助企业全面管理的信息系统。MIS系统四大部件：信息源、信息处理器、信息用户和信息管理者 。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/4.png"></p><p><strong>闭环结构在决定过程中，不断收集信息，不断发送给决策者。</strong></p><ul><li><strong>批处理系统属于【开环系统】</strong></li><li><strong>计算机实时处理系统属于【闭环系统】</strong></li></ul><h3 id="2-3-管理信息系统（MIS）"><a href="#2-3-管理信息系统（MIS）" class="headerlink" title="2.3 管理信息系统（MIS）"></a>2.3 管理信息系统（MIS）</h3><p>（1）销售市场子系统。它包括销售和推销，在运行控制方面包括雇用和训练销售人员、销售和推销的日常调度，还包括按区域、产品、顾客销售数量的定期分析等。<br>（2）生产子系统。它包括产品设计、生产设备计划、生产设备的调度和运行、生产人员的雇用和训练、质量控制和检查等。<br>（3）后勤子系统。它包括采购、收货、库存控制和分发。<br>（4）人事子系统。它包括雇用、培训、考核记录、工资和解雇等。<br>（5）财务和会计子系统。财务的目标是保证企业的财务要求，并使其花费尽可能的低;会计则是把财务业务分类、总结，填入标准财务报告，准备预算、成本数据的分析与分类等。<br>（6）信息处理子系统。该系统的作用是保证企业的信息需要。典型的任务是处理请求收集数据、改变数据和程序的请求、报告硬件和软件的故障及规划建议等。<br>（7）高层管理子系统。为高层领导服务。业务包括查询信息和支持决策，编写文件和信件，向公司其他部门发送指令。</p><h3 id="2-4-决策支持系统（DSS）"><a href="#2-4-决策支持系统（DSS）" class="headerlink" title="2.4 决策支持系统（DSS）"></a>2.4 决策支持系统（DSS）</h3><p>决策支持系统（Decision Support System，DSS） 是一个由语言系统、知识系统和问题处理系统3个互相关联的部分组成的，基于计算机的系统。</p><p>DSS的两种基本结构形式是两库结构和基于知识的结构 ，实际中的DSS由这两种基本结构通过分解或增加某些部件演变而来。两库结构由数据库子系统、模型库子系统和对话子系统形成三角形分布的结构。</p><p>【DSS应具有的特征】 ：</p><p>（1）数据和模型是DSS的主要资源。<br>（2）DSS用来支援用户作决策而不是代替用户作决策。<br>（3）DSS主要用于 解决半结构化及非结构化问题 。<br>（3）DSS的作用在于提高决策的有效性而不是提高决策的效率。</p><p>决策支持系统的组成</p><p>1、数据的重组和确认。与决策支持系统相关的数据库的问题是，获得正确的数据井且可用理想的形式操作这些数据。这个问题可以通过数据仓库的概念解决。</p><p>2、数据字典的建立。数据仓库是一个与作业层系统分离存在的数据库。通过对数据仓库的存取，管理者可以做出以事实为根据的决策来解决许多业务问题。</p><p>3、数据挖掘和智能体。一旦建成数据仓库，管理者们需要运用工具进行数据存取和查询，使用的工具称为智能体。数据挖掘的结果类型包括</p><blockquote><ol><li>联合：把各个事件联系在一起的过程。例如：将学生们经常同时选修的两门课程联系起来，以便这两门课程不被安排在同一时间</li><li>定序：识别模式的过程。例如：识别学生们多个学期课程的次序</li><li>分类：根据模式组织数据的过程。例如：以学生完成学业的时间(4年以内，4年以上)为标准分成几个小组</li><li>聚类：推到特定小组与其他小组相区分的判断规则的过程。例如，通过兴趣、年龄、工作经验来划分学生</li></ol></blockquote><p>4、模型建立。模型管理的目的就是帮助决策者理解与选择有关的现象。建立模型的方法有穷枚举法、算法、启发式和模拟法。</p><p><strong>DSS基本结构主要由4个部分组成：数据库子系统、模型库子系统、推理部分和用户接口子系统</strong> 。</p><h3 id="2-5-专家系统（ES）"><a href="#2-5-专家系统（ES）" class="headerlink" title="2.5 专家系统（ES）"></a>2.5 专家系统（ES）</h3><p><strong>专家系统（Expert System，ES）</strong> 是一个智能计算机程序系统（人工智能的一个重要分支）， <strong>其内部含有某个领域具有专家水平的大量知识与经验</strong> ，能够利用人类专家的知识和解决问题的方法来处理该领域的问题。</p><p>专家系统不同于传统的应用程序和其他类型的人工智能问题求解程序。主要表现在以下5个方面 ：</p><p>（1）专家系统属于人工智能范畴，其求解的问题是半结构化或非结构化问题。<br>（2）专家系统模拟的是人类专家在问题领域的推理，而不是模拟问题领域本身。<br>（3）专家系统由3个要素组成：描述问题状态的综合数据库、存放启发式经验知识的知识库和对知识库的知识进行推理的推理机。三要素分别对应数据级、知识库级和控制级三级知识，而传统应用程序只有数据和程序两级结构。<br>（4）专家系统处理的问题是实际的问题，而不是纯学术的问题。<br>（5）从求解手段来看，专家系统专用性强，通用性差。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/5.png"></p><p><strong>人工智能AI的主要分支有专家系统、机器人技术、视觉系统、自然语言处理、学习系统和神经网络等。</strong></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/6.png"></p><ol><li>知识库。用来存储系统求解实际问题的领域知识 。知识库中的知识可分成两类：一类为事实性知识，另一类是启发性知识。</li><li>综合数据库。是专家系统在执行与推理过程中用以存放所需要和产生的各种信息的工作存储器，因此，综合数据库又叫动态知识库 ，其内容在系统运行过程中是不断变化的。相应地把专家系统的知识库称为静态知识库。二者一起构成完整知识库。</li><li>推理机。推理机和知识库一起构成专家系统的核心 。推理机也被称为控制结构或规则解释器，通常包括推理机制和控制策略，是一组用来控制系统的运行、执行各种任务、根据知识库进行各种搜索和推理的程序模块。</li><li>知识获取。主要有两方面功能：一是知识的编辑和求精，二是知识自学习 。</li><li>解释程序。是面向用户服务的，负责解答用户提出的各种问题 。</li><li>人机接口。通常包括两部分：一部分是专家系统与用户的接口，另一部分是专家系统与领域专家和知识工程师的接口</li></ol><h3 id="2-6-办公自动化系统（OAS）"><a href="#2-6-办公自动化系统（OAS）" class="headerlink" title="2.6 办公自动化系统（OAS）"></a>2.6 办公自动化系统（OAS）</h3><p>办公自动化就是办公信息处理手段的自动化。OAS要解决的是包括数据、文字、声音图像等信息的一体化处理问题。从本质上讲，办公自动化就是以先进的科学技术为基础，利用有关办公自动化设备协助办公人员管理各项办公信息，主要利用资源以提高办公效率和办公质量。计算机技术、通信技术、系统科学和行为科学是它的4大支柱。其中以行为科学为主导，系统科学为理论基础，结合运用计算机技术和通信技术。</p><p>OAS的主要功能：</p><p>（1）事务处理 。完成办公部分内的大量繁琐事情，又称为事务办公系统，分为单机处理系统和多机处理系统（通信、信息共享）。<br>（2）信息管理 。对信息流的控制管理，主要包括信息的收集、加工、传递、交流、存取、提供、分析、判断、应用和反馈那些办公人员的综合性工作。可称为管理型办公系统，它能将事务型办公系统中各项孤立的事务处理通过信息交换和共享资源联系起来，获得准确、快捷、及时、优质的功效。管理型办公系统是一种分布式的处理系统，具有计算机通信和网络功能。<br>（3）辅助决策 。可称为决策型办公系统，以经理型办公系统提供的大量信息作为决策工作的基础，建立起能综合分析、预测发展、判断利弊的计算机可运行的决策模型，根据原始数据信息，自动做出比较符合实际的决策方案。<br>办公自动化系统的组成：计算机设备、办公设备、数据通信及网络设备、软件系统。</p><p>办公自动化系统的组成：计算机设备、办公设备、数据通信及网络设备、软件系统 。</p><h3 id="2-7-企业资源规划（ERP）"><a href="#2-7-企业资源规划（ERP）" class="headerlink" title="2.7 企业资源规划（ERP）"></a>2.7 企业资源规划（ERP）</h3><p>企业资源可以归纳为三个“流”，即物流、资金流和信息流 。ERP是指建立在信息技术基础上，以系统化的管理思想，为企业提供决策和运营手段的管理平台。ERP系统是将企业所有资源进行集成整合，并进行全面、一体化管理的信息系统。</p><p>管理思想：它是管理思想的变革。<br>软件产品：不是买来直接就用，需要个性化的开发和部署。<br>管理系统：存在 众多的子系统 ，这些子系统有统一的规划，是 互联互通的，便于事前事中的监控 。<br>包括内容：财务管理，物流管理，生产控制管理，人力资源管理，库存管理等。</p><p><strong>ERP的结构 ：</strong></p><p>（1）生产预测。市场需求是企业生存的基础，在ERP中首先需要对市场进行较准确的预测。预测主要用于计划，在ERP的5 个层次的计划中，前3个层次计划，即经营计划、生产计划大纲和主生产计划的编制都离不开预测。<br>（2）销售管理（计划）。销售管理主要是针对企业的销售部门的相关业务进行管理。<br>经营计划（生产计划大纲）。是根据经营计划的生产目标制定的，是对企业经营计划的细化,用以描述企业在可用资源的条件下，在一定时期中的产量计划。<br>（3）主生产计划。是对企业生产计划大纲的细化，说明在一定时期内的下计划:生产什么，生产多少和什么时候交货。主生产计划的编制以生产大纲为准，其汇总结果应当等同于生产计划大纲。<br>（4）物种需求计划。物料需求计划是对主生产计划的各个项目所需的全部制造件和全部采购件的网络支持计划和时间进度计划。它根据主生产计划对最终产品的需求数量和交货期，推导出构成产品的零部件及材料的需求数量和需求时期，再导出自制零部件的制作订单下达日期和采购件的采购订单发送日期，并进行需求资源和可用能力之间的进一步平衡。<br>（6）能力需求计划。是对物料需求计划所需能力进行核算的一种计划管理方法。旨在通过分析比较MRP 的需求和企业现有生产能力，及早发现能力的瓶颈所在，为实现企业的生产任务而提供能力方面的保障。<br>（7）车间作业计划。是在MRP所产生的加工制造订单（即自制零部件生产计划）的基础上，按照交货期的前后和生产优先级选择原则以及车间的生产资源情况（如设备、人员、物料的可用性、加工能力的大小等），将零部件的生产计划以订单的形式下达给适当的车间。<br>（8）采购与库存管理。采购与库存管理是ERP的基本模块，其中采购管理模块是对采购工作，即从采购订单产生至货物收到的全过程进行组织、实施与控制，库存管理模块则是对企业物料的进、出、存进行管理。<br>（9）质量与设备管理。质量管理贯穿于企业管理的始终。设备管理是指依据企业的生产经营目标，通过一系列的技术、经济和组织措施，对设备寿命周期内的所有设备物资运动形态和价值运动形态进行的综合管理。<br>（10）财务管理。会计工作是企业管理的重要组成部分，是以货币的形式反映和监督企业的日常经济活动，并对这些经济业务的数据进行分类、汇总，以便为企业管理和决策提供必要的信息支持。企业财务管理是企业会计工作和活动的统称。<br>（11）ERP有关扩展应用模块。如客户关系管理、分销资源管理、供应链管理和电子商务等。这几个扩展模块本身也是一个独立的系统，在市场上它们常作为独立的软件产品进行出售和实施。</p><p><strong>ERP的功能 ：</strong><br>支持决策的功能、为处于不同行业的企业提供有针对性的IT解决方案、从企业内部的供应链发展为全行业和跨行业的供应链。</p><h2 id="3-典型信息系统架构模型"><a href="#3-典型信息系统架构模型" class="headerlink" title="3 典型信息系统架构模型"></a>3 典型信息系统架构模型</h2><h3 id="3-1-电子政务（EG）"><a href="#3-1-电子政务（EG）" class="headerlink" title="3.1 电子政务（EG）"></a>3.1 电子政务（EG）</h3><p>电子政务是利用信息技术和其他相关技术，实现公务、政务、商务、事务的一体化管理与运行的政府形态改造的系统工程。</p><p><strong>行为主体（角色）</strong> 是： <strong>政府</strong>（Government）、 <strong>企（事）业单位</strong>（Business）、及 <strong>居民</strong>（Citizen）。如有第四类就是<strong>公务员</strong>（Employee）。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/7.png"></p><table><thead><tr><th>类型</th><th>解释及应用</th></tr></thead><tbody><tr><td>政府对政府（G2G）</td><td>政府上下级、不同地区和不同职能部门间电子公文和流转，电子司法档案，电子财政管理和电子统计等，同级别的政府之间的业务往来，包括国家和地方基础信息的采集，处理和利用。例如: 人口信息、地理信息、各级政府决策支持</td></tr><tr><td>政府对企业（G2B）</td><td>向企业提供的各种公共服务，网上税务申报，电子证照办理，以及信息咨询服务等，企业需要报税，一边是企业一边是政府报税部门。如：政府给企业单位颁发各种营业执照，许可证，合格证，质量认证。</td></tr><tr><td>政府对居民（G2C）</td><td>是政府面向公总所提供的服务，教育培训服务，公总就业服务，电子医疗服务，社会保险服务，交通管理服务，公众电子税务和电子证件服务等。如：社区公安和水、火、天灾等与公共安全有关的信息、户口、各种证件和拍照的管理</td></tr><tr><td>企业对政府（B2G）</td><td>企业向政府缴税，企业向政府供应各种商品和服务，企业向政府提建议，申诉</td></tr><tr><td>居民对政府（C2G）</td><td>个人应向政府缴纳的各种税款和费用，个人向政府反馈民意，报警服务</td></tr><tr><td>政府对公务员（G2E）</td><td>指政府与政府公务即政府雇员之间的电子政务，电子政策法规，电子公文流转，电子办公，电子培训，电子财经管理，公务员业绩评价，政府的系统给内部人员使用，如：部门内部办公自动化，内部工作系统。</td></tr></tbody></table><h3 id="3-2-企业信息化（EI）"><a href="#3-2-企业信息化（EI）" class="headerlink" title="3.2 企业信息化（EI）"></a>3.2 企业信息化（EI）</h3><p>企业信息化（Enterprise Informatization，EI）。企业信息化是企业利用现在信息技术，实现经营活动的自动化、便捷化、网络化和智能化，以加强企业核心竞争力的过程。企业信息化是技术和业务的融合，从企业战略、业务运作和管理运作3个层面去实现。企业信息化的方法有：业务流程重构方法、核心业务应用方法、信息系统建设方法、主体数据库方法、资源管理方法、人力资本投资方法。</p><h3 id="3-3-电子商务（EC）"><a href="#3-3-电子商务（EC）" class="headerlink" title="3.3 电子商务（EC）"></a>3.3 电子商务（EC）</h3><p>电子商务（Electronic Commerce，EC）。电子商务指利用Web提供的通信手段在网上买卖产品或提供服务，及其衍生行为。主要模式有B2B、B2C、C2C、O2O（线上购买线下的服务）。</p>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>基础技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络规划与设计</title>
    <link href="/2023/07/02/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/07/02/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="1-网络协议"><a href="#1-网络协议" class="headerlink" title="1 网络协议"></a>1 网络协议</h2><h3 id="1-1-网络协议与OSI层次模型关系"><a href="#1-1-网络协议与OSI层次模型关系" class="headerlink" title="1.1 网络协议与OSI层次模型关系"></a>1.1 网络协议与OSI层次模型关系</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/1.png"></p><table><thead><tr><th>协议</th><th>描述</th></tr></thead><tbody><tr><td>POP3</td><td>110端口，邮件发送</td></tr><tr><td>SMTP</td><td>25端口，邮件发送</td></tr><tr><td>FTP</td><td>20数据端口/21控制端口，文件传输协议</td></tr><tr><td>HTTP</td><td>80端口，超文本传输协议，网页传输</td></tr><tr><td>DHCP</td><td>67端口，IP地址自动分配</td></tr><tr><td>SNMP</td><td>161端口，简单网络管理协议</td></tr><tr><td>DNS</td><td>53端口，域名解析协议，记录域名和ip的映射关系</td></tr><tr><td>TCP</td><td>可靠的传输层协议</td></tr><tr><td>UDP</td><td>不可靠的传输层协议</td></tr><tr><td>ICMP</td><td>因特网控制协议，PING命令来自该协议</td></tr><tr><td>IGMP</td><td>组播协议</td></tr><tr><td>ARP</td><td>地址解析协议，IP地址转换为MAC地址</td></tr><tr><td>RARP</td><td>反向地址解析协议，MAC地址转换IP地址</td></tr></tbody></table><h3 id="1-2-TCP-IP协议族"><a href="#1-2-TCP-IP协议族" class="headerlink" title="1.2 TCP/IP协议族"></a>1.2 TCP/IP协议族</h3><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>共同点</td><td>基于IP协议的传输层协议，可以端口寻址</td><td>基于IP协议的传输层协议，可以端口寻址</td></tr><tr><td>不同点</td><td>面向连接，三次握手，流量控制，差错校验和重传，IP数据包按序接收，可靠性强，牺牲通信量，效率低</td><td>不可靠，无连接，错误检测功能弱，无拥塞控制，无流量控制，有助于提高传输的高速率性，不对无序IP数据包重新排序，不负责重传，不消除重复IP数据包，不对已收到的数据包进行确认，不负责建立或终止连接，这些由UDP进行通信的应用程序进行处理</td></tr><tr><td>相关协议</td><td>HTTP, FTP, Telnet, POP3, SMTP</td><td>DNS, DHCP, TFTP, SNMP</td></tr></tbody></table><h3 id="1-3-DNS服务应用"><a href="#1-3-DNS服务应用" class="headerlink" title="1.3 DNS服务应用"></a>1.3 DNS服务应用</h3><p><strong>域名系统（Domain Name System，DNS）</strong></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/2.png"></p><h3 id="1-4-DHCP服务应用"><a href="#1-4-DHCP服务应用" class="headerlink" title="1.4 DHCP服务应用"></a>1.4 DHCP服务应用</h3><p><strong>动态主机配置协议（DHCP，Dynamic Host Configuration Protocol）</strong></p><p>（1）客户机/服务器模型</p><p>（2）租约默认为8天</p><p>（3）当租约过半时，客户机需要向DHCP服务器申请续租</p><p>（4）当租约超过87.5%时，如果仍然没有和当初提供IP的DHCP服务器联系上，则开始联系其他的DHCP服务器。</p><p>（5）分配方式：<br>      ①固定分配（管理员分配静态绑定固定的IP地址）<br>      ②动态分配（为客户端分配租期无限长的IP地址）<br>      ③自动分配（为客户端分配具有一定有效期的IP地址）</p><p>（6）无效地址：169.254.X.X 和 0.0.0.0</p><h3 id="1-5-IPv6"><a href="#1-5-IPv6" class="headerlink" title="1.5 IPv6"></a>1.5 IPv6</h3><p>IPv6是设计用于替代现行版本IP协议（IPv4）的下一代IP协议。<br>（1）寻址能力方面的扩展。IPv6地址长度为128位，地址空间增大了2的96次方倍。<br>（2）灵活的IP报文头部格式。使用一系列固定的扩展头部取代了IPv4中可变长度的选项字段。IPv6中选项部分的出现方式也有变化，使路由器可以简单路过选项而不作任何处理，加快了报文处理速度。<br>（3）IPv6简化了报文头部格式，字段只有8个，加快报文转发，提高了吞吐量；<br>（4）提高安全性。身份认证和隐私权是IPv6的关键特性；<br>（5）支持更多的服务类型。</p><blockquote><p>单播地址（Unicast）：用于单个接口的标识符，传统的点对点通信。</p><p>组播地址（Multicast）：多播地址，一点对多点的通信，数据包交付到一组计算机中的每一个。IPv6没有广播的术语，而是将广播看做多播的一个特例。</p><p>任播地址（Anycast）：泛播地址，这是IPv6增加的一种类型。任播的目的站是一组计算机，但数据包在交付时只交付给其中一个，通常是距离最近的一个。</p></blockquote><p><strong>IPv6地址书写规范</strong></p><p>IPv6地址由8个16机制字段构成。</p><p>IPv4：点分十进制<br>IPv6：冒分十六进制</p><p><strong>（1）高位0可省略（多次）</strong><br><strong>（2）一段0可用1个0表示（多次）</strong><br><strong>（3）连续多段0可用省略用::表示（1次）</strong></p><p>IPv6规定每个网卡最少有3个IPv6的地址，分别是 链路本地地址、全球单播地址、回送地址（站点本地地址） 。<br>IPv6把自动IP地址配置作为标准功能，只要计算机连接上网络便可以自动分配IP地址。</p><p>全状态自动配置（Stateful Auto-Configuration） ：IPv6继承了IPv4动态主机配置协议（DHCP）这种配置服务。<br>无状态自动配置（Stateless Auto-Configuration） ：主机通过两个阶段分别获得链路本地地址和可聚合全球单播地址。</p><ol><li>首先主机将其网卡MAC地址附加在链路本地地址前缀1111 11110 10之后，产生一个链路本地地址，发出一个ICMPv6邻居发送请求，验证其地址唯一性。不唯一性则使用随机接口ID组成一个新的链路本地地址。</li><li>主机以链路本地地址为源地址，向本地链路中所有路由器的组播ICMPv6路由器请求报文并返回一个包含可聚合全球单播地址前缀的路由器公告报文响应。该地址前缀加上自己的接口ID，自动配置一个全球单播地址。使用无效状态自动配置，无须用户手工干预就可以改变主机的IPv6地址。</li></ol><h2 id="2-网络工程"><a href="#2-网络工程" class="headerlink" title="2 网络工程"></a>2 网络工程</h2><p>可分为网络规划、网络设计、网络实施三个环节。</p><ol><li>网络规划：以需求为导向，兼顾技术和工程可行性。</li><li>网络设计：包括网络逻辑设计和网络物理设计。</li><li>网络逻辑设计：网络结构设计、网络技术选型、IP地址和路由设计、网络冗余设计以及网络安全设计等。</li><li>网络物理设计：布线设计、机房设计、设备选址等。</li></ol><p>网络实施：包括工程计划的实施、网络设备验收、设备安装和调试、系统运行和切换、用户培训等。</p><p><strong>网络冗余设计</strong>：目的是避免网络组件单点失效造成应用失效。<br><strong>备用路径</strong>：是在主路径失效时启用，其和主路径承担不同的网络负载。<br><strong>负载分担</strong>：通过并行链路提供流量分担来提高性能；网络中存在备用链路时，可以考虑加入负载分担设计来减轻主路径负担。</p><h3 id="2-1-网络规划与设计"><a href="#2-1-网络规划与设计" class="headerlink" title="2.1 网络规划与设计"></a>2.1 网络规划与设计</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/3.png"></p><p><strong>逻辑网络设计：</strong><br>逻辑网络设计是体现网络设计核心思想的关键阶段，在这一阶段根据需求规范和通信规范，选择一种比较适宜网络逻辑结构，并基于该逻辑结构实施后续的资源分配规划、安全规划等内容。利用需求分析和现有网络体系分析的结果来设计逻辑网络结构，最后得到一份逻辑网络设计文档。</p><table><thead><tr><th>逻辑网络设计工作主要包括一下内容</th><th>输出内容</th></tr></thead><tbody><tr><td><strong>（1）网络机构的设计<br/>（2）物理层技术的选择<br/>（3）局域网技术的选择与应用<br/>（4）广域网技术选择与应用<br/>（5）地址设计和命名模型<br/>（6）路由选择协议<br/>（7）网络管理<br/>（8）网络安全<br/>（9）逻辑网络设计文档</strong></td><td><strong>（1）逻辑网络设计图<br/>（2）IP地址方案<br/>（3）安全管理方案<br/>（4）具体软/硬件、广域网连接设备和基本的网络服务<br/>（5）招聘和培训网络员工的具体说明<br/>（6）对软/硬件费用、服务提供费用、员工培训的费用初步估计</strong></td></tr></tbody></table><p><strong>物理网络设计：</strong><br>物理网络设计是对逻辑网络设计的物理实现，通过对设备的具体物理分布、运行环境等确定，确保网络的物理连接符合逻辑连接的要求。在这一阶段，网络设计者需要确定具体的软/硬件、连接设备、布线和服务部署方案，输出如下内容：<br>（1）网络物理结构图和布线方案<br>（2）设备和部件的详细列表清单<br>（4）软硬件和安装费用的估算<br>（5）安装日程表、详细说明服务的时间以及期限<br>（6）安装后的测试计划<br>（7）用户的培训计划</p><h3 id="2-2-层次化网络设计"><a href="#2-2-层次化网络设计" class="headerlink" title="2.2 层次化网络设计"></a>2.2 层次化网络设计</h3><p><strong>核心层</strong> ：<strong>主要高速数据交换，实现高速数据传输、出口路由，常用冗余机制</strong>。</p><p><strong>汇聚层</strong> ：<strong>网络访问策略控制、数据包处理和过滤、策略路由、广播域协议、寻址</strong>。</p><p><strong>接入层</strong> ：<strong>主要是针对用户端，实现用户接入、计费管理、MAC地址认证、MAC地址过滤、收集用户信息，可以使用集线器代替交换机</strong></p><h3 id="2-3-网络冗余设计"><a href="#2-3-网络冗余设计" class="headerlink" title="2.3 网络冗余设计"></a>2.3 网络冗余设计</h3><p>在网络冗余设计中，对通信线路常见的设计目标主要有两个：一个是备用路径，另一个是负载分担。</p><ol><li><strong>备用路径</strong> ：</li></ol><p>提高可用性，由路由器、交换机等设备之间的独立备用链路构成，一般情况下备用路径仅在主路径失效时投入使用。</p><p>设计时主要考虑：</p><p>（1）备用路径的带宽<br>（2）切换时间<br>（3）非对称<br>（4）自动切换<br>（5）测试</p><ol start="2"><li><strong>负载分担</strong> ：</li></ol><p>是对备用路径方式的扩充，通过并行链路提供流量分担（冗余的形式）来提高性能，主要的实现方法是利用两个或者多个网络接口和路径来同时传递流量。</p><p>设计时注意考虑：</p><p>（1）网络中存在备用路径、备用链路时，可以考略加入负载分担的设计。<br>（2）对于主路径、备用路径都相同的情况，可以实施负载分担的特例 - 负载均衡。<br>（3）对于主路径、备用路径不相同的情况，可以采用策略路由机制，让一部分应用的流量分摊到备用路径上。</p><h2 id="3-网络设计相关技术"><a href="#3-网络设计相关技术" class="headerlink" title="3 网络设计相关技术"></a>3 网络设计相关技术</h2><h3 id="3-1-网络存储技术"><a href="#3-1-网络存储技术" class="headerlink" title="3.1 网络存储技术"></a>3.1 网络存储技术</h3><ol><li>直连式存储（DAS， Direct-Attached Storage）</li><li>网络附加存储（NAS，Network-Attached Storage）</li><li>存储区域网络（SAN，Storage Area Network）</li><li>Internet 小型计算机系统接口（iSSI，Internet Small Computer System Interface）</li></ol><table><thead><tr><th>分裂</th><th>特点</th></tr></thead><tbody><tr><td>DAS/SAS</td><td>通过SCSI连接到服务器，本身是硬件的堆叠，不带任何操作系统。存储必须被直接连接到应用服务器上，不能跨平台共享文件，各系统平台下文件分别存储。</td></tr><tr><td>NAS</td><td>通过网络接口与网络直接连接，由用户通过网络访问（支持多种TCP/IP协议）。NAS设备有自己的OS，类似于一个专用的文件服务器，一般存储信息采用RAID进行管理。既插既用。</td></tr><tr><td>SAN</td><td>通过网络接口与网络直接连接，由用户通过网络访问（支持多种TCP/IP协议）。NAS设备有自己的OS，类似于一个专用的文件服务器，一般存储信息采用RAID进行管理。既插既用。</td></tr><tr><td>IP-SAN/ISSI</td><td>基于IP网络实现，设备成本低，配置技术简单，可共享和使用大容量的存储空间。</td></tr></tbody></table><p>磁盘阵列（RAID， Redundant Arrays of Independent Disk）</p><p>Raid0（条块化）：性能最高，并行处理，无冗余，损坏无法恢复</p><p>Raid1（镜像结构）：可用性，可修复性好，仅有50%利用率</p><p>Raid0+1（Raid10）：Raid0和Raid1长处的结合，高效也可靠</p><p>Raid3（奇偶校验并行传送）：N+1模式，有固定的校验盘，坏一个盘可恢复</p><p>Raid5（分布式奇偶校验的独立磁盘）：N+1模式，无固定的校验盘，坏一个盘可恢复</p><p>Raid6（两种存储的奇偶校验）：N+2模式，无固定的校验盘，坏两个盘可恢复</p><p>RAID0磁盘利用率100%，访问速度最快。</p><p>RAID1磁盘利用率50%，具备纠错功能。</p><p>现在企业采用RAID0与RAID结合的方式比较多。</p><p>RAID5磁盘利用率（n-1）/ n ，具备容错功能</p><h3 id="3-2-网络接入技术"><a href="#3-2-网络接入技术" class="headerlink" title="3.2 网络接入技术"></a>3.2 网络接入技术</h3><p><strong>有线接入</strong> ：</p><ul><li>公用交换电话网络（PSTN）</li><li>数字数据网（DDN）</li><li>综合业务数字网（ISDN）</li><li>非对称数字用户线路（ADSL）</li><li>同轴光纤技术（HFC）</li></ul><p><strong>无线接入</strong> ：</p><ul><li>IEEE 802.11（WiFi）</li><li>IEEE 802.15（蓝牙Bluetooth）</li><li>红外（IrDA）</li><li>WAPI</li></ul><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/4.png"></p><h3 id="3-3-综合布线技术"><a href="#3-3-综合布线技术" class="headerlink" title="3.3 综合布线技术"></a>3.3 综合布线技术</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/5.png"></p><ol><li>工作区子系统：由信息插座、插座盒、连接跳线和适配器组成。</li><li>水平子系统：由一个工作区的信息插座开始，经水平布置到管理区的内侧配线架的线缆所组成。</li><li>管理子系统：由交连、互连配线架组成。管理子系统为连接其它子系统提供连接手段。</li><li>垂直干线子系统：由建筑物内所有的垂直干线多对多数电缆及相关支撑硬件组成，已提供设备间总配线架与干线接线间楼层配线架之间的干线路由。</li><li>设备间子系统：是由设备间中的电缆、连接器和有关技术的支撑硬件组成，作用是将计算机、PBX、摄像头、监视器等弱电设备互连起来并连接到主配线架上。</li><li>建筑群子系统：将一个建筑物的电缆延伸到建筑群的另外一些建筑物中的通信设备和装置上，是结构化布线系统的一部分，支持提供楼群之间通信所需的硬件。它由电缆、光缆和入楼处的过流过压电器保护设备等相关硬件组成，常用介质光缆。</li></ol><h3 id="3-4-物联网技术"><a href="#3-4-物联网技术" class="headerlink" title="3.4 物联网技术"></a>3.4 物联网技术</h3><p>__物联网（The Internet of Things）__是实现物物相连的互联网络，其内涵包含两个方面：<br>第一：物联网的核心和基础仍然是互联网，是在互联网基础上延伸和扩展的网络；<br>第二：其用户端延伸和扩展到了任何物体与物体之间，使其进行用户交换和通信。</p><h4 id="3-4-1-物联网的概念与分层"><a href="#3-4-1-物联网的概念与分层" class="headerlink" title="3.4.1 物联网的概念与分层"></a>3.4.1 物联网的概念与分层</h4><p>（1）<strong>感知层</strong>：识别物体、采集信息。如：二维码、RFID、摄像头、传感器（温度、湿度）<br>（2）<strong>网络层</strong>：传递信息和处理信息。通信网与互联网的融合网络、网络管理中心、信息中心和智能处理中心等。<br>（3）<strong>应用层</strong>：解决信息处理和人机交互的问题。</p><h4 id="3-4-2-物联网关键技术"><a href="#3-4-2-物联网关键技术" class="headerlink" title="3.4.2 物联网关键技术"></a>3.4.2 物联网关键技术</h4><p><strong>射频识别技术（Radio Frequency Identification，RFID）</strong><br>又称电子标签，是一种通信技术，可通过无线电讯号识别特定目标并读写相关数据，而无需识别系统与特定目标之间建立机械或光学接触。该技术是物联网的一项核心技术，很多物联网应用都离不开它。</p><p>RFID的基本组成部分通常包括：标签、阅读器、天线。</p><p><strong>二维码</strong></p><p>二维码是用某种特定的几何图形按一定规律在平面（二维码方向上）分布的黑白相间的图形记录数据符号的信息的。在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图像输入设备或光电扫描设备自动识读以实现信息自动处理。</p><p>二维条形码，常用的码制有：Data Matrix，Maxi Code， Aztec， QR Code， Vericode， PDF417， Code49， Code16K。</p><p>若采用扩展的字母数字压缩格式，可容纳1850个字符<br>软采用二进制/ASCII格式，可容纳1108个字符<br>若采用数字压缩格式，可容纳2710个数字</p><h3 id="3-5-云计算技术"><a href="#3-5-云计算技术" class="headerlink" title="3.5 云计算技术"></a>3.5 云计算技术</h3><p><strong>云计算</strong>是一种基于互联网的计算方式，通过这种方式，共享的软硬件资源和信息可以按需提供给计算机和其他设备。云其实是网络、互联网的一种比喻说法。云计算的核心思想，是将大量用网络连接的计算资源统一管理和调度，构成一个计算资源池向用户按需服务。提供资源的网络被称为“云”。</p><p>狭义云计算指IT基础设施的交付和使用模式，指通过网络以按需、易扩展的方式获得所需资源。<br>广义云计算指服务的交付和使用模式，指通过网络以按需、易扩展的方式获得所需服务。这种服务可以是IT和短剑、互联网相关，也可以是其他服务。</p><p>特点：集合了大量计算机，规模达到成千上万。多种软硬件技术相结合。对客户端设备的要求低。规模化效应。</p><p>网络服务的概念：</p><p>软件即服务（SaaS）：在线软件的提供，在线客服<br>平台即服务（PaaS）：在平台上的二次开发<br>基础设施即服务（IaaS）：硬件资源管理</p>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>基础技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息安全技术</title>
    <link href="/2023/07/02/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/07/02/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="1-安全基础技术"><a href="#1-安全基础技术" class="headerlink" title="1 安全基础技术"></a>1 安全基础技术</h2><h3 id="1-1-对称与非对称加密"><a href="#1-1-对称与非对称加密" class="headerlink" title="1.1 对称与非对称加密"></a>1.1 对称与非对称加密</h3><p>数据加密是<strong>防止未经授权的用户访问敏感信息的手段</strong>，保障系统的机密性要素。数据加密有对称加密算法和非对称加密算法两种。</p><h4 id="1-1-1-对称加密"><a href="#1-1-1-对称加密" class="headerlink" title="1.1.1 对称加密"></a>1.1.1 对称加密</h4><p><strong>对称秘钥算法的加密秘钥和解密秘钥相同，又称共享密钥算法。</strong></p><p><strong>缺点</strong>：</p><ul><li><strong>加密强度不高，但效率高。</strong></li><li><strong>秘钥分发困难。</strong></li></ul><ol><li>DES：秘钥加密块算法（Data Encryption Standard，DES），替换 + 移位，明文切分64位的块（既分组），由56位的秘钥控制变换成64位的密文。速度快，秘钥易产生。</li><li>3DES：三重DES（Triple-DES）是EDS的改进算法，使用两把56位的秘钥对明文做三次DES加解密，秘钥长度112位，两个56位密钥K1、K2<br> 加密：K1加密 → K2解密 → K1加密<br> 解密：K1解密 → K2加密 → K1解密</li><li>RC-5：RSA数据安全公司的很多产品都使用了RC-5。</li><li>IDEA：国际数据加密算法（International Data Encryption Algorithm，IDEA），分组长度64位，秘钥长度128位，已经称为全球通用的加密标准。</li><li>AES：高级加密标准（Advanced Encryption Standard，AES）分组长度128位，支持128位、192位和256位3种秘钥长度，用于替换脆弱的DES算法，且可以通过软件或硬件实现高速加解密。</li><li>SM4国密算法，分组长度和密钥长度都是128位。</li></ol><h4 id="1-1-2-非对称加密"><a href="#1-1-2-非对称加密" class="headerlink" title="1.1.2 非对称加密"></a>1.1.2 非对称加密</h4><p>非对称密钥加密算法的加密秘钥和解密秘钥不相同，又称为不共享密钥算法或公钥加密算法。在非对称加密算法中：</p><ul><li>用公钥加密，私钥解密，可以实现保密通信。</li><li>用私钥加密，公钥解密，可以实现数字签名。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>加密速度慢。</strong></li></ul><ol><li>RSA：（Rivest，Shamir and Adleman）是一种国际通用的公钥加密算法，安全性基于大素数分解的困难性，秘钥的长度可以选择，但目前安全的秘钥长度已经高达2048位。RSA计算速度比同样安全级别的对称加密算法慢1000倍左右。2048位或1024位密钥、计算量极大、难破解。</li><li>Elgamal：安全性依赖于计算有限域上离散岁数这一难题。</li><li>ECC：椭圆曲线算法。</li><li>SM2国密算法：基于椭圆曲线离散对数问题，在相同安全程度的要求下，秘钥长度和计算规律都比RSA小得多。</li></ol><h3 id="1-2-信息摘要"><a href="#1-2-信息摘要" class="headerlink" title="1.2 信息摘要"></a>1.2 信息摘要</h3><p>信息摘要：单向散列函数，固定长度的散列值 。<br>信息摘要是单向的，不能被还原。</p><p>常用的消息摘要算法有 MD5，SHA 等，市场上广泛使用的MD5，SHA算法的散列值分别为128和160位，由于 SHA通常采用的秘钥长度较长，因此安全性高于MD5 。</p><p>主要作用：防止原文内容被篡改 。</p><h3 id="1-3-数字签名"><a href="#1-3-数字签名" class="headerlink" title="1.3 数字签名"></a>1.3 数字签名</h3><p>数字签名是公钥加密技术与数字摘要技术的应用。数字签名的条件是：可信、不可伪造、不可重用、不可改变和不可抵赖。</p><p>实际应用时先对文件做摘要，再对摘要签名，这样可以大大提升数字签名的速度。同时摘要的泄露不影响文件的保密</p><h3 id="1-4-数字信封"><a href="#1-4-数字信封" class="headerlink" title="1.4 数字信封"></a>1.4 数字信封</h3><p>数字信封是将对称密钥通过非对称加密（即：有公钥和私钥两个）的结果分发的方法。数字信封是实现信息保密性验证的技术。</p><p>PKCS#7中将数字信封作为术语进行定义，而在正文中对进行了如下解释： 数字信封包含被加密的内容和被加密的用于加密该内容的密钥。</p><p>虽然经常使用接收方的公钥来加密“加密密钥”，但这并不是必须的，也可以使用发送方和接收方预共享的对称密钥来加密。当接收方收到数字信封时，先用私钥或预共享密钥解密，得到“加密密钥”，再用该密钥解密密文，获得原文。数字信封技术使用两层加密体系。</p><p>数字信封是一种综合利用了对称加密技术和非对称加密技术两者的优点进行信息安全传输的一种技术。数字信封既发挥了对称加密算法速度快、安全性好的优点，又发挥了非对称加密算法密钥管理方便的优点。</p><h3 id="1-5-数字证书"><a href="#1-5-数字证书" class="headerlink" title="1.5 数字证书"></a>1.5 数字证书</h3><ol><li>证书的 版本信息；</li><li>证书 序列号，每个证书都有一个唯一的证书序列号；</li><li>证书所使用的签名算法；</li><li>证书的发行机构，命名规则一般采用X.500格式；</li><li>证书的 有效期，现在通用的证书一般采用UTC时间格式，它的计时范围为1950 - 2049；</li><li>证书所有人的名称，命名规则一般采用X.500的格式；</li><li>证书所有人的 公开密钥；</li><li>证书发行者对证书的签名</li></ol><h3 id="1-6-PKI公钥体系"><a href="#1-6-PKI公钥体系" class="headerlink" title="1.6 PKI公钥体系"></a>1.6 PKI公钥体系</h3><p><strong>CA（Certificate Authority）认证中心</strong><br><strong>RA（Registration Authority）注册审批机构</strong><br><strong>证书受理点</strong><br><strong>秘钥管理中心 - KMC</strong></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/1.png"></p><h2 id="2-网络安全"><a href="#2-网络安全" class="headerlink" title="2 网络安全"></a>2 网络安全</h2><h3 id="2-1-安全协议"><a href="#2-1-安全协议" class="headerlink" title="2.1 安全协议"></a>2.1 安全协议</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/2.png"></p><h3 id="2-2-网络攻击"><a href="#2-2-网络攻击" class="headerlink" title="2.2 网络攻击"></a>2.2 网络攻击</h3><p><strong>被动攻击：收集信息为主，破坏保密性。</strong></p><table><thead><tr><th>攻击名称</th><th>描述</th></tr></thead><tbody><tr><td>窃听（网络监听）</td><td>用各种可能的合法或非法的手段窃取系统中的信息资源和敏感信息</td></tr><tr><td>业务流分析</td><td>通过对系统进行长期监听、利用统计分析方法对诸如通信频度、通信的信息流向、通信总量的变化等参数进行研究，从而发现有价值的信息和规律</td></tr></tbody></table><p><strong>主动攻击：中断（破坏可用性）、篡改（破坏完整性）、伪造（破坏真实性）</strong></p><table><thead><tr><th>攻击名称</th><th>描述</th></tr></thead><tbody><tr><td>假冒身份</td><td>通过欺骗通信系统（或用户）达到非法用户冒充成为合法用户，或者特权小的用户冒充成为特权大的用户的目的，黑客大多是采用假冒进行攻击</td></tr><tr><td>抵赖</td><td>这是一种来自用户的攻击，比如：否认自己曾经发布过的某条消息，伪造一份对方来信等</td></tr><tr><td>旁路控制 [旁路攻击]</td><td>密码学中是指绕过对加密算法的繁琐分析，利用密码算法的硬件实现的运算中泄露的信息。如执行时间、功耗、电磁辐射等，结合统计物理理论快速的破解密码系统</td></tr><tr><td>重放攻击</td><td>所截获的某次合法的通信数据拷贝，出于非法的目的而被重新发送。加时间戳能识别并应对重放攻击</td></tr><tr><td>拒绝服务（DOS）</td><td>对信息或其他资源的合法访问被无条件的阻止</td></tr></tbody></table><h2 id="3-信息安全"><a href="#3-信息安全" class="headerlink" title="3 信息安全"></a>3 信息安全</h2><h3 id="3-1-系统安全防范体系层级"><a href="#3-1-系统安全防范体系层级" class="headerlink" title="3.1 系统安全防范体系层级"></a>3.1 系统安全防范体系层级</h3><p>（1）物理环境的安全性：<br>包括通信线路、物理设备和机房的安全等。<br>（2）操作系统的安全性：<br>主要表现在三个方面，一是操作系统本身的缺陷带来的不安全因素，主要包括身份认证、访问控制和系统漏洞等；二是对操作系统安全配置问题；三是病毒对操作系统的威胁。<br>（3）网络的安全性：<br>网络层的安全问题主要体现在计算机网络方面的安全性，包括网络层身份认证、网络资源的访问控制、数据传输的保密与完整性、远程接入的安全、域名系统的安全、路由系统的安全、入侵检测手段和网络设施防病毒等。<br>（4）应用的安全性：<br>由提供服务所采用的应用软件和数据的安全性产生，包括Web服务、电子邮件系统和DNS等。此外，还包括病毒对系统的威胁。<br>（5）管理的安全性：<br>包括安全技术和设备的管理、安全管理制度、部门与人员的组织规则等</p><h3 id="3-2-信息安全体系结构"><a href="#3-2-信息安全体系结构" class="headerlink" title="3.2 信息安全体系结构"></a>3.2 信息安全体系结构</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/3.png"></p>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>基础技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2023/07/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/07/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-操作系统概述"><a href="#1-操作系统概述" class="headerlink" title="1 操作系统概述"></a>1 操作系统概述</h2><p>操作系统的类型：批处理，分时，实时，网络操作系统和分布式操作系统。</p><p>操作系统具有的五大功能：处理器管理，存储管理，设备管理，文件管理和作业管理。不管任何类型的操作系统都有这样的分配。</p><p>现代的操作系统大多拥有两种工作状态：核心态和用户态。我们一般的应用程序工作在用户态，而内核模块和最基本的操作系统核心工作在核心态。</p><p>操作系统的结构可以分为无序结构，层次结构，面向对象结构，对称多处理结构和微内核结构。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.png"></p><h2 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2 进程管理"></a>2 进程管理</h2><h3 id="2-1-进程概念"><a href="#2-1-进程概念" class="headerlink" title="2.1 进程概念"></a>2.1 进程概念</h3><p>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。它由程序块、进程控制块（PCB）和数据块三部分组成。</p><p>PCB，PCB是进程存在的唯一标志，是进程的一个组成部分，是一种记录型数据结构。内容包含进程标识符、状态、位置信息、控制信息、队列指针（链接同一状态的进程）、优先级、现场保护区等。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.png"></p><p><strong>进程与程序</strong></p><p>进程与程序的区别：进程是程序的一次执行过程,没有程序就没有进程。</p><p>程序是一个静态的概念，而进程是一个动态的概念，它由创建而产生，完成任务后因撤销而消亡;进程是系统进行资源分配和调度的独立单位，而程序不是。</p><p><strong>进程与线程</strong></p><p>进程的2个基本属性：可拥有资源的独立单位，可独立调度和分配资源的基本单位。<br>一般情况下，一个进程会包含多个线程。</p><h3 id="2-2-进程状态"><a href="#2-2-进程状态" class="headerlink" title="2.2 进程状态"></a>2.2 进程状态</h3><p><strong>三态图</strong> ：就绪，运行，阻塞三种状态。就绪的时候等待时间片从而运行，而阻塞是说明进程没有被喂饱资源，有了资源就到就绪态</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.png"></p><p><strong>五态图</strong> ：运行状态，活跃就绪状态，静止就绪状态，活跃阻塞状态和静止阻塞状态。除了运行态以外，阻塞态分为了静止阻塞和活跃阻塞，而就绪态也被分为了静止就绪和活跃就绪，这样就一共有了五个状态。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.png"></p><h3 id="2-3-进程的同步与互斥"><a href="#2-3-进程的同步与互斥" class="headerlink" title="2.3 进程的同步与互斥"></a>2.3 进程的同步与互斥</h3><p><strong>互斥</strong>，千军万马过独木桥，同类资源的竞争关系</p><p><strong>同步</strong>，速度有差异，在一定情况停下等待，进程之间的协作关系</p><blockquote><p>临界资源：诸进程间需要互斥方式对其进行共享的资源，如打印机、磁带机等</p><p>临界区：每个进程中访问临界资源的那段代码称为临界区</p><p>信号量：是一种特殊的变量</p></blockquote><h3 id="2-4-PV操作"><a href="#2-4-PV操作" class="headerlink" title="2.4 PV操作"></a>2.4 PV操作</h3><p>PV操作是实现进程同步与互斥的常用方法。</p><p>P操作表示申请一个资源，负责获得资源并阻塞，V操作表示释放一个资源。</p><p>P操作和V操作是低级通信原语，在执行期间不可分割。</p><p>PV操作由P操作原语和V操作原语组成（原语是不可中断的过程）。</p><p>PV操作的意义：用信号量及PV操作来实现进程的同步和互斥。</p><p>信号量：是一种特殊的变量（全局的），习惯用大写S表示。</p><p>大部分情况下（没有事先说明），信号量S的初始值会被认为是1，1代表初始情况下有资源进行分配调用。</p><p>对信号量进行操作，具体定义如下：</p><p><strong>P操作</strong>（请求分配一个资源）：</p><p>将信号量S的值减1，即 S = S - 1<br>如果S &gt;= 0，则该进程继续执行，否则该进程进入等待状态</p><p><strong>V操作</strong>（释放一个资源）：</p><p>将信号量S的值加1，即S = S + 1<br>如果S &gt; 0，该进程继续执行，否则表示在等待队列中有某些进程正在等待该资源，需要唤醒等待</p><h3 id="2-5-前趋图"><a href="#2-5-前趋图" class="headerlink" title="2.5 前趋图"></a>2.5 前趋图</h3><p>前趋图是一个有向无循环图，由节点和有向边组成，节点代表各程序段的操作，而节点间的有向边表示两个程序段操作之间存在的前趋关系。用这种图可以描述多个程序或进程之间的执行顺序关系。</p><p>前趋图标记规则：从小到大，节点流出的都是V操作，流入的都是P操作，箭线代表一个信号量S。</p><h3 id="2-6-死锁"><a href="#2-6-死锁" class="headerlink" title="2.6 死锁"></a>2.6 死锁</h3><p>进程管理是操作系统的核心，但如果设计不当，就会出现死锁的问题。如果一个进程在等待一件不可能发生的事，则进程就死锁了。而如果一个或多个进程产生死锁，就会造成系统死锁。</p><blockquote><p>死锁的四个条件：互斥，环路等待，保持和等待，不可剥夺</p></blockquote><p><strong>如何预防死锁：顺序资源分配（有序资源分配法），银行家算法。</strong></p><h3 id="2-7-银行家算法"><a href="#2-7-银行家算法" class="headerlink" title="2.7 银行家算法"></a>2.7 银行家算法</h3><p><strong>银行家算法分配资源的原则：</strong></p><p>（1）当一个进程对资源的最大需求量不超过系统中的资源数时，可以接纳该进程<br>（2）进程可以分期请求资源，但请求的总数不能超过最大需求量<br>（3）当系统现有的资源不能满足进程尚需资源数时，对进程的请求可以推迟分配，但总能使进程在有限的时间里得到资源。</p><h2 id="3-存储管理"><a href="#3-存储管理" class="headerlink" title="3 存储管理"></a>3 存储管理</h2><h3 id="3-1-逻辑地址与物理地址"><a href="#3-1-逻辑地址与物理地址" class="headerlink" title="3.1 逻辑地址与物理地址"></a>3.1 逻辑地址与物理地址</h3><p>逻辑地址 相对地址，CPU所生成的地址，逻辑地址是内部和编程使用的、地址不唯一<br>物理地址 绝对地址，加载到内存地址寄存器中的地址，内存单元的真正地址<br>地址重定位，将程序中的虚拟地址（逻辑地址）变换成内存的真实地址（物理地址）的过程</p><h3 id="3-2-类型"><a href="#3-2-类型" class="headerlink" title="3.2 类型"></a>3.2 类型</h3><p>存储管理的主要目的是解决多个用户使用主存的问题，其存储管理方案主要包括分区存储管理、分页存储管理、分段存储管理、段页式存储管理以及虚拟存储管理。</p><h3 id="3-3-分区存储（连续空间）"><a href="#3-3-分区存储（连续空间）" class="headerlink" title="3.3 分区存储（连续空间）"></a>3.3 分区存储（连续空间）</h3><p>分区存储管理，把主存的用户区划分成若干个区域，每个区域分配给一个用户作业使用，并限定它们只能在自己的区域中运行。</p><h3 id="3-4-页式存储-分页存储（非连续空间）"><a href="#3-4-页式存储-分页存储（非连续空间）" class="headerlink" title="3.4 页式存储/分页存储（非连续空间）"></a>3.4 页式存储/分页存储（非连续空间）</h3><p>页式存储 == 分页存储</p><p>将一个进程（程序）的地址空间划分成若干个大小相等的区域，称为页。</p><p>相应地，将主存（内存）空间划分成与页相同大小的若干个物理块，称为块或页框。</p><p>在为进程分配主存时，将进程中若干页分别装入多个不相邻接的块中。</p><p>优点：利用率高,碎片小，分配及管理简单。</p><p>缺点：增加了系统开销;可能产生抖动现象。</p><p>页式存储主要考察，逻辑地址转换物理地址，注意各个进制的简便算法</p><h3 id="3-5-段式存储-分段存储（非连续空间）"><a href="#3-5-段式存储-分段存储（非连续空间）" class="headerlink" title="3.5 段式存储/分段存储（非连续空间）"></a>3.5 段式存储/分段存储（非连续空间）</h3><p>段式存储 == 分段存储</p><p>分段式存储管理系统中，为每个段分配一个连续的分区，而进程中的各个段可以离散地分配到主存的不同分区中。</p><p>在系统中为每个进程建立一张段映射表，简称为“段表”。每个段在表中占有一个表项，在其中记录了该段在主存中的起始地址（又称为“基址”）和段的长度。进程在执行时，通过査段表来找到每个段所对应的主存区。</p><p>段式存储：按用户作业中的自然段来划分逻辑空间，然后调入内存，段的长度可以不一样。</p><p>优点：多道程序共享内存，各段程序修改互不影响。</p><p>缺点：内存利用率低，内存碎片浪费大。</p><p>段式存储主要考察，主要判断逻辑地址是否合法（段号 + 偏移量），偏移量不能超过段长</p><h3 id="3-6-段页式存储管理（非连续空间）"><a href="#3-6-段页式存储管理（非连续空间）" class="headerlink" title="3.6 段页式存储管理（非连续空间）"></a>3.6 段页式存储管理（非连续空间）</h3><p>段页式系统的基本原理是先将整个主存划分成大小相等的存储块（页框），将用户程序按程序的逻辑关系分为若干个段，并为每个段赋予一个段名，再将每个段划分成若干页，以页框为单位离散分配。在段页式系统中，其地址结构由段号、段内页号和页内地址三部分组成。</p><p>段页式存储:段式与页式的综合体。先分段，再分页。1个程序有若干个段，每个段中可以有若干页，每个页的大小相同，但每个段的大小不同。</p><p>优点：空间浪费小、存储共享容易、存储保护容易、能动态连接。</p><p>缺点：由于管理软件的增加，复杂性和开销也随之增加，需要的硬件以及占用的内容也有所增加,使得执行速度大大下降。</p><h3 id="3-7-快表"><a href="#3-7-快表" class="headerlink" title="3.7 快表"></a>3.7 快表</h3><p>快表是一块小容量的相联存储器（Associative Memory），由高速缓存器组成，速度快，并且可以从硬件上保证按内容并行查找，一般用来存放当前访问最频繁的少数活动页面的页号。</p><p>快表：将页表存于Cache上；慢表：将页表存于内存上。</p><h3 id="3-8-虚拟存储管理"><a href="#3-8-虚拟存储管理" class="headerlink" title="3.8 虚拟存储管理"></a>3.8 虚拟存储管理</h3><p>在前面介绍的存储管理方案中，必须为每个作业分配足够的空间，以便装入全部信息。当主存空间不能满足作业要求时，作业无法装入主存执行。如果一个作业只部分装入主存便可开始启动运行.其余部分暂时留在磁盘上，在需要时再装入主存，这样可以有效地利用主存空间。从用户角度看，该系统所具有的主存容量将比实际主存容量大得多，人们把这样的存储器称为虚拟存储器。</p><h3 id="3-9-页面置换算法"><a href="#3-9-页面置换算法" class="headerlink" title="3.9 页面置换算法"></a>3.9 页面置换算法</h3><ol><li>最优置换算法OPT</li><li>随机淘汰算法RAND</li><li>先进先出算法FIFO， 可能“抖动”</li><li>最近最久未使用算法LRU，不会“抖动” 利用理论依据“局部性原理”，淘汰最后被访问时间最久的元素</li><li>最不经常使用页置换LFU，淘汰最近访问频率最小的元素</li><li>时钟页面替换算法， 轮转算法，最近没有使用页面置换算法NUR</li></ol><h2 id="4-文件管理"><a href="#4-文件管理" class="headerlink" title="4 文件管理"></a>4 文件管理</h2><h3 id="4-1-索引文件结构"><a href="#4-1-索引文件结构" class="headerlink" title="4.1 索引文件结构"></a>4.1 索引文件结构</h3><p>文件在逻辑上一定是连续的，在物理上可以是分散的。</p><p>文件的逻辑结构，方便用户使用；文件的物理结构，在物理设备的存放方式。</p><p>此部分经常考察逻辑号与物理号的计算转换，采取的具体什么类型索引，计算文件长度等等</p><p><strong>直接索引范围</strong> ：索引块数量 * 索引块大小</p><p><strong>一级间接索引范围</strong> ：（磁盘数据块(物理盘块)大小 / 地址项大小）* 索引块大小</p><p><strong>二级间接索引范围</strong> ：（磁盘数据块(物理盘块)大小 / 地址项大小）的2次方 * 索引块大小</p><p><strong>三级间接索引范围</strong> ：（磁盘数据块(物理盘块)大小 / 地址项大小）的3次方 * 索引块大小</p><h3 id="4-2-卫示图"><a href="#4-2-卫示图" class="headerlink" title="4.2 卫示图"></a>4.2 卫示图</h3><p><strong>位示图法</strong> ：该方法是在外存上建立一张位示图（Bitmap），记录文件存储器的使用情况。每一位仅对应文件存储器上的一个物理块，取值0和1分别表示空闲和占用。</p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.png"></p><h3 id="4-3-树形目录结构"><a href="#4-3-树形目录结构" class="headerlink" title="4.3 树形目录结构"></a>4.3 树形目录结构</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.png"></p><h2 id="5-设备管理"><a href="#5-设备管理" class="headerlink" title="5 设备管理"></a>5 设备管理</h2><h3 id="5-1-数据传输控制方式"><a href="#5-1-数据传输控制方式" class="headerlink" title="5.1 数据传输控制方式"></a>5.1 数据传输控制方式</h3><p><strong>从上往下CPU的工作量越来越少，效率从上往下越来越高。</strong></p><ol><li>程序控制方式【CPU与I/O的串行工作 】： 分为无条件传送和程序查询方式两种。方法简单，硬件开销小，但I/O能力不高，严重影响CPU的利用率。程序查询方式，CPU必须不停的测试I/O设备的状态端口 。</li><li>程序中断方式【CPU与I/O的并行工作 】：<br> 与程序控制方式相比，中断方式因为CPU无需等待而提高了传输请求的响应速度。CPU通过调用中断控制设备获得设备状态，设备通过中断通知CPU状态改变、获得数据等。中断结束后CPU会继续执行之前的程序。</li><li>DMA（直接内存存取）【CPU与I/O的并行工作 】：<br> 为了在主存和外设之间实现高速，批量数据交换而设置的。DMA方式比程序控制方式与中断方式都高效。DMA控制器与内存直接进行批量数据交换，CPU只控制开始和结束，传输过程无需CPU干预。<br> DMA硬件直接完成，无需CPU做任何干涉，适合快速I/O设备，且在CPU一个总线结束后相应DMA 。</li><li>通道方式【CPU与I/O的并行工作 】：<br> 主机中有专门的通道处理器，CPU干预更少，有对应的通道程序和通道状态字保存在内存中，CPU向通道处理器发出启动指令即可不管，通道处理器执行通道程序控制设备传输完所有数据之后发起一个中断交给CPU处理，设备挂接在通道上。</li><li>输入输出处理机（IOP）【CPU与I/O的并行工作 】：<br> 一个独立的系统，有自己的内存、指令熊、中断，专用于大型高效系统的输入输出设备控制，利用共享存储器等与主机交换信息。输入输出处理机中可能有多个通道连接设备。</li></ol><h3 id="5-2-I-O管理软件"><a href="#5-2-I-O管理软件" class="headerlink" title="5.2 I/O管理软件"></a>5.2 I/O管理软件</h3><ul><li>硬件，完成具体的I/O操作。</li><li>中断处理程序:，I/O完成后唤醒设备驱动程序</li><li>设备驱动程序，设置寄存器，检查设备状态</li><li>设备无关I/O层，设备名解析、阻塞进程、分配缓冲区</li><li>用户级I/O层（用户进程），发出I/O调用。</li></ul><h2 id="6-SPOOLing技术"><a href="#6-SPOOLing技术" class="headerlink" title="6 SPOOLing技术"></a>6 SPOOLing技术</h2><p>SPOOLing是Simultaneous Peripheral Operation On-Line （即外部设备联机并行操作）的缩写，它是关于慢速字符设备如何与计算机主机交换信息的一种技术，通常称为”假脱机技术”。</p><p><strong>SPOOLing技术（虚拟输入输出设备常用到的技术）先放入到磁盘缓冲区，再放入到设备区，它是在磁盘上开辟响应的区域，所以缓冲区是外存。SPOOLing技术将一台独享打印机改造为可供多个用户共享的打印机。</strong></p><p><strong>SPOOLing技术特点：</strong></p><p>（1）输入井和输出井，在磁盘上开辟出来的两个存储区域，用于存放I/O设备输入的数据和用户程序向设备输出的数据<br>（2）输入缓存区和输出缓冲区，在内存中开辟的两个缓冲区。输入缓冲区用户暂存输入设备送来的数据，再送入输入井；输出缓冲区暂存从输出井送来的数据，再传送到输出设备<br>（3）输入进程和输出京城，负责传输输入输出的数据<br>（4）提高了I/O速度，通过对输入井和输出井的操作，缓和了主机和外设速度不匹配的矛盾<br>（5）设备没有直接和用户进程关联<br>（6）实现虚拟设备，多个进程同时使用一个逻辑设备，每个进程都认为自己独占了设备</p><h2 id="7-微内核"><a href="#7-微内核" class="headerlink" title="7 微内核"></a>7 微内核</h2><p>微内核就是对操作系统进行瘦身，只保留最为基本的功能。普通的操作系统内核包括了进程，存储，设备，文件，任务管理五个部分，而在微内核操作系统中，已对其进行了裁剪，文件系统，通信，外设管理都放到操作系统之外去处理了。</p><p>现代操作系统大多拥有两种工作状态，分别是核心态和用户态。一般应用程序工作在用户态，而内核模块和最基本的操作系统核心工作在核心态。因为在微内核中，核心态功能少了，很多原本属于操作系统的操作放到了用户态去实施了。</p><p>微内核系统的安全性，可靠性得到了提升。微内核操作系统在分布式中有着广泛的应用，它也成为了微内核操作系统的最大优势。</p><p>当然微内核操作系统中，一个任务需要不断的在用户态和核心态直接切换来完成，频繁地切换效率自然不会很高。</p><p>将传统的操作系统代码放置到更高层，从操作系统中去掉尽可能多的东西，而只留下最小的核心，称之为微内核(C/S结构)。</p><table><thead><tr><th></th><th>实质</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>单体内核</td><td>将图形、设备驱动及文件系统等功能全部在内核中实现，运行在内核状态和同一地址空间</td><td>减少进程间通信和状态切换的系统开销，获得较高的运行效率</td><td>内核庞大，占用资源较多且不易剪裁、系统的稳定性和安全性不好</td></tr><tr><td>微内核</td><td>只实现基本功能，将图形系统、文件系统、设备驱动及通信功能放在内核之外</td><td>内核精炼，便于剪裁和移植。系统服务程序运行在用户地址空间，系统的可靠性、稳定性和安全性较高，可用于分布式系统</td><td>用户状态和内核状态需要频繁切换，从而导致系统效率不如单体内核</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>基础技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成与结构</title>
    <link href="/2023/07/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/"/>
    <url>/2023/07/01/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/%E5%9F%BA%E7%A1%80%E6%8A%80%E8%83%BD/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="1-计算机结构"><a href="#1-计算机结构" class="headerlink" title="1 计算机结构"></a>1 计算机结构</h2><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/1.png"></p><h3 id="1-1-CPU组成"><a href="#1-1-CPU组成" class="headerlink" title="1.1 CPU组成"></a>1.1 CPU组成</h3><ol><li><strong>运算器</strong></li></ol><p>① 算术逻辑单元ALU：数据的算术运算和逻辑运算<br>② 累加寄存器AC：通用寄存器， 为ALU提供一个工作区， 用于暂存数据<br>③ 数据缓冲寄存器DR：写内存时，暂存指令或数据<br>④ 状态条件寄存器PSW：存状态标志与控制标志 (争议：也有将其归为控制器的)</p><ol start="2"><li><strong>控制器</strong></li></ol><p>① 程序计数器PC：存储下一条要执行指令的地址<br>② 指令寄存器IR：存储即将执行的指令<br>③ 指令译码器ID：对指令中的操作码字段进行分析解释<br>④ 时序部件：提供时序控制信号</p><h3 id="1-2-冯·诺伊曼机构与哈佛结构"><a href="#1-2-冯·诺伊曼机构与哈佛结构" class="headerlink" title="1.2 冯·诺伊曼机构与哈佛结构"></a>1.2 冯·诺伊曼机构与哈佛结构</h3><p><strong>冯·诺依曼结构</strong><br>冯·诺依曼结构也称普林斯顿结构，是一种将程序指令存储器和数据存储器合并在一<br>起的存储器结构。特点：<br>(1) 一般用于PC处理器，如I3，I5，I7处理器<br>(2) 指令与数据存储器合并在一起<br>(3) 指令与数据都通过相同的数据总线传输</p><p><strong>哈佛结构</strong><br>哈佛结构是一种将程序指令存储和数据存储分开的存储器结构。哈佛结构是一种并<br>行体系结构，它的主要特点是将程序和数据存储在不同的存储空间中，即程序存储<br>器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问。特点：<br>(1) 一般用于嵌入式系统处理器(DSP) 数字信号处理(DSP， Digital Signal Processing)<br>(2) 指令与数据分开存储，可以并行读取，有较高数据的吞吐率<br>(3) 有4条总线：指令和数据的数据总线与地址总线</p><h3 id="1-3-嵌入式芯片"><a href="#1-3-嵌入式芯片" class="headerlink" title="1.3 嵌入式芯片"></a>1.3 嵌入式芯片</h3><table><thead><tr><th></th><th>定义</th><th>简称</th><th>特点</th><th>类比</th></tr></thead><tbody><tr><td>DSP</td><td>称数字信号处理器，是一种特别适合于进行数字信号处理运算的微处理器，其主要应用是实时快速的实现各种数字信号处理算法</td><td>数字信号处理器</td><td>适合数字信号处理运算，实时快速的实现各种数字信号处理算法</td><td>做数学运算的“大脑”</td></tr><tr><td>SoC</td><td>System on Chip，即片上系统，从狭义角度上讲，它是信息系统核心的芯片集成，是将系统关键部件集成在一块芯片上；从广义角度讲，SoC是一个微小型系统，如果说中央处理器CPU是大脑，那么SoC就是包括大脑，心脏，眼睛和手的系统。</td><td>片上系统</td><td>信息系统核心的芯片集成。微小型系统</td><td>包括大脑，心脏，眼睛和手等，完成某个功能的系统</td></tr><tr><td>MPU</td><td>微机中的中央处理器称为微处理器，是构成微机的核心部件，也可以说是微机的心脏，它起到控制整个微型计算机工作的作用，产生控制信号对相应的部件进行控制，并执行相应的操作</td><td>微处理器</td><td>微型机的核心部件，起到控制作用</td><td>缩小版“大脑”</td></tr><tr><td>MCU</td><td>微控制单元，又称单片微型计算机或者单片机，是把中央处理器的频率与规格做适当缩减，并将内存，计算器，USB，A/D转换，UART，PLC，DMA等周边接口，甚至LCD驱动电路都整合在单一芯片上，形成芯片级的计算机，为不同的应用场合做不同组合控制</td><td>单片微型计算机或单片机</td><td>芯片级计算机，对处理器做适当缩减，并将内存，计数器等周边接口整合在单一芯片上，可以为不同的应用场合做不同控制组合</td><td>缩小版“人”</td></tr></tbody></table><h2 id="2-存储系统"><a href="#2-存储系统" class="headerlink" title="2 存储系统"></a>2 存储系统</h2><h3 id="2-1-层次化存储结构"><a href="#2-1-层次化存储结构" class="headerlink" title="2.1 层次化存储结构"></a>2.1 层次化存储结构</h3><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/2.png"></p><h3 id="2-2-Cache"><a href="#2-2-Cache" class="headerlink" title="2.2 Cache"></a>2.2 Cache</h3><ol><li><p>Cache的功能：提高CPU数据输入输出的速率， 突破冯·诺依曼瓶颈， 即CPU与存储系统间数据传送带宽限制。</p></li><li><p>在计算机的存储系统体系中， Cache是访问速度最快的层次。</p></li><li><p>Cache对程序员来说是透明的。</p></li><li><p>使用Cache改善系统性能的依据是程序的局部性原理。<br> 时间局部性<br> 空间局部性</p></li></ol><blockquote><p>时间局部性：指程序中的某条指令一旦执行，不久以后该指令可能再次执行，典型原因是由于程序中存在着大量的循环操作。</p></blockquote><blockquote><p>空间局部性：指一旦程序访问了某个存储单元，不久以后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址可能集中在一定的范围内，其典型情况是程序顺序执行。</p></blockquote><ol start="5"><li>工作集理论：工作集是进程运行时被频繁访问的页面集合。</li></ol><blockquote><p><strong>如果以h代表对Cache的访问命中率， t1表示Cache的周期时间， t2表示主存储器周期时间， 以读操作为例， 使用“Cache + 主存储器” 的系统的平均周期为t3，则</strong>：<br><strong>t3 = h x t1+(1 - h) × t2</strong><br><strong>其中，(1 - h)又称为失效率(未命中率)</strong></p></blockquote><h3 id="2-3-主存编址"><a href="#2-3-主存编址" class="headerlink" title="2.3 主存编址"></a>2.3 主存编址</h3><ol><li><p>存储单元<br> 存储单元个数 = 最大地址-最小地址 + 1</p></li><li><p>编址内容<br> 按字编址：存储体的存储单元是字存储单元，即最小寻址单位是一个字<br> 按字节编址：存储体的存储单元是字节存储单元，即最小寻址单位是一个字节</p></li><li><p>总容量 = 存储单元个数 * 编址内容</p></li><li><p>根据存储器所要求的容量和选定的存储芯片的容量，就可以计算出所需芯片的总数，即：<br> 总片数 = 总容量 / 每片的容量</p></li></ol><h3 id="2-4-磁盘管理"><a href="#2-4-磁盘管理" class="headerlink" title="2.4 磁盘管理"></a>2.4 磁盘管理</h3><p><strong>存取时间 = 寻道时间 + 等待时间</strong><br><strong>寻道时间</strong>是指磁头移动到磁道所需的时间；<br><strong>等待时间</strong>为等待读写的扇区转到磁头下方所用的时间。</p><p><strong>读取磁盘数据的时间应包括以下三个部分：</strong><br>(1) 找磁道的时间。<br>(2) 找块(扇区的时间，即旋转延迟时间。<br>(3) 传输时间。</p><h3 id="2-5-磁盘调度"><a href="#2-5-磁盘调度" class="headerlink" title="2.5 磁盘调度"></a>2.5 磁盘调度</h3><ul><li><strong>先来先服务(FCFS)</strong></li><li><strong>最短寻道时间优先(SSTF)</strong></li><li><strong>扫描算法(SCAN)</strong></li><li><strong>循环扫描(CSCAN)算法</strong></li></ul><h2 id="3-数据传输控制方式"><a href="#3-数据传输控制方式" class="headerlink" title="3 数据传输控制方式"></a>3 数据传输控制方式</h2><ol><li>程序控制（查询）方式：分为无条件传送和程序查询方式两种。方法简单，硬件开销，但IO能力不高，严重影响CPU的利用率</li><li>程序中断方式：与程序控制方式相比，中断方式因为CPU无需等待而提高了传输请求的响应速度</li><li>DMA方式：DMA方式是为了在主存与外设之间实现高速、批量数据交换而设置的。DMA方式比程序控制方式与中断方式都高效，（DMAC向总线裁决逻辑提出总线请求；CPU执行完当前总线周期即可释放总线控制权。此时DMA响应，通过DMAC通知IO接口开始DMA传输）</li><li>通道方式</li><li>IO处理机</li></ol><h2 id="4-总线"><a href="#4-总线" class="headerlink" title="4 总线"></a>4 总线</h2><ul><li><p>一条总线同一时刻仅允许一个设备发送，但允许多个设备接收。所以总线是半双工模式</p></li><li><p>半双工与全双工</p></li><li><p>串行总线与并行总线</p><p>  总线的分类：</p><p>  数据总线(DataBus，DB) ： 在CPU与RAM之间来回传送需要处理或是需要储存的数据。<br>  地址总线(Address Bus， AB) ： 用来指定在RAM (Random Access Memory)之中储存的数据的地址。<br>  控制总线(Control Bus，CB)： 将微处理器控单元(Control Unit))的信号，传送到周边设备</p></li></ul><h2 id="5-CISC与RISC"><a href="#5-CISC与RISC" class="headerlink" title="5 CISC与RISC"></a>5 CISC与RISC</h2><table><thead><tr><th>指令系统类型</th><th>指令</th><th>寻址方式</th><th>实现方式</th><th>其他</th></tr></thead><tbody><tr><td>CISC（复杂）</td><td>数量多，使用频率差别大，可变长格式</td><td>支持多种</td><td>微程序控制技术（微码）</td><td>研制周期长</td></tr><tr><td>RISC（精简）</td><td>数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有Load/Store操作内存</td><td>支持方式少</td><td>增加了通用寄存器；硬布线逻辑控制为主；适合采用流水线</td><td>优化编译，有效支持高级语言</td></tr></tbody></table><h2 id="6-流水线"><a href="#6-流水线" class="headerlink" title="6 流水线"></a>6 流水线</h2><ul><li>相关参数计算：流水线执行时间计算、流水线吞吐率、流水线加速比等。</li><li>流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术。<br>  各种部件同时处理是针对不同指令而言的，它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度。</li></ul><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/3.png"></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/4.png"></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/5.png"></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/6.png"></p><p><img src="/image/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84/7.png"></p><h2 id="7-校验码"><a href="#7-校验码" class="headerlink" title="7 校验码"></a>7 校验码</h2><table><thead><tr><th></th><th>校验码位数</th><th>校验码位置</th><th>检错</th><th>纠错</th><th>校验方式</th></tr></thead><tbody><tr><td>奇偶校验</td><td>1</td><td>一般拼接在头部</td><td>可检奇数位错</td><td>不可纠错</td><td>奇校验：最终1的个数是是奇数个；偶校验：最终1的个数是偶数个；</td></tr><tr><td>CRC循环冗余校验</td><td>生成多项式最高次幂决定</td><td>拼接在信息位尾部</td><td>可检错</td><td>不可纠错</td><td>模2除法求余数，拼接作为校验位</td></tr><tr><td>海明校验</td><td>2^r  &gt;=  m+r+1</td><td>插入在信息位中间(2^k位置)</td><td>可检错</td><td>可纠错</td><td>分组奇偶校验</td></tr></tbody></table><h3 id="7-1-奇偶校验"><a href="#7-1-奇偶校验" class="headerlink" title="7.1 奇偶校验"></a>7.1 奇偶校验</h3><ul><li><strong>奇偶校验码的编码方法是：</strong> 由若干位有效信息(如一个字节)，再加上一个二进制位(校验位)组成校验码。</li><li><strong>奇校验：</strong> 整个校验码(有效信息位和校验位)中“1”的个数为奇数。<br>  <strong>偶校验：</strong> 整个校验码(有效信息位和校验位)中“1”的个数为偶数。</li><li><strong>奇偶校验，可检查1位的错误，不可纠错。</strong></li></ul><h3 id="7-2-CRC循环冗余校验"><a href="#7-2-CRC循环冗余校验" class="headerlink" title="7.2 CRC循环冗余校验"></a>7.2 CRC循环冗余校验</h3><p>CRC的编码方法是：在k位信息码之后拼接r位校验码。应用CRC码的关键是如何从k位信息位简便地得到r位校验位(编码)，以及如何从k+r位信息码判断是否出错。</p><p>循环冗余校验码编码规律如下：<br>①把待编码的N位有效信息表示为多项式M(X)；<br>②把M(X)左移K位，得到M(X)×XK，这样空出了K位，以便拼装K位余数(即校验位)；<br>③选取一个K+1位的产生多项式G(X)，对M(X)×XK做模2除；<br>④把左移K位以后的有效信息与余数R(X) 做模2加减， 拼接为CRC码， 此时的CRC码共有N+K位。</p><p>把接收到的CRC码用约定的生成多项式G(X) 去除， 如果正确， 则余数为0； 如果某一位出错，<br>则余数不为0。不同的位数出错其余数不同，余数和出错位序号之间有唯一的对应关系。</p>]]></content>
    
    
    <categories>
      
      <category>系统架构师</category>
      
      <category>基础技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统架构师</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/2023/06/20/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2023/06/20/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1 实现原理"></a>1 实现原理</h2><p>当向线程池提交一个任务之后，线程池的处理流程如下：</p><ol><li><p>判断是否达到核心线程数，若未达到，则直接创建新的线程处理当前传入的任务，否则进入下个流程</p></li><li><p>线程池中的工作队列是否已满，若未满，则将任务丢入工作队列中先存着等待处理，否则进入下个流程</p></li><li><p>是否达到最大线程数，若未达到，则创建新的线程处理当前传入的任务，否则交给线程池中的饱和策略进行处理。</p></li></ol><p><img src="/image/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg" alt="处理流程"></p><h2 id="2-java中的线程池"><a href="#2-java中的线程池" class="headerlink" title="2 java中的线程池"></a>2 java中的线程池</h2><p>jdk中提供了线程池的具体实现，实现类是：java.util.concurrent.ThreadPoolExecutor，主要构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                              TimeUnit unit,</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                              ThreadFactory threadFactory,</span><br><span class="hljs-params">                              RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure><p><strong>corePoolSize</strong>：核心线程大小，当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使有其他空闲线程可以处理任务也会创新线程，等到工作的线程数大于核心线程数时就不会在创建了。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前把核心线程都创造好，并启动。</p><p><strong>maximumPoolSize</strong>：线程池允许创建的最大线程数。如果队列满了，并且以创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果使用了无界队列，那么所有的任务会加入队列，这个参数就没有什么效果了。</p><p><strong>keepAliveTime</strong>：线程池的工作线程空闲后，保持存活的时间。如果没有任务处理了，有些线程会空闲，空闲的时间超过了这个值，会被回收掉。如果任务很多，并且每个任务的执行时间比较短，避免线程重复创建和回收，可以调大这个时间，提高线程的利用率。</p><p><strong>unit</strong>：keepAliveTime的时间单位，可以选择的单位有天、小时、分钟、毫秒、微妙、千分之一毫秒和纳秒。类型是一个枚举java.util.concurrent.TimeUnit，这个枚举也经常使用。</p><p><strong>workQueue</strong>：工作队列，用于缓存待处理任务的阻塞队列，常见的有4种。</p><p><strong>threadFactory</strong>：线程池中创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</p><p><strong>handler</strong>：饱和策略，当线程池无法处理新来的任务了，那么需要提供一种策略处理提交的新任务，默认有4种策略。</p><h2 id="3-饱和策略"><a href="#3-饱和策略" class="headerlink" title="3 饱和策略"></a>3 饱和策略</h2><p>当线程池中队列已满，并且线程池已达到最大线程数，线程池会将任务传递给饱和策略进行处理。这些策略都实现了RejectedExecutionHandler接口。接口中有个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 参数说明：r：需要执行的任务;executor：当前线程池对象</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedException</span><span class="hljs-params">(Runnable r, ThreadPoolExcutor executor)</span><br></code></pre></td></tr></table></figure><p>JDK中提供了4种常见的饱和策略:</p><p>​    （1）AbortPolicy：直接抛出异常</p><p>​    （2）CallerRunsPolicy：在当前调用者的线程中运行任务，即随丢来的任务，由他自己去处理</p><p>​    （3）DiscardOldestPolicy：丢弃队列中最老的一个任务，即丢弃队列头部的一个任务，然后执行当前传入的任务</p><p>​    （4）DiscardPolicy：不处理，直接丢弃掉，方法内部为空</p><h2 id="4-关闭方法"><a href="#4-关闭方法" class="headerlink" title="4 关闭方法"></a>4 关闭方法</h2><p>原理：遍历线程池中的所有线程，然后逐个调用线程的interrupt方法来中断线程。</p><p>线程池提供了2个关闭方法：shutdown和shutdownNow，当调用者两个方法之后，线程池会遍历内部的工作线程，然后调用每个工作线程的interrrupt方法给线程发送中断信号，内部如果无法响应中断信号的可能永远无法终止，所以如果内部有无线循环的，最好在循环内部检测一下线程的中断信号，合理的退出。调用者两个方法中任意一个，线程池的isShutdown方法就会返回true，当所有的任务线程都关闭之后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。</p><p>调用shutdown方法之后，线程池将不再接口新任务，内部会将所有已提交的任务处理完毕，处理完毕之后，工作线程自动退出。</p><p>而调用shutdownNow方法后，线程池会将还未处理的（在队里等待处理的任务）任务移除，将正在处理中的处理完毕之后，工作线程自动退出。</p><p>至于调用哪个方法来关闭线程，应该由提交到线程池的任务特性决定，多数情况下调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p><h2 id="5-合理配置线程池"><a href="#5-合理配置线程池" class="headerlink" title="5 合理配置线程池"></a>5 合理配置线程池</h2><p>要想合理的配置线程池，需要先分析任务的特性，可以冲一下几个角度分析：</p><p>​    （1）任务的性质：CPU密集型任务、IO密集型任务和混合型任务</p><p>​    （2）任务的优先级：高、中、低</p><p>​    （3）任务的执行时间：长、中、短</p><p>​    （4）任务的依赖性：是否依赖其他的系统资源，如数据库连接。</p><p>性质不同任务可以用不同规模的线程池分开处理。CPU密集型任务应该尽可能小的线程，如配置cpu数量+1个线程的线程池。由于IO密集型任务并不是一直在执行任务，不能让cpu闲着，则应配置尽可能多的线程，如：cup数量*2。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这2个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。可以通过Runtime.getRuntime().availableProcessors()方法获取cpu数量。优先级不同任务可以对线程池采用优先级队列来处理，让优先级高的先执行。使用队列的时候建议使用有界队列，有界队列增加了系统的稳定性，如果采用无界队列，任务太多的时候可能导致系统OOM，直接让系统宕机。</p><h2 id="6-JDK中的实现的四种线程池"><a href="#6-JDK中的实现的四种线程池" class="headerlink" title="6 JDK中的实现的四种线程池"></a>6 JDK中的实现的四种线程池</h2><p>Java通过Executors提供四种线程池，分别为：</p><ol><li>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** </span><br><span class="hljs-comment">*核心线程数 0</span><br><span class="hljs-comment">*最大线程数 Integer.MAX_VALUE</span><br><span class="hljs-comment">*一个线程如果在60s还没有被使用的话会被移除线程池</span><br><span class="hljs-comment">*阻塞队列使用SynchronousQueue</span><br><span class="hljs-comment">*使用中断的拒绝策略</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE, <span class="hljs-number">60L</span>, <br>                              TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>特点：</p><p>（1）按需创建新的线程，如果没有可用线程则创建新的线程,之前用过的线程可能会再次被使用；</p><p>（2）因为空闲线程会被移除线程池，因此，如果线程池长时间不被使用也不会消耗系统资源；</p></blockquote><ol start="2"><li>newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** </span><br><span class="hljs-comment">*核心线程数=最大线程数=参数nThread</span><br><span class="hljs-comment">*阻塞队列使用LinkedBlockingQueue，一个共享的无界队列</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="hljs-number">0L</span>, <br>                              TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>特点：</p><p>（1）在任何情况下最多只有nThread个线程工作，多余的Task将会被存放到队列中等待；</p><p>（2）如果线程在执行任务中被终止，终止之前会创建其他的线程代替原来的；</p><p>（3）线程将会一直存在在线程池中，直到调用shutDown()方法</p></blockquote><ol start="3"><li>newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** </span><br><span class="hljs-comment">*核心线程数：通过参数指定corePoolSize</span><br><span class="hljs-comment">*最大线程数 Integer.MAX_VALUE</span><br><span class="hljs-comment">*超过corePoolSize的线程在执行完任务后即终止</span><br><span class="hljs-comment">*阻塞队列使用DelayedWorkQueue</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span>&#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0L</span>, NANOSECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayWorkQueue</span>());<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>特点：</p><p>（1）核心线程数将会一直存在线程池中，除非设置了allowCoreThreadTimeOut</p><p>（2）可以设置线程的执行时间</p></blockquote><ol start="4"><li>newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** </span><br><span class="hljs-comment">*线程池中最多同时只有一个线程活跃</span><br><span class="hljs-comment">*同一时刻只有一个任务执行</span><br><span class="hljs-comment">*多余的任务放在LinkedBlockingQueue中</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadPool</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizeableDelegatedExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0L</span>, <br>                              TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-源码分析"><a href="#7-源码分析" class="headerlink" title="7 源码分析"></a>7 源码分析</h2><h3 id="7-1-内部状态"><a href="#7-1-内部状态" class="headerlink" title="7.1 内部状态"></a>7.1 内部状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span>   <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// runState is stored in the high-order bits</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br><br><span class="hljs-comment">// Packing and unpacking ctl</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br></code></pre></td></tr></table></figure><p>其中AtomicInteger变量ctl的功能非常强大：利用低29位表示线程池中线程数，通过高3位表示线程池的运行状态：</p><ol><li><p>RUNNING：-1 &lt;&lt; COUNT_BITS，即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；</p></li><li><p>SHUTDOWN： 0 &lt;&lt; COUNT_BITS，即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</p></li><li><p>STOP ： 1 &lt;&lt; COUNT_BITS，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</p></li><li><p>TIDYING ： 2 &lt;&lt; COUNT_BITS，即高3位为010, 所有的任务都已经终止；</p></li><li><p>TERMINATED： 3 &lt;&lt; COUNT_BITS，即高3位为011, terminated()方法已经执行完成</p></li></ol><h3 id="7-2-任务执行"><a href="#7-2-任务执行" class="headerlink" title="7.2 任务执行"></a>7.2 任务执行</h3><p>execute –&gt; addWorker –&gt;runworker （getTask）</p><p>线程池的工作线程通过Woker类实现，在ReentrantLock锁的保证下，把Woker实例插入到HashSet后，并启动Woker中的线程。</p><p>从Woker类的构造方法实现可以发现：线程工厂在创建线程thread时，将Woker实例本身this作为参数传入，当执行start方法启动线程thread时，本质是执行了Worker的runWorker方法。firstTask执行完成之后，通过getTask方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask方法会被阻塞并挂起，不会占用cpu资源； </p><h4 id="7-2-1-execute"><a href="#7-2-1-execute" class="headerlink" title="7.2.1 execute()"></a>7.2.1 execute()</h4><p>ThreadPoolExecutor.execute(task)实现了Executor.execute(task)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><span class="hljs-keyword">if</span>(workerCountOf(c) &lt; corePoolSize)&#123;<br>    <span class="hljs-comment">//workerCountOf获取线程池的当前线程数，小于corePoolSize,执行addWorker创建新线程执行command任务</span><br>    <span class="hljs-keyword">if</span>(addWorker(command, <span class="hljs-literal">true</span>))<br>        <span class="hljs-keyword">return</span>;<br>    c = ctl.get();<br>&#125;<br><span class="hljs-comment">//double check: c, recheck</span><br><span class="hljs-comment">//线程池处于RUNNING状态，把提交的任务成功放入阻塞队列中</span><br><span class="hljs-keyword">if</span>(isRunning() &amp;&amp; workQueue.offer(command))&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-comment">//recheck and if necessary 回滚到入队操作前，即倘若线程池shutdown状态，就remove(command)</span><br>    <span class="hljs-comment">//如果线程池没有RUNNING，成功从阻塞队列中删除任务，执行reject方法处理任务</span><br>    <span class="hljs-keyword">if</span>(!isRunning(recheck) &amp;&amp; remove(command))<br>        reject(command);<br>    <span class="hljs-comment">//线程池处于running状态，但是没有线程，则创建线程</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-comment">//线程池中创建新的线程失败，则reject任务</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>    reject(command);<br></code></pre></td></tr></table></figure><p>在多线程环境下，线程池的状态时刻在变化，而ctl.get()是非原子操作，很有可能刚获取了线程池状态后线程池状态就改变了。判断是否将command加入workque是线程池之前的状态。倘若没有double check，万一线程池处于非running状态（在多线程环境下很有可能发生），那么command永远不会执行。</p><h4 id="7-2-2-addWorker"><a href="#7-2-2-addWorker" class="headerlink" title="7.2.2 addWorker()"></a>7.2.2 addWorker()</h4><p>做了两件事：（1）循环CAS操作来将线程数加1；（2）新建一个线程并启用。</p><p>从方法execute的实现可以看出：addWorker主要负责创建新的线程并执行任务，线程池创建新线程执行任务时，需要获取全局锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>    retry;<br>    <span class="hljs-keyword">for</span>(;;)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runstateOf(c);<br>        <br>        <span class="hljs-comment">//是否能够添加工作线程</span><br>        <span class="hljs-comment">//判断线程池的状态，如果线程池的状态值大于或等SHUTDOWN，则不处理提交的任务，直接返回</span><br>        <span class="hljs-keyword">if</span>(rs &gt;= SHUTDOWN &amp;&amp;<br>           !(rs == SHUTDOWN &amp;&amp;<br>             firstTask == <span class="hljs-literal">null</span> &amp;&amp;<br>             !workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-comment">/** 做自旋，更新创建线程数量</span><br><span class="hljs-comment">        *  通过参数core判断当前需要创建的线程是否为核心线程，如果core为true，且当前线程数小于corePoolSize，</span><br><span class="hljs-comment">        *  则跳出循环，开始创建新的线程。</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">for</span>(;;)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workereCountOf(c);<br>            <span class="hljs-keyword">if</span>(wc &gt;= CAPACITY ||<br>               wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            <span class="hljs-keyword">if</span>(runstateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>        <span class="hljs-keyword">if</span>(t != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br>                <span class="hljs-comment">//添加线程到workers中(线程池中)。</span><br>                <span class="hljs-keyword">if</span>(rs &lt; SHUTDOWN ||<br>                   (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>))&#123;<br>                    <span class="hljs-keyword">if</span>(t.isAlive())<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStataeException</span>();<br>                    workers.add(w);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                    <span class="hljs-keyword">if</span>(s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unLock();<br>            &#125;<br>            启动新建的线程。<br>            <span class="hljs-keyword">if</span>(workerAdded)&#123;<br>                t.start();<br>                workerStarted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (!workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其中workers是一个hashSet。所以，线程池底层的存储结构其实就是一个HashSet。</strong></p><h4 id="7-2-3-runWorker"><a href="#7-2-3-runWorker" class="headerlink" title="7.2.3 runWorker"></a>7.2.3 runWorker</h4><p>runWorker方法是线程池的核心：</p><ol><li><p>线程启动之后，通过unlock方法释放锁，设置AQS的state为0，表示运行可中断；</p></li><li><p>Worker执行firstTask或从workQueue中获取任务：</p></li></ol><p>2.1 进行加锁操作，保证thread不被其他线程中断（除非线程池被中断）</p><p>2.2 检查线程池状态，倘若线程池处于中断状态，当前线程将中断。</p><p>2.3 执行beforeExecute</p><p>2.4 执行任务的run方法</p><p>2.5 执行afterExecute方法</p><p>2.6 解锁操作</p><p>通过getTask方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask方法会被阻塞并挂起，不会占用cpu资源；</p><h4 id="7-2-4-getTask"><a href="#7-2-4-getTask" class="headerlink" title="7.2.4 getTask"></a>7.2.4 getTask</h4><p>allowCoreThreadTimeOut为false，线程即使空闲也不会被销毁；倘若为ture，在keepAliveTime内仍空闲则会被销毁。</p><p>如果线程允许空闲等待而不被销毁timed == false，workQueue.take任务：如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take方法返回任务，并执行；</p><p>如果线程不允许无休止空闲timed == true, workQueue.poll任务：如果在keepAliveTime时间内，阻塞队列还是没有任务，则返回null；</p><h3 id="7-3-任务提交"><a href="#7-3-任务提交" class="headerlink" title="7.3 任务提交"></a>7.3 任务提交</h3><p><img src="/image/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/1.png"></p><p>在实际业务场景中，Future和Callable基本是成对出现的，Callable负责产生结果，Future负责获取结果。</p><p>​    1. Callable接口类似于Runnable，只是Runnable没有返回值;</p><p>​    2. Callable任务除了返回正常结果之外，如果发生异常，该异常也会被返回，即Future可以拿到异步执行任务各种结果；</p><p>​    3. Future.get方法会导致主线程阻塞，直到Callable任务执行完成；</p><h4 id="7-3-1-submit"><a href="#7-3-1-submit" class="headerlink" title="7.3.1 submit"></a>7.3.1 submit</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// submit方法在AbstractExecutorService中的实现</span><br><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task)&#123;<br>    <span class="hljs-keyword">if</span>(task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointException</span>();<br>    <span class="hljs-comment">//通过submit方法提交的Callable任务会被封装成了一个FutureTask对象</span><br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-literal">null</span>);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过submit方法提交的Callable任务会被封装成了一个FutureTask对象。通过Executor.execute方法提交FutureTask到线程池中等待被执行，最终执行的是FutureTask的run方法；</p><h4 id="7-3-2-FutureTask对象"><a href="#7-3-2-FutureTask对象" class="headerlink" title="7.3.2 FutureTask对象"></a>7.3.2 FutureTask对象</h4><p><strong>内部状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NEW</span>          <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMPLETING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>       <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span>  <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>    <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTING</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><p><strong>get方法：</strong>内部通过<strong>awaitDone</strong>方法对主线程进行阻塞:</p><ol><li><p>如果主线程被中断，则抛出中断异常；</p></li><li><p>判断FutureTask当前的state，如果大于COMPLETING，说明任务已经执行完成，则直接返回；</p></li><li><p>如果当前state等于COMPLETING，说明任务已经执行完，这时主线程只需通过yield方法让出cpu资源，等待state变成NORMAL；</p></li><li><p>通过WaitNode类封装当前线程，并通过UNSAFE添加到waiters链表；</p></li><li><p>最终通过LockSupport的park或parkNanos挂起线程；</p></li></ol><p><strong>run方法：</strong></p><p>FutureTask.run方法是在线程池中被执行的，而非主线程</p><ol><li><p>通过执行Callable任务的call方法；</p></li><li><p>如果call执行成功，则通过set方法保存结果；</p></li><li><p>如果call执行有异常，则通过setException保存异常；</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="/2023/06/20/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/ConcurrentHashMap/"/>
    <url>/2023/06/20/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/ConcurrentHashMap/</url>
    
    <content type="html"><![CDATA[<h2 id="1-JDK8版本的改进"><a href="#1-JDK8版本的改进" class="headerlink" title="1 JDK8版本的改进"></a>1 JDK8版本的改进</h2><p>在jdk1.7版本中，ConcurrentHashMap由数组+Segment+分段锁实现，其内部分为一个个段（Segment）数组，Segment通过继承ReentrantLock来进行加锁，通过每次锁住一个Segment来降低锁的粒度而且保证了每个Segment内的操作的线程安全性，从而实现全局线程安全。</p><p><img src="/image/%E5%A4%9A%E7%BA%BF%E7%A8%8B/ConcurrentHashMap/1.png"></p><p>但是这么做的缺陷就是每次通过 hash 确认位置时需要 2 次才能定位到当前 key 应该落在哪个槽：</p><ol><li><p>通过 hash 值和 段数组长度-1 进行位运算确认当前 key 属于哪个段，即确认其在 segments 数组的位置。</p></li><li><p>再次通过 hash 值和 table 数组（即 ConcurrentHashMap 底层存储数据的数组）长度 - 1进行位运算确认其所在桶。</p></li></ol><p>为了进一步优化性能，在 jdk1.8 版本中，对 ConcurrentHashMap 做了优化，取消了分段锁的设计，取而代之的是通过 cas 操作和 synchronized 关键字来实现优化（synchronized锁住的是Node节点），而扩容的时候也利用了一种分而治之的思想来提升扩容效率，在 JDK1.8 中 ConcurrentHashMap 的存储结构和 HashMap 基本一致，如下图所示：</p><p><img src="/image/%E5%A4%9A%E7%BA%BF%E7%A8%8B/ConcurrentHashMap/2.png"></p><h2 id="2-为什么key和value不允许为null"><a href="#2-为什么key和value不允许为null" class="headerlink" title="2 为什么key和value不允许为null"></a>2 为什么key和value不允许为null</h2><p>在 HashMap 中，key 和 value 都是可以为 null 的，但是在 ConcurrentHashMap 中却不允许。</p><p>作者 Doug Lea 本身对这个问题有过回答，在并发编程中，null 值容易引来歧义， 假如先调用 get(key) 返回的结果是 null，那么无法确认是因为当时这个 key 对应的 value 本身放的就是 null，还是说这个 key 值根本不存在，这会引起歧义，如果在非并发编程中，可以进一步通过调用 containsKey 方法来进行判断，但是并发编程中无法保证两个方法之间没有其他线程来修改 key 值，所以就直接禁止了 null 值的存在。</p><p>而且作者 Doug Lea 本身也认为，假如允许在集合，如 map 和 set 等存在 null 值的话，即使在非并发集合中也有一种公开允许程序中存在错误的意思，这也是 Doug Lea 和 Josh Bloch（HashMap作者之一） 在设计问题上少数不同意见之一，而 ConcurrentHashMap 是 Doug Lea 一个人开发的，所以就直接禁止了 null 值的存在。</p><h2 id="3-ConcurrentHashMap如何保证线程的安全性"><a href="#3-ConcurrentHashMap如何保证线程的安全性" class="headerlink" title="3 ConcurrentHashMap如何保证线程的安全性"></a>3 ConcurrentHashMap如何保证线程的安全性</h2><p>在 ConcurrentHashMap 中，采用了大量的分而治之的思想来降低锁的粒度，提升并发性能。其源码中大量使用了cas 操作来保证安全性，而不是和 HashTable 一样，不论什么方法，直接简单粗暴的使用 synchronized关键字来实现。</p><h3 id="3-1-如何用CAS保证数组初始化的安全"><a href="#3-1-如何用CAS保证数组初始化的安全" class="headerlink" title="3.1 如何用CAS保证数组初始化的安全"></a>3.1 如何用CAS保证数组初始化的安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K, V&gt;[] initTable()&#123;<br>    Node&lt;K, V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-keyword">while</span>((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>((sc = sizeCtl) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">//有线程在扩容，让出cpu</span><br>            Thread.<span class="hljs-keyword">yield</span>();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">//将sizeCtl改为-1，表示正在扩容</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span>((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//首次初始化之后会对sc赋值为下一次扩容的大小</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    Node&lt;K, V&gt;[] nt = (Node&lt;K, V&gt;[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?, ?&gt;[n];<br>                    table = tab = nt;<br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>); <span class="hljs-comment">//计算下次扩容的大小，即：当前容量的3/4</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sizeCtl = sc; <span class="hljs-comment">//将sc赋值给sizeCtl</span><br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面有一个非常重要的变量 sizeCtl，这个变量对理解整个 ConcurrentHashMap 的原理非常重要。sizeCtl 有四个含义：</p><p>​       sizeCtl&lt;-1 表示有 N-1 个线程正在执行扩容操作，如 -2 就表示有 2-1 个线程正在扩容。</p><p>​       sizeCtl=-1 占位符，表示当前正在初始化数组。</p><p>​       sizeCtl=0 默认状态，表示数组还没有被初始化。</p><p>​       sizeCtl&gt;0 记录下一次需要扩容的大小。</p><p>第二个分支采用了 CAS 操作，因为 SIZECTL 默认为 0，所以这里如果可以替换成功，则当前线程可以执行初始化操作，CAS 失败，说明其他线程抢先一步把 sizeCtl 改为了 -1。扩容成功之后会把下一次扩容的阈值赋值给sc，即 sizeCtl。</p><h3 id="3-2-put操作如何保证数组元素的可见性"><a href="#3-2-put操作如何保证数组元素的可见性" class="headerlink" title="3.2 put操作如何保证数组元素的可见性"></a>3.2 put操作如何保证数组元素的可见性</h3><p>ConcurrentHashMap 中存储数据采用的 Node 数组是采用了 volatile 来修饰的，但是这只能保证数组的引用在不同线程之间是可用的，并不能保证数组内部的元素在各个线程之间也是可见的，所以判定某一个桶是否有元素，并不能直接通过下标来访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> sprerad(key.hashCode()); <span class="hljs-comment">//获取hash值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//记录链表长度</span><br>    <span class="hljs-keyword">for</span> (Node&lt;K, V&gt;[] tab = table;;) &#123; <span class="hljs-comment">//自旋</span><br>        Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br>        <span class="hljs-keyword">if</span>(tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>) <span class="hljs-comment">//数组没有初始化</span><br>            tab = initTable(); <span class="hljs-comment">//初始化数组</span><br>        <span class="hljs-comment">//tabAt为null表示当前位置没有元素，采用Unsafe方法获取元素而不是直接tab[i]</span><br>        <span class="hljs-comment">//volatile修饰数组只针对数组的引用保证可见，对内部元素则不一定</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n-<span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//cas操作去put，如果cas失败说明其他线程抢先去操作，继续自旋(for循环)</span><br>            <span class="hljs-keyword">if</span>(casTabAt(tab, i, <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>            tab = helpTransfer(tab, f);<br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//当前下标已经有元素</span><br><span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">//这里就相当于每次只锁住一个下标，锁的粒度更细了。所以最多可以支持的并发数比1.7版本的分段设计更多了</span><br>            <span class="hljs-keyword">synchronized</span> (f) &#123; <span class="hljs-comment">//锁住f节点，即当前链表或者红黑树的头节点</span><br>            <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//这里要判断是否大于等于0是因为如果当前线程已经被转移了，hash值会被改为负数</span><br>                    binCount = <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                            K ek;<br>                            <span class="hljs-keyword">if</span>(e.hash == hash &amp;&amp;<br>                               ((ek = e.key) == key ||<br>                                (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek))))&#123;<br>                                oldVal = e.val;<br>                                <span class="hljs-keyword">if</span>(!onlyIfAbsent)<br>                                    e.val = value;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            ...<br>                        &#125;<br>                        ...<br>                    &#125;<br>                    ...<br>                &#125;<br>                ...<br>            &#125;<br>            ...<br>        &#125;<br>    &#125;<br>    addCount(<span class="hljs-number">1L</span>, binCount);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//tableAt 方法实际上就是一个 CAS 操作</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="hljs-title function_">tabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-keyword">return</span> (Node&lt;K,V&gt;) U.getObjectVolatile(tab, ((<span class="hljs-type">long</span>) i &lt;&lt; ASHIFT) + ABASE);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-精妙的计算方式"><a href="#3-3-精妙的计算方式" class="headerlink" title="3.3 精妙的计算方式"></a>3.3 精妙的计算方式</h3><p>在 HashMap 中，调用 put 方法之后会通过 ++size 的方式来存储当前集合中元素的个数，但是在并发模式下，这种操作是不安全的，所以不能通过这种方式。直接通过 CAS 操作来修改 size 是可行的，但是假如同时有非常多的线程要修改 size 操作，那么只会有一个线程能够替换成功，其他线程只能不断的尝试 CAS，这会影响到 ConcurrentHashMap 集合的性能，所以作者就想到了一个分而治之的思想来完成计数。作者定义了一个数组来计数，而且这个用来计数的数组也能扩容，每次线程需要计数的时候，都通过随机的方式获取一个数组下标的位置进行操作，这样就可以尽可能的降低了锁的粒度，最后获取 size 时，则通过遍历数组来实现计数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用来计数的数组，大小为2的N次幂，默认为2</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> ConuterCell[] counterCells;<br><br><span class="hljs-meta">@sun</span>.misc.Contended <span class="hljs-keyword">static</span> fianl <span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterCell</span> &#123; <span class="hljs-comment">//数组中的对象</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> value; <span class="hljs-comment">//存储元素个数</span><br>    CounterCell(<span class="hljs-type">long</span> x) &#123; value = x; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>addCount计数方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCount</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">int</span> check)</span>&#123;<br>    CounterCell[] as; <span class="hljs-type">long</span> b, s;<br>    <span class="hljs-comment">/** CounterCell数组是否为空，如果不为空，则尝试通过cas操作将baseCount加上x，如果发现BASECOUNT和baseCount不相等，</span><br><span class="hljs-comment">    *   则说明当前存在锁竞争，所以需要改用CountCell来计数，（baseCount只有在没有线程竞争时用来计数）</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span>((as = counterCells) != <span class="hljs-literal">null</span> || !U.compareAndSwapLong(<span class="hljs-built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;<br>        CounterCell a; <span class="hljs-type">long</span> v; <span class="hljs-type">int</span> m;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">uncontended</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//true表示没有线程竞争</span><br>        <span class="hljs-comment">//CounterCell计数数组为空，则直接调用fullAddCount</span><br>        <span class="hljs-keyword">if</span> (as == <span class="hljs-literal">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>            <span class="hljs-comment">//Random在线程并发的时候会有性能问题以及可能会产生相同的随机数，性能也没有ThreadLocalRandom.getProbe好</span><br>            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||<br>            <span class="hljs-comment">//通过CAS操作会修改当前数组下标中对应的计数，如果修改失败则表示有线程竞争</span><br>            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;<br>            <span class="hljs-comment">//内部包含CounterCell的扩容，初始化等操作</span><br>            fullAddCount(x, uncontended);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ...    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先会判断 CounterCell 数组是不是为空，这里的 CAS 操作是将 BASECOUNT 和 baseCount 进行比较，如果相等，则说明当前没有其他线程过来修改 baseCount（即 CAS 操作成功），此时则不需要使用 CounterCell 数组，而直接采用 baseCount 来计数。</p><p>假如 CounterCell 为空且 CAS 失败，那么就会通过调用 fullAddCount 方法来对 CounterCell 数组进行初始化。</p><p><strong>fullAddCount方法</strong></p><p>这个方法也很长，里面包含了对 CounterCell 数组的初始化和赋值等操作。</p><ol><li><strong>初始化CountCell数组：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; counterCells == as &amp;&amp; <br>        U.compareAndSwapInt(<span class="hljs-built_in">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))&#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;  <span class="hljs-comment">// Initialize table</span><br>        <span class="hljs-keyword">if</span> (counterCells == as) &#123;<br>            CounterCell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">//默认构造一个长度为2的数组</span><br>            rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>(x); <span class="hljs-comment">//计算下标（h是一个随机数，x表示添加元素的数量）</span><br>            counterCells = rs;<br>            init = <span class="hljs-literal">true</span>; <span class="hljs-comment">//初始化完成标志</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        cellsBusy = <span class="hljs-number">0</span>; <span class="hljs-comment">//恢复cellsBusy标识</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面有一个比较重要的变量 cellsBusy，默认是 0，表示当前没有线程在初始化或者扩容，所以这里判断如果 cellsBusy==0，而 as 其实在前面就是把全局变量 CounterCell 数组的赋值，这里之所以再判断一次就是再确认有没有其他线程修改过全局数组 CounterCell，所以条件满足的话就会通过 CAS 操作修改 cellsBusy 为 1，表示当前自己在初始化了，其他线程就不能同时进来初始化操作了。</p><p>最后可以看到，默认是一个长度为 2 的数组，也就是采用了 2 个数组位置进行存储当前 ConcurrentHashMap 的元素数量。</p><ol start="2"><li><strong>CountCell如何赋值</strong></li></ol><p>初始化完成之后，如果再次调用 put 方法，那么就会进入 fullAddCount 方法的另一个分支：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (;;) &#123;<br>    CounterCell[] as; CounterCell a; <span class="hljs-type">int</span> n; <span class="hljs-type">long</span> v;<br>    <span class="hljs-comment">//CounterCell不为空，则表示已经初始化</span><br>    <span class="hljs-keyword">if</span> ((as = counterCells) != <span class="hljs-literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//获得当前使用CounterCell，数组的下标</span><br>        <span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//当前位置还没有设置数量</span><br>            <span class="hljs-comment">//cellsBusy=0表示CounterCell没有初始化</span><br>            <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">CounterCell</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>(x);<br>                <span class="hljs-comment">//cellBusy由0改为1表示有线程正在操作CounterCell数组</span><br>                <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp;<br>                    U.compareAndSwapInt(<span class="hljs-built_in">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                    <span class="hljs-type">boolean</span> <span class="hljs-variable">created</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">//计算下标，并将CounterCell对象放到CounterCell[]数组对应下标</span><br>                        CounterCell[] rs; <span class="hljs-type">int</span> m, j;<br>                        <span class="hljs-keyword">if</span> ((rs = counterCells) != <span class="hljs-literal">null</span> &amp;&amp;<br>                            (m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                            rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-literal">null</span>) &#123;<br>                            rs[j] = r;<br>                            created = <span class="hljs-literal">true</span>; <span class="hljs-comment">//是否创建成功标记设置为true</span><br>                        &#125;<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        cellsBusy = <span class="hljs-number">0</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面首先判断了 CounterCell 数组不为空，然后会再次判断数组中的元素是不是为空，因为如果元素为空，就需要初始化一个 CounterCell 对象放到数组，而如果元素不为空，则只需要 CAS 操作替换元素中的数量即可。所以这里面的逻辑也很清晰，初始化 CounterCell 对象的时候也需要将 cellBusy 由 0 改成 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如果当前位置的元素不为空，则通过cas操作加上数量</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))<br>    <span class="hljs-keyword">break</span>;<br><span class="hljs-comment">//两个不相等代表有其他线程创建了新的CounterCell数组</span><br><span class="hljs-comment">//或者当前CounterCell数组大小已经大于等于CPU数量（保证并发数不会操作CPU数量）</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (counterCells != as || n &gt;= NCPU)<br>    <span class="hljs-comment">//设置当前线程的循环失败不进行扩容</span><br>    collide = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)<br>    collide = <span class="hljs-literal">true</span>; <span class="hljs-comment">//恢复collide状态，下次循环可继续扩容</span><br><span class="hljs-comment">//如果进入这个分支，则说明当前竞争压力过大，需要对CounterCell数组进行扩容</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp;<br>        U.compareAndSwapInt(<span class="hljs-built_in">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//再次判断是否相等，相等表示当前没有其他线程扩容CounterCell数组</span><br>        <span class="hljs-keyword">if</span> (counterCells == as) &#123;<br>            CounterCell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>[n &lt;&lt; <span class="hljs-number">1</span>]; <span class="hljs-comment">//扩容大小为扩大2倍</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-comment">//迁移数据</span><br>                rs[i] = as[i];<br>            coountCells = rs;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        cellsBusy = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要看上述代码最后一个分支，一旦会进入这个分支，就说明前面所有分支都不满足，即：</p><p>​       当前 CounterCell 数组已经初始化完成。</p><p>​       当前通过 hash 计算出来的 CounterCell 数组下标中的元素不为 null。</p><p>​       直接通过 CAS 操作修改 CounterCell 数组中指定下标位置中对象的数量失败，说明有其他线程在竞争修改同一个数组下标中的元素。</p><p>​       当前操作不满足不允许扩容的条件。</p><p>​       当前没有其他线程创建了新的 CounterCell 数组，且当前 CounterCell 数组的大小仍然小于 CPU 数量。</p><p>所以接下来就需要对 CounterCell 数组也进行扩容，这个扩容的方式和 ConcurrentHashMap 的扩容一样，也是将原有容量乘以 2，所以其实 CounterCell 数组的容量也是满足 2 的 N 次幂。</p><h3 id="3-4-ConcurrentHashMap扩容"><a href="#3-4-ConcurrentHashMap扩容" class="headerlink" title="3.4 ConcurrentHashMap扩容"></a>3.4 ConcurrentHashMap扩容</h3><p>接下来回到 addCount 方法，因为这个方法在添加元素数量的同时，也会判断当前 ConcurrentHashMap 的大小是否达到了扩容的阈值，如果达到，需要扩容。ConcurrentHashMap 扩容也支持多线程同时进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (check &gt;= <span class="hljs-number">0</span>) &#123;<br>Node&lt;K,V&gt;[] tab, nt; <span class="hljs-type">int</span> n, sc;<br><span class="hljs-keyword">while</span> (s &gt;= (<span class="hljs-type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="hljs-literal">null</span> &amp;&amp;<br>           (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> resizeStamp(n); <span class="hljs-comment">//获取扩容戳</span><br><span class="hljs-keyword">if</span> (sc &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="hljs-number">1</span> || <br>                sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="hljs-literal">null</span> || <br>                transferIndex &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, sc + <span class="hljs-number">1</span>))<br>                transfer(tab, nt);<br>         &#125;<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="hljs-number">2</span>))<br>             transfer(tab, <span class="hljs-literal">null</span>);<br>         s = sumCount();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 check 是传进来的链表长度，&gt;=0 才开始检查是否需要扩容，紧挨之后是一个 while 循环，主要是满足两个条件：</p><ol><li><p>sizeCtl在初始化的时候会被赋值为下一次扩容的大小（扩容之后也会），所以 &gt;=sizeCtl 表示的就是是否达到扩容阈值。</p></li><li><p>table 不为 null 且当前数组长度小于最大值 2 的 30 次方。</p></li></ol><p><strong>扩容戳有什么用：</strong>当满足扩容条件之后，首先会先调用一个方法来获取扩容戳，这个扩容戳比较有意思，要理解扩容戳，必须从二进制的角度来分析。resizeStamp 方法就一句话，其中 RESIZE_STAMP_BITS 是一个默认值 16。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">resizeStamp</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="hljs-number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>（1） Integer.numberOfLeadingZeros(n) 这个方法，实际上这个方法就是做一件事，那就是获取当前数据转成二进制后的最高非 0 位前的 0 的个数。举个例子：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">就以<span class="hljs-number">16</span>为准，<span class="hljs-number">16</span>转成二进制是<span class="hljs-number">10000</span>，最高非<span class="hljs-number">0</span>位是在第<span class="hljs-number">5</span>位，因为<span class="hljs-built_in">int</span>类型是<span class="hljs-number">32</span>位，所以他前面还有<span class="hljs-number">27</span>位，而且都是<span class="hljs-number">0</span>，那么这个方法得到的结果就是<span class="hljs-number">27</span>（<span class="hljs-number">1</span>的前面还有<span class="hljs-number">27</span>个<span class="hljs-number">0</span>）。<br></code></pre></td></tr></table></figure><p>（2）1 &lt;&lt; (RESIZE_STAMP_BITS - 1) 在当前版本就是 1&lt;&lt;15，也就是得到一个二进制数 1000000000000000，这里也是要做一件事，把这个 1 移动到第 16 位。最后这两个数通过 | 操作一定得到的结果就是第 16 位是 1，因为 int 是 32 位，最多也就是 32 个 0，而且因为 n 的默认大小是 16（ConcurrentHashMap 默认大小），所以实际上最多也就是 27（11011）个 0，执行 | 运算最多也就是影响低 5 位的结果。</p><p>27 转成二进制为 0000000000000000000000000011011，然后和 00000000000000001000000000000000 执行 | 运算，最终得到的而结果就是 00000000000000010000000000011011，注意：这里之所以要保证第 16 位为 1，是为了保证 sizeCtl 变量为负数，因为前面提到，这个变量为负数才代表当前有线程在扩容。</p><p><strong>首次扩容为什么计数要 +2 而不是 +1</strong></p><p>首次扩容一定不会走前面两个条件，而是走的最后一个条件，这个条件通过 CAS 操作将 rs 左移了 16（RESIZE_STAMP_SHIFT）位，然后加上一个 2，为什么是加 2 呢？</p><p>要回答这个问题先回答另一个问题，上面通过方法获得的扩容戳 rs 究竟有什么用？实际上这个扩容戳代表了两个含义：</p><ol><li><p>高 16 为代表当前扩容的标记，可以理解为一个纪元。</p></li><li><p>低 16 代表了扩容的线程数。</p></li></ol><p>因为 rs 最终是要赋值给 sizeCtl 的，而 sizeCtl 负数才代表扩容，而将 rs 左移 16 位就刚好使得最高位为 1，此时低 16 位全部是 0，而因为低 16 位要记录扩容线程数，所以应该 +1，但是这里是 +2，原因是 sizeCtl 中 -1 这个数值已经被使用了，用来代替当前有线程准备扩容，所以如果直接 +1 是会和标志位发生冲突。所以继续回到上图中的第二个if语句，就是正常继续 +1 了，只有初始化第一次记录扩容线程数的时候才需要 +2。</p><p><strong>扩容条件</strong></p><p>看上代码中第一个if语句，这里面有 5 个条件，代表是满足这 5 个条件中的任意一个，则不进行扩容：</p><ol><li><p>(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs 这个条件实际上有 bug，在 JDK12 中已经换掉。</p></li><li><p>sc == rs + 1 表示最后一个扩容线程正在执行首位工作，也代表扩容即将结束。</p></li><li><p>sc == rs + MAX_RESIZERS 表示当前已经达到最大扩容线程数，所以不能继续让线程加入扩容。</p></li><li><p>扩容完成之后会把 nextTable（扩容的新数组） 设为 null。</p></li><li><p>transferIndex &lt;= 0 表示当前可供扩容的下标已经全部分配完毕，也代表了当前线程扩容结束。</p></li></ol><p><strong>多并发下如何实现扩容</strong></p><p>在 ConcurrentHashMap 中采用的是分段扩容法，即每个线程负责一段，默认最小是 16，也就是说如果 ConcurrentHashMap 中只有 16 个槽位，那么就只会有一个线程参与扩容。如果大于 16 则根据当前 CPU 数来进行分配，最大参与扩容线程数不会超过 CPU 数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tab.length, stride;<br>    <span class="hljs-comment">//如果n/8在除以NCPU得到的数小于16，则只会有一个线程进行扩容</span><br>    <span class="hljs-keyword">if</span> ((stride = (NCPU &gt; <span class="hljs-number">1</span>) ? (n &gt;&gt;&gt; <span class="hljs-number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)<br>        stride = MIN_TRANSFER_STRIDE; <span class="hljs-comment">//subdivide range默认每个线程最低位数为16</span><br>    <span class="hljs-comment">//nextTab是扩容后的新数组，为空表示新数组还没有被初始化</span><br>    <span class="hljs-keyword">if</span> (nextTab == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="hljs-number">1</span>]; <span class="hljs-comment">//构建一个新数组</span><br>            nextTab = nt;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            sizeCtl = Integer.MAX_VALUE; <span class="hljs-comment">//扩容失败后将sizeCtl设为最大值，也就是不再触发扩容</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        nextTable = nextTab;<br>        transferIndex = n; <span class="hljs-comment">//transferIndex表示转移数据的下标，默认记录为旧数组大小</span><br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextn</span> <span class="hljs-operator">=</span> nextTab.length;<br>&#125;<br></code></pre></td></tr></table></figure><p>扩容空间和 HashMap 一样，每次扩容都是将原空间大小左移一位，即扩大为之前的两倍。注意这里的 transferIndex 代表的就是推进下标，默认为旧数组的大小。</p><p><strong>扩容时的数据迁移如何保证安全性</strong></p><p>初始化好了新的数组，接下来就是要准备确认边界。也就是要确认当前线程负责的槽位，确认好之后会从大到小开始往前推进，比如线程一负责 1-16，那么对应的数组边界就是 0-15，然后会从最后一位 15 开始迁移数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">nextn</span> <span class="hljs-operator">=</span> nextTabl.length;<br>ForwardingNode&lt;K,V&gt; fwd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">advance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">finishing</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,bound = <span class="hljs-number">0</span>;;)&#123;<br>    Node&lt;K,V&gt; f; <span class="hljs-type">int</span> fh;<br>    <span class="hljs-keyword">while</span> (advance) &#123;<br>        <span class="hljs-type">int</span> nextIndex, nextBound;<br>        <span class="hljs-keyword">if</span> (--i &gt;= bound || finishing)<br>            advance = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="hljs-number">0</span>) &#123;<br>            i = -<span class="hljs-number">1</span>;<br>            advance = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, TRANSFERINDEX, nextIndex,<br>                                     nextBound = (nextIndex &gt; stride ? nextIndex - stride : <span class="hljs-number">0</span>))) &#123;<br>            bound = nextBound;<br>            i = nextIndex - <span class="hljs-number">1</span>;<br>            advance = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面有三个变量比较关键：</p><ol><li><p>fwd 节点，这个代表的是占位节点，最关键的就是这个节点的 hash 值为 -1，所以一旦发现某一个节点中的 hash 值为 -1 就可以知道当前节点已经被迁移了。</p></li><li><p>advance：代表是否可以继续推进下一个槽位，只有当前槽位数据被迁移完成之后才可以设置为 true</p></li><li><p>finishing：是否已经完成数据迁移。</p></li></ol><p>知道了这几个变量，再看看上面的代码，第一次一定会进入 while 循环，因为默认 advance 为 true，第一次进入循环的目的为了确认边界，因为边界值还没有确认，所以会直接走到最后一个分支，通过 CAS 操作确认边界。确认边界这里直接表述很难理解，通过一个例子来说明：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">假设说最开始的空间为<span class="hljs-number">16</span>，那么扩容后的空间就是<span class="hljs-number">32</span>，此时transferIndex为旧数组大小<span class="hljs-number">16</span>，而在第二个<span class="hljs-keyword">if</span>判断中，transferIndex赋值给了<span class="hljs-built_in">nextIndex</span>，所以<span class="hljs-built_in">nextIndex</span>为<span class="hljs-number">16</span>，而stride代表的是每个线程负责的槽位数，最小就是<span class="hljs-number">16</span>，所以stride也是<span class="hljs-number">16</span>，所以nextBound= <span class="hljs-built_in">nextIndex</span> &gt; stride ? <span class="hljs-built_in">nextIndex</span> - stride : <span class="hljs-number">0</span> 皆可以得到：nextBound=<span class="hljs-number">0</span>和i=<span class="hljs-number">15</span>了，也就是当前线程负责<span class="hljs-number">0</span><span class="hljs-number">-15</span>的数组下标，且从<span class="hljs-number">0</span>开始推进，确认边界后立刻将advance设置为false，也就是会跳出<span class="hljs-keyword">while</span>循环，从而执行下面的数据迁移部分逻辑。<br></code></pre></td></tr></table></figure><blockquote><p>因为 nextBound=0，所以 CAS 操作实际上也是把 transferIndex 变成了 0，表示当前扩容的数组下标已经全部分配完毕，这也是前面不满足扩容的第 5 个条件。</p></blockquote><p>数据迁移时，会使用 synchronized 关键字对当前节点进行加锁，也就是说锁的粒度精确到了每一个节点，可以说大大提升了效率。加锁之后的数据迁移和 HashMap 基本一致，也是通过区分高低位两种情况来完成迁移。</p><p>当前节点完成数据迁移之后，advance 变量会被设置为 true，也就是说可以继续往前推进节点了，所以会重新进入上面的 while 循环的前面两个分支，把下标 i 往前推进之后再次把 advance 设置为 false，然后重复操作，直到下标推进到 0 完成数据迁移。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;<br>    <span class="hljs-type">int</span> sc;<br>    <span class="hljs-keyword">if</span> (finishing) &#123; <span class="hljs-comment">//finishing=true表示完成迁移</span><br>        nextTable = <span class="hljs-literal">null</span>;<br>        table = nextTab;<br>        sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">//设置下一次扩容的大小为新数组空间大小的3/4</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//首次进入这里，通过cas将sizeCtl-1表示扩容的线程数-1，因为自己已经完成扩容</span><br>    <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)<br>            <span class="hljs-keyword">return</span>;<br>        finishing = advance = <span class="hljs-literal">true</span>;<br>        i = n; <span class="hljs-comment">// recheck before commit再次循环检查一遍</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-literal">null</span>)<br>    advance = casTabAt(tab, i, <span class="hljs-literal">null</span>, fwd); <span class="hljs-comment">//数组迁移完成后把当前节点设置成fwd</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED) <span class="hljs-comment">//检测当前节点是否已被迁移，如果是的话将advance设置为true，继续推进下标</span><br>    advance = <span class="hljs-literal">true</span>; <span class="hljs-comment">// already processed</span><br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (f) &#123; <span class="hljs-comment">//这部分是负责具体迁移的代码和HashMap差不多</span><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>while 循环彻底结束之后，会进入到下面这个 if 判断，当前线程自己完成了迁移之后，会将扩容线程数进行递减，递减之后会再次通过一个条件判断，这个条件其实就是前面进入扩容前条件的反推，如果成立说明扩容已经完成，扩容完成之后会将 nextTable 设置为 null，所以上面不满足扩容的第 4 个条件就是在这里设置的。</p><h3 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5 总结"></a>3.5 总结</h3><p>在整个 ConcurrentHashMap 中，整个思想就是降低锁的粒度，减少锁的竞争，所以采用了大量的分而治之的思想，比如多线程同时进行扩容，以及通过一个数组来实现 size 的计数等。</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>集合</tag>
      
      <tag>ConcurrentHashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发工具类以及AQS</title>
    <link href="/2023/06/15/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A5%E5%8F%8AAQS/"/>
    <url>/2023/06/15/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A5%E5%8F%8AAQS/</url>
    
    <content type="html"><![CDATA[<h2 id="1-AQS"><a href="#1-AQS" class="headerlink" title="1 AQS"></a>1 AQS</h2><p>谈到并发，不得不谈ReentrantLock；而谈到ReentrantLock，不得不谈AbstractQueuedSynchronizer。</p><p>类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，是同步类的最核心的一个类，如常用的ReentrantLock/Semaphore/CountDownLatch…。</p><h3 id="1-1-整体框架"><a href="#1-1-整体框架" class="headerlink" title="1.1 整体框架"></a>1.1 整体框架</h3><p><img src="/image/%E5%A4%9A%E7%BA%BF%E7%A8%8B/AQS/1.png"></p><p>它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。state的访问方式有三种: 1.getState()；2.setState()；3.compareAndSetState()。</p><p>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><p>（1）isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</p><p>（2）tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</p><p>（3）tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</p><p>（4）tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</p><p>（5）tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p><p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><p>以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后续动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><h3 id="1-2-源码解析"><a href="#1-2-源码解析" class="headerlink" title="1.2 源码解析"></a>1.2 源码解析</h3><p>依照acquire-release、acquireShared-releaseShared的次序来，以非公平锁为例。</p><h4 id="1-2-1-节点状态waitStatus"><a href="#1-2-1-节点状态waitStatus" class="headerlink" title="1.2.1 节点状态waitStatus"></a>1.2.1 节点状态waitStatus</h4><p>Node结点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等。变量waitStatus则表示当前Node结点的等待状态，共有5种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。</p><ol><li><p>CANCELLED(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</p></li><li><p>SIGNAL(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</p></li><li><p>CONDITION(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</p></li><li><p>PROPAGATE(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</p></li><li><p>0：新结点入队时的默认状态。</p></li></ol><p>​    注意，负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&gt;0、&lt;0来判断结点的状态是否正常。</p><h4 id="1-2-2-acquire-int-—"><a href="#1-2-2-acquire-int-—" class="headerlink" title="1.2.2 acquire(int) — *"></a>1.2.2 acquire(int) — *</h4><p>此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span>&#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; <br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>函数流程如下：</p><ol><li><p>tryAcquire()尝试直接去获取资源，如果成功则直接返回，这里体现了非公平锁，每个线程获取锁时会尝试直接抢占加塞一次，而CLH队列中可能还有别的线程在等待。(若是公平锁的话，如果不是队列中的第一个，这里不允许抢占资源)；</p></li><li><p>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</p></li><li><p>acquireQueued()使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</p></li></ol><p>​    如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</p><p><img src="/image/%E5%A4%9A%E7%BA%BF%E7%A8%8B/AQS/2.png"></p><h5 id="1-2-2-1-tryAcquire"><a href="#1-2-2-1-tryAcquire" class="headerlink" title="1.2.2.1 tryAcquire"></a>1.2.2.1 tryAcquire</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义。</p><p>AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。</p><h5 id="1-2-2-2-addWaiter"><a href="#1-2-2-2-addWaiter" class="headerlink" title="1.2.2.2 addWaiter"></a>1.2.2.2 addWaiter</h5><p>此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-comment">//以给定模式构造节点，mode有两种：EXCLUSIVE(独占)，SHARED(共享)</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <br>    <span class="hljs-comment">//尝试快速方式直接放到队尾</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-keyword">if</span>(pred != <span class="hljs-literal">null</span>)&#123;<br>        node.prev = pred;<br>        <span class="hljs-keyword">if</span>(compareAndSetTail(pred, node))&#123;<br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//上一步失败则通过enq入队</span><br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span>&#123;<br>    <span class="hljs-comment">//CAS自旋，直到成功加入队尾</span><br>    <span class="hljs-keyword">for</span>(;;)&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-comment">//队列为空，创建一个空的标志节点作为head节点，并将tail也指向它</span><br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//正常流程，放入队尾</span><br>            node.prev = t;<br>            <span class="hljs-keyword">if</span>(compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-2-2-3-acquireQueued"><a href="#1-2-2-3-acquireQueued" class="headerlink" title="1.2.2.3 acquireQueued"></a>1.2.2.3 acquireQueued</h5><p>进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。acquireQueued()就是干这件事：在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。这个函数非常关键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//标记是否成功拿到资源</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupt</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//标记等待过程中是否被中断过</span><br>        <br>        <span class="hljs-comment">//自旋</span><br>        <span class="hljs-keyword">for</span>(;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor(); <span class="hljs-comment">//拿到前驱</span><br>            <span class="hljs-comment">//如果前驱是head，即该节点已成老二，那么便有资格去尝试获取资源（可能老大释放完资源唤醒自己的，当然也有可能interrupt了）</span><br>            <span class="hljs-keyword">if</span>(p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node); <span class="hljs-comment">//拿到资源后，将head指向该节点，所以head所指的标杆节点，就是当前获取到资源的那个节点或null</span><br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">//setHead中node.prev已值为null，此处再将head.next值为null，就是为了方便GC回收以前的head节点，也就意味着之前拿完资源的节点出队了</span><br>                failed = <span class="hljs-literal">false</span>; <span class="hljs-comment">//成功获取资源</span><br>                <span class="hljs-keyword">return</span> interrupt; <span class="hljs-comment">//返回等待过程中是否被中断过</span><br>            &#125;<br>            <br>            <span class="hljs-comment">//如果自己可以休息了，就是通过park进入waiting状态，直到被unpark，如果不可中断的情况下被中断了，那么会从park中醒过来，发现拿不到资源，从而继续进入park等待</span><br>            <span class="hljs-keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; <br>               parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>; <span class="hljs-comment">//如果等待过程中被中断过，哪怕只有一次，就将interrupt标记为true</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//如果等待过程中没有成功获取资源（如timeout，或者可中断的情况下被中断了），那么取消节点再队列中的等待</span><br>        <span class="hljs-keyword">if</span> (failed)&#123;<br>            cancelAcquire(node);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    <strong>shouldParkAfterFailedAcquire(Node, Node)</strong></p><p>​    此方法主要用于检查状态，看看自己是否真的可以去休息了（进入waiting状态），万一队列前边的线程都放弃了只是瞎站着。整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<span class="hljs-comment">//拿到前驱的状态</span><br>    <span class="hljs-keyword">if</span>(ws == Node.SIGNAL)<br>        <span class="hljs-comment">//如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边</span><br>        <span class="hljs-comment">//注意：那些放弃的节点，由于被自己加塞到它们前边，它们相当于形成一个无引用链，稍后就会被GC了</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下，有可能失败，人家说不定刚释放完</span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>parkAndCheckInterrupt()</strong></p><p>​    如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheakInterrypt</span><span class="hljs-params">()</span>&#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//调用park使线程进入waiting状态</span><br>    <span class="hljs-keyword">return</span> Thread.interruted();<span class="hljs-comment">//如果被唤醒，查看自己是不是被中断的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。</p><p><strong>小结：</strong></p><p>​    回到acquireQueued()，总结下该函数的具体流程：</p><ol><li><p>结点进入队尾后，检查状态，找到安全休息点；</p></li><li><p>调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己；</p></li><li><p>被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程1。</p></li></ol><h4 id="1-2-3-release-int-—"><a href="#1-2-3-release-int-—" class="headerlink" title="1.2.3 release(int) — *"></a>1.2.3 release(int) — *</h4><p>此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">//找到头节点</span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>) &#123;<br>            unparkSuccessor(h); <span class="hljs-comment">//唤醒等待队列里的下一个线程</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>它调用tryRelease()来释放资源。有一点需要注意的是，它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！！</p><h5 id="1-2-3-1-tryRelease"><a href="#1-2-3-1-tryRelease" class="headerlink" title="1.2.3.1 tryRelease"></a>1.2.3.1 tryRelease</h5><p>此方法尝试去释放指定量的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperaionException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。</p><h5 id="1-2-3-2-unparkSuccessor"><a href="#1-2-3-2-unparkSuccessor" class="headerlink" title="1.2.3.2 unparkSuccessor"></a>1.2.3.2 unparkSuccessor</h5><p>此方法用于唤醒等待队列中下一个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span>&#123;<br>    <span class="hljs-comment">//这里，node一般为当前线程所在的节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-keyword">if</span>(ws &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">//置0当前线程所在的节点的状态，允许失败</span><br>        compareAnddSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next; <span class="hljs-comment">//找到下一个需要唤醒的节点</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatue &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//如果为空或者已取消</span><br>        s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span>; t = t.prev)  <span class="hljs-comment">//从后往前找</span><br>            <span class="hljs-keyword">if</span>(t.waitStatus &lt;= <span class="hljs-number">0</span>) <span class="hljs-comment">//从这里可以看出，&lt;=0的节点，都是还有效的节点</span><br>                s = t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>        LockSupport.unpark(s.thread); <span class="hljs-comment">//唤醒</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一句话概括：用unpark()唤醒等待队列中最前边的那个未放弃线程，这里用s来表示。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head &amp;&amp; tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立了），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！</p><p>​    <strong>小结：</strong></p><p>​    release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。</p><p>​    有一个问题：如果获取锁的线程在release时异常了，没有unpark队列中的其他结点，这时队列中的其他结点会怎么办？是不是没法再被唤醒了？答案是YES！！！这时，队列中等待锁的线程将永远处于park状态，无法再被唤醒！！！但是再回头想想，获取锁的线程在什么情形下会release抛出异常呢？？</p><ol><li><p>线程突然死掉了？可以通过thread.stop来停止线程的执行，但该函数的执行条件要严苛的多，而且函数注明是非线程安全的，已经标明Deprecated；</p></li><li><p>线程被interupt了？线程在运行态是不响应中断的，所以也不会抛出异常；</p></li><li><p>release代码有bug，抛出异常了？目前来看，Doug Lea的release方法还是比较健壮的，没有看出能引发异常的情形（如果有，恐怕早被用户吐槽了）。除非自己写的tryRelease()有bug，那就没啥说的，自己写的bug只能自己含着泪去承受了。</p></li></ol><h4 id="1-2-4-acquireShared-int-—"><a href="#1-2-4-acquireShared-int-—" class="headerlink" title="1.2.4 acquireShared(int) — *"></a>1.2.4 acquireShared(int) — *</h4><p>此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span>&#123;<br>    <span class="hljs-keyword">if</span>(tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是：</p><p>​    1.tryAcquireShared()尝试获取资源，成功则直接返回；</p><p>​    2.失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。</p><h5 id="1-2-4-1-doAcquireShared"><a href="#1-2-4-1-doAcquireShared" class="headerlink" title="1.2.4.1 doAcquireShared"></a>1.2.4.1 doAcquireShared</h5><p>此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED); <span class="hljs-comment">//加入队列尾部</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//是否成功状态</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//等待过程中是否被中断过的标志</span><br>        <span class="hljs-keyword">for</span>(;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor(); <span class="hljs-comment">//前驱</span><br>            <span class="hljs-keyword">if</span>(p == head) &#123; <span class="hljs-comment">//如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，可能是head用完资源来唤醒自己</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg); <span class="hljs-comment">//尝试获取资源</span><br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//成功</span><br>                    setHeadAndPropagate(node, r); <span class="hljs-comment">//将head指向自己，还有剩余资源可以再唤醒之后的线程</span><br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">//帮助GC</span><br>                    <span class="hljs-keyword">if</span> (interrupted) <span class="hljs-comment">//如果等待过程中被打断过，此时将中断补上</span><br>                        selfInterrupt();<br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()</span><br>            <span class="hljs-keyword">if</span>(shorldParkAfterFailedAcquire(p, node) &amp;&amp; <br>               parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-2-4-2-setHeadAndPropagate"><a href="#1-2-4-2-setHeadAndPropagate" class="headerlink" title="1.2.4.2 setHeadAndPropagate"></a>1.2.4.2 setHeadAndPropagate</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span>&#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>    setHead(node); <span class="hljs-comment">//head指向自己</span><br>    <span class="hljs-comment">//如果还有余量，继续唤醒下一个邻居线程</span><br>    <span class="hljs-keyword">if</span>(propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> | h.waitStatus &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-literal">null</span> || s.isShared())<br>            doReleaseShared();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点。</p><p>doReleaseShared()下一小节的releaseShared()里来讲。</p><p><strong>小结</strong></p><p>梳理一下acquireShared()的流程：</p><p>​    1.tryAcquireShared()尝试获取资源，成功则直接返回；</p><p>​    2.失败则通过doAcquireShared()进入等待队列park()，直到被unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。</p><p>其实跟acquire()的流程大同小异，只不过多了个自己拿到资源后，还会去唤醒后继队友的操作。</p><h4 id="1-2-5-releaseShared-—"><a href="#1-2-5-releaseShared-—" class="headerlink" title="1.2.5 releaseShared() — *"></a>1.2.5 releaseShared() — *</h4><p>此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span>&#123;<br>    <span class="hljs-keyword">if</span>(tryReleaseShared(arg)) &#123; <span class="hljs-comment">//尝试释放资源</span><br>        doReleaseShared(); <span class="hljs-comment">//唤醒后继节点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。</p><h5 id="1-2-5-1-doReleaseShared"><a href="#1-2-5-1-doReleaseShared" class="headerlink" title="1.2.5.1 doReleaseShared()"></a>1.2.5.1 doReleaseShared()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span>(;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span>(h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span>(ws == Node.SIGNAL)&#123;<br>                <span class="hljs-keyword">if</span>(!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    unparkSuccessor(h); <span class="hljs-comment">//唤醒后继</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ws == <span class="hljs-number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(h == head) <span class="hljs-comment">//head发生变化</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-6-小结"><a href="#1-2-6-小结" class="headerlink" title="1.2.6 小结"></a>1.2.6 小结</h4><p>值得注意的是，acquire()和acquireShared()两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly()/acquireSharedInterruptibly()即是，相应的源码跟acquire()和acquireShared()差不多。</p><h2 id="2-其他工具类"><a href="#2-其他工具类" class="headerlink" title="2 其他工具类"></a>2 其他工具类</h2><h3 id="2-1-CountDownLatch"><a href="#2-1-CountDownLatch" class="headerlink" title="2.1 CountDownLatch"></a>2.1 CountDownLatch</h3><p>CountDownLatch 允许一个或多个线程等待其他线程完成操作。CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果想等待N个点完成，这里就传入N。</p><p>当调用一次CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，只需要把这个CountDownLatch的引用传递到线程里。</p><p>如果有某个解析sheet的线程处理的比较慢，不可能让主线程一直等待，所以可以使用另外一个带指定时间的await方法，await(long time, TimeUnit unit): 这个方法等待特定时间后，就会不再阻塞当前线程。join也有类似的方法。</p><p>注意：计数器必须大于等于0，只是等于0时候，计数器就是零，调用await方法时不会阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值。一个线程调用countDown方法 happen-before 另外一个线程调用await方法。</p><h3 id="2-2-CyclicBarrier-同步屏障"><a href="#2-2-CyclicBarrier-同步屏障" class="headerlink" title="2.2 CyclicBarrier(同步屏障)"></a>2.2 CyclicBarrier(同步屏障)</h3><p>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier已经到达了屏障，然后当前线程被阻塞。</p><p><strong>CyclicBarrier和CountDownLatch的区别</strong></p><p>1.CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。</p><p>2.CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。比如以下代码执行完之后会返回true。</p><h3 id="2-3-控制并发线程数的Semaphore"><a href="#2-3-控制并发线程数的Semaphore" class="headerlink" title="2.3 控制并发线程数的Semaphore"></a>2.3 控制并发线程数的Semaphore</h3><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p><p>在代码中，虽然有30个线程在执行，但是只允许10个并发的执行。Semaphore的构造方法Semaphore(int permits) 接受一个整型的数字，表示可用的许可证数量。Semaphore(10)表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()获取一个许可证，使用完之后调用release()归还许可证。还可以用tryAcquire()方法尝试获取许可证。</p><p>Semaphore还提供一些其他方法：</p><p>（1）int availablePermits() ：返回此信号量中当前可用的许可证数。</p><p>（2）int getQueueLength()：返回正在等待获取许可证的线程数。</p><p>（3）boolean hasQueuedThreads() ：是否有线程正在等待获取许可证。</p><p>（4）void reducePermits(int reduction) ：减少reduction个许可证。是个protected方法。</p><p>（5）Collection getQueuedThreads() ：返回所有等待获取许可证的线程集合。是个protected方法。</p><h3 id="2-4-两个线程进行数据交换的Exchanger"><a href="#2-4-两个线程进行数据交换的Exchanger" class="headerlink" title="2.4 两个线程进行数据交换的Exchanger"></a>2.4 两个线程进行数据交换的Exchanger</h3><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据， 如果第一个线程先执行exchange方法，它会一直等待第二个线程也执行exchange，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p><p>如果两个线程有一个没有到达exchange方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用exchange(V x, long timeout, TimeUnit unit)设置最大等待时长。</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>并发工具类</tag>
      
      <tag>AQS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>死锁和ThreadLocal</title>
    <link href="/2023/06/13/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%AD%BB%E9%94%81%E5%92%8CThreadLocal/"/>
    <url>/2023/06/13/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%AD%BB%E9%94%81%E5%92%8CThreadLocal/</url>
    
    <content type="html"><![CDATA[<h2 id="1-死锁-活锁"><a href="#1-死锁-活锁" class="headerlink" title="1 死锁/活锁"></a>1 死锁/活锁</h2><p>死锁： 一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象。</p><p>活锁： 活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试—失败—尝试—失败的过程。处于活锁的实体是在不断的改变状态，活锁有可能自行解开。</p><h2 id="2-死锁发生的条件"><a href="#2-死锁发生的条件" class="headerlink" title="2 死锁发生的条件"></a>2 死锁发生的条件</h2><ol><li><p>互斥，共享资源 X 和 Y 只能被一个线程占用；</p></li><li><p>占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X； </p></li><li><p>不可抢占，其他线程不能强行抢占线程 T1 占有的资源；</p></li><li><p>循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。</p></li></ol><h2 id="3-如何解决死锁的问题"><a href="#3-如何解决死锁的问题" class="headerlink" title="3 如何解决死锁的问题"></a>3 如何解决死锁的问题</h2><p>按照前面说的四个死锁的发生条件，只需要破坏其中一个，就可以避免死锁的产生。其中，互斥这个条件没有办法破坏，因为用锁为的就是互斥，其他三个条件都有办法可以破坏。</p><p>对于“占用且等待”这个条件，可以一次性申请所有的资源，这样就不存在等待了。</p><p>对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</p><p>对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序 的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</p><h2 id="4-ThreadLocal"><a href="#4-ThreadLocal" class="headerlink" title="4 ThreadLocal"></a>4 ThreadLocal</h2><p>线程隔离机制。ThreadLocal实际上一种线程隔离机制，也是为了保证在多线程环境下对于共享变量的访问的安全性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> ThreadLocal&lt;Integer&gt; local = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;() &#123;<br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//初始化一个值</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Thread[] thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">5</span> ; i++)&#123;<br>        thread[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> local.get(); <span class="hljs-comment">//获得的值都是0</span><br>            local.set(num += <span class="hljs-number">5</span>); <span class="hljs-comment">//设置到local中</span><br>            System.out.println(Thread.currentThread.getName() + <span class="hljs-string">&quot;-&quot;</span> + num);<br>        &#125;);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(innt i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>        thread[i].start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadLocal原理分析：主要介绍set方法，清理过程和替换过程。</p><p><strong>Set()方法：</strong></p><p>如果map为空的话，需要先创建map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">creatMap</span><span class="hljs-params">(Thread t, T firstValue)</span>&#123;<br>    t.threadLocals  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure><p>map不为空时的执行逻辑：</p><ol><li><p>根据key的散列哈希计算Entry的数组下标</p></li><li><p>通过线性探索探测从i开始往后一直遍历到数组的最后一个Entry</p></li><li><p>如果map中的key和传入的key相等，表示该数据已经存在，直接覆盖</p></li><li><p>如果map中的key为空，则用新的key、value覆盖，并清理key=null的数据 </p></li><li><p>rehash扩容</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span>&#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-comment">//根据哈希码和数组长度求元素放置的位置，即数组下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//从i开始往后一直遍历到数组最后一个Entry(线性探索)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>        e != <span class="hljs-literal">null</span>;<br>        e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <br>        <span class="hljs-comment">//如果key相等，覆盖value</span><br>        <span class="hljs-keyword">if</span>(k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果key为null，用新key、value覆盖，同时清理历史ney=null的陈旧数据(弱引用)</span><br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-literal">null</span>)&#123;<br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>    <span class="hljs-comment">//如果超过阈值，则扩容</span><br>    <span class="hljs-keyword">if</span>(!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)&#123;<br>        rehash();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>线性探测，是用来解决hash冲突的一种策略。它是一种开放寻址策略，hash表是根据key进行直接访问的数据结构，也就是说可以通过 hash函数把key映射到hash表中的一个位置来访问记录，从而加快查找的速度。存放记录的数据就是hash表（散列表）。当针对一个key通过hash函数计算产生的一个位置，在hash表中已经被另外一个键值对占用时，那么线性探测就可以解决这个冲突，这里分两种情况：</p><ol><li><p>写入： 查找hash表中距冲突单元最近的空闲单元，把新的键值插入到这个空闲单元</p></li><li><p>查找： 根据hash函数计算的一个位置处开始往后查找，直到找到与key对应的value或者找到空的单元。</p></li></ol><p><strong>replaceStaleEntry：</strong></p><p>清理过程和替换过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceStaleEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value, <span class="hljs-type">int</span> staleSlot)</span>&#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    Entry e;<br>    <br>    <span class="hljs-comment">//向前扫描，查找最前一个无效的slot</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">slotToExpunge</span> <span class="hljs-operator">=</span> staleSlot;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> prevIndex(staleSlot, len);<br>        (e = tab[i]) != <span class="hljs-literal">null</span>;<br>        i = prevIndex(i, len)) &#123;<br>        <span class="hljs-keyword">if</span>(e.get() == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//通过循环遍历，可以定位到最前面一个无效的slot</span><br>            slotToExpunge = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//从i开始往后一直遍历到数组最后一个Entry(线性探索)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nextIndex(staleSlot, len);<br>        (e = tab[i]) != <span class="hljs-literal">null</span>;<br>        i = nextIndex(i, len))&#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-comment">//找到匹配的key以后</span><br>        <span class="hljs-keyword">if</span>(k == key)&#123;<br>            <span class="hljs-comment">//更新对应slot的value值</span><br>            e.value = value;<br>            <span class="hljs-comment">//与无效的slot进行位置交换</span><br>            tab[i] = tab[slaleSlot];<br>            tab[staleSlot] = e;<br>            <span class="hljs-comment">//如果最早的一个无效的slot和当前的staleSlot相等，则从i作为清理的起点</span><br>        <span class="hljs-keyword">if</span>(slotToExpunge = staleSlot)&#123;<br>            slotToExpunge = i;<br>        &#125;<br>            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果当前的slot已经无效，并且向前扫描过程中没有无效slot，则更新slotToExpunge为当前位置</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span> &amp;&amp; slotToExpunge == staleSlot)&#123;<br>            slotToExpunge = i;<br>        &#125;          <br>    &#125;<br>    <span class="hljs-comment">//如果key对应的value在entry中不存在，则直接放一个新的entry</span><br>    tab[staleSlot].value = <span class="hljs-literal">null</span>;<br>    tab[staleSlot] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br><br><span class="hljs-comment">//如果有任何一个无效的slot，则做一次清理</span><br>    <span class="hljs-keyword">if</span> (slotToExpunge != staleSlot)&#123;<br>        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>死锁</tag>
      
      <tag>ThreadLocal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile关键字</title>
    <link href="/2023/06/13/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2023/06/13/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h2 id="1-一个问题"><a href="#1-一个问题" class="headerlink" title="1 一个问题"></a>1 一个问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!stop) &#123;<br>            i++;<br>            <span class="hljs-comment">//(1)System.out.println(&quot;rs: &quot; + i);</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//(2)Thread.sleep(0);</span><br>            &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    thread.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    stop = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>怎样让上述代码停下：</p><ol><li><p>print就可以导致循环结束</p><p> println底层用到了synchronized这个同步关键字，这个同步会防止循环期间对于stop值的缓存；因为println有加锁的操作，而释放锁的操作，会强制性的把工作内存中涉及到的写操作同步到主内存；从IO角度来说，print本质上是一个IO的操作，磁盘IO的效率一定要比CPU 的计算效率慢得多，所以IO可以使得CPU有时间去做内存刷新的事情，从而导致这个现象。比如可以在里面定义一个new File()</p></li><li><p>sleep(0)导致循环结束。</p><p> 官方文档上是说，Thread.sleep没有任何同步语义，编译器不需要在调用Thread.sleep之前把缓存在寄存器中的写刷新到给共享内存、也不需要在Thread.sleep之后重新加载缓存在寄存器中的值。编译器可以自由选择读取stop的值一次或者多次，这个是由编译器自己来决定的。但是：Thread.sleep(0)导致线程切换，线程切换会导致缓存失效从而读取到了新的值。</p></li></ol><h2 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2 可见性"></a>2 可见性</h2><p>保证可见性，通过对上述代码查看汇编指令，使用HSDIS工具。 可以了解到，使用volatile关键字之后，多了一个Lock指令。</p><p>在单线程的环境下，如果向一个变量先写入一个值，然后在没有写干涉的情况下读取这个变量的值，那这个时候读取到的这个变量的值应该是之前写入的那个值。这本来是一个很正常的事情。但是在多线程环境下，读和写发生在不同的线程中的时候，可能会出现：读线程不能及时的读取到其他线程写入的最新的值。这就是所谓的可见性。</p><h3 id="2-1-硬件层面"><a href="#2-1-硬件层面" class="headerlink" title="2.1 硬件层面"></a>2.1 硬件层面</h3><p><strong>1.CPU层面增加了高速缓存</strong></p><p>操作系统，进程、线程、CPU时间片来切换 </p><p>编译器的优化 ，更合理的利用CPU的高速缓存。因为高速缓存的存在，会导致一个缓存一致性问题。</p><p><strong>2.总线锁和缓存锁：</strong></p><p>总线锁，简单来说就是，在多cpu下，当其中一个处理器要对共享内存进行操作的时候，在总线上发出 一个LOCK#信号，这个信号使得其他处理器无法通过总线来访问到共享内存中的数据，总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，这种机制显然是不合适的 。</p><p>最好的方法就是控制锁的保护粒度，只需要保证对于被多个CPU缓存的同一份数据是一致的就行。在P6架构的CPU后，引入了缓存锁，如果当前数据已经被CPU缓存了，并且是要协会到主内存中的，就可以采用缓存锁来解决问题。</p><p>所谓的缓存锁，就是指内存区域如果被缓存在处理器的缓存行中，并且在Lock期间被锁定，那么当它执行锁操作回写到内存时，不再总线上加锁，而是修改内部的内存地址，基于缓存一致性协议来保证操作的原子性。</p><p>总线锁和缓存锁怎么选择，取决于很多因素，比如CPU是否支持、以及存在无法缓存的数据时（比较大或者快约多个缓存行的数据），必然还是会使用总线锁。</p><p><strong>3.缓存一致性协议</strong></p><p>为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，常见的协议有MSI，MESI，MOSI等。最常见的就是MESI协议。MESI表示缓存行的四种状态，分别是</p><ol><li><p>M(Modify) 表示共享数据只缓存在当前CPU缓存中，并且是被修改状态，也就是缓存的数据和主内存中的数据不一致</p></li><li><p>E(Exclusive) 表示缓存的独占状态，数据只缓存在当前CPU缓存中，并且没有被修改</p></li><li><p>S(Shared) 表示数据可能被多个CPU缓存，并且各个缓存中的数据和主内存数据一致</p></li><li><p>I(Invalid) 表示缓存已经失效</p></li></ol><p><strong>4.MESI的一个优化：Store Buﬀeres</strong></p><p>Store Buﬀeres是一个写的缓冲，对于上述描述的情况，CPU0可以先把写入的操作先存储到Store Buﬀeres中，Store Buﬀeres中的指令再按照缓存一致性协议去发起其他CPU缓存行的失效。而同步来说CPU0可以不用等到Ack，继续往下执行其他指令，直到收到CPU0收到 Ack再更新到缓存，再从缓存同步到主内存。</p><p><strong>5.指令重排序</strong></p><p>通过内存屏障禁止了指令重排序</p><p>X86的memory barrier指令包括lfence(读屏障) sfence(写屏障) mfence(全屏障)</p><p>Store Memory Barrier(写屏障) ，告诉处理器在写屏障之前的所有已经存储在存储缓存(store buﬀeres)中的数据同步到主内存，简单来说就是使得写屏障之前的指令的结果对屏障之后的读或者写是可见的</p><p>Load Memory Barrier(读屏障) ，处理器在读屏障之后的读操作,都在读屏障之后执行。配合写屏障，使得写屏障之前的内存更新对于读屏障之后的读操作是可见的</p><p>Full Memory Barrier(全屏障) ，确保屏障前的内存读写操作的结果提交到内存之后，再执行屏障后的读写操作</p><h3 id="2-2-软件层面"><a href="#2-2-软件层面" class="headerlink" title="2.2 软件层面"></a>2.2 软件层面</h3><p><strong>JMM</strong></p><p>简单来说，JMM定义了共享内存中多线程程序读写操作的行为规范：在虚拟机中把共享变量存储到内存以及从内存中取出共享变量的底层实现细节。通过这些规则来规范对内存的读写操作从而保证指令的正确性，它解决了CPU多级缓存、处理器优化、指令重排序导致的内存访问问题，保证了并发场景下的可见性。</p><p>需要注意的是，JMM并没有主动限制执行引擎使用处理器的寄存器和高速缓存来提升指令执行速度，也没主动限制编译器对于指令的重排序，也就是说在JMM这个模型之上，仍然会存在缓存一致性问题和指令重排序问题。JMM是一个抽象模型，它是建立在不同的操作系统和硬件层面之上对问题进行了统一的抽象，然后再Java层面提供了一些高级指令，让用户选择在合适的时候去引入这些高级指令来解决可见性问题。</p><p>导致可见性问题有两个因素，一个是高速缓存导致的可见性问题， 另一个是指令重排序。</p><p>对于缓存一致性问题，有总线锁和缓存锁，缓存锁是基于MESI协议。而对于指令重排序，硬件层面提供了内存屏障指令。而JMM在这个基础上提供了volatile、final等关键字，使得开发者可以在合适的时候增加相应的关键字来禁止高速缓存和禁止指令重排序来解决可见性和有序性问题。</p><p>被volatile修改的变量有以下特点：</p><p>（1）线程中读取的时候，每次读取都会去主内存中读取共享变量最新的值，然后将其复制到工作内存</p><p>（2）线程中修改了工作内存中变量的副本，修改之后会立即刷新到主内存</p><p><strong>happens-before</strong></p><p>除了显示引用volatile关键字能够保证可见性以外，在Java中，还有很多的可见性保障的规则。 从JDK1.5开始，引入了一个happens-before的概念来阐述多个线程操作共享变量的可见性问题。所以可以认为在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作必须要存在happens-before关系。这两个操作可以是同一个线程，也可以是不同的线程。</p><p>· 程序顺序规则（as-if-serial语义）：一个线程中的每个操作，happens-before于该线程中的任意后续操作。 </p><p>· 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。 </p><p>· volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。 </p><p>· 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。 </p><p>· start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。 </p><p>· join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</p><p>final关键字提供了内存屏障的规则</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>volatile关键字</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锁-synchronized</title>
    <link href="/2023/06/12/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81-synchronized/"/>
    <url>/2023/06/12/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81-synchronized/</url>
    
    <content type="html"><![CDATA[<p>互斥锁的本质是共享资源。</p><h2 id="1-锁的使用"><a href="#1-锁的使用" class="headerlink" title="1 锁的使用"></a>1 锁的使用</h2><p>可以修饰在方法层面和代码块层面</p><p>synchronized有三种方式来加锁，不同的修饰类型，代表锁的控制粒度：</p><ol><li><p>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁</p></li><li><p>静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</p></li><li><p>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p></li></ol><p>锁是在对象头中存储。</p><h2 id="2-锁的升级"><a href="#2-锁的升级" class="headerlink" title="2 锁的升级"></a>2 锁的升级</h2><ol><li>偏向锁</li></ol><p>在大多数情况下，锁不仅仅不存在多线程的竞争，而且总是由同一个线程多次获得。在这个背景下就设计了偏向锁。偏向锁，顾名思义，就是锁偏向于某个线程。</p><p>当一个线程访问加了同步锁的代码块时，会在对象头中存储当前线程的ID，后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。而是直接比较对象头里面是否存储了指向当前线程的偏向锁。如果相等表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了，引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。（偏向锁的目的是消除数据在无竞争情 况下的同步原语，进一步提高程序的运行性能。）</p><ol start="2"><li>轻量级锁</li></ol><p>如果偏向锁被关闭或者当前偏向锁已经已经被其他线程获取，那么这个时候如果有线程去抢占同步锁时，锁会升级到轻量级锁。</p><ol start="3"><li>重量级锁</li></ol><p>多个线程竞争同一个锁的时候，虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程；Java 线程的阻塞以及唤醒，都是依靠操作系统来完成的：os pthread_mutex_lock() ；升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><p>每一个JAVA对象都会与一个监视器monitor关联，可以把它理解成为一把锁，当一个线程想要执行一段被synchronized修饰的同步方法或者代码块时，该线程得先获取到synchronized修饰的对象对应的monitor。monitorenter表示去获得一个对象监视器。monitorexit表示释放monitor监视器的所有权，使得其他被阻塞的线程可以尝试去获得这个监视器。monitor依赖操作系统的MutexLock(互斥锁)来实现的，线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能。</p><p>任意线程对Object（Object由synchronized保护）的访问，首先要获得Object的监视器。如果获取失败，线程进入同步队列，线程状态变为BLOCKED。当访问Object的前驱（获得了锁的线程）释放了锁，则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取。</p><p>​    总结：偏向锁只有在第一次请求时采用CAS在锁对象的标记中记录当前线程的地址，在之后该线程再次进入同步代码块时，不需要抢占锁，直接判断线程ID即可，这种适用于锁会被同一个线程多次抢占的情况。轻量级锁才用CAS操作，把锁对象的标记字段替换为一个指针指向当前线程栈帧中的LockRecord，该工件存储锁对象原本的标记字段，它针对的是多个线程在不同时间段内申请同一把锁的情况。重量级锁会阻塞、和唤醒加锁的线程，它适用于多个线程同时竞争同一把锁的情况。</p><p><img src="/image/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/Synchronized%E5%8E%9F%E7%90%86.jpg"></p><p><img src="/image/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/%E9%94%81%E8%86%A8%E8%83%80.jpg"></p><p><img src="/image/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/1.png"></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>synchronized</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka原理分析以及特性总结</title>
    <link href="/2023/06/08/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/kafka%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <url>/2023/06/08/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/kafka%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="1-生产者原理"><a href="#1-生产者原理" class="headerlink" title="1 生产者原理"></a>1 生产者原理</h2><p>源码地址：<a href="https://github.com/apache/kafka/tree/trunk/clients">https://github.com/apache/kafka/tree/trunk/clients</a></p><h3 id="1-1-生产者发送消息"><a href="#1-1-生产者发送消息" class="headerlink" title="1.1 生产者发送消息"></a>1.1 生产者发送消息</h3><p>消息发送的整体流程。生产端主要由两个线程协调运行。这两条线程分别为main线程和sender线程（发送线程）。</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/3.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Producer&lt;String, String&gt; producer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaProducer</span>&lt;&gt;(pros);<br></code></pre></td></tr></table></figure><p>在创建KafkaProducer的时候，创建了一个Sender对象，并且启动了一个IO线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.sender = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sender</span>(logContext, kafkaClient, <span class="hljs-built_in">this</span>.metadata);<br><span class="hljs-type">String</span> <span class="hljs-variable">ioThreadName</span> <span class="hljs-operator">=</span> NETWORK_THREAD_PREFIX + <span class="hljs-string">&quot;|&quot;</span> + clientId;<br><span class="hljs-built_in">this</span>.ioThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaThread</span>(ioThreadName, <span class="hljs-built_in">this</span>.sender, <span class="hljs-literal">true</span>);<br><span class="hljs-built_in">this</span>.ioThread.start();<br></code></pre></td></tr></table></figure><h4 id="1-1-1-拦截器"><a href="#1-1-1-拦截器" class="headerlink" title="1.1.1 拦截器"></a>1.1.1 拦截器</h4><p>接下来执行拦截器的逻辑，在producer.send方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ProducerRecord&lt;K,V&gt; interceptedRecord = <span class="hljs-built_in">this</span>.interceptors.onSend(record);<br></code></pre></td></tr></table></figure><p>拦截器的作用是实现消息的定制化（类似于Spring Interceptor、Mybatis的插件，Quartz的监听器）。这个拦截器定义的位置是在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; interceptors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>interceptors.add(<span class="hljs-string">&quot;com.test.interceptor.TestInterceptor&quot;</span>);<br>props.put(Producer.Config.INTERCEPTOR_CLASS_CONFIG, interceptors);<br></code></pre></td></tr></table></figure><p>可以在生产者的属性中指定多个拦截器，形成拦截器链。举个例子，假设发送消息的时候要扣钱，发一条消息1分钱（把这个功能叫做按量付费），就可以用拦截器实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProducerInterceptor</span>&lt;String, String&gt; &#123;<br>    <span class="hljs-comment">//发送消息的时候触发</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ProducerRecord&lt;String, String&gt; <span class="hljs-title function_">onSend</span><span class="hljs-params">(ProducerRecord&lt;String, String&gt; record)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;扣钱&quot;</span>);<br>        <span class="hljs-keyword">return</span> record;<br>    &#125;<br>    <br>    <span class="hljs-comment">//收到服务端ack时触发</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAcknowledgement</span><span class="hljs-params">(RecordMetadata metadata, Exception exception)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;消息被服务端接收了&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;生产者关闭了&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//用键值对配置的时候触发</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(Map&lt;String, ?&gt; configs)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;configure.....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-1-2-序列化"><a href="#1-1-2-序列化" class="headerlink" title="1.1.2 序列化"></a>1.1.2 序列化</h4><p>调用send方法后，第二步是利用指定的工具对key和value进行序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">serializedKey = keySerializer.serializze(record.topic,record.headers(),record.key());<br></code></pre></td></tr></table></figure><p>Serializer.java——kafka针对不同的数据类型自带了相应的序列化工具。除了自带的序列化工具之外，可以使用如Avro，JSON，Thrift，Prorobuf等，或者使用自定义类型的序列化器来实现，实现Serializer接口即可。</p><h4 id="1-1-3-路由指定-分区器"><a href="#1-1-3-路由指定-分区器" class="headerlink" title="1.1.3 路由指定-分区器"></a>1.1.3 路由指定-分区器</h4><p>然后是路由指定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">partition</span> <span class="hljs-operator">=</span> partition(record, serializedKey, serializedValue, cluster);<br></code></pre></td></tr></table></figure><p>一条消息会发送到哪个partition呢？它返回的是一个分区的编号，从0开始。首先分一下有四种情况：</p><p>​    1、指定了partition；</p><p>​    2、没有指定partition，自定义了分区器</p><p>​    3、没有指定partition，没有自定义分区器，但是key不为空</p><p>​    4、没有指定partition，没有自定义分区器，但是key是空的</p><p><strong>第一种情况：</strong>指定partition的情况下，直接将指定的值直接作为partition值；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>    <span class="hljs-comment">//自定义，随机选择分区</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">partition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(partitionSize);<br>    ProducerRecord&lt;String, Integer&gt; producerRecord = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;&gt;(topic, partition, <span class="hljs-literal">null</span>, i);<br>    <span class="hljs-type">RecoirdMetadata</span> <span class="hljs-variable">metadata</span> <span class="hljs-operator">=</span> producer.send(prodducerRecord).get();<br>    System.out.println(<span class="hljs-string">&quot;Sent to partition: &quot;</span> + metadata.partition() + <span class="hljs-string">&quot;, offset: &quot;</span> + metadata.offset);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二种情况：</strong>自定义分区器，将使用自定义的分区器算法选择分区，比如SimplePartitioner，用ProducerAutoPartition指定，发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">props.put(<span class="hljs-string">&quot;partition.class&quot;</span>, <span class="hljs-string">&quot;com.test.partition.SimplePartitioner&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>第三种情况：</strong>没有指定partition值但是有key的情况下，使用默认分区器DefaultPartitioner，将key的hash值与topic的partution数进行取余得到partition值；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;<br></code></pre></td></tr></table></figure><p><strong>第四种情况：</strong>既没有partition值又没有key值得情况下，第一次调用时随机生成一个证书（后面每次调用在这个整数上自增），将这个值与topic可用得partition总数取余得到partition值，也就是常说得round-robin算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> Utils.toPositive(ThreadLocalRandom.current().nextInt());<br>newPart = availablePartitions.get(random % availablePartitions.size()).partiton();<br></code></pre></td></tr></table></figure><h4 id="1-1-4-消息累加器"><a href="#1-1-4-消息累加器" class="headerlink" title="1.1.4 消息累加器"></a>1.1.4 消息累加器</h4><p>选择分区后并没有直接发送消息，而是把消息放入了消息累加器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">RecordAccumulator.<span class="hljs-type">RecordAppendResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> accumulator.append(tp,timestamp,serializedKey,serializedValue,headers,interceptCallback,remainingWaitMs);<br></code></pre></td></tr></table></figure><p>RecordAccumulator本质上是一个ConcurrentMap，一个partition一个Batch。batch满了之后，会唤醒Sender线程，发送消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(rasult.batchIsFull || result.newBatchCreated)&#123;<br>    log.trace(<span class="hljs-string">&quot;Waking up the sender since topic &#123;&#125; partition &#123;&#125; is either full or getting a new batch&quot;</span>, record.topic(), partition);<br>    <span class="hljs-built_in">this</span>.sender.wakeup();<br>&#125;<br></code></pre></td></tr></table></figure><p>小结一下：可以在拦截器中自定义消息处理逻辑，也可以选择自己喜欢得序列化工具，还可以自由选择分区。</p><h3 id="1-2-服务端响应ack"><a href="#1-2-服务端响应ack" class="headerlink" title="1.2 服务端响应ack"></a>1.2 服务端响应ack</h3><h4 id="1-2-1-响应策略"><a href="#1-2-1-响应策略" class="headerlink" title="1.2.1 响应策略"></a>1.2.1 响应策略</h4><p>kafka服务端应该要有一种响应客户端的方式，只有在服务端确认以后，生产者才发送下一轮的消息，否则重新发送数据。因为消息是存储在不同的partition中的，所以是写入到partition之后响应生产者。</p><p>当然，单个partition（leader）写入成功，还是不够可靠，如果有多个副本，follower也要写入成功才可以。服务端发送ACK给生产者总体上有两种思路：</p><p>​    第一种是需要有半数以上的follower节点完成同步，这样的话客户端等待的时间就短一些，延迟低。</p><p>​    第二种需要所有的follower全部完成同步，才发送ACK给客户端，延迟相对来说高一些，但是节点挂掉的影响相对来说小一些，因为所有的节点数据都是完整的。</p><p>​    kafka选择了第二种方案。部署同样机器数量的情况下，第二种方案的可靠性更高。例如部署5台机器，那么第一种方案最多可能会有2台机器丢失数据，第二种都不会丢失。而且网络延迟对kakfa的影响不大。</p><h4 id="1-2-2-ISR"><a href="#1-2-2-ISR" class="headerlink" title="1.2.2 ISR"></a>1.2.2 ISR</h4><p>不是所有的follower都有权力让我等待。应该把那些正常和leader保持同步的replica维护起来，放到一个动态set中，这个就叫做in-sync replica set （ISR）。现在只要ISR中的follower同步完数据之后，就给客户端发送ACK。对于经常性迟到，睡觉还关手机的太子，看来他不关心国事，也不能指望他了，把他从太子早会微信群移除了。如果一个follower长时间不同步数据，就要从ISR剔除。这个时间由参数replica.lag.time.max.ms决定（默认值30秒）。如果leader挂了，就会从ISR重新选举leader。</p><h4 id="1-2-3-ACK应答机制"><a href="#1-2-3-ACK应答机制" class="headerlink" title="1.2.3 ACK应答机制"></a>1.2.3 ACK应答机制</h4><p>kafka为客户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡，选择响应的配置。</p><p>acks=0：producer不等待broker的ack，这一操作提供了一个最低的延迟，broker一接受到还没写入磁盘就已经返回，当broker故障时有可能丢失数据；</p><p>acks=1（默认）：producer等待broker的ack，partition的leader落盘成功后返回ack，如果follower同步成功之前leader故障，那么将会丢失数据；</p><p>acks=-1（all）：producer等待broker的ack，partition的leader和follower全部落盘成功后才返回ack。</p><p>三种机制，性能依次递减（producer吞吐量降低），数据健壮性则依次递增。可以根据业务场景使用不同的参数。（类比：MySQL的binlog主从复制——同步，异步，半同步）</p><h2 id="2-Broker存储原理"><a href="#2-Broker存储原理" class="headerlink" title="2 Broker存储原理"></a>2 Broker存储原理</h2><h3 id="2-1-文件的存储结构"><a href="#2-1-文件的存储结构" class="headerlink" title="2.1 文件的存储结构"></a>2.1 文件的存储结构</h3><p>配置文件：config/server.properties  -&gt;  logs.dir配置，默认/tmp/kafka-logs</p><h4 id="2-1-1-partition分区"><a href="#2-1-1-partition分区" class="headerlink" title="2.1.1 partition分区"></a>2.1.1 partition分区</h4><p>为了实现横向扩展，把不同的数据存放在不同的Broker上，同时降低单台服务器的访问压力，把一个topic中的数据分隔成多个partition。一个partition中的消息是有序的，顺序写入，但是全局不一定有序。在服务器上，每个partiton都有一个物理目录，topic名字后面的数据标号即代表分区。</p><h4 id="2-1-2-replica副本"><a href="#2-1-2-replica副本" class="headerlink" title="2.1.2 replica副本"></a>2.1.2 replica副本</h4><p>为了提高分区的可靠性，kafka又设计了副本机制。创建topic的时候，通过指定replication-factor确定topic的副本数。注意：副本数必须小于等于节点数，而不能大于Broker的数量，否则会报错。这样就可以保证，绝对不会有一个分区的两个副本分布在同一个节点上，不然副本机制也失去了备份的意义了。</p><p>这些所有的副本分为两种角色，leader对外提供读写服务。follower唯一的任务就是从leader异步拉取数据。读写都发生在leader节点，就不存在读写分离带来的一致性问题了。这个叫做单调读一致性。</p><h4 id="2-1-3-副本在Broker的分布"><a href="#2-1-3-副本在Broker的分布" class="headerlink" title="2.1.3 副本在Broker的分布"></a>2.1.3 副本在Broker的分布</h4><p>分配策略是由AdminUtils.scala的assignReplicasToBrokers函数决定的。规则如下：</p><p>​    1）first of all，副本因子不能大于Broker的个数</p><p>​    2）第一个分区（编号为0的分区）的第一个副本放置位置是随机从brokerList选择的（Brokers2的副本）</p><p>​    3）其他分区的第一个副本放置位置相对于第0个分区依次往后移，也就是说：如果有5个Broker，5个分区，假设第一个分区的第一个副本放在第四个Broker上，那么第二个分区的第一个副本将会放在第五个Broker上；第三个分区的第一个副本将会放在第一个Broker上；第四个分区的第一个副本将会放在第二个Broker上，以此类推；</p><p>​    4）每个分区剩余的副本相对于第一个副本放置位置其实是nextReplicaShift决定的，而这个数也是随机产生的。</p><p>在每个分区的第一个副本错开之后，一般第一个分区的第一个副本（按Broker编号排序）都是leader。leader是错开的，不至于一挂影响太大。bin目录下的kafka-reassign-partitons.sh可以根据Broker数量变化情况重新分配分区。</p><h4 id="2-1-4-segment"><a href="#2-1-4-segment" class="headerlink" title="2.1.4 segment"></a>2.1.4 segment</h4><p>为了防止log不断追加导致文件过大，导致检索消息效率变低，一个partition又被划分成多个segment来组织数据（MySQL也有segment的逻辑概念，叶子节点就是数据段，非叶子节点就是索引段）。在磁盘上，每个segment由一个log文件和两个index文件组成。</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/4.png"></p><p>leader-epoch-checkpoint中保存了每一任leader开始写入消息时的offset。</p><p>（1）.log日志文件（日志就是数据）</p><p>​    在一个segment文件里面，日志是追加写入的。如果满足一定条件，就会切分日志文件，产生要给新的segment。</p><p>​    第一种是根据日志文件大小。当一个segment写满之后，会创建一个新的segment，用最新的offset作为名称。这个例子可以通过往一个Topic发送大量消息产生。segment的默认大小是1G，由这个参数控制：log.segment.bytes</p><p>​    第二种是根据消息的最大时间戳，和当前系统时间戳的差值。有一个默认的参数，168小时（一周）：log.roll.hours=168。意味着：如果服务器上次写入消息是一周之前，旧的segment就不写了，现在要创建一个新的segment。还可以从更加精细的时间单位进行控制，如果配置毫秒级别的日志切分间隔，会优先使用这个单位。否则就用小时的。log.roll.ms</p><p>​    第三种是offset索引文件或者timestamp索引文件达到了一定的大小，默认是10M。如果要减少日志文件的切分，可以把这个值调大一点。log.index.size.max.bytes</p><p>​    以及：索引文件写满了，数据文件也要跟着拆分，不然这一套东西对不上。另外两个是索引文件，单独来看：</p><p>​    （2）.index偏移量（offset）索引文件</p><p>​    （3）.timeindex时间戳（timestamp）索引文件</p><h4 id="2-1-5-索引"><a href="#2-1-5-索引" class="headerlink" title="2.1.5 索引"></a>2.1.5 索引</h4><p>由于一个segment的文件中可能存放很多消息，如果要根据offset获取消息，必须要有一个快速检索消息的机制。这个就是索引。在kafka中设计了两种索引。偏移量索引文件记录的是offset和消息物理地址（在log文件中的位置）的映射关系。时间戳索引文件记录的是时间戳和offset的关系。</p><p>当然，内容是二进制地文件，不能以纯文本形式查看。bin目录下dumplog工具。</p><p>kafka的索引并不是每一条消息都会建立索引，而是一种稀疏索引sparse index（DB2和MongoDB中都有稀疏索引）。</p><p>消息的大小来控制索引的产生，默认是4KB：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">log.index.interval.bytes</span>=<span class="hljs-string">4096</span><br></code></pre></td></tr></table></figure><p>只要写入的消息超过了4KB，偏移量索引文件.index和时间戳索引文件.timeindex就会增加一条索引记录（索引项）。这个值设置越小，索引越密集/值设置的越大，索引越稀疏。相对来说，越稠密的索引检索数据更快，但是会消耗更多的存储空间。越稀疏索引占用存储空间越小，但是插入和删除时所需的维护开销也小。Kafka索引的时间复杂度为O(log2n) + O(m)，n是索引文件里索引的个数，m是稀疏程度。</p><p>第二种索引类型是时间戳索引。首先消息是必须要记录时间戳的。客户端封装的ProducerRecord和ConsumerRecord都有一个long timestamp属性。</p><p>1、如果要基于时间切分日志文件，必须要记录时间戳。</p><p>2、如果要基于时间清理消息，必须要记录时间戳</p><p>注意时间戳有两种，一种是消息创建的时间戳，一种是消费在Broker追加写入的时间。到底用哪个时间由一个参数来控制：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">log.message.timestamp.type</span>=<span class="hljs-string">CreateTime</span><br></code></pre></td></tr></table></figure><p>默认是创建时间。如果要改成日志追加时间，则修改LogAppendTime。</p><p>kafka如何基于索引快速检索消息:</p><ol><li>消费的时候是能够确定分区的，所以第一步是找到在哪个segment中。segment文件是用base offset命名的，所以可以用二分法很快确定</li><li>这个segment有对应的索引文件，它们是成套出现的。所以现在要在索引文件中根据offset找position</li><li>得到position之后，到对应的log文件开始查找offset，和消息的offset进行比较，直到找到消息</li></ol><p>kafka是写多，查少。如果kafka用B+Tree，首先会出现大量的B+Tree，大量插入数据带来的B+tree的调整会非常消耗性能。</p><h3 id="2-2-消息保留-清理-机制"><a href="#2-2-消息保留-清理-机制" class="headerlink" title="2.2 消息保留(清理)机制"></a>2.2 消息保留(清理)机制</h3><h4 id="2-2-1-开关与策略"><a href="#2-2-1-开关与策略" class="headerlink" title="2.2.1 开关与策略"></a>2.2.1 开关与策略</h4><p>Kafka中提供了两种方式，一种是直接删除delete，一种是对日志进行压缩compact。默认是直接删除。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">log.cleanup.policy</span>=<span class="hljs-string">delete</span><br></code></pre></td></tr></table></figure><h4 id="2-2-2-删除策略"><a href="#2-2-2-删除策略" class="headerlink" title="2.2.2 删除策略"></a>2.2.2 删除策略</h4><p>日志删除是通过定时任务实现的。默认5分钟执行一次，看看有没有需要删除的数据。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">log.retention.check.interval.ms</span>=<span class="hljs-string">300000</span><br></code></pre></td></tr></table></figure><p>删除是从最老的数据开始删。关键是对老数据的定义。由一个参数控制：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">log.retention.hours</span>=<span class="hljs-string">168</span><br></code></pre></td></tr></table></figure><p>默认值是168小时（一周），也就是时间戳超过一周的数据才会删除。kafka另外提供了两个粒度更细的配置，分钟和毫秒。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 默认值是空。它的优先级比小时高，如果配置了则用这个。</span><br><span class="hljs-attr">log.retention.minutes</span><br><span class="hljs-comment"># 默认值是空。它的优先级比分钟高，如果配置了则用这个。</span><br><span class="hljs-attr">log.retention.ms</span><br></code></pre></td></tr></table></figure><p>第二种删除策略是根据日志大小删除，先删除旧的消息，删到不超过这个大小为止。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">log.retention.bytes</span>=<span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><p>默认值是-1，代表不限制大小，想写多少就写多少。log.retention.bytes指的是所有日志问价的总大小。也可以对单个segment文件大小进行限制。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 默认值1G。</span><br><span class="hljs-attr">log.segment.bytes</span>=<span class="hljs-string">1G</span><br></code></pre></td></tr></table></figure><h4 id="2-2-3-压缩策略"><a href="#2-2-3-压缩策略" class="headerlink" title="2.2.3 压缩策略"></a>2.2.3 压缩策略</h4><p>当有了这些key相同的value不同的消息的时候，存储空间旧被浪费了。压缩就是把相同的key合并为最后一个value。这个压缩跟Compression的含义不一样。所以，这里称为压紧更加合适。Log Compaction执行过后的偏移量不再是连续的，不过这并不影响日志的查询。</p><h3 id="2-3-高可用架构"><a href="#2-3-高可用架构" class="headerlink" title="2.3 高可用架构"></a>2.3 高可用架构</h3><h4 id="2-3-1-Controller选举"><a href="#2-3-1-Controller选举" class="headerlink" title="2.3.1 Controller选举"></a>2.3.1 Controller选举</h4><p>不是所有的repalica都参与leader选举，而是由其中的一个Broker统一来指挥，这个Broker的角色就是Controller。就像Redis Sentinel的架构，执行故障转移的时候，必须要先从所有哨兵中选一个负责做故障转移的节点一样。kafka也要先从所有Broker中选出唯一的一个Controller。所有的Broker会尝试在zookeeper中创建临时节点/controller，只有要给能创建成功（先到先得）。</p><p>​    如果Controller挂掉了或者网络出现了问题，ZK上的临时节点会消失。其他的Broker通过watch监听到Controller下线的消息后，开始竞选新的Controller。方法跟之前的还是一样的，谁现在ZK中写入一个Controller节点，谁就成为新的Controller。</p><p>​    一个节点成为Controller之后，它肩上的责任也比别人重了几份，正所谓劳力越大，责任越大：监听Broker变化；监听Topic变化；监听Partition变化；获取和管理Broker、Topic、Partition的信息；管理Partition的主从信息。</p><h4 id="2-3-2-分区副本Leader选举"><a href="#2-3-2-分区副本Leader选举" class="headerlink" title="2.3.2 分区副本Leader选举"></a>2.3.2 分区副本Leader选举</h4><p>一个分区所有的副本，叫做Assigned-Replicas（AR）。所有的皇太子。这些所有的副本中，跟leader数据保持一定程度同步的，叫做In-Sync Replicas（ISR）。天天过来参加早会，有希望继位的皇太子。跟leader不同步的副本，叫做Out-Sync-Replicas（OSR）。天天睡懒觉，不参加早会，没被皇帝放在眼里的皇太子。</p><p>AR=ISR+OSR。正常情况下OSR是空的，大家都正常同步，AR=ISR</p><p>默认情况下，当leader副本发生故障时，只有在ISR集合中的副本才有资格被选举为新的leader。</p><p>​    如果ISR为空呢？皇帝突然驾崩，太子们都还小，但是群龙不能无首。在这种情况下，可以让ISR之外的副本参与选举。允许ISR之外的副本参与选举，叫做unclean leader election。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">unclean.leader.election.enable</span>=<span class="hljs-string">false</span><br></code></pre></td></tr></table></figure><p>把这个参数改成true（一般情况不建议开启，会造成数据丢失）。</p><p>kafka的选举实现，最相近的是微软的PacificA算法。在这种算法中，默认是让ISR中第一个replica变成leader。比如ISR是1、5、9，优先让1成为leader。这个跟中国古代皇帝传为是一样的，优先传给皇长子。</p><h4 id="2-3-3-主从同步"><a href="#2-3-3-主从同步" class="headerlink" title="2.3.3 主从同步"></a>2.3.3 主从同步</h4><p>leader确定之后，客户端的读写只能操作leader节点。follower需要向leader同步数据。先说几个概念:</p><ol><li>LEO（Log End Offset）：下一条等待写入的消息的offset（最新的offset+1）</li><li>HW（High Watermark）：ISR中最小的LEO。Leader会管理所有ISR中最小的LEO作为HW。consumer最多只能消费到HW之前的位置（消费到offset5的消息）。也就是说：其他的副本没有同步过去的消息，是不能被消费的。如果在同步成功之前就被消费了，consumer group的offset会偏大。如果leader奔溃，中间会缺失消息。</li></ol><p>同步过程：</p><p>1、follower节点会向leader发送一个fetch请求，leader向follower发送数据后，即需要更新follower的LEO。</p><p>2、follower接收到数据响应后，依次写入消息并且更新LEO。</p><p>3、leader更新HW（ISR最小的LEO）</p><p>kafka设计了独特的ISR复制，可以在保障数据一致性的情况下又可以提高吞吐量。</p><h4 id="2-3-4-replica故障处理"><a href="#2-3-4-replica故障处理" class="headerlink" title="2.3.4 replica故障处理"></a>2.3.4 replica故障处理</h4><h5 id="2-3-4-1-follower故障处理"><a href="#2-3-4-1-follower故障处理" class="headerlink" title="2.3.4.1 follower故障处理"></a>2.3.4.1 follower故障处理</h5><p>首先follower发生故障，会被踢出ISR。恢复之后，首先根据之前记录的HW（6），把高于HW的消息截掉（6、7）.然后向leader同步消息。追上leader之后（30秒），重新加入ISR。</p><h5 id="2-3-4-2-leader故障处理"><a href="#2-3-4-2-leader故障处理" class="headerlink" title="2.3.4.2 leader故障处理"></a>2.3.4.2 leader故障处理</h5><p>首先选一个leader。为了保证数据一致，其他的follower需要把高于HW的消息截取掉（这里没有消息需要截取）。然后同步数据。注意：这种机制只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</p><h2 id="3-消费者原理"><a href="#3-消费者原理" class="headerlink" title="3 消费者原理"></a>3 消费者原理</h2><h3 id="3-1-offset维护"><a href="#3-1-offset维护" class="headerlink" title="3.1 offset维护"></a>3.1 offset维护</h3><h4 id="3-1-1-offset的存储"><a href="#3-1-1-offset的存储" class="headerlink" title="3.1.1 offset的存储"></a>3.1.1 offset的存储</h4><p>命令查看offset信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./kafka-consumer-groups.sh --bootstrap-server &lt;ip&gt; --describe --group assign-group-1<br></code></pre></td></tr></table></figure><table><thead><tr><th>PARTITION</th><th>CURRENT-OFFSET</th><th>LOG-END-OFFSET</th><th>LAG</th><th>CONSUMER-ID</th></tr></thead><tbody><tr><td>0</td><td>5</td><td>5</td><td>0</td><td>consumer-1</td></tr><tr><td>1</td><td>5</td><td>5</td><td>0</td><td>consumer-1</td></tr><tr><td>2</td><td>5</td><td>5</td><td>0</td><td>consumer-2</td></tr></tbody></table><p>CURRENT-OFFSET指的是下一个未使用的offset。</p><p>Log End Offset(LEO)：下一条等待写入的消息的offset（最新的offset+1）</p><p>LAG是延迟量</p><p>注意：不是一个消费者和Topic的关系。是一个consumer group和topic中的一个partiton的关系（offset在partition中连续编号而不是全局连续编号），这个对应关系是保存在服务端的。</p><p>kafka早期的版本把消费者组和partition的offset直接维护在ZK中，但是读写的性能消耗太大了。后来就放在一个特护的Topic中，名字叫_consumer_offsets，默认由50分区（offsets.topic.num.partitions默认是50），每个分区默认一个replication。</p><p>这个Topic中主要存储两种对象：</p><ol><li><p>GroupMetadata：保存了消费者组中各个消费者的信息（每个消费者有编号）。</p></li><li><p>OffsetAndMetadata：保存了消费者组和各个partition的offset位移信息元数据。</p></li></ol><p>确定offset在哪个分区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Math.abs(<span class="hljs-string">&quot;assign-group-1&quot;</span>.hashCode()) % <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><p>什么情况下找不到offset？就是没有消费过，没有把当前的offset上报给Broker。消费者的代码中有一个参数，用来控制如果找不到偏移量的时候从哪里开始消费。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">auto.fooset.reset</span>=<span class="hljs-string">latest</span><br></code></pre></td></tr></table></figure><p>默认值是latest，也就是最新的消息（最后发送的）开始消费。历史消息是不能消费的。</p><p>earliest代表从最早的（最先发送的）消息开始消费。可以消费到历史消息。</p><p>none，如果consumer group在服务端找不到offset会报错。</p><h4 id="3-1-2-offset的更新"><a href="#3-1-2-offset的更新" class="headerlink" title="3.1.2 offset的更新"></a>3.1.2 offset的更新</h4><p>消费者组的offset是保存在Broker的，但是是由消费者上报给Broker的，并不是消费者组消费了消息，offset就会更新，消费者必须要有一个commit的动作。就跟RabbitMQ中消费者的ACK一样。一样的，消费者可以手动提交或者自动提交，由参数控制：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">enable.auto.commit</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><p>默认是true，true代表消费者消费消息以后自动提交此时Broker会更新消费者组的offset。另外还可以使用一个参数来控制自动提交的频率：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 默认是5秒</span><br><span class="hljs-attr">auto.commit.interval.ms</span>=<span class="hljs-string">5000</span><br></code></pre></td></tr></table></figure><p>如果要在消费完消息做完业务逻辑处理之后才commit，就要把这个值改成false，如果是false，消费者就必须要调用一个方法让Broker更新offset。有两种方式：consumer.commitSync()的手动同步提交；consumer.commitAsync()的手动异步提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="hljs-number">100</span>));<br>    <span class="hljs-keyword">for</span>(ConsumerRecord&lt;String, String&gt; record : records) &#123;<br>        System.out.println(<span class="hljs-string">&quot;......&quot;</span>);<br>        buffer.add(record);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(buffer.size() &gt;= minBatchSize)&#123;<br>        <span class="hljs-comment">//同步提交</span><br>        consumer.commitSync();<br>        buffer.clear();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不提交或者提交失败，Broker的offset不会更新，消费者组下次消费的时候会消费到重复的消息。</p><h3 id="3-2-消费者消费策略"><a href="#3-2-消费者消费策略" class="headerlink" title="3.2 消费者消费策略"></a>3.2 消费者消费策略</h3><p>通过partition.assignment.strategy设置消费策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">props.put(<span class="hljs-string">&quot;partition.assignment.strategy&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.clients.consumer.RoundRobinAssignor&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="3-2-1-消费策略"><a href="#3-2-1-消费策略" class="headerlink" title="3.2.1 消费策略"></a>3.2.1 消费策略</h4><ol><li>RangeAssignor，默认策略。按照范围连续分配的。</li><li>RoundRobinAssignor，随机策略</li><li>StickyAssignor：这种策略复杂一点，但是相对来说均匀一点（每次结果都可能不一样）。原则：1）分区的分配尽可能的均匀。2）分区的分配尽可能和上次分配保持相同。</li></ol><p>Consumer可以指定topic的某个分区消费，要用到assign而不是subscrible的接口。subscribe会自动分配消费者组的分区，而assign可以手动指定分区消费，相当于consumer group id失效了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TopicPartition</span> <span class="hljs-variable">tp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TopicPartition</span>(<span class="hljs-string">&quot;as5part&quot;</span>, <span class="hljs-number">0</span>);<br>consumer.assign(Arrays.asList(tp));<br></code></pre></td></tr></table></figure><h4 id="3-2-2-rebalance分区重分配"><a href="#3-2-2-rebalance分区重分配" class="headerlink" title="3.2.2 rebalance分区重分配"></a>3.2.2 rebalance分区重分配</h4><p>有两种情况需要重新分配分区和消费者的关系：</p><p>​    1、消费者组的消费者数量发生变化。比如增加了消费者，消费者关闭连接</p><p>​    2、Topic的分区数发生变更，新增或者减少</p><p>​    为了让分区分配尽量地均衡，这个时候会触发rebalance机制。重新分配分成这么几步：</p><p>​    1、找一个话事人，它起到一个见度和保证公平地作用，每个Broker上都有要给用来管理offset，消费者组地实例，叫做GroupCoordinator。第一步就是要从所有地GroupCoordinator中找一个话事人出来。</p><p>​    2、第二步，清点一下认数。所有的消费者连接到GroupCoordinator报数，这个叫join group请求</p><p>​    3、第三步，选组长，GroupCoordinator从所有消费者中选一个leader。这个消费者会根据消费者地情况和设置地策略，确定一个方案。Leader把方案上报给GroupCoordinator，GroupCoordinator会通知给所有消费者。</p><h2 id="4-kafka特性"><a href="#4-kafka特性" class="headerlink" title="4 kafka特性"></a>4 kafka特性</h2><p>顺序读写，批量读写和文件压缩，零拷贝</p><h2 id="5-kafka消息不丢失的配置"><a href="#5-kafka消息不丢失的配置" class="headerlink" title="5 kafka消息不丢失的配置"></a>5 kafka消息不丢失的配置</h2><p>​    1、producer端使用producer.send(msg,callback)带有回调的send方法，而不是producer.send(msg)方法。根据回调，一旦出现消息提交失败的情况，就可以有针对性的进行处理。</p><p>​    2、设置acks=all。acks是Producer的一个参数，代表“已提交”消息的定义。如果设置成all，则标名所有Broker都要接收到消息，该消息才算是“已提交”。</p><p>​    3、设置retries为一个较大的值。同样是Producer的参数。当出现网络抖动时，消息发送可能会失败，此时配置了retries的Producer能够自动重试发送消息，尽量避免消息丢失。</p><p>​    4、设置unclean.leader.election.enable = false。</p><p>​    5、设置replication.factor&gt;=3。需要三个以上的副本。</p><p>​    6、设置min.insync.replicas&gt;1/Broker端参数，控制消息至少要被写入到多少个副本才算是已提交。设置成大于1可以提升消息持久性。在生产环境中不要使用默认值1。确保replication.factor&gt;min.insync.replicas。如果两者相等，那么只要有一个副本离线，整个分区就无法正常工作了。推荐设置成replication.factor = min.insync.replicas + 1。</p><p>​    7、确保消息消费完成再提交。Consumer端有个参数enable.auto.commit，最好设置成false，并自己来处理offset的提交更新。</p><h2 id="6-与RabbitMQ的对比"><a href="#6-与RabbitMQ的对比" class="headerlink" title="6 与RabbitMQ的对比"></a>6 与RabbitMQ的对比</h2><p>主要区别：</p><p>​    1、产品侧重——kafka：流式处理、消息引擎；RabbitMQ：消息代理</p><p>​    2、性能：kafka有更高的吞吐量。RabbitMQ主要是push，kafka只有pull</p><p>​    3、消息顺序：kafka分区中的消息是有序的，同一个consumer group中的一个消费者只能消费一个partition，能保证消息的顺序性。</p><p>​    4、消息的路由和分发：RabbitMQ更加灵活</p><p>​    5、延迟消息，死信队列：RabbitMQ支持</p><p>​    6、消息的留存：kafka消费完之后消息会留存，RabbitMQ消费完就删除。kafka可以设置retention，清理消息。</p><p>​    优先选择RabbitMQ的情况：高级灵活的路由规则；消息时序控制（控制消息过期或者消息延迟）；高级的容错处理能力，在消费者更有可能处理消息不成功的情景中（瞬时或者持久）；更简单的消费者实现。</p><p>​    优先选择kafka的情况：严格的消息顺序；延长消息留存时间，包括过去消息重放的可能；传统解决方案无法满足的高伸缩能力。</p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka使用</title>
    <link href="/2023/06/08/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/kafka%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/06/08/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/kafka%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Java-API"><a href="#1-Java-API" class="headerlink" title="1 Java API"></a>1 Java API</h2><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kafka-clients<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>topic要先提前创建，或者配置允许自动创建topic。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">auto.create.topics.enable</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><ol start="2"><li>消费者</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleConsumer</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        props.put(<span class="hljs-string">&quot;bootstrap.servers&quot;</span>, <span class="hljs-string">&quot;192.168.44.160:9092&quot;</span>);<br>        props.put(<span class="hljs-string">&quot;group.id&quot;</span>, <span class="hljs-string">&quot;test-group&quot;</span>);<br>        <span class="hljs-comment">//是否自动提交偏移量，只有commit之后才更新消费组的offset</span><br>        props.put(<span class="hljs-string">&quot;enable.auto.commit&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>        <span class="hljs-comment">//消费者自动提交的间隔</span><br>        props.put(<span class="hljs-string">&quot;auto.commit.interval.ms&quot;</span>, <span class="hljs-string">&quot;1000&quot;</span>);<br>        <span class="hljs-comment">//从最早的数据开始消费， earliest | latest | none</span><br>        props.put(<span class="hljs-string">&quot;auto.offset.reset&quot;</span>, <span class="hljs-string">&quot;earliest&quot;</span>);<br>        props.put(<span class="hljs-string">&quot;key.deserializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);<br>        props.put(<span class="hljs-string">&quot;value.deserializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);<br>        <br>        KafkaConsumer&lt;String, String&gt; consumer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaConsumer</span>&lt;&gt;(props);<br>        <span class="hljs-comment">//订阅队列</span><br>        consumer.subscribe(Arrays.asList(<span class="hljs-string">&quot;mytopic&quot;</span>));<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="hljs-number">1000</span>));<br>                <span class="hljs-keyword">for</span>(ConsumerRecord&lt;String, String&gt; record : records)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;.....&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            consumer.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>生产者</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">pros</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        pros.put(<span class="hljs-string">&quot;bootstrap.servers&quot;</span>, <span class="hljs-string">&quot;192.168.44.160:9092&quot;</span>);<br>        pros.put(<span class="hljs-string">&quot;key.deserializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);<br>        pros.put(<span class="hljs-string">&quot;value.deserializer&quot;</span>, <span class="hljs-string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);<br>        <span class="hljs-comment">//0 发出去就确认 | 1 leader落盘就确认 | all 所有Follower同步完才确认</span><br>        pros.put(<span class="hljs-string">&quot;acks&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>        <span class="hljs-comment">//异常自动重试次数</span><br>        pros.put(<span class="hljs-string">&quot;retries&quot;</span>, <span class="hljs-number">3</span>);<br>        <span class="hljs-comment">//多少条数据发送一次，默认16K</span><br>        pros.put(<span class="hljs-string">&quot;batch.size&quot;</span>, <span class="hljs-number">16384</span>);<br>        <span class="hljs-comment">//批量发送的等待时间</span><br>        pros.put(<span class="hljs-string">&quot;linger.ms&quot;</span>, <span class="hljs-number">5</span>);<br>        <span class="hljs-comment">//客户端缓冲区大小，默认为32M，满了也会触发消息发送</span><br>        pros.put(<span class="hljs-string">&quot;buffer.memory&quot;</span>, <span class="hljs-number">33554432</span>);<br>        <span class="hljs-comment">//获取元素据时生产者的阻塞时间，超时后抛出异常</span><br>        pros.put(<span class="hljs-string">&quot;max.block.ms&quot;</span>, <span class="hljs-number">3000</span>);<br>        <br>        Producer&lt;String, String&gt; producer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaProducer</span>&lt;&gt;(pros);<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)&#123;<br>            producer.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="hljs-string">&quot;mytopic&quot;</span>,Integer.toString(i)));<br>            System.out.println(<span class="hljs-string">&quot;发送成功&quot;</span>)；<br>        &#125;<br>        priducer.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-SpringBoot集成"><a href="#2-SpringBoot集成" class="headerlink" title="2 SpringBoot集成"></a>2 SpringBoot集成</h2><p>版本对应关系：<a href="https://spring.io/projects/spring-kafka">https://spring.io/projects/spring-kafka</a></p><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-kafka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>配置</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">7271</span><br><span class="hljs-attr">spring.kafka.bootstrap-servers</span>=<span class="hljs-string">192.168.44.160:9092</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#producer</span><br><span class="hljs-attr">spring.kafka.producer.retries</span>=<span class="hljs-string">1</span><br><span class="hljs-attr">spring.kafka.producer.batch-size</span>=<span class="hljs-string">16384</span><br><span class="hljs-attr">spring.kafka.producer.buffer-memory</span>=<span class="hljs-string">33554432</span><br><span class="hljs-attr">spring.kafka.producer.acks</span>=<span class="hljs-string">1</span><br><span class="hljs-attr">spring.kafka.producer.properties.linger.ms</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">spring.kafka.producer.key-serializer</span>=<span class="hljs-string">org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="hljs-attr">spring.kafka.producer.value-serializer</span>=<span class="hljs-string">org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="hljs-comment">#consumer</span><br><span class="hljs-attr">spring.kafka.consumer.auto-offset-reset</span>=<span class="hljs-string">earliest</span><br><span class="hljs-attr">spring.kafka.consumer.enable-auto-commit</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">spring.kafka.consumer.auto-commit-interval</span>=<span class="hljs-string">1000</span><br><span class="hljs-attr">spring.kafka.consumer.key-deserializer</span>=<span class="hljs-string">org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="hljs-attr">spring.kafka.consumer.value-deserializer</span>=<span class="hljs-string">org.apache.kafka.common.serialization.StringDeserializer</span><br></code></pre></td></tr></table></figure><ol start="3"><li>消费者</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用注解@KafkaListener监听Topic</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerListener</span>&#123;<br>    <span class="hljs-meta">@KafkaListener(topics = &quot;springboottopic&quot;, groupId=&quot;springgboottopic-group&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String msg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;收到消息：&quot;</span> + msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>生产者</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注入模板方法KafkaTemplate发送消息，注意send方法有很多重载。异步回调ListenableFuture。</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KafkaProducer</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> KafkaTemplate&lt;String, Object&gt; kafkaTemplate;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String msg)</span>&#123;<br>        kafkaTemplate.send(<span class="hljs-string">&quot;springboottopic&quot;</span>, msg);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">KafkaTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    KafkaProducer controller;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(time + <span class="hljs-string">&quot;已经发出&quot;</span>);<br>        controller.send(<span class="hljs-string">&quot;test&quot;</span> + time);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-集成Canal数据同步"><a href="#3-集成Canal数据同步" class="headerlink" title="3 集成Canal数据同步"></a>3 集成Canal数据同步</h2><p>Canal是一款纯Java开发的数据同步工具，可以支持binlog增量订阅（注意不是全量）。binlog设置为row模式以后，不仅能获取到执行的每一个增删改的脚本，同时还能获取到修改前和修改后的数据。所以，作为一款binlog增量数据解析的工具，canal可以做的事情很多，比如备份数据，缓存的同步刷新，构建ES索引，增量数据的处理等等。</p><p>canal可以多种方式把数据增量变动的信息发送出去，比如TCP和多种MQ，目前支持kafka，RabbitMQ，RocketMQ，而且提供了同步数据到hbase，elasticsearch的适配器。工作流程：数据变动——产生binlog信息——canal服务端获取binlog信息——发送MQ消息——消费者消费MQ消息，完成后续逻辑处理。</p><ol><li>在目标数据库上创建用户和数据库</li></ol><p>注意121的数据库首先要开启binlog，binlog-format必须是ROW</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">log-bin</span>=<span class="hljs-string">/var/lib/mysql/mysql-bin</span><br><span class="hljs-attr">binlog-format</span>=<span class="hljs-string">ROW</span><br></code></pre></td></tr></table></figure><p>用户和数据库创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建canal专用的用户，用于访问master获取binlog</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> canal IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><br><span class="hljs-comment">-- 给canal用户分配查询和复制的权限</span><br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>, REPLICATION SLAVE, REPLICATION CLIENT <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> canal@<span class="hljs-string">&#x27;%&#x27;</span>;<br><br><span class="hljs-comment">-- 刷新权限</span><br>FLUSH PRIVILEGES;<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;canal&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><br><span class="hljs-comment">-- 创建测试数据库</span><br><span class="hljs-keyword">CREATE</span> DATABASE `canaltest` CHARSET `utf8mb4` <span class="hljs-keyword">COLLATE</span> `utf8mb4_unicode_ci`;<br></code></pre></td></tr></table></figure><ol start="2"><li>在192.168.44.161上安装zk和kafka</li></ol><p>具体查看集群环境搭建</p><ol start="3"><li>下载安装canal</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft/<br><span class="hljs-built_in">mkdir</span> canal<br><span class="hljs-built_in">cd</span> canal<br>wget https://github.com/alibaba/canal/releases/download/canal-1.1.4/canal.deployer-1.1.4.tar.gz<br>tar -zxvf canal.deployer-1.1.4.tar.gz<br></code></pre></td></tr></table></figure><blockquote><p>需要修改的配置项：conf/canal.properties</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">canal.serverMode</span>=<span class="hljs-string">kafka</span><br><span class="hljs-attr">canal.mq.servers</span> = <span class="hljs-string">192.168.44.160:9092</span><br></code></pre></td></tr></table></figure><blockquote><p>example/instance.properties</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">canal.instance.master.address</span>=<span class="hljs-string">192.168.44.121:3306</span><br><span class="hljs-attr">canal.instance.dbUsername</span>=<span class="hljs-string">canal</span><br><span class="hljs-attr">canal.instance.dbPassword</span>=<span class="hljs-string">123456</span><br><span class="hljs-comment"># 新增</span><br><span class="hljs-attr">canal.instance.defaultDatabaseName</span>=<span class="hljs-string">canaltest</span><br><span class="hljs-comment"># 这个topic会自动创建</span><br><span class="hljs-attr">canal.mq.topic</span>=<span class="hljs-string">canal-topic</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 启动canal</span><br>sh startup.sh <br><span class="hljs-comment"># 查看实例日志</span><br><span class="hljs-built_in">tail</span> -100f /usr/local/soft/canal/logs/canal/canal.log<br></code></pre></td></tr></table></figure><h2 id="4-消息幂等性"><a href="#4-消息幂等性" class="headerlink" title="4 消息幂等性"></a>4 消息幂等性</h2><p>消息重复消费问题需要在消费者端解决，也就是消费者实现幂等性。考虑所有的消费者都要做一样的实现，kafka干脆在Broker实现了消息的重复性判断，大大的解放了消费者的双手。肯定要依赖于生产者的消息的唯一标识，不然是没办法知道是不是同一条消息的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">props.put(<span class="hljs-string">&quot;ennable.idempotence&quot;</span>, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>enable.idempotence设置成true后，Producer自动升级成幂等性Producer。Kafka会自动去重。有两个重要机制:</p><p>​    1、PID（Producer ID），幂等性的生产者每个客户端都有一个唯一的编号；</p><p>​    2、sequence number，幂等性的生产者发送的每条消息都会带相应的sequence number，Server端就是根据这个值来判断数据是否重复。如果说发现sequence number比服务端已经记录的值要小，那肯定是出现消息重复了。</p><p>​    当然，这个sequence number并不是全局有序的，不能保证所有时间上的幂等。所以，它的作用范围是有限的：</p><p>​    1、只能保证单分区上的幂等性，即一个幂等性Producer能够保证某个主题的一个分区不出现重复消息。</p><p>​    2、只能实现单会话上的幂等性，这里的会话是Producer进程的一次运行。当重启了Producer进程之后，幂等性不保证。</p><p>​    这个也很容易理解，也就是说不允许生产者在一次会话中向同一个partition发送相同的消息。如果要实现多个分区的消息的原子性，就要用到kafka的事务机制了。</p><h2 id="5-生产者事务"><a href="#5-生产者事务" class="headerlink" title="5 生产者事务"></a>5 生产者事务</h2><p>生产者事务是kafka2017年0.11.0.0引入的新特性，通过事务，kafka可以保证跨生产者会话的消息幂等发送。有几种情况需要开启事务：</p><p>​    1、假设只有1个Broker，1个topic的分区只有一个副本，如果要发送多条消息，想要让这些消息全部成功或者全部失败</p><p>​    2、更加复杂的情况，如果生产者发送消息到多个topic或者多个partition，它们有可能分布在不同的服务器上，需要它们全部发送成功或者全部发送失败</p><p>​    3、消费者和生产者在同一块代码中（consumer-process-produce），从上游接收消息，经过处理后发给下游，这个时候要保证接收消息和发送消息同时成功。</p><p>​    生产者跟事务相关的方法一共有5个：</p><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td>initTransactions()</td><td>初始化事务</td></tr><tr><td>beginTransaction()</td><td>开启事务</td></tr><tr><td>commitTransaction()</td><td>提交事务</td></tr><tr><td>abortTransaction()</td><td>终止事务</td></tr><tr><td>sendOffsetsToTransaction()</td><td>这个方法是消费者和生产者在同一段代码中使用的（从上游接收消费发送给下游），在提交的时候把消费的消息的offset发给consumer Corordinator</td></tr></tbody></table><p>在Spring boot中可以同executeInTransaction 方法，或者加上@Transaction的注解。   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//事务ID，唯一</span><br>pros.put(<span class="hljs-string">&quot;transaction.id&quot;</span>, UUID.randomUUID().toString());<br>Producer&lt;String, String&gt; producer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KafkaProducer</span>&lt;&gt;(pros);<br><span class="hljs-comment">//初始化事务</span><br>producer.initTransactions();<br><span class="hljs-keyword">try</span> &#123;<br>    producer.beginTransaction();<br>    producer.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="hljs-string">&quot;transaction-test&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>));<br>    producer.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="hljs-string">&quot;transaction-test&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>));<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>    producer.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="hljs-string">&quot;transaction-test&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>));<br>    <span class="hljs-comment">//提交事务</span><br>    producer.commitTransaction();<br>&#125; <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>    <span class="hljs-comment">//终止事务</span><br>    producer.abortTransaction();<br>&#125;<br></code></pre></td></tr></table></figure><p>kafka的分布式事务实现的核心思想。其中有几个关键点：</p><p>​    1）因为生产者的消息可能会跨分区，所以这里的事务是属于分布式事务。分布式事务的实现方式有很多，kafka选择了最常见的连接断提交（2PC）。如果大家都可以commit，那么就commit，否则abort。</p><p>​    2）既然是2PC，必须要有一个协调者的角色，叫做Transaction Coordinator。</p><p>​    3）事务管理器必须要有事务日志，来记录事务的状态，以便Coordinator在意外挂掉之后继续处理原来的事务，跟消费者offset的存储一样，kafka使用一个特殊的topic_transaction_state来记录事务状态。</p><p>​    4）如果生产者挂了，事务要在重启之后可以继续处理，接着之前未处理完的事务，或者在其他机器上处理，必须要有一个唯一的ID，这个就是transaction.id，这里使用UUID。配置了transaction.id，则此时enable.idempotence会被设置为true（事务实现的前提是幂等性）。事务ID相同的生产者，可以接着处理原来的事务。</p><p>步骤描述：</p><p>​    1、生产者通过initTransaction API向Coordinator注册事务ID</p><p>​    2、Coordinator记录事务日志</p><p>​    3、生产者把消息写入目标分区</p><p>​    4、分区和Coordinator的交互。当事务完成以后，消息的状态应该是已提交，这样消费者才可以消费到。</p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka入门及架构介绍</title>
    <link href="/2023/06/08/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/kafka%E5%85%A5%E9%97%A8%E5%8F%8A%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/06/08/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/kafka%E5%85%A5%E9%97%A8%E5%8F%8A%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>官网：<a href="http://kafka.apache.org/documentation/">http://kafka.apache.org/documentation/</a></p><p>Kafka 是使用 Scala 编写具有高水平扩展和高吞吐量的分布式消息系统。</p><p>Kafka 对消息保存时根据 Topic 进行归类，发送消息者成为 Producer ，消息接受者成为 Consumer ，此外 kafka 集群有多个 kafka 实例组成，每个实例(server)称为 broker。</p><p>无论是 Kafka集群，还是 producer 和 consumer 都依赖于 zookeeper 来保证系统可用性，为集群保存一些 meta 信息。</p><h2 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1 使用场景"></a>1 使用场景</h2><h3 id="1-1-消息传递"><a href="#1-1-消息传递" class="headerlink" title="1.1 消息传递"></a>1.1 消息传递</h3><p>消息传递就是发送数据，作为TCP HTTP或者RPC的替代方案，可以实现异步，解耦，削峰（RabbitMQ、RocketMQ能做的事情，它也能做）。因为kafka的吞吐量更高，在大规模消息系统中更有优势。第二个是大数据领域的使用，比如网站行为分析。</p><p>具体可以做网站活动跟踪，日志集合，应用指标监控等。</p><h3 id="1-2-数据集成-流计算"><a href="#1-2-数据集成-流计算" class="headerlink" title="1.2 数据集成+流计算"></a>1.2 数据集成+流计算</h3><p>数据集成指的是把kafka的数据导入Hadoop，Hbase等离线数据仓库，实现数据分析。</p><p>​    第三块是流计算。什么是流（Stream）？它不是静态的数据，而是没有边界的，源源不断地产生的数据，就像流水一样。流计算指的就是Stream对做实时的计算。</p><p>​    Kafka在0.10版本后，内置了流处理框架API——kafka Streams。</p><p>​    所以，它跟RabbitMQ的定位差别还是比较大的，不仅仅是一个简单的消息中间件，而且是一个流处理平台。在kafka中，消息被称为日志。日志就是消息的数据文件。</p><h2 id="2-安装与命令"><a href="#2-安装与命令" class="headerlink" title="2 安装与命令"></a>2 安装与命令</h2><h3 id="2-1-CentOS单机安装"><a href="#2-1-CentOS单机安装" class="headerlink" title="2.1 CentOS单机安装"></a>2.1 CentOS单机安装</h3><ol><li>下载解压kafka</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft<br>wget https://mirror.bit.edu.cn/apache/kafka/2.5.0/kafka_2.13-2.5.0.tgz<br>tar -xzvf kafka_2.13-2.5.0.tgz<br><span class="hljs-built_in">cd</span> kafka_2.13-2.5.0<br></code></pre></td></tr></table></figure><ol start="2"><li>启动zookeeper</li></ol><p>kafka需要依赖ZK，安装包中已经自带了一个ZK，也可以改成指定已运行的ZK。<br>如果改成指定的ZK需要修改修改 kafka 安装目录下的 config/server.properties 文件中的 zookeeper.connect 。这里使用自带的ZK。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 后台启动zk</span><br><span class="hljs-built_in">nohup</span> ./bin/zookeeper-server-start.sh config/zookeeper.properties &gt;&gt; zookeeper.nohup &amp;<br><span class="hljs-comment"># 检查zk是否启动成功</span><br>ps -ef | grep zookeeper<br></code></pre></td></tr></table></figure><ol start="3"><li>启动kafka</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 修改相关配置</span><br>vim config/server.properties<br></code></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># Broker ID启动以后就不能改了</span><br><span class="hljs-attr">broker.id</span>=<span class="hljs-string">1</span><br><span class="hljs-comment"># 取消注释，改成本机IP：</span><br><span class="hljs-attr">listeners</span>=<span class="hljs-string">PLAINTEXT://192.168.44.160:9092</span><br><span class="hljs-comment"># num.partitions后面增加2行。</span><br><span class="hljs-comment"># 发送到不存在topic自动创建。允许永久删除topic。</span><br><span class="hljs-attr">num.partitions</span>=<span class="hljs-string">1</span><br><span class="hljs-attr">auto.create.topics.enable</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">delete.topic.enable</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 后台启动kafka（kafka安装目录下）</span><br><span class="hljs-built_in">nohup</span> ./bin/kafka-server-start.sh ./config/server.properties &amp; <br></code></pre></td></tr></table></figure><ol start="4"><li>创建Topic</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建一个名为gptest的topic，只有一个副本，一个分区</span><br>sh bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic <span class="hljs-built_in">test</span><br><br><span class="hljs-comment"># 查看已经创建的 topic</span><br>sh bin/kafka-topics.sh -list -zookeeper localhost:2181<br></code></pre></td></tr></table></figure><ol start="5"><li>启动Producer</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 新窗口</span><br>sh bin/kafka-console-producer.sh --broker-list localhost:9092 --topic <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><ol start="6"><li>启动Consumer</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 新窗口</span><br>sh bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="hljs-built_in">test</span> --from-beginning<br></code></pre></td></tr></table></figure><ol start="7"><li>删除kafka全部数据</li></ol><p>（1）停止每台机器上的kafka；<br>（2）删除kafka存储目录（server.properties文件log.dirs配置，默认为“/tmp/kafka-logs”）全部topic的数据目录；<br>（3）删除zookeeper上与kafka相关的znode节点；除了/zookeeper<br>（4）重启kafka。</p><h3 id="2-2-单机集群安装-伪集群"><a href="#2-2-单机集群安装-伪集群" class="headerlink" title="2.2 单机集群安装-伪集群"></a>2.2 单机集群安装-伪集群</h3><ol><li>下载解压</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft<br>wget https://mirror.bit.edu.cn/apache/kafka/2.5.0/kafka_2.13-2.5.0.tgz<br>tar -xzvf kafka_2.13-2.5.0.tgz<br><span class="hljs-built_in">cd</span> kafka_2.13-2.5.0<br></code></pre></td></tr></table></figure><ol start="2"><li>修改配置文件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 复制3个配置文件</span><br><span class="hljs-built_in">cd</span> config<br><span class="hljs-built_in">cp</span> server.properties server1.properties <br><span class="hljs-built_in">cp</span> server.properties server2.properties <br><span class="hljs-built_in">cp</span> server.properties server3.properties <br></code></pre></td></tr></table></figure><p>修改配置文件中的broker.id分别为1、2、3<br>listeners这一行取消注释，端口号分别为9093、9094、9095<br>log.dirs分别设置为kafka-logs1、kafka-logs2、kafka-logs3（先创建）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> -p /tmp/kafka-logs1 /tmp/kafka-logs2 /tmp/kafka-logs3<br></code></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># server1.properties 的配置：</span><br><span class="hljs-attr">broker.id</span>=<span class="hljs-string">1</span><br><span class="hljs-attr">listeners</span>=<span class="hljs-string">PLAINTEXT://192.168.44.161:9093</span><br><span class="hljs-attr">log.dirs</span>=<span class="hljs-string">/tmp/kafka-logs1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># server2.properties 的配置：</span><br><span class="hljs-attr">broker.id</span>=<span class="hljs-string">2</span><br><span class="hljs-attr">listeners</span>=<span class="hljs-string">PLAINTEXT://192.168.44.161:9094</span><br><span class="hljs-attr">log.dirs</span>=<span class="hljs-string">/tmp/kafka-logs2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># server3.properties 的配置：</span><br><span class="hljs-attr">broker.id</span>=<span class="hljs-string">3</span><br><span class="hljs-attr">listeners</span>=<span class="hljs-string">PLAINTEXT://192.168.44.161:9095</span><br><span class="hljs-attr">log.dirs</span>=<span class="hljs-string">/tmp/kafka-logs3</span><br></code></pre></td></tr></table></figure><ol start="3"><li>启动三个服务</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 先启动zk，再启动kafka</span><br>./kafka-server-start.sh -daemon ../config/server1.properties<br>./kafka-server-start.sh -daemon ../config/server2.properties<br>./kafka-server-start.sh -daemon ../config/server3.properties<br><br><span class="hljs-comment"># 如果遇到zk node exists的问题，先把brokers节点删掉（临时解决方案）。</span><br></code></pre></td></tr></table></figure><ol start="4"><li>创建Topic</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建一个名为gptest的topic，只有一个副本，一个分区</span><br>sh kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic <span class="hljs-built_in">test</span><br><span class="hljs-comment"># 查看已经创建的 topic</span><br>sh kafka-topics.sh -list -zookeeper localhost:2181<br></code></pre></td></tr></table></figure><ol start="5"><li>启动Consumer</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 新窗口</span><br>sh kafka-console-consumer.sh --bootstrap-server 192.168.44.161:9093,192.168.44.161:9094,192.168.44.161:9095 --topic <span class="hljs-built_in">test</span> --from-beginning<br></code></pre></td></tr></table></figure><ol start="6"><li>启动Producer</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 新窗口</span><br>sh kafka-console-producer.sh --broker-list 192.168.44.161:9093,192.168.44.161:9094,192.168.44.161:9095 --topic <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h3 id="2-3-kafka脚本介绍"><a href="#2-3-kafka脚本介绍" class="headerlink" title="2.3 kafka脚本介绍"></a>2.3 kafka脚本介绍</h3><table><thead><tr><th>脚本</th><th>作用</th></tr></thead><tbody><tr><td>kafka-server-start.sh <br />kafka-server-stop.sh</td><td>kafka启动停止</td></tr><tr><td>kafka-topics.sh</td><td>查看创建删除topic</td></tr><tr><td>kafka-console-consumer.sh</td><td>消费者操作，例如监听topic</td></tr><tr><td>kafka-consumer-groups.sh</td><td>消费者组操作</td></tr><tr><td>kafka-console-producer.sh</td><td>生产者操作，例如发送消息</td></tr><tr><td>zookeeper-server-start.sh</td><td>zk操作，启动停止连接zk</td></tr><tr><td>kafka-reassign-partitions.sh</td><td>分区重新分配</td></tr><tr><td>kafka-consumer-perf-test.sh</td><td>性能测试</td></tr></tbody></table><h3 id="2-4-kafka界面管理工具"><a href="#2-4-kafka界面管理工具" class="headerlink" title="2.4 kafka界面管理工具"></a>2.4 kafka界面管理工具</h3><p>Kafka没有自带管理界面，但是基于admin的接口可以开发。目前比较流行的管理界面主要是kafka-manager和kafka-eagle（国产）。</p><p><a href="https://github.com/yahoo/kafka-manager/releases">https://github.com/yahoo/kafka-manager/releases</a></p><p><a href="https://github.com/smartloli/kafka-eagle">https://github.com/smartloli/kafka-eagle</a></p><p>注意最新版本的cmak对java版本要求比较高，最低需要JDK11。kafka-eagle对内存要求比较高，在虚拟机中部署需要修改JVM参数才能启动。</p><h2 id="3-架构分析"><a href="#3-架构分析" class="headerlink" title="3 架构分析"></a>3 架构分析</h2><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/1.png"></p><h3 id="3-1-Broker"><a href="#3-1-Broker" class="headerlink" title="3.1 Broker"></a>3.1 Broker</h3><p>kafka作为一个中间件，是存储和转发消息的，它做的事情优点像中介，所以把kafka的服务叫做Broker，默认是9092端口。生产者和消费者都需要跟这个Broker建立一个连接，才可以实现消息的收发。</p><h3 id="3-2-消息"><a href="#3-2-消息" class="headerlink" title="3.2 消息"></a>3.2 消息</h3><p>客户端之间传输的数据叫做消息，或者叫做记录。在客户端的代码中。Reocrd可以是一个KV键值对。</p><p>生产者对应的封装类是ProducerRecord，消费者对应的封装类是ConsumerRecord。消息在传输过程中需要序列化，所以代码中要指定序列化工具。消息在服务端的存储格式（RecordBatc和Record）：<a href="http://kafka.apache.org/documentation/#messageformat">http://kafka.apache.org/documentation/#messageformat</a></p><h3 id="3-3-生产者"><a href="#3-3-生产者" class="headerlink" title="3.3 生产者"></a>3.3 生产者</h3><p>发送消息的一方叫做生产者，接收消息的一方叫做消费者。为了提升消息发送速率，生产者不是逐条发送消息给Broker，而是批量发送的。多少条发送一次由一个参数决定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">pros.put(<span class="hljs-string">&quot;batch.size&quot;</span>, <span class="hljs-number">16384</span>);<br></code></pre></td></tr></table></figure><h3 id="3-4-消费者"><a href="#3-4-消费者" class="headerlink" title="3.4 消费者"></a>3.4 消费者</h3><p>一般来说消费者获得消息有两种模式，一种是pull模式，一种是push模式。</p><p>Pull模式就是消息放在Broker，消费者自己决定什么时候去获取。Push模式是消息放在Consumer，只要有消息到达Broker，都直接推给消费者。</p><p>RabbitMQ Consumer支持push和pull，一般使用push。Kafka只有pull模式。</p><p>为什么消费者用pull，官网已经说得很明白了：<a href="http://kafka.apache.org/documentation/#design_pull">http://kafka.apache.org/documentation/#design_pull</a></p><p>在push模式下，如果消息产生速度远远大于消费者消费消息的速率，那消费者就会不堪重负，直到挂掉。而且消费者可以自己控制一次到底获取多少条消息：max.poll.records。默认500。在poll方法中可以指定。</p><h3 id="3-5-Topic"><a href="#3-5-Topic" class="headerlink" title="3.5 Topic"></a>3.5 Topic</h3><p>kafka中，队列叫做Topic，是一个逻辑的概念，可以理解为一组消息的集合（不同业务用途的消息）。生产者和Topic以及Topic和消费者的关系都是多对多。一个生产者可以发送消息到多个Topic，一个消费者也可以从多个Topic获取消息（但是不建议这么做）。</p><p>注意，生产者发送消息时，如果Topic不存在，会自动创建。由一个参数控制： auto.create.topics.enable</p><p>默认为true。如果要彻底删掉一个Topic，这个参数必须改为false，否则只有代码使用这个Topic，它就会自动创建。</p><p><a href="https://kafka.apache.org/documentation/#auto.crete.topics.enable">https://kafka.apache.org/documentation/#auto.crete.topics.enable</a></p><h3 id="3-6-Partition与Cluster"><a href="#3-6-Partition与Cluster" class="headerlink" title="3.6 Partition与Cluster"></a>3.6 Partition与Cluster</h3><p>如果说一个Topic的消息太多，会带来两个问题：</p><p>​    1、不方便横向扩展，比如想要在集群中把数据分布在不同的机器上实现扩展，而不是通过升级硬件做到，如果一个Topic的消息无法在物理上拆分到多台机器的时候，这个是做不到的。</p><p>​    2、并发或者负载的问题，所以的客户端操作的都是同一个Topic，在搞并发的场景下性能会大大下降。</p><p>​    怎么解决这个问题呢？想到的就是把一个Topic进行拆分（分片的思想）。</p><p>​    kafka引入了一个分区（Partition）的概念。一个Topic可以划分成多个分区。分区在创建topic的时候指定，每个topic至少有一个分区。如果没有指定分区数，默认的分区数是一个，这个参数可以修改：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">num.partitions</span>=<span class="hljs-string">1</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>partitions是分区数，replication-factor是主题的副本数。</p><p>partition思想上有点类似与分库分表，实现的也是横向扩展和负载的目的。</p><p>每个partition都有一个物理目录。在配置的数据目录下（日志就是数据）：/tem/kafka-logs</p><p>跟RabbitMQ不一样的地方是，Partition中的消息被读取之后不会被删除，所以一批消息在一个Partition里面顺序，追加写入的。这个也是kafka吞吐量大的一个很重要的原因。</p><h3 id="3-7-Partition副本Replica机制"><a href="#3-7-Partition副本Replica机制" class="headerlink" title="3.7 Partition副本Replica机制"></a>3.7 Partition副本Replica机制</h3><p>如果partiton的数据只存储一份，在发生网络或者硬件故障的时候，该分区的数据就无法访问或者无法恢复了。kafka在0.8版本后增加了副本机制。每个partition可以有若干个副本（Replica），副本必须在不同的Broker上面。一般说的副本包括其中的主节点。由repliacation-factor指定一个Topic的副本数。服务端有一个参数控制默认的副本数：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">offsets<span class="hljs-selector-class">.topic</span><span class="hljs-selector-class">.replication</span>.factor<br></code></pre></td></tr></table></figure><h3 id="3-8-Segment"><a href="#3-8-Segment" class="headerlink" title="3.8 Segment"></a>3.8 Segment</h3><p>kafka的数据是放在后缀.log的文件中的。如果一个partiton只有一个log文件，消息不断地追加，这个log文件也会变得越来越大，这个时候要检索数据效率就很低了。所以干脆把partition再做一个切分，切分出来的单位就叫做段（Segment）。实际上kafka的存储文件是划分成段来存储的。默认存储路径：/tmp/kafka-logs</p><p>每个segment都有至少1个数据文件和2个索引文件，这三个文件是成套出现的。segment默认大小是1G，由这个参数控制：log.segment.bytes</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/2.png"></p><h3 id="3-9-Consumer-Group"><a href="#3-9-Consumer-Group" class="headerlink" title="3.9 Consumer Group"></a>3.9 Consumer Group</h3><p>Consumer Group消费组的概念，在代码中通过group id来配置。消费同一个topic的消费者不一定是同一组，只有group id相同的消费者才是同一个消费者组。</p><p>注意：同一个group中的消费者，不能浪费相同的partition——partition要在消费者之间分配。</p><p>怎么理解呢？在上大学的时候是没有固定的教室的吧？教室中的座位可以理解成partition，分区。一个教室由很多班级都可以使用，一个班级就可以理解为consumer group。很显然，对于一个班级来说，是不可能两个人坐一张桌子的。但是对于不同的班级，却是可以的。比如编号为0的这张桌子，5班的某个学生用，6班的某个学生用，7班的某个学生用。</p><p>​    那就会有一个问题，如果学生比桌子多，或者学生比桌子少，怎么办？</p><p>​    1、如果消费者比partition少，一个消费者可能消费多个partition（两张桌子凑在一起，躺在桌子上都可以）</p><p>​    2、如果消费者比partition多，肯定有消费者没有partition可以消费（两个人不能挤在一张桌子上，有一个人站着上课了）。不会出现一个group中的消费者消费同一个partition的情况。</p><p>​    如果想要同时消费同一个partition的消息，那么需要其他的组来消费。</p><h3 id="3-10-Consumer-Offset"><a href="#3-10-Consumer-Offset" class="headerlink" title="3.10 Consumer Offset"></a>3.10 Consumer Offset</h3><p>partition中的消息是顺序写入的，被读取之后不会被删除。如果消息者挂了或者下一次读取，想要接着上次的位置读取消息，或者从某个特定的位置读取消息，怎么办呢？会不会出现重复消费的情况？因为消息是有序的，可以对消息进行编号，用来标识一条唯一的消息。</p><p>这个编号就把它叫做offset，偏移量。offset记录着下一条将要发送给consumer的消息的序号。这个消费者跟partition之间的的偏移量没有保存在ZK，而是直接保存在服务端。</p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ实践应用</title>
    <link href="/2023/06/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/%E5%AE%9E%E8%B7%B5%E5%BA%94%E7%94%A8/"/>
    <url>/2023/06/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/%E5%AE%9E%E8%B7%B5%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-订单延迟关闭"><a href="#1-订单延迟关闭" class="headerlink" title="1 订单延迟关闭"></a>1 订单延迟关闭</h2><h3 id="1-1-业务场景"><a href="#1-1-业务场景" class="headerlink" title="1.1 业务场景"></a>1.1 业务场景</h3><p>假设有一个业务场景：超过30分钟未付款的订单自动关闭，这个功能怎么做？</p><p>思路：发一条跟订单相关的消息，30分钟后被消费，在消费者的代码中查询订单数据，如果支付状态是未付款，就关闭订单。</p><p>RabbitMQ本身不支持延迟投递，总的来说有2种实现方案：</p><p>​    1、先存储到数据库，用定时任务扫描</p><p>​    2、利用RabbitMQ的死信队列（Dead Letter Queue）实现</p><p>定时任务比较容易实现，比如每隔一分钟扫描一次，查出30分钟之前未付款的订单，把状态改成关闭。但是如果瞬间要处理的数据量过大，比如10万条，把这些数据查询到内存中逐条处理，也会给服务器带来很大的压力，影响正常业务的运行。</p><p>第二点，死信队列</p><h3 id="1-2-Message-TTL-Time-To-Live"><a href="#1-2-Message-TTL-Time-To-Live" class="headerlink" title="1.2 Message TTL (Time To Live)"></a>1.2 Message TTL (Time To Live)</h3><h4 id="1-2-1-队列的属性"><a href="#1-2-1-队列的属性" class="headerlink" title="1.2.1 队列的属性"></a>1.2.1 队列的属性</h4><p>首先队列有一个消息过期属性。就像丰巢超过24小时就收费一样，通过设置这个属性，超过了指定的消息将会被丢弃。这个属性叫：x-message-ttl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">// 队列中的消息未被消费11秒后过期</span><br>    map.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>, <span class="hljs-number">11000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;TTL_Queue&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, map);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这种方式不是那么灵活。所以RabbitMQ的消息也有单独的过期事件属性。</p><h4 id="1-2-2-消息的属性"><a href="#1-2-2-消息的属性" class="headerlink" title="1.2.2 消息的属性"></a>1.2.2 消息的属性</h4><p>在发送消息的时候通过MessageProperties指定消息属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MessageProperties</span> <span class="hljs-variable">messageProperties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageProperties</span>();<br><span class="hljs-comment">// 消息过期属性，单位ms</span><br>messageProperties.setExpiration(<span class="hljs-string">&quot;4000&quot;</span>);<br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;这条消息4秒后过期&quot;</span>.getBytes(), messageProperties);<br>rabbitTemplate.send(<span class="hljs-string">&quot;TTL_EXCHANGE&quot;</span>)<br></code></pre></td></tr></table></figure><p>如果同时指定了message TTL和Queue TTL，则小的那个时间生效。</p><p>有了过期时间还不够，这个消息不能直接丢弃，不然就没办法消费了。最好是丢到一个容器中，这样就可以实现延迟消费了。这里来了解一下死信的概念。</p><h3 id="1-3-死信"><a href="#1-3-死信" class="headerlink" title="1.3 死信"></a>1.3 死信</h3><p>消息过期后，如果没有任何配置，是会直接丢弃的。可以通过配置让这样的消息变成死信（Dead Letter），在别的地方存储。</p><h4 id="1-3-1-死信去哪里"><a href="#1-3-1-死信去哪里" class="headerlink" title="1.3.1 死信去哪里"></a>1.3.1 死信去哪里</h4><p>队列在创建的时候可以指定一个死信交换机DLX（Dead Letter Exchange）。死信交换机绑定的队列被称为死信队列DLQ（Dead Letter Queue），DLX实际上也是普通的交换机，DLQ也是普通的队列。</p><p>也就是说，如果消息过期了，队列指定了DLX，就会发送到DLX。如果DLX指定DLQ，就会路由到DLQ。路由到DLQ后，就可以消费了。</p><h4 id="1-3-2-死信队列的使用"><a href="#1-3-2-死信队列的使用" class="headerlink" title="1.3.2 死信队列的使用"></a>1.3.2 死信队列的使用</h4><p>下面通过一个例子来演示死信队列的使用。</p><p>​    1、声明原交换机，原队列，相互绑定。指定原队列的死信交换机。</p><p>​    2、声明死信交换机，死信队列，并且通过“#”绑定，代表无条件路由</p><p>​    3、最终消费者监听死信队列，在这里实现检查订单状态逻辑。</p><p>​    4、生产者发送消息测试，设置消息10秒过期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">![<span class="hljs-number">5</span>](E:\Project\blog-hexo\source\image\消息队列\RabbitMQ\<span class="hljs-number">5.</span>png)<span class="hljs-comment">//指定队列的死信交换机</span><br>Map&lt;String, Object&gt; arguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>arguments.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, <span class="hljs-string">&quot;DEAD_LETTER_EXCHANGE&quot;</span>);<br><span class="hljs-comment">//arguments.put(&quot;x-expires&quot;, &quot;9000&quot;);  //设置队列的TTL</span><br><span class="hljs-comment">//arguments.put(&quot;x-max-length&quot;, 4);    //如果设置了队列的最大长度，超过长度时，先入队的消息会被发送到DLX</span><br><br><span class="hljs-comment">//声明队列（默认交换机AMQP default, Direct）</span><br><span class="hljs-comment">//String queue, boolean durable, boolean exclusive, boolean antoDelete, Map&lt;String, Object&gt; arguments</span><br>channel.queueDeclare(<span class="hljs-string">&quot;ORI_USE_QUEUE&quot;</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,arguments);<br><span class="hljs-comment">//声明死信交换机</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;DEAD_LETTER_EXCHANGE&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br><span class="hljs-comment">//声明死信队列</span><br>channel.queueDeclare(<span class="hljs-string">&quot;DEAD_LETTER_QUEUE&quot;</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br><span class="hljs-comment">//绑定</span><br>channel.queueBind(<span class="hljs-string">&quot;DEAD_LETTER_QUEUE&quot;</span>,<span class="hljs-string">&quot;DEAD_LETTER_EXCHANGE&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;wating for message&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="1-3-3-消息流转"><a href="#1-3-3-消息流转" class="headerlink" title="1.3.3 消息流转"></a>1.3.3 消息流转</h4><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/5.png"></p><p>总结一下，利用消息的过期时间，过期后投递到DLX，路由到DLQ，监听DLQ，实现了延迟队列。</p><p>消息的流转流程：生产者——原交换机——原队列（超过TTL之后）——死信交换机——死信队列——最终消费者。</p><h3 id="1-4-延迟队列的其他实现"><a href="#1-4-延迟队列的其他实现" class="headerlink" title="1.4 延迟队列的其他实现"></a>1.4 延迟队列的其他实现</h3><p>使用死信队列实现延时消息的缺点：</p><p>​    （1）如果统一用队列来设置消息的TTL，当梯度非常多的情况下，比如1分钟，2分钟，5分钟，10分钟，20分钟，30分钟……需要创建很多交换机和队列来路由消息。</p><p>​    （2）如果单独设置消息的TTL，则可能会造成队列中的消息阻塞——前一条消息没有出队（没有被消费），后面的消息无法投递（比如第一条消息过期TTL是30min，第二条消息TTL是10min。10分钟后，及时第二条消息应该投递了，但是由于第一条消息还未出队，所以无法投递）</p><p>​    （3）可能存在一定的时间误差</p><p>在RabbitMQ3.5.7及以后的版本提供了一个插件（rabbitmq-delayed-message-exchange）来实现演示队列功能（Linux和windows都可用）。同时插件依赖Erlang/OPT18.0及以上。</p><p>​    插件源码地址：<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange</a></p><p>​    插件下载地址：<a href="https://bintray.com/rabbitmq/community-plugins.rabbitmq_delayed_message_exchange">https://bintray.com/rabbitmq/community-plugins.rabbitmq_delayed_message_exchange</a></p><p>使用方法：</p><ol><li>进入目录</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">whereis rabbitmq<br><span class="hljs-built_in">cd</span> /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.12/plugins<br></code></pre></td></tr></table></figure><ol start="2"><li>下载插件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">wget https://bintray.com/rabbitmq/community-plugins/download_file?file_path=rabbitmq_delayed_message_exchange-0.0.1.ez<br></code></pre></td></tr></table></figure><p>如果下载的文件名带问号，则需要改名，如图：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mv</span> download_file?file_path=rabbitmq_delayed_message_exchange-0.0.1.ez rabbitmq_delayed_message_exchange-0.0.1.ez<br></code></pre></td></tr></table></figure><ol start="3"><li>启用插件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_delayed_message_exchange<br></code></pre></td></tr></table></figure><ol start="4"><li>停用插件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rabbitmq-plugins <span class="hljs-built_in">disable</span> rabbitmq_delayed_message_exchange<br></code></pre></td></tr></table></figure><ol start="5"><li>插件使用</li></ol><p>通过声明一个x-delayed-message类型的Exchange来使用delayed-messageing特性。x-delayed-message是插件提供的类型，并不是rabbitmq本身的（区别于direct，topic，fanout，headers）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(&quot;delayExchange&quot;)</span><br><span class="hljs-keyword">public</span> TopicExchange <span class="hljs-title function_">exchange</span><span class="hljs-params">()</span>&#123;<br>    Map&lt;String, Object&gt; arges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    arges.put(<span class="hljs-string">&quot;x-delay-type&quot;</span>, <span class="hljs-string">&quot;direct&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TopicExchange</span>(<span class="hljs-string">&quot;DELAY_EXCHANGE&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,arges);<br>&#125;<br></code></pre></td></tr></table></figure><p>生产者：消息属性中指定x-delay参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MessageProperties</span> <span class="hljs-variable">messageProperties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageProperties</span>();<br><span class="hljs-comment">// 延迟的间隔时间，目标时刻减去当前时刻</span><br>messageProperties.setHeader(<span class="hljs-string">&quot;x-delay&quot;</span>, delayTime.getTime() - now.getTime());<br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(msg.getBytes(),messageProperties);<br>rabbitTempliate.send(<span class="hljs-string">&quot;DELAY_EXCHANGE&quot;</span>, <span class="hljs-string">&quot;#&quot;</span>, message);<br></code></pre></td></tr></table></figure><p>补充：除了消息过期，还有什么情况消息会变成死信？</p><p>​    1）消息被消费者拒绝并且未设置重回队列：（NACK || Reject）&amp;&amp;requeue == false</p><p>​    2）队列达到最大长度，超过了Max length（消息数）或者Max length bytes（字节数），最先入队的消息会被发送到DLX。</p><p>RabbitMQ的消息是存在磁盘上的，如果内存节点，会同时存在磁盘和内存中。当RabbitMQ生产MQ消息的速度远大于消费消息的速度时，会产生大量的消息堆积，占用系统资源，导致机器性能下降。流量控制可以从几方面来控制，一个是服务端，一个是消费端。</p><h2 id="2-服务端流控"><a href="#2-服务端流控" class="headerlink" title="2 服务端流控"></a>2 服务端流控</h2><p><a href="https://www.rabbitmq.com/configure.html">https://www.rabbitmq.com/configure.html</a></p><p><a href="https://www.rabbitmq.com/flow-control.html">https://www.rabbitmq.com/flow-control.html</a></p><p><a href="https://www.rabbitmq.com/memory.html">https://www.rabbitmq.com/memory.html</a></p><p><a href="https://www.rabbitmq.com/disk-alarms.html">https://www.rabbitmq.com/disk-alarms.html</a></p><h3 id="2-1-队列长度"><a href="#2-1-队列长度" class="headerlink" title="2.1 队列长度"></a>2.1 队列长度</h3><p>队列有两个控制长度的属性：</p><p>x-max-length：队列中最大存储最大消息数，超过这个数量，对头的消息会被丢弃。</p><p>x-max-length-bytes：队列存储的最大消息容量（单位bytes），超过这个容量，对头的消息会被丢弃。</p><p>需要注意的是，设置队列长度只在消息堆积的情况下有意义，而且会删除先入队的消息，不能真正的实现服务端限流</p><h3 id="2-2-内存控制"><a href="#2-2-内存控制" class="headerlink" title="2.2 内存控制"></a>2.2 内存控制</h3><p><a href="https://www.rabbitmq.com/configure.html">https://www.rabbitmq.com/configure.html</a></p><p>RabbitMQ会在启动时检测机器的物理内存数值。默认当MQ占用40%以上内存时，MQ会主动抛出一个内存警告并阻塞所有连接（Connections）。可以通过修改rabbitmq.config文件来调整内存阈值，默认值是0.4，如下所示：windows默认配置文件：advanced.config</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">[&#123;rabbit,</span> <span class="hljs-string">[&#123;vm_memory_high_watermark, 0.4&#125;]&#125;]</span><br></code></pre></td></tr></table></figure><p>也可以用命令动态设置，如果设置成0，则所有的消息都不能发布。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rabbitmqctl set_vm_memory_high_watermark 0.3<br></code></pre></td></tr></table></figure><h3 id="2-3-磁盘控制"><a href="#2-3-磁盘控制" class="headerlink" title="2.3 磁盘控制"></a>2.3 磁盘控制</h3><p><a href="https://www.rabbitmq.com/configure.html">https://www.rabbitmq.com/configure.html</a></p><p>另一种方式是通过磁盘来控制消息的发布。当磁盘剩余可用空间低于指定的值时（默认50MB），触发流控措施。例如：指定为磁盘的30%或者2GB</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">disk_free_limie.ralative</span>=<span class="hljs-string">3.0</span><br><span class="hljs-attr">disk_free_limit.absolute</span>=<span class="hljs-string">2GB</span><br></code></pre></td></tr></table></figure><p>还有一种情况，虽然Broker消息存储的过来，但是push模型下（consume，有消息就消费），消费者消费不过来了，这个时候也要对流量进行控制。</p><h2 id="3-消费端流控"><a href="#3-消费端流控" class="headerlink" title="3 消费端流控"></a>3 消费端流控</h2><p><a href="https://www.rabbitmq.com/consumer-perfetch.html">https://www.rabbitmq.com/consumer-perfetch.html</a></p><p>默认情况下，如果不进行配置，RabbitMQ会尽可能快速地把队列中地消息发送给消费者。因为消费者会在本地缓存消息，如果消息数量过多，可能导致OOM或者影响其他进程地正常运行。</p><p>在消费者处理消息地能力有限，例如消费者数量太少，或者单条消息地处理时间过长的情况下，如果希望在一定数量的消息消费完之前，不再推送消息过来，就要用到消费端的流量限制措施。</p><p>可以基于Consumer或者channel设置prefetch count的值，含义为Consumer端的最大的unacked messages数目。当超过这个数值的消息未被确认，RabbitMQ会停止投递新的消息给该消费者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.basicQos(<span class="hljs-number">2</span>); <span class="hljs-comment">//如果超过2条消息没有发送ACK，当前消费者不再接受队列消息</span><br>channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">false</span>, consumer);<br></code></pre></td></tr></table></figure><p>启动两个消费者，其中一个Consumer2消费很慢，qos设置为2，最多一次给它发两条消息，其他的消息都被Consumer1接收了。这个叫能者多劳。</p><h2 id="4-消息可靠性投递"><a href="#4-消息可靠性投递" class="headerlink" title="4 消息可靠性投递"></a>4 消息可靠性投递</h2><p>一个经典的面试题：在使用MQ实现异步通信的过程中，有消息丢了怎么办？或者MQ消息重复了怎么办？</p><p>​    这个就是RabbitMQ的可靠性投递。当然，RabbitMQ在设计的时候其实就考虑了这一点，提供了很多保证消息可靠性投递的机制。这个可以说是RabbitMQ比较突出的一个特性。</p><p>​    可靠性只是问题的一个方面，发送消息的效率同样是需要考虑的问题，而这两个因素是无法兼得的，如果在发送消息的每一个环节都采取相关措施来保证可靠性，势必会对消息的收发效率造成影响。在一些业务实时一致性要求不是很高的场合，可以牺牲一些可靠性来换取效率。</p><p>在使用RabbitMQ收发消息的时候，有几个主要环节：</p><p>​    1）消息从生产者发送到Broker，生产者把消息发到Broker之后，怎么知道自己的消息有没有被Broker成功接收？如果Broker不给应答，生产者不断地发送，那有可能是一厢情愿，消息全部进了黑洞。</p><p>​    2）消息从Exchange路由到Queue，Exchange是一个绑定列表，它的职责是分发消息。如果它没有办法履行它地指责怎么办？也就是说，找不到队列或者找不到正确的队列，怎么处理？</p><p>​    3）消息在Queue中存储，队列有自己的数据库（Mnesia），它是真正用来存储消息的。如果还没有消费者来消费，那么消息要一直存储在队列中。怎么保证消息在队列中稳定的存储呢？</p><p>​    4）消费者订阅Queue并消费消息，队列的特性是什么？FIFO。队列中的消息是一条一条的投递的，也就是说，只有上一条消息被消费者接收以后，才能把这一条消息从数据库删掉，继续投递下一条消息。Broker怎么知道消费者已经接受了消息呢？</p><h3 id="4-1-消息发送到RabbitMQ服务器"><a href="#4-1-消息发送到RabbitMQ服务器" class="headerlink" title="4.1 消息发送到RabbitMQ服务器"></a>4.1 消息发送到RabbitMQ服务器</h3><p>第一个环节是生产者发送消息到Broker。可能因为网络连接或者Broker的问题（比如硬盘故障，硬盘写满了）导致消息发送失败，生产者不能确定Broker有没有正确的接收。如果去设计，肯定要给生产者发送消息的接口一个应答，生产者才可以明确知道消息有没有发送成功。在RabbitMQ中提供了两种机制<strong>服务端确认机制</strong>，也就是在生产者发送消息给RabbitMQ的服务端的时候，服务端会通过某种方式返回一个应答，只要生产者收到了这个应答，就知道消息发送成功了。</p><p>​    第一种是Transaction（事务）模式，第二种Confirm（确认）模式。</p><h4 id="4-1-1-Transaction-事务-模式"><a href="#4-1-1-Transaction-事务-模式" class="headerlink" title="4.1.1 Transaction(事务)模式"></a>4.1.1 Transaction(事务)模式</h4><p>在创建channel的时候，可以把信道设置成事务模式，然后就可以发布消息给RabbitMQ了。如果channel.txCommit();的方法调用成功，就说明事务提交成功，则消息一定到达了RabbitMQ中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    channel.txSelect();<br>    <span class="hljs-comment">// 发送消息</span><br>    channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,QUEUE_NAME,<span class="hljs-literal">null</span>,msg.getBytes());<br>    channel.txCommit();<br>    System.out.println(<span class="hljs-string">&quot;消息发送成功&quot;</span>)；<br>&#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>    channel.txRollback();<br>    System.out.println(<span class="hljs-string">&quot;消息已经回滚&quot;</span>)；<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在事务提交之前由于RabbitMQ异常奔溃或者其他原因抛出异常，这个时候便可以将其进行捕获，进而通过执行channel.txRoolback()方法来实现事务回滚。</p><p>在事务模式中，只有收到了服务端的Commit-OK的指令，才能提交成功。所以可以解决生产者和服务端确认的问题。但是事务模式有一个缺点，它是阻塞的，一条消息没有发送完毕，不能发送下一条消息，它会榨干RabbitMQ服务器的性能。所以不建议在生产环境中使用。 SpringBoot中的设置： rabbitTemplate.setChannelTransacted(true)；</p><h4 id="4-1-2-Confirm-确认-模式"><a href="#4-1-2-Confirm-确认-模式" class="headerlink" title="4.1.2 Confirm(确认)模式"></a>4.1.2 Confirm(确认)模式</h4><p>确认模式有三种</p><ol><li>普通确认模式</li></ol><p>在生产者这边通过调用channel.confirmSelect()方法将信道设置为Confirm模式，然后发送消息。一旦消息被投递到交换机后（跟是否路由到队列没有关系），RabbitMQ就会发送一个确认（Basic.Ack）个生产者，也就是调用channel.waitForConfirms()返回true，这样生产者就知道消息被服务端接受了。如果网络错误，会抛出连接异常。如果交换机不存在，会抛出404错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//开启发送方确认模式</span><br>channel.confirmSelect();<br>channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,QUEUE_NAME,<span class="hljs-literal">null</span>,msg.getBytes());<br><span class="hljs-comment">//普通confirm模式，发送一条，确认一条</span><br><span class="hljs-keyword">if</span>(channel.waitForConfirms())&#123;<br>    System.out.println(<span class="hljs-string">&quot;消息发送成功&quot;</span>)；<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>批量确认模式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    channel.confirmSelect();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,QUEUE_NAME,<span class="hljs-literal">null</span>,(msg+<span class="hljs-string">&quot;-&quot;</span>+i).getBytes());<br>    &#125;<br>    <span class="hljs-comment">//批量确认结果，ACK如果是Multiple=True，代表ACK中的Delivery-Tag之前的消息都被确认了</span><br>    <span class="hljs-comment">//比如5条消息可能只收到1个ACK，也可能收到2个（抓包才能看得到）</span><br>    <span class="hljs-comment">//知道所有信息都发布，只要有一个未被Broker确认就会IOException</span><br>    channel.waitForConfirmsOrDie();<br>    System.out.println(<span class="hljs-string">&quot;消息发送完毕，批量确认成功&quot;</span>)；<br>&#125; <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>    <span class="hljs-comment">//发生异常，可能需要对所有消息进行重发</span><br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>只要channel.waitForConfirmsOrDie();方法没有抛出异常，就代表消息都被服务端接受了。批量确认的方式比单条确认的方式效率要高，但是也有两个问题：第一个就是批量的数量的确定。对于不同的业务，到底发送多少条消息确认一次？数量太少，效率提升不上去。数量多的话，又会带来另一个问题，比如发1000条消息才确认一次，如果前面999条消息都被服务端接收了，如果第1000条消息被拒绝了，那么前面所有的消息都要重发。</p><p>异步确认模式需要添加一个ConfirmListen，并且用一个SortedSet来维护一个批次中没有被确认的消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> SortedSet&lt;Long&gt; confirmSet = Collections.sunchronizedSortedSet(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;Long&gt;());<br><span class="hljs-comment">//这里不会打印所有响应的ACK，ACK可能有多个，有可能一次确认多条，也有可能一次确认一条</span><br><span class="hljs-comment">//异步监听确认和未确认的消息</span><br><span class="hljs-comment">//如果要重复运行，先停掉之前的生产者，清空队列</span><br>channel.addConfirmListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfirmListener</span>()&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleNack</span><span class="hljs-params">(<span class="hljs-type">long</span> deliveryTag, <span class="hljs-type">boolean</span> multiple)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        System.out.println(<span class="hljs-string">&quot;Broker 未确认消息，标识：&quot;</span> + deliveryTag);<br>        <span class="hljs-keyword">if</span>(multiple)&#123;<br>            <span class="hljs-comment">//headSet表示后面参数之前的所有元素全部删除</span><br>            confirmSet.headSet(deliveryTag + <span class="hljs-number">1L</span>).clear();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            confirmSet.remove(deliveryTag);<br>        &#125;<br>        <span class="hljs-comment">//todo 这里添加重发的方法</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleAck</span><span class="hljs-params">(<span class="hljs-type">long</span> deliveryTag, <span class="hljs-type">boolean</span> multiple)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//如果true表示批量执行了deliveryTag这个值以前的所有消息，如果为false的话表示单条确认</span><br>        System.out.println(<span class="hljs-string">&quot;Broker 已确认消息，标识：%d，多个消息：%b&quot;</span>, deliveryTag, multiple);<br>        <span class="hljs-keyword">if</span>(multiple)&#123;<br>            <span class="hljs-comment">//headSet表示后面参数之前的所有元素全部删除</span><br>            confirmSet.headSet(deliveryTag + <span class="hljs-number">1L</span>).clear();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            confirmSet.remove(deliveryTag);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;未确认的消息：&quot;</span> + confirmSet);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">//开启发送放确认模式</span><br>channel.confirmSelect();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">nextSeqNo</span> <span class="hljs-operator">=</span> channel.getNextPublishSeqNo();<br>    channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,QUEUE_NAME,<span class="hljs-literal">null</span>,(msg+<span class="hljs-string">&quot;-&quot;</span>+i).getBytes());<br>    confirmSet.add(nextSeqNo);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;所有消息：&quot;</span> + confirmSet);<br></code></pre></td></tr></table></figure><p>SpringBoot：Confirm模式是在Channel上开启的，RabbitTemplate对Channel进行了封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">rabbitTemplate.setConfirmCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RabbitTemplate</span>.ConfirmCallback()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-type">boolean</span> ack, String cause)</span>&#123;<br>        <span class="hljs-keyword">if</span>(!ack)&#123;<br>            System.out.println(<span class="hljs-string">&quot;发送消息失败&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;发送异常&quot;</span> + cause);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="4-2-消息从交换机到队列"><a href="#4-2-消息从交换机到队列" class="headerlink" title="4.2 消息从交换机到队列"></a>4.2 消息从交换机到队列</h3><p>第二个环节就是消息从交换机路由到队列。可能因为routingkey错误，或者队列不存在（但是生产环境基本上不会出现这两种问题）。</p><p>有两种方式处理无法路由的消息，一种是让服务端重发给生产者，一种是让交换机路由到另一个备份的交换机。</p><ol><li>消息回发</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.addReturnListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReturnListener</span>()&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleReturn</span><span class="hljs-params">(<span class="hljs-type">int</span> replyCode, String repluText, String exchange, String routingKey, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        System.out.println(<span class="hljs-string">&quot;.....&quot;</span>);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>SpringBoot消息回发的方式：使用mandatory参数和ReturnListener（在Spring AMQP中是ReturnCallback）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">rabbitTemplate.setMandatory(<span class="hljs-literal">true</span>);<br>rabbitTemplate.setReturnCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RabbitTemplate</span>.ReturnCallback()&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">returnedMessage</span><span class="hljs-params">(Message message, <span class="hljs-type">int</span> replyCode, String repluText, String exchange, String routingKey)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;.....&quot;</span>);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>消息路由到备份交换机的方式。</li></ol><p>在创建交换机的时候，从属性中指定备份交换机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; arguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>arguments.put(<span class="hljs-string">&quot;alternate-exchange&quot;</span>, <span class="hljs-string">&quot;ALTERNATE_EXCHANGE&quot;</span>); <span class="hljs-comment">//指定交换机的备份交换机</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;TEST_EXCHANGE&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,arguments);<br></code></pre></td></tr></table></figure><p>（注意区别，队列可以指定死信交换机；交换机可以指定备份交换机）</p><h3 id="4-3-消息在队列中存储"><a href="#4-3-消息在队列中存储" class="headerlink" title="4.3 消息在队列中存储"></a>4.3 消息在队列中存储</h3><p>第三个环节是消息在队列存储，如果没有消费者的话，队列一直存在数据库中。如果RabbitMQ的服务或者硬件发生故障，比如系统宕机，重启，关闭等等，可能会导致内存中的消息丢失，所以要把消息本身和元数据（队列，交换机，绑定）都保存到磁盘。集群。</p><h3 id="4-4-消息投递到消费者"><a href="#4-4-消息投递到消费者" class="headerlink" title="4.4 消息投递到消费者"></a>4.4 消息投递到消费者</h3><p>服务端应该以某种方式得知消费者对消息的接收情况，并决定是否重新投递这条消息给其他消费者。RabbitMQ提供了消费者的消息确认机制（message acknowledgement），消费者可以自动或者手动地发送ACK给服务端。</p><p>​    没有收到ACK地消息，消费者断开连接后，RabbitMQ会把这条消息发送给其他消费者。如果没有其他消费者，消费者重启后会重新消费这条消息，重复执行业务逻辑。</p><p>​    消费者给Broker应答有两种方式，一种是自动ACK，一种是手动ACK。</p><p>​    首先是自动ACK，这个也是默认的情况。也就是没有在消费者处编写ACK的代码，消费者会在收到消息地时候就自动发送ACK，而不是在方法执行完毕地时候发送ACK（并不关心你有没有正常收到消息）。如果想要等消息消费完毕或者方法执行完毕才发送ACK，需要先把自动ACK设置成手动ACK。把autoAck设置成false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.basicConsume(QUEUE_NAME,<span class="hljs-literal">false</span>,consumer);<br></code></pre></td></tr></table></figure><p>这个时候RabbitMQ会等待消费者显示地回复ACK后才从队列中移去消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.basicAck(envelope.getDeliveryTag(),<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>在SpringBoot中：application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.listener.direct.acknowledge-mode</span>=<span class="hljs-string">manual</span><br><span class="hljs-attr">spring.rabbitmq.listener.simple.acknowledge-mode</span>=<span class="hljs-string">manual</span><br></code></pre></td></tr></table></figure><p>SimpleRabbitListenerContainer或者SimpleRabbitListenerContainerFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">factory.setAcknowledgeMode(AcknowledgeMode,MANUAL);<br></code></pre></td></tr></table></figure><p>注意这三个值的区别：NONE-自动ACK；MANUAL-手动ACK；AUTO-如果方法未抛出异常，则发送ack。如果方法抛出异常，并且不是AmqpRejectAndDontRequeueEsception则发送nack，并且重新入对。如果抛出异常时则发送nack不会重新入队。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecondConsumer</span>&#123;<br>    <span class="hljs-meta">@RabbitHandler</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msgContent, Channel channel, Message message)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果消费者出了问题，确实是不能发送ACK告诉服务端成功消费了，也有拒绝消息的指令，而且还可以让消息重新入队给其他消费者消费。如果消息无法处理或者消费失败，也有两种拒绝的方式，Basic.Reject()拒绝单条，Basic.Nack()批量拒绝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(msg.contains(<span class="hljs-string">&quot;拒收&quot;</span>))&#123;<br>    <span class="hljs-comment">//拒绝消息</span><br>    <span class="hljs-comment">//requeue:是否重新入队列，true-是，false-直接丢弃，相当于告诉队列可以直接删除调</span><br>    <span class="hljs-comment">//TODO 如果只有这一个消费者，requeue为true的时候会造成消息重复消费</span><br>    channel.basicReject(envelop.getDeliveryTag(),<span class="hljs-literal">false</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(msg.contains(<span class="hljs-string">&quot;异常&quot;</span>))&#123;<br>    <span class="hljs-comment">//批量拒绝</span><br>    channel.basicNack(envelope.getDeliveryTag(),<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果requeue参数设置为true，可以把这条消息重新存入队列，以便发给下一个消费者（当然，只有一个消费者的时候，这种方式可能会出现无线循环重复消费的情况。可以投递到新的队列中，或者只打印异常的日志）。</p><p>​    简单总结一下：从生产者到Broker，交换机到队列，队列本身，队列到消费者，都有相应的方法知道消费有没有正常流转，或者说当消息没有正常流转的时候采取相关措施。</p><p>​    思考：服务端收到了ACK或者NACK，生产者会知道吗？即使消费者没有接收到消息，或者消费时出现异常，生产者也是完全不知情的。这个是符合解耦思想的。但是如果现在为了保证一致性，生产者必须知道消费者有没有成功消费，怎么办?所以，这个是生产者最终确定消费者有没有消费成功的两种方式：</p><p>​    1）消费者收到消息，处理完毕后，调用生产者的API（是否破坏解耦？）</p><p>​    2）消费者收到消息，处理完毕后，发送一条响应消息给生产者。</p><h3 id="4-5-消费者回调"><a href="#4-5-消费者回调" class="headerlink" title="4.5 消费者回调"></a>4.5 消费者回调</h3><p>1）调用生产者API</p><p>​    例如：提单系统给其他系统发送了保险消息后，其他系统必须在处理完消息后调用提单系统提供的API，来修改提单系统中这笔数据的状态。只要API没有被调用，数据状态没有被修改，提单系统就认为下游系统没有收到这条消息。</p><p>2）发送响应消息给生产者</p><p>​    例如：商业银行与人民银行二代支付通信（使用IBM MQ），无论是人行收到了商业银行的消息，还是商业银行收到了人行的消息，都必须发送一条响应消息（叫做回执报文）。整个通信的流程设计的非常复杂，但是对于金融场景下的消息可靠性保证，是很有用的。</p><h3 id="4-6-补偿机制"><a href="#4-6-补偿机制" class="headerlink" title="4.6 补偿机制"></a>4.6 补偿机制</h3><p>如果生产者的API就是没有被调用，也没有收到消费者的响应消息，怎么办？生产者和消费者之间应该约定一个超时时间，对于这个时间没有得到响应的消息，才确定为消费失败，比如5分钟。5分钟，对于临时性故障的处理，比如网络恢复，或者重启应用，重启数据库，应该够了。过了5分钟依然没有得到回复的消息，才判断为消费失败。确定失败以后怎么办呢？肯定要重发消息了。不过这里面有几个问题：</p><p>​    1.谁来重发？</p><p>​    假设这个消息是由业务人员操作产生的，对于异步的操作来说，他只要提交了请求就OK了，后面成不成功是不归他管的。所以肯定是后台的代码重发的，不可能让业务人员重新做一笔交易。先创建一个定时任务，比如30秒跑一次，找到业务表里面的这条业务状态是中间状态的记录，查询出来，构建为MQ消息，重新发送。也可以单独设计一张消息表，把本系统所以发送出去的消息全部异步地等级起来，找出状态是未回复地消息发送（注意：这种做法会消耗性能，消耗数据库存储空间）。</p><p>​    2.隔多久重发一次？</p><p>​    假如消费者一直没有回复，比如它重启要20分钟，你5分钟之内尝试重发，肯定还不能正常消费。所以重发肯定不止发一次，要尝试多次，但是又不能发的太频繁，给它一点恢复的时间。不可以设置为1分钟重发一次。也可以设置衰减机制，第一次隔一分钟，第二次隔两分钟。时间由定时任务的执行时间决定。</p><p>​    3.一共重发几次？</p><p>​    重发消息务必控制次数，比如设置3次。这个要在消息表中记录次数来实现，发一次就加一。</p><p>​    4.重发什么内容？</p><p>​    重发，是否发送一摸一样的内容？参考：ATM机上运行的系统叫C端（ATMC）银行的前置系统或者渠道系统叫P端，它接收ATMC的消息，再转发给卡系统或者核心系统。</p><p>​    1）如果客户存款，没有收到核心系统的应答，怎么处理？</p><p>​    因为不知道有没有记账成功，不能给客户吐钞，否则会造成银行短款。因为已经吞钞了，所以要保证成功。最多发送3次存款确认报文。</p><p>​    2）如果客户取款，ATMC未得到核心系统的应答时，怎么处理？</p><p>​    因为没有吐钞，所以要保证失败。最多发送3次存款冲正报文。</p><h3 id="4-7-消息幂等性"><a href="#4-7-消息幂等性" class="headerlink" title="4.7 消息幂等性"></a>4.7 消息幂等性</h3><p>如果消费者状态是正常的，每一条消息都可以正常处理。只是在响应或者调用API的时候出了问题，会不会出现消息的重复处理？例如：存款1000元，ATMC重发了3次存款交易，核心系统一共处理了4次，账户余额增加了4000元。所以，为了避免相同消息的重复处理，必须要采取一定的措施。RabbitMQ服务端是没有这种控制的（同一批的消息有个递增的DeliveryTag），它并不知道对于你的业务来说什么才是重复的消息。所以这个只能在消费端控制。</p><p>​    消息出现重复可能会有两个原因：</p><p>​    1.生产者得问题，环节一重复发送消息，比如在开启了Confirm模式但未收到确认，消费者重复投递。</p><p>​    2.由于消费者未发送ACK或者其他原因，消息重复消费。</p><p>​    3.生产者代码或者网络问题</p><p>​    对于重复发送的消息，可以对每一条消息生成一个唯一的业务员ID，通过日志或者消息落库来做重复控制。</p><h3 id="4-8-最终一致"><a href="#4-8-最终一致" class="headerlink" title="4.8 最终一致"></a>4.8 最终一致</h3><p>如果确实是消费者宕机了，或者代码出现了BUG导致无法正常消费，在尝试多次重发以后，消息最终也没有得到处理，怎么办？例如存款的场景，客户的钱已经被吞了，但是余额没有增加，这个时候银行出现了长款，要怎么处理？如果客户没有主动通知银行，他没有及时查询余额，这个问题是怎么发现的？银行最终怎么把这个账务做平？</p><p>​    在金融系统中，都会有双方对账或者多方对账的操作，通常是在一天业务结束之后，第二天营业之前，金融系统中，多一分钱少一分钱都是非常严重的问题。</p><p>​    会约定一个标准，比如ATM跟核心系统对账，肯定是以核心系统的账务为准。ATMC获取到的对账文件，然后解析，登记成数据，然后跟自己记录的流水比较，找出有问题的数据。对账之后，再手工平账。比如取款寄了账但是没吐钞的，做一笔冲正。存款吞了钞没记账的，要么把钱退给客户，要么补一笔钱。</p><h3 id="4-9-消息的顺序性"><a href="#4-9-消息的顺序性" class="headerlink" title="4.9 消息的顺序性"></a>4.9 消息的顺序性</h3><p>消息的顺序性指的是消费者消费消息的顺序跟生产者生产消息的顺序是一致的。</p><p>​    在RabbitMQ中，一个队列有多个消费者，由于不同的消费者消费消息的速度是不一样的，顺序无法保证。只有一个队列仅有一个消费者的情况才能保证顺序消费（不同的业务消息发送到不同的专用的队列）。除非负载均衡，不要用多个消费者消费消息，消费端捕获异常。</p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ集群与高可用</title>
    <link href="/2023/06/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/%E9%9B%86%E7%BE%A4%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <url>/2023/06/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/%E9%9B%86%E7%BE%A4%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-集群配置-docker"><a href="#1-集群配置-docker" class="headerlink" title="1 集群配置-docker"></a>1 集群配置-docker</h2><p>1）拉取RabbitMQ镜像（带managment）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull rabbitmq:3.7.17-management<br></code></pre></td></tr></table></figure><p>2）创建docker网络（让容器可以和主机通信）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker network create rabbitmqnet<br></code></pre></td></tr></table></figure><p>3）创建三个容器，端口分别是 5673 5674 5675 ，管理端口是 15673 15674 15675</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d \<br> --name=rabbitmq1 \<br> -p 5673:5672 \<br> -p 15673:15672 \<br> -e RABBITMQ_NODENAME=rabbitmq1 \<br> -e RABBITMQ_ERLANG_COOKIE=<span class="hljs-string">&#x27;GUPAOEDUFORBETTERYOU&#x27;</span> \<br> -h rabbitmq1 \<br> --net=rabbitmqnet \<br> rabbitmq:3.7.17-management<br> <br>docker run -d \<br> --name=rabbitmq2 \<br> -p 5674:5672 \<br> -p 15674:15672 \<br> -e RABBITMQ_NODENAME=rabbitmq1 \<br> -e RABBITMQ_ERLANG_COOKIE=<span class="hljs-string">&#x27;GUPAOEDUFORBETTERYOU&#x27;</span> \<br> -h rabbitmq2 \<br> --net=rabbitmqnet \<br> rabbitmq:3.7.17-management<br> <br>docker run -d \<br> --name=rabbitmq3 \<br> -p 5675:5672 \<br> -p 15675:15672 \<br> -e RABBITMQ_NODENAME=rabbitmq1 \<br> -e RABBITMQ_ERLANG_COOKIE=<span class="hljs-string">&#x27;GUPAOEDUFORBETTERYOU&#x27;</span> \<br> -h rabbitmq3 \<br> --net=rabbitmqnet \<br> rabbitmq:3.7.17-management<br></code></pre></td></tr></table></figure><p>4）后两个节点作为内存节点加入集群</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it rabbitmq2 /bin/bash<br>rabbitmqctl stop_app<br>rabbitmqctl reset<br>rabbitmqctl join_cluster --ram rabbitmq1@rabbitmq1<br>rabbitmqctl start_app<br><br>docker <span class="hljs-built_in">exec</span> -it rabbitmq3 /bin/bash<br>rabbitmqctl stop_app<br>rabbitmqctl reset<br>rabbitmqctl join_cluster --ram rabbitmq1@rabbitmq1<br>rabbitmqctl start_app<br></code></pre></td></tr></table></figure><p>5）启动访问</p><h2 id="2-集群节点类型"><a href="#2-集群节点类型" class="headerlink" title="2 集群节点类型"></a>2 集群节点类型</h2><p>集群有两种节点类型，一种是磁盘节点（Disc Node），一种是内存节点（RAM Node）。</p><p>​    磁盘节点：将元数据（包括队列名字属性，减缓及的类型名字属性，绑定，vhost）放在磁盘中。未指定类型的情况下，默认为磁盘节点。集群中至少需要一个磁盘节点用来持久化元数据，否则全部内存节点奔溃时，就无从同步元数据。</p><p>​    内存节点：将元数据放在内存中。</p><p>​    PS：内存节点会将磁盘节点的地址存放在磁盘（不然重启后就没有办法同步数据了）。如果是持久化的消息，会同时存放在内存和磁盘。我们一般把应用连接到内存节点（读写快），磁盘节点用来备份。</p><p>​    集群的配置步骤：</p><p>​    1、配置hosts以便相互通信</p><p>​    2、同步erlang.cookie</p><p>​    3、加入集群（join cluster命令）</p><p>元数据包含以下内容： </p><ol><li>队列元数据：队列的名称及属性 </li><li>交换器：交换器的名称及属性 </li><li>绑定关系元数据：交换器与队列或者交换器与交换器 </li><li>vhost 元数据：为 vhost 内的队列、交换器和绑定提供命名空间及安全属性之间的绑定关系</li></ol><h2 id="3-集群模式"><a href="#3-集群模式" class="headerlink" title="3 集群模式"></a>3 集群模式</h2><h3 id="3-1-普通模式"><a href="#3-1-普通模式" class="headerlink" title="3.1 普通模式"></a>3.1 普通模式</h3><p>普通集群模式下，不同的节点之间只会相互同步元数据（交换机，队列，绑定关系，Vhost的定义），而不会同步消息。</p><p>比如队列1的消息只存储在节点1上。节点2和节点3同步了队列1的定义，但是没有同步消息。假如生产者连接的是节点3，要将消息通过交换机A路由到队列1，最终消息还是会转发到节点1上存储，因为队列1的内容只在节点1上。同理，如果消费者连接是节点2，要从队列1上拉取消息，消息会从节点1转发到节点2。其他节点起到一个路由的作用，类似于指针。</p><p>​    这样有一个问题：如果节点1挂了，队列1的所有数据就全部丢失了，为什么不直接把消息在所有节点上复制一份？</p><p>​    主要是出于存储和同步数据的网络开销的考虑，如果所有节点都存储相同的数据，就无法达到线性的增加性能和存储容量的目的（堆机器）。这就是一种分片存储的思想。当然，如果需要保证队列的高可用性，就需要第二种集群模式了。</p><h3 id="3-2-镜像模式"><a href="#3-2-镜像模式" class="headerlink" title="3.2 镜像模式"></a>3.2 镜像模式</h3><p>镜像队列模式下，消息内容会在镜像节点间同步，可用性更高。不过也有一定的副作用，系统性能会降低，节点过多的情况下同步的代价比较大。集群模式可以通过UI或者CLI或者HTTP操作。镜像模式的集群是在普通模式的基础上，通过policy来实现，使用镜像模式可以实现RabbitMQ的 高可用方案。</p><table><thead><tr><th>操作方式</th><th>命令或步骤</th></tr></thead><tbody><tr><td>rabbitmqctl (Windows)</td><td>rabbitmqctl set_policy ha-add “^ha.” “{“”ha-mode””:””all””}”</td></tr><tr><td>HTTP API</td><td>PUT /api/policies/%2f/ha-all {“pattern”:”^ha.”,”definition”:{“ha-mode”:”all”}}</td></tr><tr><td>Web UI</td><td>1. avigate to Admin &gt; Policies &gt; Add / update a policy <br />2. Name输入：mirror_image <br />3. Pattern输入：^ (代表匹配所有) <br />4. Definition点击HA mode，右边输入：all  <br />5. Add policy</td></tr></tbody></table><h2 id="4-持久化机制"><a href="#4-持久化机制" class="headerlink" title="4 持久化机制"></a>4 持久化机制</h2><p>RabbitMQ 的持久化分为队列持久化、消息持久化和交换器持久化。 不管是持久化的消息还是非持久化的消息都可以被写入到磁盘。</p><h3 id="4-1-队列持久化"><a href="#4-1-队列持久化" class="headerlink" title="4.1 队列持久化"></a>4.1 队列持久化</h3><p>队列的持久化是在定义队列时的durable参数来实现的，durable为true时，队列才会持久化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> connectionFactory.newConnection();<br><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br><span class="hljs-comment">// 第二个参数设置为true，即durable=true</span><br>channel.queueDeclare(<span class="hljs-string">&quot;queue1&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><h3 id="4-2-消息持久化"><a href="#4-2-消息持久化" class="headerlink" title="4.2 消息持久化"></a>4.2 消息持久化</h3><p>消息持久化通过消息的属性deliveryMode来设置是否持久化，在发送消息时通过basicPublish的参数传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过传入MessageProperties.PERSISTENT_TEXT_PLAIN就可以实现消息持久化</span><br>channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;queue1&quot;</span>,MessageProperties.PERSISTENT_TEXT_PLAIN,<span class="hljs-string">&quot;test&quot;</span>.getBytes());<br></code></pre></td></tr></table></figure><h3 id="4-3-交换器持久化"><a href="#4-3-交换器持久化" class="headerlink" title="4.3 交换器持久化"></a>4.3 交换器持久化</h3><p>同队列一样，交换器也需要在定义时设置持久化标识，否则在Broker重启后将丢失</p><h2 id="5-内存控制"><a href="#5-内存控制" class="headerlink" title="5 内存控制"></a>5 内存控制</h2><p>当内存使用超过配置的阈值或者磁盘剩余空间低于配置的阈值时，RabbitMQ 会暂时阻塞客户端的连接， 并停止接收从客户端发来的消息，以此避免服务崩溃，客户端与服务端的心跳检测也会失效。</p><p>当出现内存告警时，可以通过管理命令临时调整内存大小: </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rabbitmqctl set_vm_memory_high_watermark &lt;fraction&gt;<br></code></pre></td></tr></table></figure><blockquote><p>fraction 为内存阈值，RabbitMQ 默认值为0.4，表示当RabbitMQ 使用的内存超过40%时， 就会产生告警并阻塞所有生产者连接。 通过此命令修改的阈值在Broker重启后将会失效，通过修改配置文件的方式设置的阈值则不会在重启后消失，但需要重启Broker才会生效。</p></blockquote><p>配置文件地址：/etc/rabbitmq/rabbitmq.conf</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">vm_memory_high_watermark.relative</span> = <span class="hljs-string">0.4</span><br><span class="hljs-comment"># vm_memory_high_watermark.absolute = 1GB</span><br></code></pre></td></tr></table></figure><p>RabbitMQ 提供relative或absolute两种配置方式 </p><p>• relative 相对值，即前面的fraction，建议取值在0.4~0.66之间，不建议超过0.7 </p><p>• absolute 绝对值，单位为KB、MB、GB，对应的命令是:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rabbitmqctl set_vm_memory_high_watermark absolute &lt;value&gt;<br></code></pre></td></tr></table></figure><p>在某个 Broker 节点触及内存并阻塞生产者之前，它会尝试将队列中的消息换页到磁盘以释放内存空间。 持久化和非持久化的消息都会被转储到磁盘中，其中持久化的消息本身就在磁盘中有一份副本，这里会将持久化的消息从内存中清除掉。</p><blockquote><p>默认情况下，在内存到达内存阈值的 50%时会进行换页动作。 也就是说，在默认的内存阈值为 0.4 的情况下，当内存超过 0.4 * 0.5=0.2时会进行换页动作</p></blockquote><p>可以通过在配置文件中配置vm_memory_high_watermark_paging_ratio项来修改此值</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">vm_memory_high_watermark.relative</span> = <span class="hljs-string">0.4</span><br><span class="hljs-attr">vm_memory_high_watermark_paging_ratio</span> = <span class="hljs-string">0.75</span><br></code></pre></td></tr></table></figure><blockquote><p>以上配置将会在RabbitMQ 内存使用率达到30%时进行换页动作，并在40%时阻塞生产者。当 vm_memory_high_watermark_paging_ratio的值大于1时，相当于禁用了换页功能。</p></blockquote><h2 id="6-磁盘控制"><a href="#6-磁盘控制" class="headerlink" title="6 磁盘控制"></a>6 磁盘控制</h2><p>当磁盘剩余空间低于确定的阈值时，RabbitMQ 同样会阻塞生产者，这样可以避免因非持久化的消息持续换页而耗尽磁盘空间导致服务崩溃。</p><p>默认情况下，磁盘阈值为50MB，表示当磁盘剩余空间低于50MB 时会阻塞生产者并停止内存 中消息的换页动作 。 这个阈值的设置可以减小，但不能完全消除因磁盘耗尽而导致崩溃的可能性。比如在两次磁盘空间检测期间内，磁盘空间从大于50MB被耗尽到0MB 。一个相对谨慎的做法是将磁盘阈值设置为与操作系统所显示的内存大小一致。</p><p>通过命令可以临时调整磁盘阈值:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">rabbitmqctl set_disk_free_limit &lt;disk_limit&gt;<br>rabbitmqctl set_disk_free_limit mem_relative &lt;fraction&gt;<br></code></pre></td></tr></table></figure><p>disk_limit 为固定大小，单位为KB、MB、GB fraction 为相对比值，建议的取值为1.0~2.0之间 </p><p>对应的配置如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">disk_free_limit.relative</span> = <span class="hljs-string">2.0</span><br><span class="hljs-comment"># disk_free_limit.absolute = 50m</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ基本介绍</title>
    <link href="/2023/06/05/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/06/05/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>官网：<a href="http://www.rabbitmq.com/getstarted.html">http://www.rabbitmq.com/getstarted.html</a></p><h2 id="1-安装与配置"><a href="#1-安装与配置" class="headerlink" title="1 安装与配置"></a>1 安装与配置</h2><p>由于RabbitMQ是用Erlang语言编写的，必须要先安装Erlang环境。</p><p>Erlang和RabbitMQ版本有对应关系：<a href="https://www.rabbitmq.com/which-erlang.html">https://www.rabbitmq.com/which-erlang.html</a></p><h3 id="1-1-window"><a href="#1-1-window" class="headerlink" title="1.1 window"></a>1.1 window</h3><ol><li>下载安装Erlang 23.1：<a href="https://www.erlang.org/downloads/23.1%EF%BC%8Cexe%E4%B8%80%E8%B7%AFnext%E5%B0%B1%E5%8F%AF%E4%BB%A5">https://www.erlang.org/downloads/23.1，exe一路next就可以</a></li><li>配置Erlang环境变量</li><li>下载安装RabbitMQ 3.8.9：<a href="http://www.rabbitmq.com/install-windows.html">http://www.rabbitmq.com/install-windows.html</a></li><li>配置RabbitMQ环境变量</li><li>启用RabbitMQ管理插件：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 启动管理界面插件</span><br><span class="hljs-string">&quot;C:\Program Files\RabbitMQ Server\rabbitmq_server-3.8.9\sbin\rabbitmq-plugins.bat&quot;</span> <span class="hljs-built_in">enable</span> rabbitmq_management<br></code></pre></td></tr></table></figure><ol start="6"><li>启动RabbitMQ</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">net start RabbitMQ<br></code></pre></td></tr></table></figure><ol start="7"><li>关闭RabbitMQ</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">net stop RabbitMQ<br></code></pre></td></tr></table></figure><p>访问管理界面：<a href="http://localhost:15672/">http://localhost:15672/</a><br>默认用户名：guest<br>默认密码为：guest</p><h3 id="1-2-linux"><a href="#1-2-linux" class="headerlink" title="1.2 linux"></a>1.2 linux</h3><ol><li>安装Erlang 21.3</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装环境</span><br>yum -y install gcc glibc-devel make ncurses-devel openssl-devel xmlto perl wget<br><br><span class="hljs-comment"># 安装Erlang</span><br>wget http://erlang.org/download/otp_src_21.3.tar.gz<br>tar -xvf otp_src_21.3.tar.gz<br><span class="hljs-built_in">cd</span> otp_src_21.3<br>./configure --prefix=/usr/local/erlang<br><br><span class="hljs-comment"># 配置Erlang环境变量</span><br>vim /etc/profile<br><span class="hljs-comment"># 加入</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/erlang/bin<br><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><ol start="2"><li>安装RabbitMQ 3.8.4</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装</span><br>wget https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.8.4/rabbitmq-server-generic-unix-3.8.4.tar.xz<br>xz -d rabbitmq-server-generic-unix-3.8.4.tar.xz<br>tar -xvf rabbitmq-server-generic-unix-3.8.4.tar <br><br><span class="hljs-comment"># 配置环境变量</span><br>vim /etc/profile<br><span class="hljs-comment"># 加入</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/rabbitmq_server-3.8.4/sbin<br><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><ol start="3"><li>启动RabbitMQ</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 后台启动rabbitmq服务</span><br><span class="hljs-built_in">cd</span> /usr/local/soft/rabbitmq_server-3.8.4/sbin<br>./rabbitmq-server -detached<br><br>./rabbitmq-server start<br><br>service rabbitmq-server start<br></code></pre></td></tr></table></figure><ol start="4"><li>添加新用户</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">./rabbitmqctl add_user admin admin<br>./rabbitmqctl set_user_tags admin administrator<br>./rabbitmqctl set_permissions -p / admin <span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-string">&quot;.*&quot;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>启用管理插件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_management<br></code></pre></td></tr></table></figure><ol start="6"><li>访问：http://虚拟机IP:15672</li></ol><h2 id="2-核心概念"><a href="#2-核心概念" class="headerlink" title="2 核心概念"></a>2 核心概念</h2><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/1.png"></p><h3 id="2-1-Producer"><a href="#2-1-Producer" class="headerlink" title="2.1 Producer"></a>2.1 Producer</h3><p>生产者，就是投递消息的一方。生产者创建消息，然后发布到 RabbitMQ 中。</p><p>消息一般可以包含两个部分：消息体和附加信息。</p><ol><li>消息体（payload） 在实际应用中，消息体一般是一个带有业务逻辑结构的数据，比如一个JSON字符串。当然可以进 一步对这个消息体进行序列化操作。</li><li>附加信息 用来表述这条消息，比如目标交换器的名称、路由键和一些自定义属性等等。</li></ol><h3 id="2-2-Broker"><a href="#2-2-Broker" class="headerlink" title="2.2 Broker"></a>2.2 Broker</h3><p>消息中间件的服务节点 。对于RabbitMQ来说， 一个RabbitMQ Broker可以简单地看作一个RabbitMQ服务节点，或者 RabbitMQ服务实例。也可以将一个RabbitMQ Broker看作一台 RabbitMQ服务器。</p><h3 id="2-3-Connection"><a href="#2-3-Connection" class="headerlink" title="2.3 Connection"></a>2.3 Connection</h3><p>无论是生产者发送消息，还是消费者接收消息，都必须要跟Broker之间建立一个连接，这个连接是一个TCP的长连接。</p><h3 id="2-4-Channel"><a href="#2-4-Channel" class="headerlink" title="2.4 Channel"></a>2.4 Channel</h3><p>频道或信道，是建立在Connection连接之上的一种轻量级的连接。</p><p>大部分的操作是在Channel这个接口中完成的，包括定义队列的声明queueDeclare、交换机的声明 exchangeDeclare、队列的绑定queueBind、发布消息basicPublish、消费消息basicConsume等。</p><p>如果把Connection比作一条光纤电缆的话，那么Channel信道就比作成光纤电缆中的其中一束光纤。一个 Connection上可以创建任意数量的Channel。</p><h3 id="2-5-Queue"><a href="#2-5-Queue" class="headerlink" title="2.5 Queue"></a>2.5 Queue</h3><p>队列，是RabbitMQ的内部对象，用于存储消息。</p><h3 id="2-6-Consumer"><a href="#2-6-Consumer" class="headerlink" title="2.6 Consumer"></a>2.6 Consumer</h3><p>消费者消费消息有两种模式：</p><p>​    一种是Pull模式，对应的方法是basicGet。消息存放在服务端，只有消费者主动获取才能拿到消息。如果每个一段时间获取一次消息，消息的实时性会降低。但是好处是可以根据自己的消费能力决定获取消息的频率。</p><p>​    另一种是Push模式，对应的方法是basicConsume，只要生产者发消息到服务器，就马上推送给消费者，消息保存在客户端，实时性很高，如果消费不过来可能会造成消息积压。Spring AMQP是push方式，通过事件机制对队列进行监听，只要有消息到队列，就会触发消费消息的方法。</p><p>​    RabbitMQ中pull和push都有实现。kafka和RocketMQ只有pull。</p><p>​    由于队列FIFO的特性，只有确定前一条消息被消费者接收之后，Broker才会把这条消息从数据库删除，继续投递下一条消息。</p><p>​    一个消费者是可以监听多个队列的，一个队列也可以被多个消费者监听。但是在生产环境中，一般建议一个消费者只处理一个队列的雄安锡。如果需要提升处理消息的能力，可以增加多个消费者。这个时候消息会在多个消费者之间轮询。</p><h3 id="2-7-Exchange"><a href="#2-7-Exchange" class="headerlink" title="2.7 Exchange"></a>2.7 Exchange</h3><p>交换器，生产者将消息发送到 Exchange (交换器，通常也可以用大写的“X”来表示)， 由交换器将消息路由到一个或者多个队列中。如果路由不到，或返回给生产者，或直接丢弃。</p><p><a href="http://tryrabbitmq.com/">http://tryrabbitmq.com/</a></p><p>RabbitMQ中一共有四种类型的交换机，Direct、Topic、Fanout、Headers。其中Headers不常用。交换机的类型可以在创建的时候指定，网页或者代码中。</p><h4 id="2-7-1-Direct-直连"><a href="#2-7-1-Direct-直连" class="headerlink" title="2.7.1 Direct-直连"></a>2.7.1 Direct-直连</h4><p>一个队列与直连类型的交换机绑定，需指定一个明确的绑定键（binding key）。生产者发送给消息时会携带一个路由键（routing key）。当消息的路由键与某个队列的绑定键完全匹配时，这条消息才会从交换机路由到这个队列上。多个队列也可以使用相同的绑定键。</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/2.png"></p><p>直连类型的交换机，适用于一些业务用途明确的消息。比如HR系统中销售系统之间通信，传输时销售系统专用的消息，就可以建一个直连类型的交换机，使用明确的绑定键。</p><h4 id="2-7-2-Topic-主题"><a href="#2-7-2-Topic-主题" class="headerlink" title="2.7.2 Topic-主题"></a>2.7.2 Topic-主题</h4><p>一个队列与主题类型的交换机绑定时，可以在绑定键中使用通配符。支持两个通配符：</p><p>#代表0个或者多个单词</p><p>*代表只有一个单词</p><p>单词（word）指的是用英文的点“.”隔开的字符。例如a.bc.def是3个单词。</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/3.png"></p><p>主题路由的交换机适用于一些根据业务主题或者消息等级过滤消息的场景，比如说一条消息可能既跟资金有关，又跟风控有关，那就可以让这个消息指定一个多级的路由键。第一个单词代表和资金有关，第二个单词代表和风控有关。下游的业务系统的队列就可以使用不同的绑定键去接收消息了。</p><h4 id="2-7-3-Fanout-广播"><a href="#2-7-3-Fanout-广播" class="headerlink" title="2.7.3 Fanout-广播"></a>2.7.3 Fanout-广播</h4><p>广播类型的交换机与队列绑定时，不需要指定绑定键。因此生产者发送消息到广播类型交换机上，也不需要携带路由键。消息到达交换机时，所有与之绑定了的队列，都会收到相同消息的副本。</p><p>广播类型的消息适用于一些通用的业务消息。比如产品系统产品数据变化的消息，是所有的系统都会用到的，就可以创建一个广播类型的交换机，大家自己建队列就绑定就ok了。</p><h4 id="2-7-4-headers-头交换机-不常用"><a href="#2-7-4-headers-头交换机-不常用" class="headerlink" title="2.7.4 headers-头交换机(不常用)"></a>2.7.4 headers-头交换机(不常用)</h4><p>不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。headers 类型的交换器性能很差，而且也不实用。</p><h3 id="2-8-Vhost"><a href="#2-8-Vhost" class="headerlink" title="2.8 Vhost"></a>2.8 Vhost</h3><p>虚拟主机，表示一批交换器、消息队列和相关对象。 虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。 vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的vhost是 / 。Vhost除了可以提高硬件资源的利用率之外，还可以实现资源的隔离和权限的控制。</p><h3 id="2-9-RoutingKey"><a href="#2-9-RoutingKey" class="headerlink" title="2.9 RoutingKey"></a>2.9 RoutingKey</h3><p>路由键。生产者将消息发给交换器的时候，一般会指定一个 RoutingKey，用来指定这个消息的路由规则。</p><p>RoutingKey需要与交换器类型和绑定键 (BindingKey) 联合使用 在交换器类型和绑定键 (BindingKey) 固定的情况下，生产者可以在发送消息给交换器时，通过指定 RoutingKey 来决定消息流向哪里。</p><h3 id="2-10-Binding"><a href="#2-10-Binding" class="headerlink" title="2.10 Binding"></a>2.10 Binding</h3><p>绑定，RabbitMQ 中通过绑定将交换器与队列关联起来，在绑定的时候一般会指定一个绑定键 ( BindingKey ) ，这样 RabbitMQ 就知道如何正确地将消息路由到队列了。</p><h2 id="3-工作流程"><a href="#3-工作流程" class="headerlink" title="3 工作流程"></a>3 工作流程</h2><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/4.png"></p><h3 id="3-1-生产者发送消息的过程"><a href="#3-1-生产者发送消息的过程" class="headerlink" title="3.1 生产者发送消息的过程"></a>3.1 生产者发送消息的过程</h3><ol><li>生产者连接到 RabbitMQ Broker，建立一个连接( Connection) ，开启一个信道 (Channel)</li><li>生产者声明一个交换器 ，并设置相关属性，比如交换机类型、是否持久化等</li><li>生产者声明一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除等</li><li>生产者通过路由键将交换器和队列绑定起来</li><li>生产者发送消息至RabbitMQ Broker，其中包含路由键、交换器等信息</li><li>相应的交换器根据接收到的路由键查找相匹配的队列</li><li>如果找到，则将从生产者发送过来的消息存入相应的队列中</li><li>如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者</li><li>关闭信道、关闭连接</li></ol><h3 id="3-2-消费者接收消息的过程"><a href="#3-2-消费者接收消息的过程" class="headerlink" title="3.2 消费者接收消息的过程"></a>3.2 消费者接收消息的过程</h3><ol><li>生产者连接到RabbitMQ Broker，建立一个连接( Connection) ，开启一个信道 (Channel)</li><li>消费者向RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数，以及做一些准备工作</li><li>等待RabbitMQ Broker 回应并投递相应队列中的消息， 消费者接收消息</li><li>消费者确认 (ack) 接收到的消息</li><li>RabbitMQ 从队列中删除相应己经被确认的消息</li><li>关闭信道、关闭连接</li></ol>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx实践应用</title>
    <link href="/2023/06/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx%E5%AE%9E%E8%B7%B5%E5%BA%94%E7%94%A8/"/>
    <url>/2023/06/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx%E5%AE%9E%E8%B7%B5%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>启动两个tomcat(161,159)做测试</p><blockquote><p>nginx.conf</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">worker_processes</span>  <span class="hljs-string">1;</span><br><br><span class="hljs-attr">events</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">worker_connections</span>  <span class="hljs-string">1024;</span><br><span class="hljs-attr">&#125;</span><br><br><span class="hljs-attr">http</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">    # mime.types静态资源类型对应文件</span><br>    <span class="hljs-attr">include</span>       <span class="hljs-string">mime.types;</span><br>    <span class="hljs-attr">default_type</span>  <span class="hljs-string">application/octet-stream;</span><br><br>    <span class="hljs-attr">sendfile</span>        <span class="hljs-string">on;</span><br><br>    <span class="hljs-attr">keepalive_timeout</span>  <span class="hljs-string">65;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #gzip  on; 压缩</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    #引入外部化配置文件</span><br>    <span class="hljs-attr">include</span> <span class="hljs-string">extra/*.conf  </span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="1-反向代理"><a href="#1-反向代理" class="headerlink" title="1 反向代理"></a>1 反向代理</h2><blockquote><p>extra/proxy_demo.conf</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server</span> <span class="hljs-string">&#123;</span><br><span class="hljs-attr">listen</span> <span class="hljs-string">80;</span><br><span class="hljs-attr">server_name</span> <span class="hljs-string">localhost;</span><br><span class="hljs-attr">location</span> <span class="hljs-string">/ &#123;</span><br><span class="hljs-comment"># 转发路径</span><br><span class="hljs-attr">proxy_pass</span> <span class="hljs-string">http://192.168.11.161:8080; </span><br><span class="hljs-comment"># 将nginx的host信息传到后台</span><br><span class="hljs-attr">proxy_set_header</span> <span class="hljs-string">Host $host;</span><br><span class="hljs-comment"># 将nginx的远程地址传到后台</span><br><span class="hljs-attr">proxy_set_header</span> <span class="hljs-string">X-Real_IP $remote_addr;</span><br><span class="hljs-comment"># 将nginx的所有的代理服务器地址传到后台</span><br><span class="hljs-attr">proxy_set_header</span> <span class="hljs-string">X-Forwarded_For $proxy_add_x_forwarded_for;</span><br><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-负载均衡"><a href="#2-负载均衡" class="headerlink" title="2 负载均衡"></a>2 负载均衡</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 1. weight权重</span><br><span class="hljs-attr">upstream</span> <span class="hljs-string">tomcat &#123;</span><br><span class="hljs-comment"># 服务地址 </span><br><span class="hljs-comment"># 159访问失败2次后60s内不再访问</span><br><span class="hljs-attr">server</span> <span class="hljs-string">192.168.11.159:8080 max_fails=2 fail_timeout=60s weight=1;</span><br><span class="hljs-attr">server</span> <span class="hljs-string">192.168.11.161:8080 weight=2;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"># 2. ip_hash</span><br><span class="hljs-comment">#upstream tomcat &#123;</span><br><span class="hljs-comment"># 服务地址</span><br><span class="hljs-comment">#ip_hash;</span><br><span class="hljs-comment">#server 192.168.11.159:8080;</span><br><span class="hljs-comment">#server 192.168.11.161:8080;</span><br><span class="hljs-comment">#&#125;</span><br><br><span class="hljs-attr">server</span> <span class="hljs-string">&#123;</span><br><span class="hljs-attr">listen</span> <span class="hljs-string">80;</span><br><span class="hljs-attr">server_name</span> <span class="hljs-string">localhost;</span><br><span class="hljs-attr">location</span> <span class="hljs-string">/ &#123;</span><br><span class="hljs-comment"># 转发路径</span><br><span class="hljs-attr">proxy_pass</span> <span class="hljs-string">http://tomcat;  #upstream的名称</span><br><span class="hljs-comment"># 将nginx的host信息传到后台</span><br><span class="hljs-attr">proxy_set_header</span> <span class="hljs-string">Host $host;</span><br><span class="hljs-comment"># 将nginx的远程地址传到后台</span><br><span class="hljs-attr">proxy_set_header</span> <span class="hljs-string">X-Real_IP $remote_addr;</span><br><span class="hljs-comment"># 将nginx的所有的代理服务器地址传到后台</span><br><span class="hljs-attr">proxy_set_header</span> <span class="hljs-string">X-Forwarded_For $proxy_add_x_forwarded_for;</span><br><span class="hljs-comment"># 访问服务器发生以下配置错误时，会自动转发到下一个</span><br><span class="hljs-attr">proxy_next_upstream</span> <span class="hljs-string">error timeout http_500 http_503;</span><br><span class="hljs-comment"># nginx与服务器的连接超时时间</span><br><span class="hljs-attr">proxy_connect_timeout</span> <span class="hljs-string">60s;</span><br><span class="hljs-attr">proxy_send_timout</span> <span class="hljs-string">60s;</span><br><span class="hljs-attr">proxy_read_timout</span> <span class="hljs-string">60s;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="3-动静分离"><a href="#3-动静分离" class="headerlink" title="3 动静分离"></a>3 动静分离</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server</span> <span class="hljs-string">&#123;</span><br><span class="hljs-attr">listen</span> <span class="hljs-string">80;</span><br><span class="hljs-attr">server_name</span> <span class="hljs-string">localhost;</span><br><br><span class="hljs-attr">location</span> <span class="hljs-string">~ .*\.(js|css|png|svg|ico|jpg)$ &#123;</span><br><span class="hljs-attr">root</span> <span class="hljs-string">static-resource;</span><br><span class="hljs-comment"># 静态资源缓存时间</span><br><span class="hljs-attr">expired</span> <span class="hljs-string">1d;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 创建static-resource文件夹</span><br><span class="hljs-comment"># 将静态文件放入文件夹，即可访问</span><br></code></pre></td></tr></table></figure><h2 id="4-缓存"><a href="#4-缓存" class="headerlink" title="4 缓存"></a>4 缓存</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server</span> <span class="hljs-string">&#123;</span><br><span class="hljs-attr">listen</span> <span class="hljs-string">80;</span><br><span class="hljs-attr">server_name</span> <span class="hljs-string">localhost;</span><br><br><span class="hljs-attr">location</span> <span class="hljs-string">~ .*\.(js|css|png|svg|ico|jpg)$ &#123;</span><br><span class="hljs-attr">root</span> <span class="hljs-string">static-resource;</span><br><span class="hljs-comment"># 静态资源缓存时间</span><br><span class="hljs-attr">expired</span> <span class="hljs-string">1d;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="5-压缩"><a href="#5-压缩" class="headerlink" title="5 压缩"></a>5 压缩</h2><blockquote><p>nginx.conf</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">http</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">include</span>       <span class="hljs-string">mime.types;</span><br>    <span class="hljs-attr">default_type</span>  <span class="hljs-string">application/octet-stream;</span><br>    <span class="hljs-attr">sendfile</span>        <span class="hljs-string">on;</span><br>    <span class="hljs-attr">keepalive_timeout</span>  <span class="hljs-string">65;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    # 开启压缩</span><br>    <span class="hljs-attr">gzip</span>  <span class="hljs-string">on; </span><br><span class="hljs-comment">    # 超过限制后才压缩</span><br>    <span class="hljs-attr">gzip_min_length</span>  <span class="hljs-string">5k;</span><br><span class="hljs-comment">    # 压缩等级</span><br>    <span class="hljs-attr">gzip_comp_level</span>  <span class="hljs-string">3;</span><br><span class="hljs-comment">    # 对哪些资源进行压缩</span><br>    <span class="hljs-attr">gzip_types</span> <span class="hljs-string">applcation/javascript image/jpeg;</span><br><span class="hljs-comment">    # 设置缓冲区</span><br>    <span class="hljs-attr">gzip_buffers</span> <span class="hljs-string">4 32k;</span><br><span class="hljs-comment">    # 是否传输gzip的压缩标志</span><br>    <span class="hljs-attr">gzip_vary</span> <span class="hljs-string">on;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    #引入外部化配置文件</span><br>    <span class="hljs-attr">include</span> <span class="hljs-string">extra/*.conf  </span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="6-防盗链"><a href="#6-防盗链" class="headerlink" title="6 防盗链"></a>6 防盗链</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server</span> <span class="hljs-string">&#123;</span><br><span class="hljs-attr">listen</span> <span class="hljs-string">80;</span><br><span class="hljs-attr">server_name</span> <span class="hljs-string">localhost;</span><br><br><span class="hljs-attr">location</span> <span class="hljs-string">~ .*\.(js|css|png|svg|ico|jpg)$ &#123;</span><br><span class="hljs-comment"># 限制访问静态资源，可以配置域名，正则表达式</span><br><span class="hljs-comment"># 允许160访问</span><br><span class="hljs-attr">vlid_referers</span> <span class="hljs-string">none blocked 192.168.11.160;</span><br><span class="hljs-attr">if</span> <span class="hljs-string">($invalid_referer) &#123;</span><br><span class="hljs-comment"># 重定向</span><br><span class="hljs-attr">return</span> <span class="hljs-string">404;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">root</span> <span class="hljs-string">static-resource;</span><br><span class="hljs-attr">expired</span> <span class="hljs-string">1d;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="7-跨域"><a href="#7-跨域" class="headerlink" title="7 跨域"></a>7 跨域</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server</span> <span class="hljs-string">&#123;</span><br><span class="hljs-attr">listen</span> <span class="hljs-string">80;</span><br><span class="hljs-attr">server_name</span> <span class="hljs-string">localhost;</span><br><span class="hljs-attr">location</span> <span class="hljs-string">/ &#123;</span><br><span class="hljs-attr">proxy_pass</span> <span class="hljs-string">http://tomcat;</span><br><span class="hljs-attr">proxy_set_header</span> <span class="hljs-string">Host $host;</span><br><span class="hljs-attr">proxy_set_header</span> <span class="hljs-string">X-Real_IP $remote_addr;</span><br><span class="hljs-attr">proxy_set_header</span> <span class="hljs-string">X-Forwarded_For $proxy_add_x_forwarded_for;</span><br><span class="hljs-attr">proxy_next_upstream</span> <span class="hljs-string">error timeout http_500 http_503;</span><br><span class="hljs-attr">proxy_connect_timeout</span> <span class="hljs-string">60s;</span><br><span class="hljs-attr">proxy_send_timout</span> <span class="hljs-string">60s;</span><br><span class="hljs-attr">proxy_read_timout</span> <span class="hljs-string">60s;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 允许所有地址访问</span><br><span class="hljs-attr">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;;</span><br><span class="hljs-comment"># 允许支持的方法访问</span><br><span class="hljs-attr">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Method&#x27; &#x27;GET,POST,DELETE&#x27;;</span><br><span class="hljs-comment"># 允许支持的媒体类型</span><br><span class="hljs-attr">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Header&#x27; &#x27;Content-Type, *&#x27;;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx基本使用</title>
    <link href="/2023/06/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/06/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1 基本命令"></a>1 基本命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#启动</span><br>./bin/nginx<br><span class="hljs-comment">#停止</span><br>./bin/nginx -s stop<br></code></pre></td></tr></table></figure><h2 id="2-配置详解"><a href="#2-配置详解" class="headerlink" title="2 配置详解"></a>2 配置详解</h2><blockquote><p>conf/nginx.conf</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#全局块</span><br><span class="hljs-comment">#user  nobody;</span><br><span class="hljs-attr">worker_processes</span>  <span class="hljs-string">1;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#error_log  logs/error.log;</span><br><span class="hljs-comment">#error_log  logs/error.log  notice;</span><br><span class="hljs-comment">#error_log  logs/error.log  info;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#pid        logs/nginx.pid;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#event块</span><br><span class="hljs-attr">events</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">worker_connections</span>  <span class="hljs-string">1024;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#http块</span><br><span class="hljs-attr">http</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">include</span>       <span class="hljs-string">mime.types;</span><br>    <span class="hljs-attr">default_type</span>  <span class="hljs-string">application/octet-stream;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="hljs-comment">    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="hljs-comment">    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #access_log  logs/access.log  main;</span><br><br>    <span class="hljs-attr">sendfile</span>        <span class="hljs-string">on;</span><br><span class="hljs-comment">    #tcp_nopush     on;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #keepalive_timeout  0;</span><br>    <span class="hljs-attr">keepalive_timeout</span>  <span class="hljs-string">65;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #gzip  on;</span><br><br>    <span class="hljs-attr">server</span> <span class="hljs-string">&#123;</span><br>        <span class="hljs-attr">listen</span>       <span class="hljs-string">80;</span><br>        <span class="hljs-attr">server_name</span>  <span class="hljs-string">localhost;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        #charset koi8-r;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        #access_log  logs/host.access.log  main;</span><br><br>        <span class="hljs-attr">location</span> <span class="hljs-string">/ &#123;</span><br>            <span class="hljs-attr">root</span>   <span class="hljs-string">html;</span><br>            <span class="hljs-attr">index</span>  <span class="hljs-string">index.html index.htm;</span><br>        <span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        #error_page  404              /404.html;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        # redirect server error pages to the static page /50x.html</span><br><span class="hljs-comment">        #</span><br>        <span class="hljs-attr">error_page</span>   <span class="hljs-string">500 502 503 504  /50x.html;</span><br>        <span class="hljs-attr">location</span> = <span class="hljs-string">/50x.html &#123;</span><br>            <span class="hljs-attr">root</span>   <span class="hljs-string">html;</span><br>        <span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="hljs-comment">        #</span><br><span class="hljs-comment">        #location ~ \.php$ &#123;</span><br><span class="hljs-comment">        #    proxy_pass   http://127.0.0.1;</span><br><span class="hljs-comment">        #&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="hljs-comment">        #</span><br><span class="hljs-comment">        #location ~ \.php$ &#123;</span><br><span class="hljs-comment">        #    root           html;</span><br><span class="hljs-comment">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="hljs-comment">        #    fastcgi_index  index.php;</span><br><span class="hljs-comment">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="hljs-comment">        #    include        fastcgi_params;</span><br><span class="hljs-comment">        #&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        # deny access to .htaccess files, if Apache&#x27;s document root</span><br><span class="hljs-comment">        # concurs with nginx&#x27;s one</span><br><span class="hljs-comment">        #</span><br><span class="hljs-comment">        #location ~ /\.ht &#123;</span><br><span class="hljs-comment">        #    deny  all;</span><br><span class="hljs-comment">        #&#125;</span><br>    <span class="hljs-attr">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="hljs-comment">    #</span><br><span class="hljs-comment">    #server &#123;</span><br><span class="hljs-comment">    #    listen       8000;</span><br><span class="hljs-comment">    #    listen       somename:8080;</span><br><span class="hljs-comment">    #    server_name  somename  alias  another.alias;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #    location / &#123;</span><br><span class="hljs-comment">    #        root   html;</span><br><span class="hljs-comment">    #        index  index.html index.htm;</span><br><span class="hljs-comment">    #    &#125;</span><br><span class="hljs-comment">    #&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    # HTTPS server</span><br><span class="hljs-comment">    #</span><br><span class="hljs-comment">    #server &#123;</span><br><span class="hljs-comment">    #    listen       443 ssl;</span><br><span class="hljs-comment">    #    server_name  localhost;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #    ssl_certificate      cert.pem;</span><br><span class="hljs-comment">    #    ssl_certificate_key  cert.key;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="hljs-comment">    #    ssl_session_timeout  5m;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="hljs-comment">    #    ssl_prefer_server_ciphers  on;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #    location / &#123;</span><br><span class="hljs-comment">    #        root   html;</span><br><span class="hljs-comment">    #        index  index.html index.htm;</span><br><span class="hljs-comment">    #    &#125;</span><br><span class="hljs-comment">    #&#125;</span><br><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-1-全局块"><a href="#2-1-全局块" class="headerlink" title="2.1 全局块"></a>2.1 全局块</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 指定可以运行nginx服务的用户和用户组，只能在全局块配置</span><br><span class="hljs-attr">user</span> <span class="hljs-string">[user] [group]</span><br><span class="hljs-comment"># 将user指令注释掉，或者配置成nobody的话所有用户都可以运行</span><br><span class="hljs-attr">user</span> <span class="hljs-string">nobody nobody;</span><br><span class="hljs-comment"># user指令在Windows上不生效，如果你制定具体用户和用户组会报小面警告</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 指定工作线程数，可以制定具体的进程数，也可使用自动模式，这个指令只能在全局块配置</span><br><span class="hljs-attr">worker_processes</span> <span class="hljs-string">number | auto；</span><br><span class="hljs-comment"># 列子：指定4个工作线程，这种情况下会生成一个master进程和4个worker进程</span><br><span class="hljs-attr">worker_processes</span> <span class="hljs-string">4;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 指定pid文件存放的路径，这个指令只能在全局块配置</span><br><span class="hljs-attr">pid</span> <span class="hljs-string">logs/nginx.pid;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 指定错误日志的路径和日志级别，此指令可以在全局块、http块、server块以及location块中配置。</span><br><span class="hljs-comment"># 其中debug级别的日志需要编译时使用--with-debug开启debug开关</span><br><span class="hljs-attr">error_log</span> <span class="hljs-string">[path] [debug | info | notice | warn | error | crit | alert | emerg] </span><br><span class="hljs-attr">error_log</span>  <span class="hljs-string">logs/error.log  notice;</span><br><span class="hljs-attr">error_log</span>  <span class="hljs-string">logs/error.log  info;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-event块"><a href="#2-2-event块" class="headerlink" title="2.2 event块"></a>2.2 event块</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 开启的时候，将会对多个Nginx进程接收连接进行序列化，防止多个进程对连接的争抢，默认是开启状态</span><br><span class="hljs-attr">accept_mutex</span> <span class="hljs-string">on | off;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 如果multi_accept被禁止了，nginx一个工作进程只能同时接受一个新的连接。否则，一个工作进程可以同时接受所有的新连接。 </span><br><span class="hljs-comment"># 如果nginx使用kqueue连接方法，那么这条指令会被忽略，因为这个方法会报告在等待被接受的新连接的数量。</span><br><span class="hljs-comment"># 默认是off状态</span><br><span class="hljs-attr">multi_accept</span> <span class="hljs-string">on | off;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 指定使用哪种网络IO模型，method可选择的内容有：select、poll、kqueue、epoll、rtsig、/dev/poll以及eventport。</span><br><span class="hljs-comment"># use method</span><br><span class="hljs-attr">use</span> <span class="hljs-string">epoll</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 设置允许每一个worker process同时开启的最大连接数，当每个工作进程接受的连接数超过这个值时将不再接收连接</span><br><span class="hljs-comment"># 当所有的工作进程都接收满时，连接进入logback，logback满后连接被拒绝</span><br><span class="hljs-comment"># 注意：这个值不能超过超过系统支持打开的最大文件数，也不能超过单个进程支持打开的最大文件数</span><br><span class="hljs-attr">worker_connections</span>  <span class="hljs-string">1024;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-http块-重点"><a href="#2-3-http块-重点" class="headerlink" title="2.3 http块(重点)"></a>2.3 http块(重点)</h3><h4 id="2-3-1-http全局块"><a href="#2-3-1-http全局块" class="headerlink" title="2.3.1 http全局块"></a>2.3.1 http全局块</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># include指令，用于包含其他的配置文件，可以放在配置文件的任何地方，但是要注意你包含进来的配置文件一定符合配置规范</span><br><span class="hljs-comment"># 下面的指令将mime.types包含进来，mime.types和ngin.cfg同级目录，不同级的话需要指定具体路径</span><br><span class="hljs-attr">include</span>  <span class="hljs-string">mime.types;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 配置默认类型，如果不加此指令，默认值为text/plain。</span><br><span class="hljs-comment"># 此指令还可以在http块、server块或者location块中进行配置。</span><br><span class="hljs-attr">default_type</span>  <span class="hljs-string">application/octet-stream;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># access_log配置，此指令可以在http块、server块或者location块中进行设置</span><br><span class="hljs-comment"># 在全局块中，介绍过errer_log指令，用于配置Nginx进程运行时的日志存放和级别，此处所指的日志与常规的不同，它是指记录Nginx服务器提供服务过程应答前端请求的日志</span><br><span class="hljs-comment"># access_log path [format [buffer=size]]</span><br><span class="hljs-comment"># 如果你要关闭access_log,你可以使用下面的命令</span><br><span class="hljs-attr">access_log</span> <span class="hljs-string">off;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># log_format指令，用于定义日志格式，此指令只能在http块中进行配置</span><br><span class="hljs-attr">log_format</span> <span class="hljs-string">main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br>                <span class="hljs-attr">&#x27;$status</span> <span class="hljs-string">$body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br>                <span class="hljs-attr">&#x27;&quot;$http_user_agent&quot;</span> <span class="hljs-string">&quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="hljs-comment"># 定义了上面的日志格式后，可以以下面的形式使用日志</span><br><span class="hljs-attr">access_log</span> <span class="hljs-string">logs/access.log  main;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 开启关闭sendfile方式传输文件，可以在http块、server块或者location块中进行配置</span><br><span class="hljs-attr">sendfile</span>  <span class="hljs-string">on | off;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 设置sendfile最大数据量,此指令可以在http块、server块或location块中配置</span><br><span class="hljs-attr">sendfile_max_chunk</span> <span class="hljs-string">size;</span><br><span class="hljs-comment"># 其中，size值如果大于0，Nginx进程的每个worker process每次调用sendfile()传输的数据量最大不能超过这个值(这里是128k，所以每次不能超过128k)；如果设置为0，则无限制。默认值为0。</span><br><span class="hljs-attr">sendfile_max_chunk</span> <span class="hljs-string">128k;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 配置连接超时时间,此指令可以在http块、server块或location块中配置。</span><br><span class="hljs-comment"># 与用户建立会话连接后，Nginx服务器可以保持这些连接打开一段时间</span><br><span class="hljs-comment"># timeout，服务器端对连接的保持时间。默认值为75s;header_timeout，可选项，在应答报文头部的Keep-Alive域设置超时时间：“Keep-Alive:timeout= header_timeout”。报文中的这个指令可以被Mozilla或者Konqueror识别。</span><br><span class="hljs-attr">keepalive_timeout</span> <span class="hljs-string">timeout [header_timeout]</span><br><span class="hljs-comment"># 下面配置的含义是，在服务器端保持连接的时间设置为120s，发给用户端的应答报文头部中Keep-Alive域的超时时间设置为100s。</span><br><span class="hljs-attr">keepalive_timeout</span> <span class="hljs-string">120s 100s</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 配置单连接请求数上限，此指令可以在http块、server块或location块中配置。</span><br><span class="hljs-comment"># Nginx服务器端和用户端建立会话连接后，用户端通过此连接发送请求。指令keepalive_requests用于限制用户通过某一连接向Nginx服务器发送请求的次数。默认是100</span><br><span class="hljs-attr">keepalive_requests</span> <span class="hljs-string">number;</span><br></code></pre></td></tr></table></figure><h4 id="2-3-2-server块"><a href="#2-3-2-server块" class="headerlink" title="2.3.2 server块"></a>2.3.2 server块</h4><p>每一个http块都可以包含多个server块，而每个server块就相当于一台虚拟主机。server块也可以包含自己的全局块，同时可以包含多个location块。</p><h5 id="2-3-2-1-listen指令"><a href="#2-3-2-1-listen指令" class="headerlink" title="2.3.2.1 listen指令"></a>2.3.2.1 listen指令</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">listen</span> <span class="hljs-string">127.0.0.1:8000;     #只监听来自127.0.0.1这个IP，请求8000端口的请求</span><br><span class="hljs-attr">listen</span> <span class="hljs-string">127.0.0.1;          #只监听来自127.0.0.1这个IP，请求80端口的请求（不指定端口，默认80）</span><br><span class="hljs-attr">listen</span> <span class="hljs-string">8000;               #监听来自所有IP，请求8000端口的请求</span><br><span class="hljs-attr">listen</span> <span class="hljs-string">*:8000;             #和上面效果一样</span><br><span class="hljs-attr">listen</span> <span class="hljs-string">localhost:8000;     #和第一种效果一致</span><br></code></pre></td></tr></table></figure><h5 id="2-3-2-2-server-name指令"><a href="#2-3-2-2-server-name指令" class="headerlink" title="2.3.2.2 server_name指令"></a>2.3.2.2 server_name指令</h5><p>对于name 来说，可以只有一个名称，也可以由多个名称并列，之间用空格隔开。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server_name</span> <span class="hljs-string">myserver.com www.myserver.com</span><br><span class="hljs-attr">server_name</span> <span class="hljs-string">myserver.* *.myserver.com</span><br></code></pre></td></tr></table></figure><h5 id="2-3-2-3-location块"><a href="#2-3-2-3-location块" class="headerlink" title="2.3.2.3 location块"></a>2.3.2.3 location块</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> [ = | <span class="hljs-regexp">~ |</span> <span class="hljs-regexp">~* |</span><span class="hljs-regexp"> ^~</span> ] uri &#123; <br><span class="hljs-attribute">root</span> html;  <span class="hljs-comment">#静态资源存放位置</span><br><span class="hljs-attribute">index</span>  index.html index.htm;  <span class="hljs-comment">#文件名</span><br><span class="hljs-attribute">deny</span>  all;  <span class="hljs-comment">#拒绝访问的ip限制，会返回403页面</span><br>&#125;<br></code></pre></td></tr></table></figure><p>uri变量是待匹配的请求字符串，可以是不含正则表达的字符串，如/myserver.php等；也可以是包含有正则表达的字符串，如 .php$（表示以.php结尾的URL）</p><p>其中方括号里的部分，是可选项，用来改变请求字符串与 uri 的匹配方式:</p><ul><li>“=”，用于标准uri前，要求请求字符串与uri严格匹配。优先级最高。</li><li>“^～”，用于标准uri前，要求Nginx服务器找到标识uri和请求字符串匹配度最高的location后，立即使用此location处理请求。</li><li>“～”，用于表示uri包含正则表达式，并且区分大小写。</li><li>“～<code>*</code>”，用于表示uri包含正则表达式，并且不区分大小写。注意如果uri包含正则表达式，就必须要使用“～”或者“～*”标识</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span> location = /<br><span class="hljs-number">2</span> location = /index<br><span class="hljs-number">3</span> location ^~ <span class="hljs-regexp">/article/</span><br><span class="hljs-number">4</span> location ^~ <span class="hljs-regexp">/article/</span>files/<br><span class="hljs-number">5</span> location ~ \.(gif|png|js|css)$<br><span class="hljs-number">6</span> location /<br><br>http:<span class="hljs-regexp">//</span>localhost/   -&gt; <span class="hljs-number">1</span><br>http:<span class="hljs-regexp">//</span>localhost/index   -&gt; <span class="hljs-number">2</span><br>http:<span class="hljs-regexp">//</span>localhost<span class="hljs-regexp">/article/</span>   -&gt; <span class="hljs-number">3</span><br>http:<span class="hljs-regexp">//</span>localhost<span class="hljs-regexp">/article/</span>files/<span class="hljs-number">1</span>.txt   -&gt; <span class="hljs-number">4</span><br>http:<span class="hljs-regexp">//</span>localhost/<span class="hljs-number">1</span>.txt   -&gt; <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h5 id="2-3-2-4-错误码页面"><a href="#2-3-2-4-错误码页面" class="headerlink" title="2.3.2.4 错误码页面"></a>2.3.2.4 错误码页面</h5><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 发生错误500 502 503 504都会重定向到html下的/50x.html页面</span><br>error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /<span class="hljs-number">50</span>x.html;<br><span class="hljs-keyword">location</span> <span class="hljs-title">= /50x</span>.html &#123;<br>root   html;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo-高级应用</title>
    <link href="/2023/06/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/dubbo/Dubbo-%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    <url>/2023/06/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/dubbo/Dubbo-%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>官网：<a href="https://cn.dubbo.apache.org/zh-cn">https://cn.dubbo.apache.org/zh-cn</a></p><p><a href="https://www.processon.com/view/link/6343917be0b34d40be5a3daf">https://www.processon.com/view/link/6343917be0b34d40be5a3daf</a></p><h2 id="1-服务注册与发现"><a href="#1-服务注册与发现" class="headerlink" title="1 服务注册与发现"></a>1 服务注册与发现</h2><p>Apache Dubbo天然就支持服务注册发现，最早开源的时候，官方建议使用 Apache Zookeeper作为注册中心。 因此到现在仍然还有很多公司是Dubbo+Zookeeper这样一个架构。 随着Apache Dubbo重新迭代，从Apache Dubbo2.7.x版本开始，支持的注册中心增加了很多，包括： Consul、Etcd、Nacos、Sofa、Zookeeper、Eureka、Redis。 但是在Dubbo3.x版本里面，默认只支持Nacos和Zookeeper两种，其他的注册中心被分离出来作为独立的组件，如果需要用到，则需要单独增加这些组件的依赖。</p><p><a href="https://cn.dubbo.apache.org/zh-cn/docs/new-in-dubbo3/#%E6%89%A9%E5%B1%95%E7%82%B9%E5%88%86%E7%A6%BB">https://cn.dubbo.apache.org/zh-cn/docs/new-in-dubbo3/#扩展点分离</a></p><h3 id="1-1-Dubbo多注册中心支持"><a href="#1-1-Dubbo多注册中心支持" class="headerlink" title="1.1 Dubbo多注册中心支持"></a>1.1 Dubbo多注册中心支持</h3><p>Dubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。</p><p>修改application.properties文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">dubbo.registries.zk-registry.id</span>=<span class="hljs-string">zk-registry</span><br><span class="hljs-attr">dubbo.registries.zk-registry.address</span>=<span class="hljs-string">zookeeper://192.168.8.133:2181?timeout=60000&amp;blockUntilConnectedWait=30</span><br><span class="hljs-attr">dubbo.registries.zk-registry.use-as-config-center</span>=<span class="hljs-string">false</span><br><span class="hljs-attr">dubbo.registries.zk-registry.use-as-metadata-center</span>=<span class="hljs-string">false</span><br><br><span class="hljs-attr">dubbo.registries.nacos-registry.id</span>=<span class="hljs-string">nacos-registry</span><br><span class="hljs-attr">dubbo.registries.nacos-registry.address</span>=<span class="hljs-string">nacos://192.168.8.133:8848</span><br><span class="hljs-attr">dubbo.registries.nacos-registry.username</span>=<span class="hljs-string">nacos</span><br><span class="hljs-attr">dubbo.registries.nacos-registry.password</span>=<span class="hljs-string">nacos</span><br><span class="hljs-attr">dubbo.registries.nacos-registry.use-as-config-center</span>=<span class="hljs-string">false</span><br><span class="hljs-attr">dubbo.registries.nacos-registry.use-as-metadata-center</span>=<span class="hljs-string">false</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DubboService(registry = &#123;&quot;zk-registry&quot;,&quot;nacos-registry&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserService</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">say</span><span class="hljs-params">(String msg)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Spring Boot Integration Apache Dubbo Example&quot;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//同样消费者也是如此</span><br><span class="hljs-comment">//@DubboReference(registry = &quot;nacos-registry&quot;)</span><br></code></pre></td></tr></table></figure><p>在Dubbo3开始，增加了应用级别的服务注册发现，默认情况下，服务端会自动开启接口级和应用级的双重注册，这也是为了兼容Dubbo2.x版本考虑。但是如果生产者和消费者都升级到了Dubbo3，就建议开启应用级别的注册以及关闭接口级的订阅。 可以通过下面这个配置来设置:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 双注册</span><br><span class="hljs-attr">dubbo.application.register-mode</span>=<span class="hljs-string">all</span><br><span class="hljs-comment"># 仅应用级注册</span><br><span class="hljs-attr">dubbo.application.register-mode</span>=<span class="hljs-string">instance</span><br></code></pre></td></tr></table></figure><p>还可以通过注册中心地址上配置参数registry-type=service来显示指定该注册中心为应用级服务发现的注册中心，带上此配置的注册中心将只进行应用级服务发现:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">dubbo.registry.address</span>=<span class="hljs-string">&quot;zookeeper://192.168.8.133:2181?registry-type=service&quot;</span><br></code></pre></td></tr></table></figure><h2 id="2-服务接口的版本支持"><a href="#2-服务接口的版本支持" class="headerlink" title="2 服务接口的版本支持"></a>2 服务接口的版本支持</h2><p>可以通过version这个属性的配置，设置接口或者方法的版本。在进行功能迭代，可能存在新的功能对老版本不兼容的时候，就可以 通过版本号来过度。具体过程是： </p><ol><li>在低压力时间段，先升级一半提供者为新版本 </li><li>再将所有消费者升级为新版本 </li><li>然后将剩下的一半提供者升级为新版本</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DubboService(registry = &#123;&quot;zk-registry&quot;,&quot;nacos-registry&quot;&#125;, version = &quot;1.0&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserService</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">say</span><span class="hljs-params">(String msg)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Spring Boot Integration Apache Dubbo Example&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费端进行消费的时候，可以在@DubboReference上指定消费的版本号。 如果不需要区分版本号，可以使用version=“*”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DubboReference(version = &quot;1.0&quot;)</span><br></code></pre></td></tr></table></figure><h2 id="3-负载均衡策略"><a href="#3-负载均衡策略" class="headerlink" title="3 负载均衡策略"></a>3 负载均衡策略</h2><p>Apache Dubbo不需要像Spring Cloud那样需要单独引入Ribbon或者 LoadBalancer组件来实现负载。 它默认就集成了负载均衡算法，默认的算法是random。</p><table><thead><tr><th>算法</th><th>特性</th><th>备注</th></tr></thead><tbody><tr><td>Weighted Random</td><td>加权随机</td><td>默认算法，默认权重相同</td></tr><tr><td>RoundRobin</td><td>加权轮询</td><td>借鉴于Nginx的平滑加权轮询算法，默认权重相同</td></tr><tr><td>LeastActive</td><td>最少活跃优先+加权随机</td><td>背后是能者多劳的思想</td></tr><tr><td>Shortest-Response</td><td>最短响应优先+加权随机</td><td>更加关注响应速度</td></tr><tr><td>ConsistentHash</td><td>一致性哈希</td><td>确定的入参，确定的提供者，适用于有状态请求</td></tr><tr><td>P2C</td><td>Power of Two Choice</td><td>随机选择两个节点后，继续选择连接数较小的那个节点</td></tr><tr><td>Adaptive</td><td>自适应负载均衡</td><td>在P2C算法基础上，选择两者中load最小的那个节点</td></tr></tbody></table><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DubboService(registry = &#123;&quot;zk-registry&quot;,&quot;nacos-registry&quot;&#125;, loadbalance=&quot;roundrobin&quot;)</span><br></code></pre></td></tr></table></figure><h3 id="3-1-Weighted"><a href="#3-1-Weighted" class="headerlink" title="3.1 Weighted"></a>3.1 Weighted</h3><ul><li><strong>加权随机</strong>，按权重设置随机概率。</li><li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li><li>缺点：存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上</li></ul><h3 id="3-2-RoundRobin"><a href="#3-2-RoundRobin" class="headerlink" title="3.2 RoundRobin"></a>3.2 RoundRobin</h3><ul><li><strong>加权轮询</strong>，按公约后的权重设置轮询比率，循环调用节点</li><li>缺点：同样存在慢的提供者累积请求的问题。</li></ul><p>加权轮询过程过程中，如果某节点权重过大，会存在某段时间内调用过于集中的问题。 例如 ABC 三节点有如下权重：<code>&#123;A: 3, B: 2, C: 1&#125;</code> 那么按照最原始的轮询算法，调用过程将变成：<code>A A A B B C</code></p><p>对此，Dubbo 借鉴 Nginx 的平滑加权轮询算法，对此做了优化，调用过程可抽象成下表:</p><p><img src="/image/dubbo/2.png"></p><p>注：轮前加和权重 = 轮后权重 + 节点权重</p><h3 id="3-3-LeastActive"><a href="#3-3-LeastActive" class="headerlink" title="3.3 LeastActive"></a>3.3 LeastActive</h3><ul><li><strong>加权最少活跃调用优先</strong>，活跃数越低，越优先调用，相同活跃数的进行加权随机。活跃数指调用前后计数差（针对特定提供者：请求发送数 - 响应返回数），表示特定提供者的任务堆积量，活跃数越低，代表该提供者处理能力越强。</li><li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大；相对的，处理能力越强的节点，处理更多的请求。</li></ul><h3 id="3-4-ShortestResponse"><a href="#3-4-ShortestResponse" class="headerlink" title="3.4 ShortestResponse"></a>3.4 ShortestResponse</h3><ul><li><strong>加权最短响应优先</strong>，在最近一个滑动窗口中，响应时间越短，越优先调用。相同响应时间的进行加权随机。</li><li>使得响应时间越快的提供者，处理更多的请求。</li><li>缺点：可能会造成流量过于集中于高性能节点的问题。</li></ul><p>这里的响应时间 = 某个提供者在窗口时间内的平均响应时间，窗口时间默认是 30s。</p><h3 id="3-5-ConsistentHash"><a href="#3-5-ConsistentHash" class="headerlink" title="3.5 ConsistentHash"></a>3.5 ConsistentHash</h3><ul><li><strong>一致性 Hash</strong>，相同参数的请求总是发到同一提供者。</li><li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li><li>缺省只对第一个参数 Hash，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</code></li><li>缺省用 160 份虚拟节点，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</code></li></ul><h3 id="3-6-P2C"><a href="#3-6-P2C" class="headerlink" title="3.6 P2C"></a>3.6 P2C</h3><ol><li>对于每次调用，从可用的provider列表中做两次随机选择，选出两个节点providerA和providerB。</li><li>比较providerA和providerB两个节点，选择其“当前正在处理的连接数”较小的那个节点。</li></ol><h3 id="3-7-Adaptive"><a href="#3-7-Adaptive" class="headerlink" title="3.7 Adaptive"></a>3.7 Adaptive</h3><p>Adaptive 即自适应负载均衡，是一种能根据后端实例负载自动调整流量分布的算法实现，它总是尝试将请求转发到负载最小的节点。</p><h2 id="4-启动时检查"><a href="#4-启动时检查" class="headerlink" title="4 启动时检查"></a>4 启动时检查</h2><p>在Dubbo服务中，难免会出现循环依赖的情况。而Dubbo在启动的时候，会默认去检查依赖的服务状态，并且建立通信连接。因此在这种情况下，就会导致服务无法启动的问题。 Dubbo里面提供了一个check参数，可以通过这个参数来关闭启动检查。</p><p>这个参数可以修饰在三个层面：</p><ol><li>@DubboReference ，直接关闭某个服务的启动检查 </li><li>dubbo.consumer.check=false，关闭消费端所有服务的启动检查 </li><li>dubbo.registry.check=false，关闭注册中心启动时检查</li></ol><h2 id="5-容错策略"><a href="#5-容错策略" class="headerlink" title="5 容错策略"></a>5 容错策略</h2><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p><ol><li>Failover Cluster：失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 <code>retries=&quot;2&quot;</code> 来设置重试次数(不含第一次)。</li><li>Failfast Cluster：快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li><li>Failsafe Cluster：失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li><li>Failback Cluster：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li><li>Forking Cluster：并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 <code>forks=&quot;2&quot;</code> 来设置最大并行数。</li><li>Broadcast Cluster：广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。现在广播调用中，可以通过 broadcast.fail.percent 配置节点调用失败的比例，当达到这个比例后，BroadcastClusterInvoker 将不再调用其他节点，直接抛出异常。 broadcast.fail.percent 取值在 0～100 范围内。默认情况下当全部调用失败后，才会抛出异常。 broadcast.fail.percent 只是控制的当失败后是否继续调用其他节点，并不改变结果(任意一台报错则报错)。</li><li>Available Cluster：调用目前可用的实例（只调用一个），如果当前没有可用的实例，则抛出异常。通常用于不需要负载均衡的场景。</li><li>Mergeable Cluster：将集群中的调用结果聚合起来返回结果，通常和group一起配合使用。通过分组对结果进行聚合并返回聚合后的结果，比如菜单服务，用group区分同一接口的多种实现，现在消费方需从每种group中调用一次并返回结果，对结果进行合并之后返回，这样就可以实现聚合菜单项。</li><li>ZoneAware Cluster：多注册中心订阅的场景，注册中心集群间的负载均衡。</li></ol>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo-初识</title>
    <link href="/2023/05/31/%E4%B8%AD%E9%97%B4%E4%BB%B6/dubbo/Dubbo-%E5%88%9D%E8%AF%86/"/>
    <url>/2023/05/31/%E4%B8%AD%E9%97%B4%E4%BB%B6/dubbo/Dubbo-%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>官网：<a href="https://cn.dubbo.apache.org/zh-cn">https://cn.dubbo.apache.org/zh-cn</a></p><h2 id="1-dubbo介绍"><a href="#1-dubbo介绍" class="headerlink" title="1 dubbo介绍"></a>1 dubbo介绍</h2><p>Dubbo不仅仅是一个RPC框架，更是一个成熟的微服务框架。官网是这么定义Dubbo的：“Apache Dubbo 是一款微服务框架，为大规模 微服务实践提供高性能 RPC 通信、流量治理、可观测性等解决方案”。它包括以下功能：</p><ol><li>面向接口代理的高性能RPC调用，提供高性能的基于代理的远程调用能力，服务以接口为粒度，为开发者屏蔽远程调用底层细节 </li><li>智能负载均衡，内置多种负载均衡策略，智能感知下游节点健康状况，显著减少调用延迟，提高系统吞吐量 </li><li>服务自动注册与发现，支持多种注册中心服务，服务实例上下线实时感知</li><li>可视化的服务治理与运维，提供丰富服务治理、运维工具：随时查询服务元数据、服务健康状态及调用统计，实时下发路由策略、调整配置参数 </li><li>运行期流量调度，内置条件、脚本等路由策略，通过配置不同的路由规则，轻松实现灰度发布，同机房优先等功能 </li><li>高度可扩展能力，遵循微内核+插件的设计原则，所有核心能力如Protocol、Transport、Serialization被设计为扩展点，平等对待内置实现和第三方实现</li></ol><p>整体架构：</p><p><img src="/image/dubbo/1.png"></p><table><thead><tr><th>节点</th><th>角色说明</th></tr></thead><tbody><tr><td>Provider</td><td>暴露服务的服务提供方</td></tr><tr><td>Consumer</td><td>调用远程服务的服务消费方</td></tr><tr><td>Registry</td><td>服务注册与发现的注册中心</td></tr><tr><td>Monitor</td><td>统计服务的调用次数和调用时间的监控中心</td></tr><tr><td>Container</td><td>服务运行容器</td></tr></tbody></table><h2 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2 基本使用"></a>2 基本使用</h2><p>spring xml配置(了解，目前都是基于注解去实现)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo_provider&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:provicer</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;5000&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 注册中心地址 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:regitry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;zookeeper://192.168.0.1:2184&quot;</span> <span class="hljs-attr">check</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 如果协议是dubbo的话，这个就是netty服务端绑定的端口，默认是20880 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;29015&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userServiceImpl&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.service.UserServiceImpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.test.service.UserService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userServiceImpl&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;dubbo:method name=&quot;&quot; /&gt; --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:service</span>&gt;</span><br></code></pre></td></tr></table></figure><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span>&#123;<br>    String <span class="hljs-title function_">queryUser</span><span class="hljs-params">(String var1)</span>;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doKill</span><span class="hljs-params">(String var1)</span>;<br>&#125;<br><br><span class="hljs-comment">//生产者</span><br><span class="hljs-comment">//@DubboService注解就是服务暴露的注解</span><br><span class="hljs-meta">@DubboService(methods = &#123;@Method(name = &quot;doKill&quot;,executes = 10,actives = 10)&#125;,connections = 10,protocol = &quot;dubbo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">queryUser</span><span class="hljs-params">(String s)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> RpcContext.getContext().getAttachment(<span class="hljs-string">&quot;username&quot;</span>);<br>System.out.println(username);<br>System.out.println(<span class="hljs-string">&quot;=======provider======&quot;</span> + s);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK--&quot;</span> + s;<br>&#125;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doKill</span><span class="hljs-params">(String s)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;=======provider======&quot;</span> + s);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//消费者</span><br><span class="hljs-meta">@DubboReference(check = false,protocol = &quot;dubbo&quot;,retries = 3,timeout = 1000000000,cluster = &quot;failover&quot;,loadbalance = &quot;random&quot;,sticky = true,methods = &#123;@Method(name = &quot;doKill&quot;,isReturn = false)&#125;/*,url = &quot;dubbo://localhost:20880&quot;*/)</span><br>UserService userService;<br><br><span class="hljs-comment">//在启动类上加入注解@EnableDubbo(scanBasePackages = &quot;com.test&quot;)即可使用dubbo</span><br></code></pre></td></tr></table></figure><h2 id="3-引入注册中心zookeeper"><a href="#3-引入注册中心zookeeper" class="headerlink" title="3 引入注册中心zookeeper"></a>3 引入注册中心zookeeper</h2><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-dependencies-zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">dubbo.application.name</span>=<span class="hljs-string">dubbo_provider</span><br><span class="hljs-attr">dubbo.registry.address</span>=<span class="hljs-string">zookeeper://$&#123;zookeeper.address:127.0.0.1&#125;:2181</span><br><span class="hljs-attr">dubbo.protocol.name</span>=<span class="hljs-string">dubbo</span><br><span class="hljs-attr">dubbo.protocol.port</span>=<span class="hljs-string">20880</span><br><span class="hljs-comment">#dubbo.protocol.port=-1 自动生成不冲突的端口</span><br></code></pre></td></tr></table></figure><h2 id="4-dubbo监控平台"><a href="#4-dubbo监控平台" class="headerlink" title="4 dubbo监控平台"></a>4 dubbo监控平台</h2><p><a href="https://github.com/apache/dubbo-admin">https://github.com/apache/dubbo-admin</a></p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper源码解析</title>
    <link href="/2023/05/23/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/05/23/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Zookeeper-Server启动流程"><a href="#1-Zookeeper-Server启动流程" class="headerlink" title="1 Zookeeper Server启动流程"></a>1 Zookeeper Server启动流程</h2><p><img src="/image/zookeeper/Zookeeper%E5%8D%95%E6%9C%BA%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8.jpg"></p><h2 id="2-客户端实例化与创建节点"><a href="#2-客户端实例化与创建节点" class="headerlink" title="2 客户端实例化与创建节点"></a>2 客户端实例化与创建节点</h2><p><img src="/image/zookeeper/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%8E%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9.jpg"></p><h2 id="3-Zookeeper源码分析之查询数据与watch"><a href="#3-Zookeeper源码分析之查询数据与watch" class="headerlink" title="3 Zookeeper源码分析之查询数据与watch"></a>3 Zookeeper源码分析之查询数据与watch</h2><p><img src="/image/zookeeper/%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E3%80%81%E6%B7%BB%E5%8A%A0%E7%9B%91%E5%90%AC%E5%92%8C%E5%9B%9E%E8%B0%83.jpg"></p><h2 id="4-集群启动与Leader选举"><a href="#4-集群启动与Leader选举" class="headerlink" title="4 集群启动与Leader选举"></a>4 集群启动与Leader选举</h2><p><img src="/image/zookeeper/ZK%E9%9B%86%E7%BE%A4%E5%90%AF%E5%8A%A8%E4%B8%8Eleader%E9%80%89%E4%B8%BE.jpg"></p><h2 id="5-Learn与Leader数据同步"><a href="#5-Learn与Leader数据同步" class="headerlink" title="5 Learn与Leader数据同步"></a>5 Learn与Leader数据同步</h2><p><img src="/image/zookeeper/Learn%E4%B8%8ELeader%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5.jpg"></p><h2 id="6-ZAB协议处理事务请求"><a href="#6-ZAB协议处理事务请求" class="headerlink" title="6 ZAB协议处理事务请求"></a>6 ZAB协议处理事务请求</h2><p><img src="/image/zookeeper/ZAB%E5%8D%8F%E8%AE%AE%E5%A4%84%E7%90%86%E4%BA%8B%E5%8A%A1%E8%AF%B7%E6%B1%82.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper集群</title>
    <link href="/2023/05/23/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E9%9B%86%E7%BE%A4/"/>
    <url>/2023/05/23/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="1-初识Zookeeper集群"><a href="#1-初识Zookeeper集群" class="headerlink" title="1 初识Zookeeper集群"></a>1 初识Zookeeper集群</h2><p>官网：<a href="https://zookeeper.apache.org/doc/current/zookeeperOver.html#sc_designGoals">https://zookeeper.apache.org/doc/current/zookeeperOver.html#sc_designGoals</a></p><h3 id="1-1-zk集群中的角色"><a href="#1-1-zk集群中的角色" class="headerlink" title="1.1 zk集群中的角色"></a>1.1 zk集群中的角色</h3><p><img src="/image/zookeeper/6.png"></p><p>客户端是可以连接任意一个Zookeeper Server Cluster中的机器的。</p><p>Leader：只能有一个，可以处理客户端的读写请求。</p><p>Follower：可以有多个，只能处理客户端的读请求，要是收到写请求，则会转发给Leader进行处理。</p><p>Observer：可以有多个，只能处理客户端的读请求，要是收到写请求，则会转发给Leader进行处理，与Follower不同的是，Observer不参与Leader的投票选举以及写请求的提议和提交过程。</p><h3 id="1-2-对zk集群的理解"><a href="#1-2-对zk集群的理解" class="headerlink" title="1.2 对zk集群的理解"></a>1.2 对zk集群的理解</h3><h4 id="1-2-1-leader选举"><a href="#1-2-1-leader选举" class="headerlink" title="1.2.1 leader选举"></a>1.2.1 leader选举</h4><p>Leader+Follower的数量最好是奇数台，因为选举的时候需要进行投票，只有某个节点的票数超过半数，才会成为Leader。</p><p> 如果Leader+Follower是2台，则超过半数就是2。如果Leader+Follower是3台，则超过半数也是 2。</p><h4 id="1-2-2-节点的状态"><a href="#1-2-2-节点的状态" class="headerlink" title="1.2.2 节点的状态"></a>1.2.2 节点的状态</h4><p>Looking：启动节点，但还没有确定当前节点的角色时的状态。 </p><p>Leading：Leader节点所处的状态。 </p><p>Following：Follower节点所处的状态。 </p><p>Observing：Observer节点所处的状态。</p><h4 id="1-2-3-数据同步"><a href="#1-2-3-数据同步" class="headerlink" title="1.2.3 数据同步"></a>1.2.3 数据同步</h4><p>当zk02成为leader之后，zk01、zk03、zk04需要从leader上同步最新的数据。</p><h4 id="1-2-4-崩溃恢复"><a href="#1-2-4-崩溃恢复" class="headerlink" title="1.2.4 崩溃恢复"></a>1.2.4 崩溃恢复</h4><p>如果Leader节点挂了，则集群重新进行leader选举，此时集群对外是不能提供服务的。</p><h2 id="2-搭建Zookeeper集群"><a href="#2-搭建Zookeeper集群" class="headerlink" title="2 搭建Zookeeper集群"></a>2 搭建Zookeeper集群</h2><h3 id="2-1-centos"><a href="#2-1-centos" class="headerlink" title="2.1 centos"></a>2.1 centos</h3><p>（1）准备4台centos机器</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">zk01</span> <span class="hljs-number">192.168.0.111</span><br>zk02 <span class="hljs-number">192.168.0.112</span><br>zk03 <span class="hljs-number">192.168.0.113</span><br>zk04 <span class="hljs-number">192.168.0.114</span> observer<br></code></pre></td></tr></table></figure><p>（2）准备好一些前置环境</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Java、Maven</span><br><span class="hljs-keyword"></span>Zookeeper压缩包并解压<br>Zookeeper的环境变量配置<br></code></pre></td></tr></table></figure><p>（3）配置4台机器的hosts文件</p><blockquote><p>/etc/hosts</p></blockquote><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.0.111</span> zk1<br><span class="hljs-number">192.168.0.112</span> zk2<br><span class="hljs-number">192.168.0.113</span> zk3<br><span class="hljs-number">192.168.0.114</span> zk4<br></code></pre></td></tr></table></figure><p>（4）创建zk持久化目录的文件夹data </p><p>（5）在data目录下创建并配置myid文件 内容分别为：1、2、3、4</p><p>（6）在conf目录下编写zoo.cfg文件</p><blockquote><p>2888用于数据同步或节点间通信</p><p>3888用于leader选举投票</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">tickTime</span>=<span class="hljs-string">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-string">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">dataDir</span>=<span class="hljs-string">/usr/local/zookeeper/apache-zookeeper-3.7.1-bin/data</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-string">2181</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-string">zk1:2888:3888</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-string">zk2:2888:3888</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-string">zk3:2888:3888</span><br><span class="hljs-attr">server.4</span>=<span class="hljs-string">zk4:2888:3888:observer</span><br></code></pre></td></tr></table></figure><p>（7）依次启动zk01、zk02、zk03、zk04，并观察各个节点的状态</p><p>（8）图解</p><p><img src="/image/zookeeper/ZK%E9%9B%86%E7%BE%A4%E5%9B%BE%E8%A7%A3.jpg"></p><h3 id="2-2-基于K8s"><a href="#2-2-基于K8s" class="headerlink" title="2.2 基于K8s"></a>2.2 基于K8s</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f zk-cluster.yaml<br>kubectl get pods -n zookeeper-cluster<br>kubectl get pods -n zookeeper-cluster -o wide<br>kubectl get svc -n zookeeper-cluster<br>kubectl get statefulset -n zookeeper-cluster<br>kubectl describe svc zk-client -n zookeeper-cluster<br>kubectl <span class="hljs-built_in">exec</span> -it zk-1 -n zookeeper-cluster /bin/bash<br>zkServer.sh status<br></code></pre></td></tr></table></figure><h3 id="2-3-基于源码"><a href="#2-3-基于源码" class="headerlink" title="2.3 基于源码"></a>2.3 基于源码</h3><p>（1）下载源码</p><p><a href="https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.7.1/apache-zookeeper-3.7.1.tar.gz">https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.7.1/apache-zookeeper-3.7.1.tar.gz</a></p><p>（2）maven构建 打开源码文件的跟目录，执行如下命令</p><blockquote><p>mvn clean install ‐DskipTests</p></blockquote><p>（3）导入到idea中</p><p>（4）配置日志输出</p><p>a-将conf文件下的log.properties文件复制到zookeeper-server的resources文件夹下 </p><p>b-在zookeeper-server的pom文件中添加slf4j的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>&lt;/dependency<br></code></pre></td></tr></table></figure><p>（5）复制4个zoo文件</p><blockquote><p>zoo-01.cfg</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">tickTime</span>=<span class="hljs-string">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-string">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">dataDir</span>=<span class="hljs-string">D:\\install\\dev\\zookeeper\\zk01\\data</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-string">2191</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-string">127.0.0.1:2881:3881</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-string">127.0.0.1:2882:3882</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-string">127.0.0.1:2883:3883</span><br><span class="hljs-attr">server.4</span>=<span class="hljs-string">127.0.0.1:2884:3884:observer</span><br></code></pre></td></tr></table></figure><blockquote><p>zoo-02.cfg</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">tickTime</span>=<span class="hljs-string">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-string">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">dataDir</span>=<span class="hljs-string">D:\\install\\dev\\zookeeper\\zk02\\data</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-string">2192</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-string">127.0.0.1:2881:3881</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-string">127.0.0.1:2882:3882</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-string">127.0.0.1:2883:3883</span><br><span class="hljs-attr">server.4</span>=<span class="hljs-string">127.0.0.1:2884:3884:observer</span><br></code></pre></td></tr></table></figure><blockquote><p>zoo-03.cfg</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">tickTime</span>=<span class="hljs-string">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-string">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">dataDir</span>=<span class="hljs-string">D:\\install\\dev\\zookeeper\\zk03\\data</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-string">2193</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-string">127.0.0.1:2881:3881</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-string">127.0.0.1:2882:3882</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-string">127.0.0.1:2883:3883</span><br><span class="hljs-attr">server.4</span>=<span class="hljs-string">127.0.0.1:2884:3884:observer</span><br></code></pre></td></tr></table></figure><blockquote><p>zoo-04.cfg</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">tickTime</span>=<span class="hljs-string">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-string">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">dataDir</span>=<span class="hljs-string">D:\\install\\dev\\zookeeper\\zk04\\data</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-string">2194</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-string">127.0.0.1:2881:3881</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-string">127.0.0.1:2882:3882</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-string">127.0.0.1:2883:3883</span><br><span class="hljs-attr">server.4</span>=<span class="hljs-string">127.0.0.1:2884:3884:observer</span><br></code></pre></td></tr></table></figure><p>（7）在各自的data目录创建myid文件，并配置上1、2、3、4 </p><p>（8）寻找启动入口类并配置</p><blockquote><p>bin/zkServer.cmd 或 bin/zkServer.sh</p><p>也就是服务端启动的时候，会通过QuorumPeerMain进行启动</p></blockquote><p>ZOOMAIN=org.apache.zookeeper.server.quorum.QuorumPeerMain</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper实现注册中心</title>
    <link href="/2023/05/17/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <url>/2023/05/17/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Zookeeper实现注册中心"><a href="#1-Zookeeper实现注册中心" class="headerlink" title="1 Zookeeper实现注册中心"></a>1 Zookeeper实现注册中心</h2><h3 id="1-1-项目准备"><a href="#1-1-项目准备" class="headerlink" title="1.1 项目准备"></a>1.1 项目准备</h3><p>创建一个父工程，名称为handwritten-zookeeper-discovery，并在父工程下创建两个Spring Boot项目，分别为order-service和user-service，并在order-service中准备一个OrderController。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/query&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">query</span><span class="hljs-params">()</span>&#123;<br>        System.out.printLn(<span class="hljs-string">&quot;query...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;query...&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-实现服务注册"><a href="#1-2-实现服务注册" class="headerlink" title="1.2 实现服务注册"></a>1.2 实现服务注册</h3><blockquote><p>以order-service项目为例，实现服务注册的功能</p></blockquote><h4 id="1-2-1-事件监听机制扩展Spring-Boot源码"><a href="#1-2-1-事件监听机制扩展Spring-Boot源码" class="headerlink" title="1.2.1 事件监听机制扩展Spring Boot源码"></a>1.2.1 事件监听机制扩展Spring Boot源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JackApplicationListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;事件监听机制的回调...&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Spring SPI: MATA-INF/spring.factories</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span>.ApplicationListener=com<span class="hljs-selector-class">.jack</span><span class="hljs-selector-class">.zkorderservice</span><span class="hljs-selector-class">.initializer</span>.JackApplicationListener<br></code></pre></td></tr></table></figure><h4 id="1-2-2-定义服务注册接口和实现类"><a href="#1-2-2-定义服务注册接口和实现类" class="headerlink" title="1.2.2 定义服务注册接口和实现类"></a>1.2.2 定义服务注册接口和实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ServiceRegistry</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZookeeperServiceRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServiceRegistry</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-3-构造函数初始化curatorFramework"><a href="#1-2-3-构造函数初始化curatorFramework" class="headerlink" title="1.2.3 构造函数初始化curatorFramework"></a>1.2.3 构造函数初始化curatorFramework</h4><p>（1）引入curator依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）构造函数初始化curator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> CuratorFramework curatorFramework;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ZookeeperServiceRegistry</span><span class="hljs-params">(String zkServer)</span>&#123;<br>    <span class="hljs-built_in">this</span>.curatorFramework = CUratorFrameworkFactory<br>        .build()<br>        .connectionTimeoutMs(<span class="hljs-number">20000</span>)<br>        .connectString(zkServer)<br>        .retryPolicy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>        .build();<br>    curatorFramework.start();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-4-配置application-properties"><a href="#1-2-4-配置application-properties" class="headerlink" title="1.2.4  配置application.properties"></a>1.2.4  配置application.properties</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">9091</span><br><span class="hljs-attr">zk.service-name</span>=<span class="hljs-string">order-service</span><br><span class="hljs-attr">zk.server</span>=<span class="hljs-string">192.168.0.8:2181</span><br><span class="hljs-attr">zk.ip</span>=<span class="hljs-string">127.0.0.1</span><br></code></pre></td></tr></table></figure><h4 id="1-2-5-完善监听器回调逻辑"><a href="#1-2-5-完善监听器回调逻辑" class="headerlink" title="1.2.5 完善监听器回调逻辑"></a>1.2.5 完善监听器回调逻辑</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JackApplicationListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span>&#123;<br>System.out.printLn(<span class="hljs-string">&quot;事件监听机制得回调。。。&quot;</span>);<br>        <span class="hljs-comment">// 获取app.properties配置属性</span><br><span class="hljs-type">Environment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> event.getApplicationContext().getEnvironment();<br><span class="hljs-type">String</span> <span class="hljs-variable">serviceName</span> <span class="hljs-operator">=</span> environment.getProperty(<span class="hljs-string">&quot;zk.service-name&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> environment.getProperty(<span class="hljs-string">&quot;zk.ip&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> environment.getProperty(<span class="hljs-string">&quot;server.port&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">zkServer</span> <span class="hljs-operator">=</span> environment.getProperty(<span class="hljs-string">&quot;zk.server&quot;</span>);<br><span class="hljs-comment">// 服务注册</span><br><span class="hljs-type">ServiceRegistry</span> <span class="hljs-variable">zookeeperServiceRegistry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZookeeperServiceRegistry</span>(zkServer);<br>zookeeperServiceRegistry.register()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-6-完善ZookeeperRegistry构造函数"><a href="#1-2-6-完善ZookeeperRegistry构造函数" class="headerlink" title="1.2.6 完善ZookeeperRegistry构造函数"></a>1.2.6 完善ZookeeperRegistry构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 服务注册</span><br><span class="hljs-type">ServiceRegistry</span> <span class="hljs-variable">zookeeperServiceRegistry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZookeeperServiceRegistry</span>(serviceName,ip,port,zkServer);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZookeeperServiceRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServiceRegistry</span>&#123;<br><span class="hljs-keyword">private</span> CuratorFramework curatorFramework;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String ip;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String port;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String serviceName;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String basePath=<span class="hljs-string">&quot;/jack-registry&quot;</span>;<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ZookeeperServiceRegistry</span><span class="hljs-params">(String serviceName, String ip, String port, String zkServer)</span> &#123;<br><span class="hljs-built_in">this</span>.serviceName=serviceName;<br><span class="hljs-built_in">this</span>.ip=ip;<br><span class="hljs-built_in">this</span>.port=port;<br><span class="hljs-built_in">this</span>.curatorFramework = CuratorFrameworkFactory<br>            .builder()<br>.connectionTimeoutMs(<span class="hljs-number">20000</span>)<br>.connectString(zkServer)<br>.retryPolicy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>.build();<br>curatorFramework.start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-7-完善ZookeeperServiceRegistry-register-方法"><a href="#1-2-7-完善ZookeeperServiceRegistry-register-方法" class="headerlink" title="1.2.7 完善ZookeeperServiceRegistry#register()方法"></a>1.2.7 完善ZookeeperServiceRegistry#register()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span> &#123;<br>String serviceNamePath=basePath+<span class="hljs-string">&quot;/&quot;</span>+serviceName;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span>(curatorFramework.checkExists().forPath(serviceNamePath)==<span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.curatorFramework.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(serviceNamePath);<br>&#125;<br><span class="hljs-type">String</span> <span class="hljs-variable">urlNode</span> <span class="hljs-operator">=</span> curatorFramework.create().withMode(CreateMode.EPHEMERAL).forPath(serviceNamePath + <span class="hljs-string">&quot;/&quot;</span> + ip +<span class="hljs-string">&quot;:&quot;</span>+ port);<br>System.out.println(<span class="hljs-string">&quot;服务 &quot;</span>+urlNode+<span class="hljs-string">&quot; 注册成功...&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-注册多个服务实例"><a href="#1-3-注册多个服务实例" class="headerlink" title="1.3 注册多个服务实例"></a>1.3 注册多个服务实例</h3><p>（1）修改application.properties文件 </p><p>（2）允许多个实例的方式进行注册 </p><p>（3）观察order-service节点下的实例</p><h3 id="1-4-手写服务发现"><a href="#1-4-手写服务发现" class="headerlink" title="1.4 手写服务发现"></a>1.4 手写服务发现</h3><h4 id="1-4-1-定义服务发现接口和实现类"><a href="#1-4-1-定义服务发现接口和实现类" class="headerlink" title="1.4.1 定义服务发现接口和实现类"></a>1.4.1 定义服务发现接口和实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ServiceDiscovery</span> &#123;<br>List&lt;String&gt; <span class="hljs-title function_">discovery</span><span class="hljs-params">(String serviceName)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">registerWatch</span><span class="hljs-params">(String serviceNamePath)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceDiscoveryImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServiceDiscovery</span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">discovery</span><span class="hljs-params">(String serviceName)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerWatch</span><span class="hljs-params">(String serviceNamePath)</span> &#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-2-定义配置信息"><a href="#1-4-2-定义配置信息" class="headerlink" title="1.4.2 定义配置信息"></a>1.4.2 定义配置信息</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">6666</span><br><span class="hljs-attr">zk.server</span>=<span class="hljs-string">192.168.0.8:2181</span><br></code></pre></td></tr></table></figure><h4 id="1-4-3-完善ServiceDiscoveryImpl构造函数"><a href="#1-4-3-完善ServiceDiscoveryImpl构造函数" class="headerlink" title="1.4.3 完善ServiceDiscoveryImpl构造函数"></a>1.4.3 完善ServiceDiscoveryImpl构造函数</h4><p>（1）引入curator依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）完善构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CuratorFramework curatorFramework;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String basePath=<span class="hljs-string">&quot;/jack-registry&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ServiceDiscoveryImpl</span><span class="hljs-params">(String zkServer)</span> &#123;<br><span class="hljs-built_in">this</span>.curatorFramework = CuratorFrameworkFactory<br>        .builder()<br>.connectionTimeoutMs(<span class="hljs-number">20000</span>)<br>.connectString(zkServer)<br>.retryPolicy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>.build();<br>curatorFramework.start();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-4-完善ServiceDiscoveryImpl-discovery方法"><a href="#1-4-4-完善ServiceDiscoveryImpl-discovery方法" class="headerlink" title="1.4.4 完善ServiceDiscoveryImpl#discovery方法"></a>1.4.4 完善ServiceDiscoveryImpl#discovery方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">discovery</span><span class="hljs-params">(String serviceName)</span> &#123;<br>String serviceNamePath=basePath + <span class="hljs-string">&quot;/&quot;</span> + serviceName;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.curatorFramework.checkExists().forPath(serviceNamePath)!=<span class="hljs-literal">null</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.curatorFramework.getChildren().forPath(serviceNamePath);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-5-将ServiceDiscoveryImpl交给Spring-IoC容器管理"><a href="#1-4-5-将ServiceDiscoveryImpl交给Spring-IoC容器管理" class="headerlink" title="1.4.5  将ServiceDiscoveryImpl交给Spring IoC容器管理"></a>1.4.5  将ServiceDiscoveryImpl交给Spring IoC容器管理</h4><p>（1）创建ZookeeperDiscoveryAutoConfiguration配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZookeeperDiscoveryAutoConfiguration</span> &#123;<br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> Environment environment;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> ServiceDiscoveryImpl <span class="hljs-title function_">serviceDiscovery</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceDiscoveryImpl</span>(environment.getProperty(<span class="hljs-string">&quot;zk.server&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）通过spring spi机制管理配置类</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">com.jack.zkuserservice.config.ZookeeperDiscoveryAutoConfiguration</span><br></code></pre></td></tr></table></figure><h4 id="1-4-6-负载均衡"><a href="#1-4-6-负载均衡" class="headerlink" title="1.4.6 负载均衡"></a>1.4.6 负载均衡</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LoadBalance</span> &#123;<br>String <span class="hljs-title function_">select</span><span class="hljs-params">(List&lt;String&gt; urls)</span>;<br>&#125;<br><br><span class="hljs-comment">//-----------</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomLoadBalance</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LoadBalance</span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">select</span><span class="hljs-params">(List&lt;String&gt; urls)</span> &#123;<br><span class="hljs-type">int</span> len=urls.size();<br>Random random=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-keyword">return</span> urls.get(random.nextInt(len));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-7-ServiceDiscoveryTest测试"><a href="#1-4-7-ServiceDiscoveryTest测试" class="headerlink" title="1.4.7  ServiceDiscoveryTest测试"></a>1.4.7  ServiceDiscoveryTest测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceDiscoveryTest</span> &#123;<br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> ServiceDiscovery serviceDiscovery;<br>    <br><span class="hljs-keyword">private</span> List&lt;String&gt; urls;<br>    <br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">discovery</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>urls = <span class="hljs-built_in">this</span>.serviceDiscovery.discovery(<span class="hljs-string">&quot;order-service&quot;</span>);<br>LoadBalance loadBalance=<span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomLoadBalance</span>();<br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> loadBalance.select(urls);<br>System.out.println(<span class="hljs-string">&quot;目标url为: &quot;</span>+url);<br><span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>().getForObject(<span class="hljs-string">&quot;http://&quot;</span> + url + <span class="hljs-string">&quot;/order/query&quot;</span>, String.class);<br>System.out.println(<span class="hljs-string">&quot;response: &quot;</span>+response);<br><span class="hljs-comment">// 添加对节点order-service的监听</span><br>    <span class="hljs-built_in">this</span>.serviceDiscovery.registerWatch(<span class="hljs-string">&quot;/jack-registry/order-service&quot;</span>,urls);<br>System.in.read();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-8-添加对节点的监听"><a href="#1-4-8-添加对节点的监听" class="headerlink" title="1.4.8 添加对节点的监听"></a>1.4.8 添加对节点的监听</h4><blockquote><p>监听order-service子节点的变化，完善ServiceDiscoveryImpl#registerWatch方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerWatch</span><span class="hljs-params">(String serviceNamePath)</span> &#123;<br><span class="hljs-comment">// 永久的监听</span><br><span class="hljs-type">CuratorCache</span> <span class="hljs-variable">curatorCache</span> <span class="hljs-operator">=</span> CuratorCache.build(curatorFramework, serviceNamePath);<br><span class="hljs-type">CuratorCacheListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> CuratorCacheListener.builder().forPathChildrenCache(serviceNamePath, curatorFramework, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathChildrenCacheListener</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">childEvent</span><span class="hljs-params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>System.out.println(<span class="hljs-string">&quot;最新的urls为: &quot;</span>+curatorFramework.getChildren().forPath(serviceNamePath));<br>&#125;<br>&#125;).build();<br>curatorCache.listenable().addListener(listener);<br>curatorCache.start();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Spring-Cloud-Zookeeper实现注册中心"><a href="#2-Spring-Cloud-Zookeeper实现注册中心" class="headerlink" title="2 Spring Cloud Zookeeper实现注册中心"></a>2 Spring Cloud Zookeeper实现注册中心</h2><p>（1）创建spring-cloud-zookeeper的spring boot项目，Spring Boot版本为2.7.2</p><p>（2）定义Spring Cloud的版本管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--定义版本的管理--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-comment">&lt;!--定义sc的版本--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（3）引入spring cloud zookeeper注册中心的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- spring cloud zookeeper discovery 注册中心--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（4）写注册中心相关的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">zookeeper:</span><br>      <span class="hljs-attr">connect-string:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.8</span><span class="hljs-string">:2181</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">root:</span> <span class="hljs-string">/services/registries</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">spring-cloud-zookeeper</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9091</span><br></code></pre></td></tr></table></figure><p>（5）启动Spring Boot项目，观察Zookeeper Server上的数据</p><p>（6）服务发现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;<br><span class="hljs-meta">@RequestMapping(&quot;/sc-zk-discovery&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;ServiceInstance&gt; <span class="hljs-title function_">serviceUrl</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> discoveryClient.getInstances(<span class="hljs-string">&quot;spring-cloud-zookeeper&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>（7）服务注册实现核心入口</p><blockquote><p>AbstractAutoServiceRegistration#onApplicationEvent</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper实现配置中心</title>
    <link href="/2023/05/16/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <url>/2023/05/16/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h2 id="1-本地配置原理"><a href="#1-本地配置原理" class="headerlink" title="1 本地配置原理"></a>1 本地配置原理</h2><p><a href="https://docs.spring.io/spring-boot/docs/2.7.2/reference/htmlsingle/#features.external-config">https://docs.spring.io/spring-boot/docs/2.7.2/reference/htmlsingle/#features.external-config</a></p><p>（1）加载application.properties文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">PropertySourceLoader#load()<br>-&gt;PropertiesPropertySourceLoader#load()<br>-&gt;OriginTrackedMapPropertySource<br></code></pre></td></tr></table></figure><p>（2）查看Environment的属性配置源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">SpringApplication#run()<br>-&gt;debug: configureIgnoreBeanInfo(environment)<br></code></pre></td></tr></table></figure><p>（3）比如在Program arguments中配置hello=hi，environment中的 SimpleCommandLinePropertySource</p><p>（4）@Value实现原理</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs livescript">（<span class="hljs-number">1</span>）使用BeanPostProcessor解析类上的@Value字段<br>（<span class="hljs-number">2</span>）获取到字段上的@Value字段<br>（<span class="hljs-number">3</span>）解析@Value字段的value属性值，比如age<br>（<span class="hljs-number">4</span>）从environment中的属性配置源OriginTrackedMapPropertySource中寻找age的key<br>（<span class="hljs-number">5</span>）根据key获取到对应的value值<br>（<span class="hljs-number">6</span>）通过field反射的方式设置value值<br><br>源码：<br>AutowiredAnnotationBeanPostProcessor<span class="hljs-comment">#inject()</span><br>-&gt;resolveFieldValue(field, bean, beanName)   <span class="hljs-comment">#设置条件:</span><br>beanName.equals<span class="hljs-function"><span class="hljs-params">(<span class="hljs-string">&quot;orderController&quot;</span>)</span></span><br><span class="hljs-function">-&gt;</span>AutowiredAnnotationBeanPostProcessor.this.beanFactory.resolveDependency(<br>-&gt;DefaultListableBeanFactory<span class="hljs-comment">#resolveDependency</span><br>-&gt;this.doResolveDependency(descriptor...)<br><span class="hljs-comment"># 获取到@Value属性上的value，比如age</span><br>-&gt;<span class="hljs-built_in">Object</span> value = getAutowireCandidateResolver().getSuggestedValue(descriptor) <br><span class="hljs-comment"># 根据age从env中寻找与之对应的值</span><br>-&gt; <span class="hljs-built_in">String</span> strVal = resolveEmbeddedValue((<span class="hljs-built_in">String</span>) value)<br><span class="hljs-comment">#AutowiredAnnotationBeanPostProcessor#inject最后一段逻辑 通过反射给目标字段赋值</span><br>-&gt; field<span class="hljs-comment">#set(bean,value) </span><br></code></pre></td></tr></table></figure><h2 id="2-spring生态中的扩展机制"><a href="#2-spring生态中的扩展机制" class="headerlink" title="2 spring生态中的扩展机制"></a>2 spring生态中的扩展机制</h2><h3 id="2-1-常见扩展机制"><a href="#2-1-常见扩展机制" class="headerlink" title="2.1  常见扩展机制"></a>2.1  常见扩展机制</h3><blockquote><p>所谓的扩展机制就是不修改Spring生态源码，也能够把一些想要的代码放到启动流程中</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">ApplicationContextInitializer<br>事件监听机制<br><span class="hljs-keyword">BeanPostProcessor</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">BeanFactoryPostProcessor</span><br><span class="hljs-keyword"></span>ApplicationRunner<br>...<br></code></pre></td></tr></table></figure><h3 id="2-2-举例使用ApplicationContextInitializer"><a href="#2-2-举例使用ApplicationContextInitializer" class="headerlink" title="2.2 举例使用ApplicationContextInitializer"></a>2.2 举例使用ApplicationContextInitializer</h3><p>（1）自定义ApplicationContextInitializer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZkConfigApplicationContextInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextInitializer</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> &#123;<br>            <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>resources/META-INF/spring.factories</p><p>SPI:读取所有spring.factories文件中的ApplicationContextInitializer类型，并实例化存放到list集合中</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span>.ApplicationContextInitializer=\com<span class="hljs-selector-class">.jack</span><span class="hljs-selector-class">.handwrittenzookeeperconfig</span><span class="hljs-selector-class">.initializer</span>.ZkConfigApplicationContextInitializer<br></code></pre></td></tr></table></figure><h2 id="3-Zookeeper实现配置中心"><a href="#3-Zookeeper实现配置中心" class="headerlink" title="3 Zookeeper实现配置中心"></a>3 Zookeeper实现配置中心</h2><h3 id="3-1-启动Spring-Boot拉取zk-Server数据"><a href="#3-1-启动Spring-Boot拉取zk-Server数据" class="headerlink" title="3.1 启动Spring Boot拉取zk Server数据"></a>3.1 启动Spring Boot拉取zk Server数据</h3><h4 id="3-1-1-准备数据"><a href="#3-1-1-准备数据" class="headerlink" title="3.1.1 准备数据"></a>3.1.1 准备数据</h4><blockquote><p>/jack-config/product-service</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;product&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mobile&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3000&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="3-1-2-Curator连接ZK并获取指定节点数据"><a href="#3-1-2-Curator连接ZK并获取指定节点数据" class="headerlink" title="3.1.2  Curator连接ZK并获取指定节点数据"></a>3.1.2  Curator连接ZK并获取指定节点数据</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZkConfigApplicationContextInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextInitializer</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;我被调用了...&quot;</span>);<br>    String connectStr=<span class="hljs-string">&quot;192.168.0.8:2181&quot;</span>;<br>        <span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">curatorFramework</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory<br>.builder()<br>.connectionTimeoutMs(<span class="hljs-number">20000</span>)<br>.connectString(connectStr)<br>.retryPolicy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>.build();<br>curatorFramework.start();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">byte</span>[] bytes = curatorFramework.getData().forPath(<span class="hljs-string">&quot;/jackconfig/product-service&quot;</span>);<br><span class="hljs-comment">// String字符串的Json转成Map</span><br>Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>().readValue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes), Map.class);<br>System.out.println(<span class="hljs-string">&quot;从zookeeper server获取到的值为: &quot;</span>+map);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-将map以属性源的形式保存到env中"><a href="#3-2-将map以属性源的形式保存到env中" class="headerlink" title="3.2 将map以属性源的形式保存到env中"></a>3.2 将map以属性源的形式保存到env中</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将map转换成MapPropertySource</span><br><span class="hljs-type">MapPropertySource</span> <span class="hljs-variable">mapPropertySource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapPropertySource</span>(<span class="hljs-string">&quot;product-serviceremote-env&quot;</span>, map);<br><span class="hljs-type">ConfigurableEnvironment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> context.getEnvironment();<br>environment.getPropertySources().addFirst(mapPropertySource);<br>System.out.println(<span class="hljs-string">&quot;env新增MapPropertySource成功.&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="3-3-添加对节点-jack-config-product-service的监听"><a href="#3-3-添加对节点-jack-config-product-service的监听" class="headerlink" title="3.3  添加对节点/jack-config/product-service的监听"></a>3.3  添加对节点/jack-config/product-service的监听</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 永久的监听</span><br><span class="hljs-type">CuratorCache</span> <span class="hljs-variable">curatorCache</span> <span class="hljs-operator">=</span> CuratorCache.build(curatorFramework, <span class="hljs-string">&quot;/jack-config/product-service&quot;</span>, CuratorCache.Options.SINGLE_NODE_CACHE);<br><span class="hljs-type">CuratorCacheListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> CuratorCacheListener.builder().forAll(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CuratorCacheListener</span>() &#123;<br><span class="hljs-comment">// 一旦对应 /jack-config/product-service ZNode发生变化，就会回调这个方法</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">event</span><span class="hljs-params">(Type type, ChildData oldData, ChildData data)</span> &#123;<br><span class="hljs-keyword">if</span>(type.equals(Type.NODE_CHANGED))&#123;<br>System.out.println(<span class="hljs-string">&quot;ZNode数据更新了, 事件类型为: &quot;</span> + type);<br>&#125;<br>&#125;<br>&#125;).build();<br>curatorCache.listenable().addListener(listener);<br>curatorCache.start();<br></code></pre></td></tr></table></figure><h3 id="3-4-获取到更新后的数据并重新赋值给environment"><a href="#3-4-获取到更新后的数据并重新赋值给environment" class="headerlink" title="3.4 获取到更新后的数据并重新赋值给environment"></a>3.4 获取到更新后的数据并重新赋值给environment</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CuratorCacheListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> CuratorCacheListener.builder().forAll(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CuratorCacheListener</span>() &#123;<br><span class="hljs-comment">// 一旦对应 /jack-config/product-service ZNode发生变化，就会回调这个方法</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">event</span><span class="hljs-params">(Type type, ChildData oldData, ChildData data)</span> &#123;<br><span class="hljs-keyword">if</span>(type.equals(Type.NODE_CHANGED))&#123;<br>System.out.println(<span class="hljs-string">&quot;ZNode数据更新了, 事件类型为: &quot;</span> + type);<br><span class="hljs-keyword">try</span> &#123;<br>Map&lt;String, Object&gt; updateMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>().readValue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data.getData()), Map.class);<br>System.out.println(<span class="hljs-string">&quot;更新后的数据map为: &quot;</span>+updateMap);<br>environment.getPropertySources().replace(<span class="hljs-string">&quot;product-service-remote-env&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapPropertySource</span>(<span class="hljs-string">&quot;product-service-remote-enve&quot;</span>, updateMap));<br>&#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br>&#125;).build();<br></code></pre></td></tr></table></figure><h3 id="3-5-更新-Value字段"><a href="#3-5-更新-Value字段" class="headerlink" title="3.5 更新@Value字段"></a>3.5 更新@Value字段</h3><p>（1）FieldDetail</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FieldDetail</span> &#123;<br><span class="hljs-keyword">private</span> Field field; <span class="hljs-comment">// 具体哪个字段</span><br><span class="hljs-keyword">private</span> Object instance; <span class="hljs-comment">// 属于哪个实例</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FieldDetail</span><span class="hljs-params">(Field field, Object instance)</span> &#123;<br><span class="hljs-built_in">this</span>.field = field;<br><span class="hljs-built_in">this</span>.instance = instance;<br>&#125;<br><span class="hljs-keyword">public</span> Field <span class="hljs-title function_">getField</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> field;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setField</span><span class="hljs-params">(Field field)</span> &#123;<br><span class="hljs-built_in">this</span>.field = field;<br>&#125;<br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> instance;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setInstance</span><span class="hljs-params">(Object instance)</span> &#123;<br><span class="hljs-built_in">this</span>.instance = instance;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）定义需要保存下来类的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> JackRefreshScope &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）添加到目标类上，比如ProductController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/product&quot;)</span><br><span class="hljs-meta">@JackRefreshScope</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductController</span> &#123;<br></code></pre></td></tr></table></figure><p>（4）使用后置处理器进行逻辑判断并保存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParseJackRefreshScopeBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><span class="hljs-keyword">private</span> Map&lt;String, FieldDetail&gt; fieldDetailMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> Map&lt;String, FieldDetail&gt; <span class="hljs-title function_">getFieldDetailMap</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> fieldDetailMap;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>Class&lt;?&gt; clazz = bean.getClass();<br><span class="hljs-keyword">if</span>(clazz.isAnnotationPresent(JackRefreshScope.class))&#123;<br>System.out.println(clazz); <span class="hljs-comment">// class com.jack.controller.ProductController</span><br><span class="hljs-keyword">for</span> (Field field : clazz.getDeclaredFields()) &#123;<br><span class="hljs-keyword">if</span>(field.isAnnotationPresent(Value.class))&#123;<br><span class="hljs-type">Value</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> field.getAnnotation(Value.class);<br>String val=value.value(); <span class="hljs-comment">// 获取到了对应的value值 $&#123;id&#125; ---&gt; id</span><br>val=val.substring(<span class="hljs-number">2</span>,val.indexOf(<span class="hljs-string">&quot;&#125;&quot;</span>)); <span class="hljs-comment">// id</span><br>System.out.println(<span class="hljs-string">&quot;val: &quot;</span>+val);<br><span class="hljs-comment">// 保存 val 对应的Field和Field所在的clazz</span><br><span class="hljs-built_in">this</span>.fieldDetailMap.put(val,<span class="hljs-keyword">new</span> <span class="hljs-title class_">FieldDetail</span>(field,bean));<br>&#125;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> BeanPostProcessor.<span class="hljs-built_in">super</span>.postProcessAfterInitialization(bean,beanName);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）完善ZkConfigApplicationContextInitializer最后的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取到有哪些字段可能需要更新</span><br><span class="hljs-type">ParseJackRefreshScopeBeanPostProcessor</span> <span class="hljs-variable">parseJackRefreshScopeBeanPostProcessor</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;parseJackRefreshScopeBeanPostProcessor&quot;</span>, ParseJackRefreshScopeBeanPostProcessor.class);<br>Map&lt;String, FieldDetail&gt; fieldDetailMap = parseJackRefreshScopeBeanPostProcessor.getFieldDetailMap();<br><span class="hljs-keyword">for</span> (String key : fieldDetailMap.keySet()) &#123;<br><span class="hljs-keyword">if</span>(updateMap.containsKey(key))&#123; <span class="hljs-comment">// 判断远端发送过来的map数据中的key</span><br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> environment.getProperty(key);<br><span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> fieldDetailMap.get(key).getField();<br>field.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 反射更新字段的值</span><br>field.set(fieldDetailMap.get(key).getInstance(),value);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper-API</title>
    <link href="/2023/05/16/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper-API/"/>
    <url>/2023/05/16/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper-API/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Zookeeper-API"><a href="#1-Zookeeper-API" class="headerlink" title="1 Zookeeper API"></a>1 Zookeeper API</h2><h3 id="1-1-引入Zookeeper依赖"><a href="#1-1-引入Zookeeper依赖" class="headerlink" title="1.1 引入Zookeeper依赖"></a>1.1 引入Zookeeper依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-2-日志输出"><a href="#1-2-日志输出" class="headerlink" title="1.2 日志输出"></a>1.2 日志输出</h3><p>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）定义log4j.properties文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">###set log levels###</span><br><span class="hljs-attr">log4j.rootLogger</span>=<span class="hljs-string">info, stdout</span><br><span class="hljs-comment">###output to the console###</span><br><span class="hljs-attr">log4j.appender.stdout</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-attr">log4j.appender.stdout.Target</span>=<span class="hljs-string">System.out</span><br><span class="hljs-attr">log4j.appender.stdout.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-attr">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="hljs-string">[%d&#123;dd/MM/yy HH:mm:ss:SSS z&#125;] %t%5p %c&#123;2&#125;: %m%n</span><br></code></pre></td></tr></table></figure><h3 id="1-3-连接服务端"><a href="#1-3-连接服务端" class="headerlink" title="1.3  连接服务端"></a>1.3  连接服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZkConnUtil</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ZooKeeper zookeeper;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 获得zkConn</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ZooKeeper <span class="hljs-title function_">getZkConn</span><span class="hljs-params">(String zkServer)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>zookeeper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(zkServer, <span class="hljs-number">30000</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent event)</span> &#123;<br>Event.<span class="hljs-type">KeeperState</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> event.getState();<br><span class="hljs-keyword">if</span> (Event.KeeperState.SyncConnected == state) &#123;<br>System.out.println(<span class="hljs-string">&quot;连接zkServer成功.&quot;</span>);<br>countDownLatch.countDown();<br>&#125;<br>&#125;<br>&#125;);<br>countDownLatch.await();<br><span class="hljs-keyword">return</span> zookeeper;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">ZooKeeper</span> <span class="hljs-variable">zooKeeper</span> <span class="hljs-operator">=</span> getZkConn(<span class="hljs-string">&quot;192.168.0.8:2181&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-创建ZNode"><a href="#1-4-创建ZNode" class="headerlink" title="1.4 创建ZNode"></a>1.4 创建ZNode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateZNode</span> &#123;<br><span class="hljs-keyword">private</span> ZooKeeper zooKeeper;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CreateZNode</span><span class="hljs-params">(ZooKeeper zooKeeper)</span> &#123;<br><span class="hljs-built_in">this</span>.zooKeeper = zooKeeper;<br>&#125;<br><span class="hljs-comment">// 同步创建节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createZNodeWithSync</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">znode</span> <span class="hljs-operator">=</span> zooKeeper.create(<span class="hljs-string">&quot;/zookeeper-api-sync&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br>System.out.println(<span class="hljs-string">&quot;创建节点成功: &quot;</span>+znode);<br>&#125;<br><span class="hljs-comment">// 异步创建节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createZNodeWithAsync</span><span class="hljs-params">()</span>&#123;<br>zooKeeper.create(<span class="hljs-string">&quot;/zookeeper-api-async&quot;</span>,<span class="hljs-string">&quot;111&quot;</span>.getBytes(),ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncCallback</span>.StringCallback()&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processResult</span><span class="hljs-params">(<span class="hljs-type">int</span> rc, String path, Object ctx, String name)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;rc: &quot;</span>+rc);<br>System.out.println(<span class="hljs-string">&quot;path: &quot;</span>+path);<br>System.out.println(<span class="hljs-string">&quot;ctx: &quot;</span>+ctx);<br>System.out.println(<span class="hljs-string">&quot;name: &quot;</span>+name);<br>&#125;<br>&#125;,<span class="hljs-string">&quot;create-asyn&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">CreateZNode</span> <span class="hljs-variable">createZNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreateZNode</span>(ZkConnUtil.getZkConn(<span class="hljs-string">&quot;192.168.0.8:2181&quot;</span>));<br><span class="hljs-comment">// createZNode.createZNodeWithSync();</span><br>createZNode.createZNodeWithAsync();<br>System.in.read();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-5-查询ZNode数据并设置监听"><a href="#1-5-查询ZNode数据并设置监听" class="headerlink" title="1.5 查询ZNode数据并设置监听"></a>1.5 查询ZNode数据并设置监听</h3><blockquote><p>watch是一次性的，不是永久的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetZNodeData</span> &#123;<br><span class="hljs-keyword">private</span> ZooKeeper zooKeeper;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">GetZNodeData</span><span class="hljs-params">(ZooKeeper zooKeeper)</span> &#123;<br><span class="hljs-built_in">this</span>.zooKeeper = zooKeeper;<br>&#125;<br><span class="hljs-comment">// 同步获取数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDataSync</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">Stat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stat</span>();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">byte</span>[] data = zooKeeper.getData(<span class="hljs-string">&quot;/zookeeper-api-sync&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>()&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent event)</span> &#123;<br><span class="hljs-comment">// 一旦节点发生变化，则会回调该方法</span><br>System.out.println(<span class="hljs-string">&quot;event: &quot;</span>+event);<br>&#125;<br>&#125;, stat);<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data);<br>System.out.println(<span class="hljs-string">&quot;data: &quot;</span>+s);<br>System.out.println(<span class="hljs-string">&quot;stat: &quot;</span>+stat);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><span class="hljs-comment">// 异步获取数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDataAsync</span><span class="hljs-params">()</span>&#123;<br>zooKeeper.getData(<span class="hljs-string">&quot;/zookeeper-api-async&quot;</span>,<span class="hljs-literal">false</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncCallback</span>.DataCallback() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processResult</span><span class="hljs-params">(<span class="hljs-type">int</span> rc, String path, Object ctx, <span class="hljs-type">byte</span>[] data, Stat stat)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;rc: &quot;</span>+rc);<br>System.out.println(<span class="hljs-string">&quot;path: &quot;</span>+path);<br>System.out.println(<span class="hljs-string">&quot;ctx: &quot;</span>+ctx);<br>System.out.println(<span class="hljs-string">&quot;data: &quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data));<br>System.out.println(<span class="hljs-string">&quot;stat: &quot;</span>+stat);<br>&#125;<br>&#125;,<span class="hljs-string">&quot;get-data-async&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">GetZNodeData</span> <span class="hljs-variable">getZNodeData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GetZNodeData</span>(ZkConnUtil.getZkConn(<span class="hljs-string">&quot;192.168.0.8:2181&quot;</span>));<br>getZNodeData.getDataSync();<br>getZNodeData.getDataAsync();<br>System.in.read();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-6-修改ZNode数据"><a href="#1-6-修改ZNode数据" class="headerlink" title="1.6 修改ZNode数据"></a>1.6 修改ZNode数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateZNodeData</span> &#123;<br><span class="hljs-keyword">private</span> ZooKeeper zooKeeper;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">UpdateZNodeData</span><span class="hljs-params">(ZooKeeper zooKeeper)</span> &#123;<br><span class="hljs-built_in">this</span>.zooKeeper = zooKeeper;<br>&#125;<br><span class="hljs-comment">// 同步修改节点数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDataSync</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">// 版本号为-1，表示可以直接修改，不用关心版本号</span><br>zooKeeper.setData(<span class="hljs-string">&quot;/zookeeper-api-sync&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>.getBytes(), -<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// 异步修改节点数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDataAsync</span><span class="hljs-params">()</span>&#123;<br>zooKeeper.setData(<span class="hljs-string">&quot;/zookeeper-api-async&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>.getBytes(), -<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncCallback</span>.StatCallback() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processResult</span><span class="hljs-params">(<span class="hljs-type">int</span> rc, String path, Object ctx, Stat stat)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;rc: &quot;</span>+rc);<br>System.out.println(<span class="hljs-string">&quot;path: &quot;</span>+path);<br>System.out.println(<span class="hljs-string">&quot;ctx: &quot;</span>+ctx);<br>System.out.println(<span class="hljs-string">&quot;stat: &quot;</span>+stat);<br>&#125;<br>&#125;,<span class="hljs-string">&quot;set-data-async&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 根据版本修改同步节点数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDataSyncWithVersion</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">Stat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stat</span>();<br>zooKeeper.getData(<span class="hljs-string">&quot;/zookeeper-api-sync&quot;</span>, <span class="hljs-literal">false</span>, stat);<br>zooKeeper.setData(<span class="hljs-string">&quot;/zookeeper-api-sync&quot;</span>, <span class="hljs-string">&quot;555&quot;</span>.getBytes(),<br>stat.getVersion());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">UpdateZNodeData</span> <span class="hljs-variable">updateZNodeData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateZNodeData</span>(ZkConnUtil.getZkConn(<span class="hljs-string">&quot;192.168.0.8:2181&quot;</span>));<br><span class="hljs-comment">// updateZNodeData.setDataSync();</span><br><span class="hljs-comment">// updateZNodeData.setDataAsync();</span><br>updateZNodeData.setDataSyncWithVersion();<br>System.in.read();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-7-删除ZNode"><a href="#1-7-删除ZNode" class="headerlink" title="1.7 删除ZNode"></a>1.7 删除ZNode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeleteZNode</span> &#123;<br><span class="hljs-keyword">private</span> ZooKeeper zooKeeper;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DeleteZNode</span><span class="hljs-params">(ZooKeeper zooKeeper)</span> &#123;<br><span class="hljs-built_in">this</span>.zooKeeper = zooKeeper;<br>&#125;<br><span class="hljs-comment">// 同步删除节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteZNodeSync</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>zooKeeper.delete(<span class="hljs-string">&quot;/zookeeper-api-sync&quot;</span>,-<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// 异步删除节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteZNodeAsync</span><span class="hljs-params">()</span>&#123;<br>zooKeeper.delete(<span class="hljs-string">&quot;/zookeeper-api-async&quot;</span>, -<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncCallback</span>.VoidCallback() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processResult</span><span class="hljs-params">(<span class="hljs-type">int</span> rc, String path, Object ctx)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;rc: &quot;</span>+rc);<br>System.out.println(<span class="hljs-string">&quot;path: &quot;</span>+path);<br>System.out.println(<span class="hljs-string">&quot;ctx: &quot;</span>+ctx);<br>&#125;<br>&#125;,<span class="hljs-string">&quot;delete-znode-async&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DeleteZNode</span> <span class="hljs-variable">deleteZNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeleteZNode</span>(ZkConnUtil.getZkConn(<span class="hljs-string">&quot;192.168.0.8:2181&quot;</span>));<br>deleteZNode.deleteZNodeAsync();<br>deleteZNode.deleteZNodeSync();<br>System.in.read();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Apache-Curator"><a href="#2-Apache-Curator" class="headerlink" title="2  Apache Curator"></a>2  Apache Curator</h2><p>官网：<a href="https://curator.apache.org/">https://curator.apache.org/</a></p><p>最初是由Netflix团队开发的，后来捐献给了Apache，目前是Apache的顶级项目。Curator是对Zookeeper客户端的封装，主要目的就是简化Zookeeper客户端的使用，不需要自己手动处理ConnectionLossException、NodeExistsException等异常，提供了连接重连以及watch永久注册等解决方案。</p><h3 id="2-1-引入依赖"><a href="#2-1-引入依赖" class="headerlink" title="2.1 引入依赖"></a>2.1 引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-Curator对节点的增删改查"><a href="#2-2-Curator对节点的增删改查" class="headerlink" title="2.2 Curator对节点的增删改查"></a>2.2 Curator对节点的增删改查</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CuratorApi</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">connectStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.0.8:2181&quot;</span>;<br><span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">curatorFramework</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory <span class="hljs-comment">// fluent</span><br>.builder()<br>.connectionTimeoutMs(<span class="hljs-number">20000</span>)<br>.connectString(connectStr)<br>.retryPolicy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">// 设置客户端的重试策略，每隔10秒中重试一次，最多3次</span><br>.build();<br>curatorFramework.start();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 创建节点 curator-api</span><br><span class="hljs-type">String</span> <span class="hljs-variable">znode</span> <span class="hljs-operator">=</span> curatorFramework<br>.create()<br>.withMode(CreateMode.PERSISTENT)<br>.forPath(<span class="hljs-string">&quot;/curator-api&quot;</span>, <span class="hljs-string">&quot;666&quot;</span>.getBytes());<br>System.out.println(<span class="hljs-string">&quot;创建节点成功: &quot;</span> + znode);<br><span class="hljs-comment">// 查询节点 curator-api 数据</span><br><span class="hljs-type">byte</span>[] bytes = curatorFramework.getData().forPath(znode);<br>System.out.println(<span class="hljs-string">&quot;节点curator-api 数据查询成功: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br><span class="hljs-comment">// 修改节点 curator-api 数据</span><br>curatorFramework.setData().forPath(znode, <span class="hljs-string">&quot;888&quot;</span>.getBytes());<br>System.out.println(<span class="hljs-string">&quot;节点curator-api 数据修改成功.&quot;</span>);<br><span class="hljs-comment">// 删除节点 curator-api</span><br>curatorFramework.delete().forPath(znode);<br>System.out.println(<span class="hljs-string">&quot;节点curator-api 已被删除.&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-Curator设置监听"><a href="#2-3-Curator设置监听" class="headerlink" title="2.3 Curator设置监听"></a>2.3 Curator设置监听</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CuratorWatch</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>curatorWatchPersistent();<br>&#125;<br><span class="hljs-comment">// 一次性监听</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">curatorWatchOnce</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">connectStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.0.8:2181&quot;</span>;<br><span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">curatorFramework</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory<br>.builder()<br>.connectionTimeoutMs(<span class="hljs-number">20000</span>)<br>.connectString(connectStr)<br>.retryPolicy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>.build();<br>curatorFramework.start();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 创建节点 curator-watch-once</span><br><span class="hljs-type">String</span> <span class="hljs-variable">znode</span> <span class="hljs-operator">=</span> curatorFramework.create().withMode(CreateMode.PERSISTENT).forPath(<span class="hljs-string">&quot;/curatorwatch-once&quot;</span>, <span class="hljs-string">&quot;&quot;</span>.getBytes());<br>System.out.println(<span class="hljs-string">&quot;节点创建成功: &quot;</span> + znode);<br><span class="hljs-comment">// 给节点 curator-watch-once 添加一次性watch</span><br>curatorFramework.getData().usingWatcher(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CuratorWatcher</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent event)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>System.out.println(<span class="hljs-string">&quot;节点发生变化: &quot;</span> + event);<br>&#125;<br>&#125;).forPath(znode);<br>System.out.println(<span class="hljs-string">&quot;给节点curator-watch-once 添加watch成功.&quot;</span>);<br><span class="hljs-comment">// 让当前进程不结束</span><br>System.in.read();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><span class="hljs-comment">// 永久监听</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">curatorWatchPersistent</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">connectStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.0.8:2181&quot;</span>;<br><span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">curatorFramework</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory<br>.builder()<br>.connectionTimeoutMs(<span class="hljs-number">20000</span>)<br>.connectString(connectStr)<br>.retryPolicy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>))<br>.build();<br>curatorFramework.start();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 创建节点 curator-watch-persistent</span><br><span class="hljs-type">String</span> <span class="hljs-variable">znode</span> <span class="hljs-operator">=</span> curatorFramework.create().forPath(<span class="hljs-string">&quot;/curator-watchpersistent&quot;</span>, <span class="hljs-string">&quot;&quot;</span>.getBytes());<br>System.out.println(<span class="hljs-string">&quot;节点创建成功: &quot;</span> + znode);<br><span class="hljs-comment">// 永久的监听</span><br><span class="hljs-type">CuratorCache</span> <span class="hljs-variable">curatorCache</span> <span class="hljs-operator">=</span> CuratorCache.build(curatorFramework,znode, CuratorCache.Options.SINGLE_NODE_CACHE);<br><span class="hljs-type">CuratorCacheListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> CuratorCacheListener.builder().forAll(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CuratorCacheListener</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">event</span><span class="hljs-params">(Type type, ChildData oldData, ChildData data)</span>&#123;<br><span class="hljs-comment">// 等同于Watch#process回调</span><br>System.out.println(<span class="hljs-string">&quot;节点 &quot;</span>+data.getPath()+<span class="hljs-string">&quot; 发生改变, 事件类型为: &quot;</span> + type);<br>&#125;<br>&#125;).build();<br>curatorCache.listenable().addListener(listener);<br>curatorCache.start();<br>System.out.println(<span class="hljs-string">&quot;给节点curator-watch-persistent 添加watch成功.&quot;</span>);<br><span class="hljs-comment">// 让当前进程不结束</span><br>System.in.read();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper高级特性</title>
    <link href="/2023/05/16/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <url>/2023/05/16/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Watch"><a href="#1-Watch" class="headerlink" title="1 Watch"></a>1 Watch</h2><p><a href="https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#ch_zkWatches">https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#ch_zkWatches</a></p><p>图解：</p><p><img src="/image/zookeeper/4.png"></p><p>支持watch的命令</p><blockquote><p>watch的注册基本上都是读事件</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">help</span><br>config [-c] [-w] [-s]<br>get [-s] [-w] path<br><span class="hljs-built_in">ls</span> [-s] [-w] [-R] path<br><span class="hljs-built_in">stat</span> [-w] path<br></code></pre></td></tr></table></figure><h3 id="1-1-watch体验"><a href="#1-1-watch体验" class="headerlink" title="1.1 watch体验"></a>1.1 watch体验</h3><blockquote><p>分类： </p><p>get stat 监听节点数据的变化 </p><p>ls (-R) 针对(子)节点的变化</p></blockquote><h4 id="1-1-1-监听节点数据变化"><a href="#1-1-1-监听节点数据变化" class="headerlink" title="1.1.1 监听节点数据变化"></a>1.1.1 监听节点数据变化</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建节点并添加监听</span><br>create /zk-watch 111<br>get -w /zk-watch<br><span class="hljs-comment"># 来到另外一个客户端</span><br><span class="hljs-built_in">set</span> /zk-watch 222<br><br><span class="hljs-comment"># 观察第一个zkClient的变化，发现收到通知</span><br><span class="hljs-comment">#WATCHER::</span><br><span class="hljs-comment">#WatchedEvent state:SyncConnected type:NodeDataChanged path:/zk-watch</span><br><br><span class="hljs-comment"># 收到watch通知之后，就可以进行对应的业务逻辑处理。但如果再修改/zk-watch的值，发现就不会收到watch通知了，因为该命令下的watch通知是一次性的，要想再收到，得继续添加watch监听</span><br>get -w /zk-watch<br></code></pre></td></tr></table></figure><h4 id="1-1-2-监听-子-节点的创建和删除"><a href="#1-1-2-监听-子-节点的创建和删除" class="headerlink" title="1.1.2 监听(子)节点的创建和删除"></a>1.1.2 监听(子)节点的创建和删除</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建子节点并对父节点添加watch</span><br>create /zk-watch/sub1<br>get -w /zk-watch<br><span class="hljs-comment"># 修改/zk-watch/sub1节点的数据值，发现watch并没有生效，因为get只监听单个节点</span><br><span class="hljs-built_in">set</span> /zk-watch/sub1 111<br><span class="hljs-comment"># 通过ls添加对(子)节点的增加和删除监听</span><br><span class="hljs-built_in">ls</span> -w /zk-watch<br>create /zk-watch/sub2 111<br><span class="hljs-comment"># 继续添加zk-watch节点的子节点，发现并没有收到通知，因为ls也是一次性的</span><br>create /zk-watch/sub3 111<br></code></pre></td></tr></table></figure><h4 id="1-1-3-永久监听"><a href="#1-1-3-永久监听" class="headerlink" title="1.1.3 永久监听"></a>1.1.3 永久监听</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">create /zk-watch-update 666<br>addWatch /zk-watch-update<br><span class="hljs-built_in">set</span> /zk-watch-update 999<br><span class="hljs-built_in">set</span> /zk-watch-update 888<br>create /zk-watch-update/sub1<br>create /zk-watch-update/sub2<br>delete /zk-watch-update/sub1<br><span class="hljs-built_in">set</span> /zk-watch-update/sub2 222<br>create /zk-watch-update/sub2/sub1 111<br>delete /zk-watch-update/sub2/sub1<br>delete /zk-watch-update/sub2<br>delete /zk-watch-update<br></code></pre></td></tr></table></figure><h2 id="2-Monitoring-监控"><a href="#2-Monitoring-监控" class="headerlink" title="2  Monitoring-监控"></a>2  Monitoring-监控</h2><h3 id="2-1-The-Four-Letter-Words"><a href="#2-1-The-Four-Letter-Words" class="headerlink" title="2.1 The Four Letter Words"></a>2.1 The Four Letter Words</h3><p><a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_4lw">https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_4lw</a></p><p>ZooKeeper响应一小组命令。每个命令由四个字母组成。您可以通过客户端端口的 telnet 或 nc 向 ZooKeeper 发出命令。说白了就是由4个字母组成的命令，可以通过telnet或ncat使用客户端向zkServere发出命令。</p><ol><li>修改zoo.cfg文件</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">（1）打开zoo.cfg文件</span><br><span class="hljs-attr">（2）添加一行配置</span>:<span class="hljs-string"></span><br><span class="hljs-attr">4lw.commands.whitelist</span>=<span class="hljs-string">*</span><br><span class="hljs-attr">echo</span> <span class="hljs-string">&quot;4lw.commands.whitelist=*&quot; &gt;&gt; zoo.cfg</span><br><span class="hljs-attr">（3）重启zk服务</span><br><span class="hljs-attr">zkServer.sh</span> <span class="hljs-string">restart</span><br></code></pre></td></tr></table></figure><ol start="2"><li>体验一下</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh">（1）安装ncat: yum install -y nc<br>（2）查看节点是否正常<br><span class="hljs-built_in">echo</span> ruok | ncat localhost 2181<br>（3）查看节点相关配置<br><span class="hljs-built_in">echo</span> conf | ncat localhost 2181<br>（4）查看节点更详细的状态<br><span class="hljs-built_in">echo</span> <span class="hljs-built_in">stat</span> | ncat localhost 2181<br>（5）查看节点更详细的状态<br><span class="hljs-built_in">echo</span> srvr | ncat localhost 2181<br>（6）查看临时节点<br><span class="hljs-built_in">echo</span> dump| ncat localhost 2181<br>（7）查看watch<br>get -w /zk-watch<br><span class="hljs-built_in">echo</span> wchc| ncat localhost 2181<br>（8）查看server的<span class="hljs-built_in">env</span><br><span class="hljs-built_in">echo</span> envi| ncat localhost 2181<br></code></pre></td></tr></table></figure><h3 id="2-2-AdminServer"><a href="#2-2-AdminServer" class="headerlink" title="2.2 AdminServer"></a>2.2 AdminServer</h3><p><a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_adminserver">https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_adminserver</a></p><p><strong>3.5.0 中的新功能：</strong>管理服务器是一个嵌入式 Jetty 服务器，为四个字母的单词命令提供 HTTP 接口。默认情况下，服务器在端口 8080 上启动，并通过转到 URL “/command/[命令名称]”（例如 <a href="http://localhost:8080/commands/stat%EF%BC%89%E5%8F%91%E5%87%BA%E5%91%BD%E4%BB%A4%E3%80%82%E5%91%BD%E4%BB%A4%E5%93%8D%E5%BA%94%E4%BB%A5">http://localhost:8080/commands/stat）发出命令。命令响应以</a> JSON 形式返回。与原始协议不同，命令不限于四个字母的名称，命令可以有多个名称;例如，“STMK”也可以称为“set_trace_mask”。要查看所有可用命令的列表，请将浏览器指向 URL /command（例如，<a href="http://localhost:8080/commands%EF%BC%89">http://localhost:8080/commands）</a></p><h3 id="2-3-JMX-Java-Management-Extensions"><a href="#2-3-JMX-Java-Management-Extensions" class="headerlink" title="2.3 JMX(Java Management Extensions)"></a>2.3 JMX(Java Management Extensions)</h3><p>（1）zkServer.sh中配置JMX</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">ZOOMAIN=<span class="hljs-string">&quot;-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8888</span><br><span class="hljs-string">-Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false</span><br><span class="hljs-string">-Djava.rmi.server.hostname=192.168.0.8</span><br><span class="hljs-string">-Dcom.sun.management.jmxremote.local.only=false</span><br><span class="hljs-string">org.apache.zookeeper.server.quorum.QuorumPeerMain&quot;</span><br></code></pre></td></tr></table></figure><p>（2）重启zkServer</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">zkServer.sh restart<br></code></pre></td></tr></table></figure><p>（3）查看8888端口监听</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">lsof -i:8888 <br></code></pre></td></tr></table></figure><p>（4）打开本地jconsole，连接指定JMX的ip和port：192.168.0.8:8888</p><p><img src="/image/zookeeper/5.png"></p><h2 id="3-ACL-权限"><a href="#3-ACL-权限" class="headerlink" title="3 ACL-权限"></a>3 ACL-权限</h2><p><a href="https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#sc_ZooKeeperAccessControl">https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#sc_ZooKeeperAccessControl</a></p><h3 id="3-1-ACL的组成"><a href="#3-1-ACL的组成" class="headerlink" title="3.1 ACL的组成"></a>3.1 ACL的组成</h3><p>scheme : id : permission </p><ol><li><strong>scheme：表示策略</strong> </li></ol><p>（1）world 该scheme只有一个id，为anyone，表示所有人，格式为 world:anyone:permission </p><p>（2）auth 该scheme表示需要认证登录，也就是对应注册的用户需拥有权限才可以访问，格式为 auth:user:password:permission </p><p>（3）digest 该scheme表示需要密码加密才能访问，格式为 digest:username:BASE64(password):permission</p><p>（4）ip 该scheme表示指定的ip才能访问，格式为 ip:localhost:permission </p><p>（5）super 该scheme表示超管，拥有所有权限</p><ol start="2"><li><p><strong>id：表示允许访问的用户</strong> </p></li><li><p><strong>permission：表示访问的权限</strong></p></li></ol><p>（1）CREATE: you can create a child node </p><p>（2）READ: you can get data from a node and list its children. </p><p>（3）WRITE: you can set data for a node </p><p>（4）DELETE: you can delete a child node </p><p>（5）ADMIN: you can set permissions</p><h3 id="3-2-ACL体验"><a href="#3-2-ACL体验" class="headerlink" title="3.2 ACL体验"></a>3.2 ACL体验</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建节点并查看权限</span><br>create /zk-acl 111<br>getAcl /zk-acl<br><span class="hljs-comment"># 设置某个用户对某个节点的权限</span><br>create /zk-jack 666<br>setAcl /zk-jack auth:jack:123:cdrwa<br><span class="hljs-comment"># 表示该用户还没有在zk中注册，注册一下</span><br>addauth digest jack:123<br>setAcl /zk-jack auth:jack:123:cdrwa<br>getAcl /zk-jack<br><span class="hljs-comment"># 这样一来，对于/zk-jack节点的操作，就需要先登录一下，打开另外一个客户端，执行如下命令，提示:Insufficient permission : /zk-jack</span><br><span class="hljs-built_in">ls</span> /zk-jack<br>get /zk-jack<br><span class="hljs-comment"># 授权</span><br>addauth digest jack:123<br>get /zk-jack<br></code></pre></td></tr></table></figure><h2 id="4-序列化与反序列化"><a href="#4-序列化与反序列化" class="headerlink" title="4 序列化与反序列化"></a>4 序列化与反序列化</h2><p>常见的序列化方式：json、protobuf、thrif、avro等。Zookeeper使用的序列化方式是jute，Java类需要实现Record接口，底层使用的是DataOutput和 DataInput。</p><p>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）定义Java类并测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Record</span>&#123;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(OutputArchive archive, String tag)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        archive.startRecord(<span class="hljs-built_in">this</span>, tag);<br>        archive.writeString(username, <span class="hljs-string">&quot;username&quot;</span>);<br>        archive.writeInt(age, <span class="hljs-string">&quot;age&quot;</span>);<br>        archive.endRecord(<span class="hljs-built_in">this</span>, tag);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(InputArchive archive, String tag)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        archive.startRecord(tag);<br>        username = archive.readString(<span class="hljs-string">&quot;username&quot;</span>);<br>        age = archive.readInt(<span class="hljs-string">&quot;age&quot;</span>);<br>        archive.endRecord(tag);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//序列化</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">BinaryOutputArchive</span> <span class="hljs-variable">binaryOutputArchive</span> <span class="hljs-operator">=</span> BinaryOutputArchive.getArchive(byteArrayOutputStream);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">16</span>).serialize(binaryOutputArchive, <span class="hljs-string">&quot;person&quot;</span>);<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(byteArrayOutputStream.toByteArray());<br>        <span class="hljs-comment">// 反序列化</span><br><span class="hljs-type">ByteBufferInputStream</span> <span class="hljs-variable">byteBufferInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteBufferInputStream</span>(byteBuffer);<br><span class="hljs-type">BinaryInputArchive</span> <span class="hljs-variable">binaryInputArchive</span> <span class="hljs-operator">=</span> BinaryInputArchive.getArchive(byteBufferInputStream);<br><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person.deserialize(binaryInputArchive, <span class="hljs-string">&quot;person&quot;</span>);<br>System.out.println(person.toString());<br><span class="hljs-comment">// 关闭资源</span><br>byteArrayOutputStream.close();<br>byteBufferInputStream.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-快照数据与事务日志"><a href="#5-快照数据与事务日志" class="headerlink" title="5 快照数据与事务日志"></a>5 快照数据与事务日志</h2><p>快照数据：记录所有ZNode节点及数据某一时刻的快照，保存在zoo.cfg文件配置项的dataDir目录的 version-2中，格式为snapshot.zxid 事务日志：记录每一次事务操作的记录，保存在dataLogDir[dataDir]目录的version-2中，格式为 log.zxid</p><p>数据与日志里都是二进制数据，不能直接打开，需要使用以下工具：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">zkSnapShotToolkit.sh snapshot.zxid<br>zkTxnLogToolkit.sh log.zxid<br></code></pre></td></tr></table></figure><h3 id="5-1-zkServer第一次启动"><a href="#5-1-zkServer第一次启动" class="headerlink" title="5.1 zkServer第一次启动"></a>5.1 zkServer第一次启动</h3><p>zkServer第一次启动时，因为此时zxid的值为0，会生成一个snapshot.0的数据快照文件，对应的源码是FileTnxSnapLog#save方法。</p><p>文件的大小不会进行预分配，而是取决于内存DataTree的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">snapLog.serialize(dataTree, sessionsWithTimeouts, snapshotFile, syncSnap);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">SnapshotInfo</span>(Util.getZxidFromName(snapShot.getName(), SNAPSHOT_FILE_PREFIX),snapShot.lastModified() / <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p>查看快照日志文件内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">zkSnapShotToolkit.sh snapshot.0<br></code></pre></td></tr></table></figure><h3 id="5-2-第一次创建事务日志文件"><a href="#5-2-第一次创建事务日志文件" class="headerlink" title="5.2 第一次创建事务日志文件"></a>5.2 第一次创建事务日志文件</h3><p>使用客户端连接zk server时，也是事务事件，会生成了一个log.1的事务日志文件，对应的源码是 FileTxnLog#append方法。</p><p>文件的大小会进行预分配，也就是FilePadding#preAllocaSize = 65536 * 1024 Byte = 64M 也就是说每个事务日志文件的默认大小是64M，可以直接在windows中查看文件。如果事务日志文件的空间剩余不足4KB，则会再次预分配64M的磁盘空间。从这里可以看出，快照文件和日志文件最好不要放在一起，防止文件句柄数的频繁打开。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">zkTxnLogToolkit.sh log.1<br></code></pre></td></tr></table></figure><h3 id="5-3-新建数据快照文件和事务日志文件"><a href="#5-3-新建数据快照文件和事务日志文件" class="headerlink" title="5.3 新建数据快照文件和事务日志文件"></a>5.3 新建数据快照文件和事务日志文件</h3><p>每进行一次事务操作，事务日志中都会增加一条记录，当经过snapCount(默认100000)的过半随机次数(即在5万到10万之间)的事务写入之后，就会触发一次快照数据文件生成，同时也会新生成一个事务日志文件。</p><p>注意：每一次重新启动zk server，如果之前有zxid的变化，则也会创建一个新的快照数据文件，同时在后续的事务操作中，也会新建一个新的事务日志文件。</p><p>具体源码见SyncRequestProcessor#shouldSnapshot()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldSnapshot</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">logCount</span> <span class="hljs-operator">=</span> zks.getZKDatabase().getTxnCount();<br><span class="hljs-type">long</span> <span class="hljs-variable">logSize</span> <span class="hljs-operator">=</span> zks.getZKDatabase().getTxnSize();<br><span class="hljs-keyword">return</span> (logCount &gt; (snapCount / <span class="hljs-number">2</span> + randRoll)) <br>        || (snapSizeInBytes &gt; <span class="hljs-number">0</span> &amp;&amp; logSize &gt; (snapSizeInBytes / <span class="hljs-number">2</span> + randSize));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-数据快照文件和事务日志文件的清理"><a href="#5-4-数据快照文件和事务日志文件的清理" class="headerlink" title="5.4 数据快照文件和事务日志文件的清理"></a>5.4 数据快照文件和事务日志文件的清理</h3><blockquote><p>QuorumPeerConfig</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">purgeInterval</span>=<span class="hljs-string">0   #触发自动清理的时间间隔，单位是小时，默认值为0，表示不开启自动清理的功能</span><br><span class="hljs-attr">snapRetainCount</span>=<span class="hljs-string">3   #自动清理保留3个事务日志和快照数据</span><br></code></pre></td></tr></table></figure><h3 id="5-5-总结"><a href="#5-5-总结" class="headerlink" title="5.5 总结"></a>5.5 总结</h3><p>针对每一次事务操作，都会将其保存到事务日志文件中，同时会将数据的变化应用到内存DataTree中。当经过了一定次数的事务操作后，则会将内存DataTree中的全量数据保存到数据快照文件中。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper初识</title>
    <link href="/2023/05/15/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E5%88%9D%E8%AF%86/"/>
    <url>/2023/05/15/%E4%B8%AD%E9%97%B4%E4%BB%B6/zookeeper/Zookeeper%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>官网：<a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a></p><h2 id="1-Zookeeper环境安装"><a href="#1-Zookeeper环境安装" class="headerlink" title="1 Zookeeper环境安装"></a>1 Zookeeper环境安装</h2><h3 id="1-1-服务端安装启动"><a href="#1-1-服务端安装启动" class="headerlink" title="1.1 服务端安装启动"></a>1.1 服务端安装启动</h3><h4 id="1-1-1-centos"><a href="#1-1-1-centos" class="headerlink" title="1.1.1 centos"></a>1.1.1 centos</h4><ol><li>前置环境</li></ol><p>Java8    Maven</p><ol start="2"><li>下载Zookeeper：3.7.1</li></ol><p><a href="https://zookeeper.apache.org/releases.html">https://zookeeper.apache.org/releases.html</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">wget https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.7.1/apache-zookeeper-3.7.1-bin.tar.gz<br></code></pre></td></tr></table></figure><ol start="3"><li>解压</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xvf apache-zookeeper-3.7.1-bin.tar.gz<br></code></pre></td></tr></table></figure><ol start="4"><li>进入conf目录并拷贝zoo_sample.cfg，因为启动的时候会默认使用conf/zoo.cfg文 件，当然也可以指定启动文件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cp</span> zoo_sample.cfg zoo.cfg<br></code></pre></td></tr></table></figure><ol start="5"><li>修改配置文件conf/zoo.cfg，比如修改dataDir、dataLogDir和clientPort等，当然如果不额外指定dataLogDir，则事务日志文件也会存储到dataDir中。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> -p /usr/local/zookeeper/apache-zookeeper-3.7.1-bin/data<br></code></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">tickTime</span>=<span class="hljs-string">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-string">10syncLimit=5</span><br><span class="hljs-attr">dataDir</span>=<span class="hljs-string">/usr/local/zookeeper/apache-zookeeper-3.7.1-bin/data</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-string">2181</span><br></code></pre></td></tr></table></figure><ol start="6"><li>根据自己的需求选择是否配置zk的环境变量，也就是在任意目录之下可以使用bin中的命令</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim /etc/profile<br><span class="hljs-comment"># 文件末尾增加如下配置</span><br><span class="hljs-built_in">export</span> ZOOKEEPER_HOME=/usr/local/zookeeper/apache-zookeeper-3.7.1-bin<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$ZOOKEEPER_HOME</span>/bin<br><br><span class="hljs-comment"># 让profile文件生效</span><br><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><ol start="7"><li>启动与停止zkServer</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">zkServer.sh start <span class="hljs-comment"># 启动</span><br>zkServer.sh start-foreground <span class="hljs-comment"># 前端启动</span><br>zkServer.sh status <span class="hljs-comment"># 查看状态</span><br>zkServer.sh stop <span class="hljs-comment"># 停止</span><br></code></pre></td></tr></table></figure><h4 id="1-1-2-docker"><a href="#1-1-2-docker" class="headerlink" title="1.1.2 docker"></a>1.1.2 docker</h4><ol><li><a href="https://hub.docker.com/">https://hub.docker.com/</a></li><li>搜索zookeeper镜像，版本选择: 3.7.1</li><li>拉取镜像</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull zookeeper:3.7.1<br></code></pre></td></tr></table></figure><ol start="4"><li>运行zookeeper container</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d --name test-zk-server -p 2281:2182 zookeeper:3.7.1<br></code></pre></td></tr></table></figure><h4 id="1-1-3-源码"><a href="#1-1-3-源码" class="headerlink" title="1.1.3 源码"></a>1.1.3 源码</h4><ol><li>下载源码：<a href="https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.7.1/apache-zookeeper-3.7.1.tar.gz">https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.7.1/apache-zookeeper-3.7.1.tar.gz</a></li><li>maven构建：在源码根目录下执行如下命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mvn clean install ‐‐DskipTests<br></code></pre></td></tr></table></figure><ol start="3"><li>导入到idea中</li><li>创建zoo.cfg文件并配置，和centos配置方式一样</li><li>寻找启动类</li></ol><blockquote><p>bin/zkServer.cmd 或 bin/zkServer.sh，也就是服务端启动的时候，会通过QuorumPeerMain进行启动</p><p>ZOOMAIN=org.apache.zookeeper.server.quorum.QuorumPeerMain</p></blockquote><ol start="6"><li>配置启动类</li></ol><p><img src="/image/zookeeper/1.png"></p><ol start="7"><li>日志输出</li></ol><p>​    a- 将conf文件下的log.properties文件复制到zookeeper-server的resources文件夹下 </p><p>​    b- 在zookeeper-server的pom.xml中添加slf4j的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">denpendency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">denpendency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="8"><li>动zk server-standalone</li></ol><h3 id="1-2-客户端安装启动"><a href="#1-2-客户端安装启动" class="headerlink" title="1.2 客户端安装启动"></a>1.2 客户端安装启动</h3><h4 id="1-2-1-centos"><a href="#1-2-1-centos" class="headerlink" title="1.2.1 centos"></a>1.2.1 centos</h4><blockquote><p>通过zkCli.sh连接</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">zkCli.sh <span class="hljs-comment"># 默认连接本机的2181端口</span><br>zkCli.sh -server 127.0.0.1:2181 <span class="hljs-comment"># 指定zk server</span><br></code></pre></td></tr></table></figure><h4 id="1-2-2-源码"><a href="#1-2-2-源码" class="headerlink" title="1.2.2 源码"></a>1.2.2 源码</h4><blockquote><p>找到zkCli.cmd，发现客户端是通过ZookeeperMain运行的</p></blockquote><p><img src="/image/zookeeper/2.png"></p><h4 id="1-2-3-prettyZoo"><a href="#1-2-3-prettyZoo" class="headerlink" title="1.2.3 prettyZoo"></a>1.2.3 prettyZoo</h4><p><a href="https://github.com/vran-dev/PrettyZoo/releases">https://github.com/vran-dev/PrettyZoo/releases</a></p><h4 id="1-2-3-web图形化界面zkui"><a href="#1-2-3-web图形化界面zkui" class="headerlink" title="1.2.3 web图形化界面zkui"></a>1.2.3 web图形化界面zkui</h4><p><a href="https://github.com/DeemOpen/zkui">https://github.com/DeemOpen/zkui</a></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>来到zk-server所在机器<br><span class="hljs-symbol">2 </span>下载源码：git clone https://github.<span class="hljs-keyword">com</span>/DeemOpen/zkui<br><span class="hljs-symbol">3 </span>mvn clean install<br><span class="hljs-symbol">4 </span>复制config.cfg到jar包所在目录: target<br><span class="hljs-symbol">5 </span>打开配置文件，配置zkServer=zkServer=<span class="hljs-number">192.168</span>.<span class="hljs-number">0.8</span>:<span class="hljs-number">2181</span><br><span class="hljs-symbol">6 </span>zkui默认端口在<span class="hljs-number">9090</span>: serverPort=<span class="hljs-number">9090</span><br><span class="hljs-symbol">7 </span>运行jar包: java -jar zkui-<span class="hljs-number">2.0</span>-SNAPSHOT-jar-with-dependencies.jar<br><span class="hljs-symbol">8 </span>访问地址: localhost:<span class="hljs-number">9090</span><br><span class="hljs-symbol">9 </span>默认用户名密码：admin manager，可以通过userSet修改<br></code></pre></td></tr></table></figure><h2 id="2-Zookeeper-Sessions"><a href="#2-Zookeeper-Sessions" class="headerlink" title="2 Zookeeper Sessions"></a>2 Zookeeper Sessions</h2><p><a href="https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#ch_zkSessions">https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#ch_zkSessions</a></p><p>可以通过zkCli.sh 查看session相关信息，比如sessionTimeout=30000毫秒、seession id=0x10000314a5a0002 </p><p>Zookeeper连接是TCP长连接，超时时间指的是客户端和服务端因为一些原因断开了连接，如果在超时时间内能够重新连接上，则会话依然有效。</p><h2 id="3-数据模型与基本操作"><a href="#3-数据模型与基本操作" class="headerlink" title="3  数据模型与基本操作"></a>3  数据模型与基本操作</h2><h3 id="3-1-数据模型"><a href="#3-1-数据模型" class="headerlink" title="3.1 数据模型"></a>3.1 数据模型</h3><p><a href="https://zookeeper.apache.org/doc/current/zookeeperOver.html#sc_dataModelNameSpace">https://zookeeper.apache.org/doc/current/zookeeperOver.html#sc_dataModelNameSpace</a></p><p><img src="/image/zookeeper/3.png"></p><h3 id="3-2-基本操作"><a href="#3-2-基本操作" class="headerlink" title="3.2 基本操作"></a>3.2 基本操作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看帮助</span><br><span class="hljs-built_in">help</span><br><br><span class="hljs-comment"># 创建节点</span><br>create /gupao<br>create /gupao/jack<br>create /gupao/james<br><br><span class="hljs-comment"># 创建节点并往节点上存数据</span><br>create /gupao/jack/age 17<br>create /gupao/jack/hobby coding<br><br><span class="hljs-comment"># 获取ZNode</span><br><span class="hljs-built_in">ls</span> /<br><span class="hljs-built_in">ls</span> /gupao<br><span class="hljs-built_in">ls</span> -R /gupao<br><br><span class="hljs-comment"># 查询某个 查询某个ZNode ZNode数据数据</span><br>get /gupao/jack<br>get /gupao/jack/age<br>get /gupao/jack/hobby<br><br><span class="hljs-comment"># 修改ZNode的值</span><br><span class="hljs-built_in">set</span> /gupao/jack/age 16<br>get /gupao/jack/age<br><br><span class="hljs-comment"># 删除节点，当某个节点下存在子节点时，不能直接删除该节点</span><br>delete /gupao/jack/age<br><span class="hljs-built_in">ls</span> -R /<br>deleteall /gupao<br><span class="hljs-built_in">ls</span> -R /<br></code></pre></td></tr></table></figure><h3 id="3-3-节点状态"><a href="#3-3-节点状态" class="headerlink" title="3.3  节点状态"></a>3.3  节点状态</h3><p><a href="https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#sc_zkStatStructure">https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#sc_zkStatStructure</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查询节点状态信息 查询节点状态信息((详情详情)) 总共11个</span><br><span class="hljs-built_in">stat</span> /gupao<br>get -s /gupao<br></code></pre></td></tr></table></figure><h4 id="3-3-1-基本"><a href="#3-3-1-基本" class="headerlink" title="3.3.1 基本"></a>3.3.1 基本</h4><p>（1）numChildren：当前节点子节点的数量 </p><p>（2）dataLength：当前节点保存的数据长度 </p><p>（3）ephemeralOwner：当前节点是否为临时节点，如果为临时节点则该值为 sessionid，否则为0</p><h4 id="3-3-2-时间相关"><a href="#3-3-2-时间相关" class="headerlink" title="3.3.2 时间相关"></a>3.3.2 时间相关</h4><p>（1）ctime：当前节点比创建的时间。比如ctime = Thu Jul 21 22:00:07 UTC 2022 </p><p>（2）mtime：当前节点最后一次被修改的时间。比如mtime = Thu Jul 21 22:08:47 UTC 2022</p><h4 id="3-3-3-版本相关"><a href="#3-3-3-版本相关" class="headerlink" title="3.3.3 版本相关"></a>3.3.3 版本相关</h4><p>（1）dataVersion：当前节点的数据被修改的次数，也就是数据的版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">set</span> -v 2 /gupao 888<br><span class="hljs-built_in">set</span> -v 1 /gupao 888<br><br><span class="hljs-built_in">stat</span> /gupao<br></code></pre></td></tr></table></figure><p>（2）cversion：子节点的版本号，是节点的版本，不是数据的版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">reate /gupao/test1<br><span class="hljs-built_in">stat</span> /gupao<br>create /gupao/test2<br><span class="hljs-built_in">stat</span> /gupao<br></code></pre></td></tr></table></figure><p>（3）aversion：acl的版本号</p><h4 id="3-3-4-zxid"><a href="#3-3-4-zxid" class="headerlink" title="3.3.4  zxid"></a>3.3.4  zxid</h4><p><a href="https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#sc_timeInZk">https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#sc_timeInZk</a></p><p>zxid是事务编号，8字节的整型数，即64个比特位，前32位标识epoch，后32位用来计数。</p><p>zxid的初始值为0，每一次事务请求都会把后面32位的值+1，比如进行了10次事务请求，则zxid变为 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00001010，每进行一次leader选举，前32位的值就会+1，并把后面的32位清零，则zxid变为 00000000 00000000 00000000 00000001 00000000 00000000 00000000 00000000，若一直没有进行leader选举，同时一直在发生事务请求，则后面32位会一直增加，极限值是00000000 00000000 00000000 00000000 11111111 11111111 11111111 11111111，此时再发生事务请求，则把前面的32位+1，变成00000000 00000000 00000000 00000001 00000000 00000000 00000000 00000000 </p><p>（1）czxid：表示当前节点被创建时的事务id </p><p>（2）mzxid：表示当前节点被最后一次更新时的事务id </p><p>（3）pzxid：表示该节点的子节点最后一次被修改时的事务id。只有子节点变化才会影响 pzxid，子节点的数据变化不会影响pzxid</p><h2 id="4-节点特性"><a href="#4-节点特性" class="headerlink" title="4 节点特性"></a>4 节点特性</h2><p>查看create命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">[zk: localhost:2181(CONNECTED) 22] create<br>create [-s] [-e] [-c] [-t ttl] path [data] [acl]<br></code></pre></td></tr></table></figure><h3 id="4-1-持久节点PERSISTENT"><a href="#4-1-持久节点PERSISTENT" class="headerlink" title="4.1  持久节点PERSISTENT"></a>4.1  持久节点PERSISTENT</h3><blockquote><p>创建节点默认是持久节点，不会因为客户端宕机而删除节点</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">create /jack 666<br><span class="hljs-built_in">stat</span> /jack jack <span class="hljs-comment">## ephemeralOwner ephemeralOwner = 0x0</span><br>quit<br>zkCli.sh<br><span class="hljs-built_in">ls</span> /<br></code></pre></td></tr></table></figure><h3 id="4-2-临时节点EPHEMERAL"><a href="#4-2-临时节点EPHEMERAL" class="headerlink" title="4.2  临时节点EPHEMERAL"></a>4.2  临时节点EPHEMERAL</h3><blockquote><p>会因为客户端宕机而删除节点</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">create -e /test 111<br><span class="hljs-built_in">stat</span> /test <span class="hljs-built_in">test</span> <span class="hljs-comment">## ephemeralOwner ephemeralOwner = 0x100000aa4c70002 sessionid</span><br>quit<br>zkCli.sh<br><span class="hljs-built_in">ls</span> /<br></code></pre></td></tr></table></figure><h3 id="4-3-有序节点SEQUENTIAL"><a href="#4-3-有序节点SEQUENTIAL" class="headerlink" title="4.3 有序节点SEQUENTIAL"></a>4.3 有序节点SEQUENTIAL</h3><blockquote><p>会给节点名称添加一个自增的序号</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#  持久有序节点</span><br>create -s /order<br>create -s /order<br>create -s /order<br><span class="hljs-comment"># 临时有序节点</span><br>create -s -e /product<br>create -s -e /product<br>create -s -e /product<br></code></pre></td></tr></table></figure><h3 id="4-4-容器节点"><a href="#4-4-容器节点" class="headerlink" title="4.4 容器节点"></a>4.4 容器节点</h3><p><a href="https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#Container+Nodes">https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#Container+Nodes</a></p><blockquote><p>3.6.0后新加的节点类型，当一个节点下的子节点都被删除后，这个容器节点也会自动删除</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">create -c /jack-container<br>create /jack-container/sub1<br>create /jack-container/sub2<br><span class="hljs-built_in">ls</span> -R /jack-container<br><br>delete /jack-container/sub1<br>delete /jack-container/sub2<br><br><span class="hljs-comment"># 等待一段时间之后，查看节点是否存在</span><br></code></pre></td></tr></table></figure><h3 id="4-5-TTL节点"><a href="#4-5-TTL节点" class="headerlink" title="4.5  TTL节点"></a>4.5  TTL节点</h3><p><a href="https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#TTL+Nodes">https://zookeeper.apache.org/doc/current/zookeeperProgrammers.html#TTL+Nodes</a></p><blockquote><p>3.6.0后新加的节点类型，可以给持久节点设置一个超时时间，需要在配置文件中添加配置：</p><p>zookeeper.extendedTypesEnabled=true      重启服务</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">reate -t 10 /zk-ttl 111<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB高级应用</title>
    <link href="/2023/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    <url>/2023/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-复制集"><a href="#1-复制集" class="headerlink" title="1 复制集"></a>1 复制集</h2><h3 id="1-1-复制集机制与原理"><a href="#1-1-复制集机制与原理" class="headerlink" title="1.1 复制集机制与原理"></a>1.1 复制集机制与原理</h3><h4 id="1-1-1-复制集作用"><a href="#1-1-1-复制集作用" class="headerlink" title="1.1.1 复制集作用"></a>1.1.1 复制集作用</h4><ol><li><p>MongoDB 复制集的主要意义在于实现服务高可用 </p></li><li><p>它的实现依赖于两个方面的功能： </p></li></ol><p>​        • 数据写入时将数据迅速复制到另一个独立节点上 </p><p>​        • 在接受写入的节点发生故障时自动选举出一个新的替代节点</p><ol start="3"><li><p>在实现高可用的同时，复制集实现了其他几个附加作用： </p><p> • 数据分发：将数据从一个区域复制到另一个区域，减少另一个 区域的读延迟 </p><p> • 读写分离：不同类型的压力分别在不同的节点上执行 </p><p> • 异地容灾：在数据中心故障时候快速切换到异地</p></li></ol><h4 id="1-1-2-复制集结构"><a href="#1-1-2-复制集结构" class="headerlink" title="1.1.2 复制集结构"></a>1.1.2 复制集结构</h4><p>一个典型的复制集由3个以上具有投票权的节点组成，包括：</p><p> • 一个主节点（PRIMARY）：接受写入操作和选举时投票 </p><p>• 两个（或多个）从节点（SECONDARY）：复制主节点上的新数据和选举时投票 </p><p>• 不推荐使用 Arbiter（投票节点）</p><h4 id="1-1-3-数据是如何复制的？"><a href="#1-1-3-数据是如何复制的？" class="headerlink" title="1.1.3 数据是如何复制的？"></a>1.1.3 数据是如何复制的？</h4><p>● 当一个修改操作，无论是插入、更新或删除，到达主节点时，它对数据的操作将被记录下来（经过一些必要的转换），这些记录称为 oplog。</p><p> ● 从节点通过在主节点上打开一个 tailable 游标不断获取新进入主节点的 oplog，并在自己的数据上回放，以此保持跟主节点的数据一致</p><h4 id="1-1-4-故障恢复"><a href="#1-1-4-故障恢复" class="headerlink" title="1.1.4 故障恢复"></a>1.1.4 故障恢复</h4><p>通过选举完成故障恢复：</p><p>● 具有投票权的节点之间两两互相发送心跳； ● 当5次心跳未收到时判断为节点失联； ● 如果失联的是主节点，从节点会发起选举，选出新的主节点； ● 如果失联的是从节点则不会产生新的选举；● 选举基于 RAFT一致性算法实现，选举成功的必要条件是大多数投票节点存活； ● 复制集中最多可以有50个节点，但具有投票权的节点最多7个。</p><p><strong>影响选举的因素</strong>：● 整个集群必须有大多数节点存活； ● 被选举为主节点的节点必须：能够与多数节点建立连接；具有较新的oplog；具有较高的优先级（如果有配置）</p><p><strong>常见配置选项</strong>：• 是否具有投票权（v 参数）：有则参与投票； • 优先级（priority 参数）：优先级越高的节点越优先成为主节点。优先级为0的节点无法成为主节点； • 隐藏（hidden 参数）：复制数据，但对应用不可见。隐藏节点可以具有投票仅，但优先级必须为0； • 延迟（slaveDelay 参数）：复制 n 秒之前的数据，保持与主节点的时间差。</p><h4 id="1-1-5-复制集注意事项"><a href="#1-1-5-复制集注意事项" class="headerlink" title="1.1.5 复制集注意事项"></a>1.1.5 复制集注意事项</h4><ol><li>关于硬件</li></ol><p>​    • 因为正常的复制集节点都有可能成为主节点，它们的地位是一样的，因此硬件配置上必须 一致；</p><p>​    • 为了保证节点不会同时宕机，各节点使用的硬件必须具有独立性。</p><ol start="2"><li>关于软件</li></ol><p>​    • 复制集各节点软件版本必须一致，以避免出现不可预知的问题。</p><ol start="3"><li>增加节点不会增加系统写性能！</li></ol><h3 id="1-2-搭建复制集"><a href="#1-2-搭建复制集" class="headerlink" title="1.2 搭建复制集"></a>1.2 搭建复制集</h3><ol><li>准备</li></ol><p>● 安装最新的 MongoDB 版本 </p><p>● Windows 系统请事先配置好 MongoDB 可执行文件的环境变量 </p><p>● Linux 和 Mac 系统请配置 PATH 变量 </p><p>● 确保有 10GB 以上的硬盘空间</p><ol start="2"><li>创建数据目录</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> -p /data/db&#123;1,2,3&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li> 准备配置文件</li></ol><p>复制集的每个mongod进程应该位于不同的服务器。现在在一台机器上运行3个进程，因此要为它们各自配置：</p><p>● 不同的端口。示例中将使用 28017/28018/28019</p><p>● 不同的数据目录。示例中将使用： /data/db1 /data/db2  /data/db3 </p><p>● 不同日志文件路径。示例中将使用： /data/db1/mongod.log  /data/db2/mongod.log  /data/db3/mongod.log </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># /data/db1/mongod.conf</span><br><span class="hljs-attr">systemLog:</span><br>   <span class="hljs-attr">destination:</span> <span class="hljs-string">file</span><br>   <span class="hljs-attr">path:</span> <span class="hljs-string">/data/db1/mongod.log</span> <span class="hljs-comment"># log path</span><br>   <span class="hljs-attr">logAppend:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">storage:</span><br>   <span class="hljs-attr">dbPath:</span> <span class="hljs-string">/data/db1</span> <span class="hljs-comment"># data directory</span><br><span class="hljs-attr">net:</span><br>   <span class="hljs-attr">bindIp:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>   <span class="hljs-attr">port:</span> <span class="hljs-number">28017</span> <span class="hljs-comment"># port</span><br><span class="hljs-attr">replication:</span><br>   <span class="hljs-attr">replSetName:</span> <span class="hljs-string">rs0</span><br><span class="hljs-attr">processManagement:</span><br>   <span class="hljs-attr">fork:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ol start="4"><li>启动 MongoDB 进程</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">mongod -f /data/db1/mongod.conf<br>mongod -f /data/db2/mongod.conf<br>mongod -f /data/db3/mongod.conf<br></code></pre></td></tr></table></figure><p>注意：如果启用了 SELinux，可能阻止上述进程启动。简单起见请关闭 SELinux。</p><ol start="5"><li> 配置复制集</li></ol><p><strong>方法1:</strong> 此方式hostname 需要能被解析</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># mongo --port 28017</span><br><span class="hljs-comment"># hostname -f</span><br>&gt; rs.initiate() <span class="hljs-comment"># 这个时候 SECONDARY&gt; 这个时候变成了从节点 在等几秒钟 再按一下回车就变成了PARIMARY了 可以正常负责读和写了</span><br>&gt; rs.add(”HOSTNAME:28018<span class="hljs-string">&quot;)</span><br><span class="hljs-string">&gt; rs.add(”HOSTNAME:28019&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>方法2</strong>：在主节点配置即可，无须重复配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># mongo --port 28017</span><br><span class="hljs-comment"># mongo localhost:28018</span><br>rs.initiate(&#123;<br>   _id: <span class="hljs-string">&quot;rs0&quot;</span>,<br>   members: [&#123;<br>       _id: 0,<br>       host: <span class="hljs-string">&quot;localhost:28017&quot;</span><br>   &#125;,&#123;<br>       _id: 1,<br>       host: <span class="hljs-string">&quot;localhost:28018&quot;</span><br>   &#125;,&#123;<br>       _id: 2,<br>       host: <span class="hljs-string">&quot;localhost:28019&quot;</span><br>   &#125;]<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="6"><li>验证</li></ol><p>MongoDB 主节点进行写入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># mongo localhost:28017</span><br>&gt; db.test.insert(&#123; a:1 &#125;);<br>&gt; db.test.insert(&#123; a:2 &#125;);<br></code></pre></td></tr></table></figure><p>MongoDB 从节点进行读</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># mongo localhost:28018</span><br>&gt; rs.slaveOk() <span class="hljs-comment"># secondary OK（）</span><br>&gt; db.test.find()<br><span class="hljs-comment"># --------隔一段时间</span><br>&gt; db.test.find()<br></code></pre></td></tr></table></figure><h2 id="2-事务"><a href="#2-事务" class="headerlink" title="2 事务"></a>2 事务</h2><p>mongodb的一致性需要借助writeConcern和readConcern的帮忙。</p><h3 id="2-1-写操作事务-writeConcern"><a href="#2-1-写操作事务-writeConcern" class="headerlink" title="2.1 写操作事务-writeConcern"></a>2.1 写操作事务-writeConcern</h3><p>writeConcern 决定一个写操作落到多少个节点上才算成功。</p><p> writeConcern 的取值包括： • 0：发起写操作，不关心是否成功； • 1~集群最大数据节点数：写操作需要被复制到指定节点数才算成 功； • majority：写操作需要被复制到大多数节点上才算成功。 </p><p>发起写操作的程序将阻塞到写操作到达指定的节点数为止。</p><p>journal 定义如何才算成功。取值包括： • true: 写操作落到 journal 文件中才算成功; • false: 写操作到达内存即算作成功</p><p><strong>writeConcern 实践</strong>：</p><ol><li>在复制集测试writeConcern参数</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">db.test.insert( &#123;count: 1&#125;, &#123;writeConcern: &#123;w:<span class="hljs-string">&quot;majority&quot;</span>&#125;&#125;)<br>db.test.insert( &#123;count: 1&#125;, &#123;writeConcern: &#123;w: 3 &#125;&#125;)<br>db.test.insert( &#123;count: 1&#125;, &#123;writeConcern: &#123;w: 4 &#125;&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>配置延迟节点，模拟网络延迟（复制延迟）</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">conf = rs.conf()<br>conf.members[2].slaveDelay = 5<br>conf.members[2].priority = 0<br>rs.reconfig(conf)<br></code></pre></td></tr></table></figure><ol start="3"><li>观察复制延迟下的写入，以及timeout参数</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">db.test.insert( &#123;count: 1&#125;, &#123;writeConcern: &#123;w: 3&#125;&#125;)<br>db.test.insert( &#123;count: 1&#125;, &#123;writeConcern: &#123;w: 3,wtimeout:3000 &#125;&#125;)<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong>:</p><p>• 虽然多于半数的 writeConcern 都是安全的，但通常只会设置 majority，因为这是等待写入延迟时间最短的选择； </p><p>• 不要设置 writeConcern 等于总节点数，因为一旦有一个节点故障，所有写操作都将失败； </p><p>• writeConcern 虽然会增加写操作延迟时间，但并不会显著增加集群压力，因此无论是否等待，写操作最终都会复制到所有节点上。 设置 writeConcern 只是让写操作等待复制后再返回而已； </p><p>• 应对重要数据应用 {w: “majority”}，普通数据可以应用 {w: 1} 以确保最佳性能。</p><h3 id="2-2-读操作事务-readPreference"><a href="#2-2-读操作事务-readPreference" class="headerlink" title="2.2 读操作事务-readPreference"></a>2.2 读操作事务-readPreference</h3><p>在读取数据的过程中需要关注以下两个问题： 从哪里读？ 什么样的数据可以读？ 第一个问题是是由 readPreference 来解决；第二个问题则是由 readConcern 来解决。</p><p>readPreference 决定使用哪一个节点来满足正在发起的读请求。 可选值包括： • primary: 只选择主节点； • primaryPreferred：优先选择主节点，如果不可用则选择从节点； • secondary：只选择从节点； • secondaryPreferred：优先选择从节点， 如果从节点不可用则选 择主节点； • nearest：选择最近的节点；</p><p><strong>readPreference 与 Tag</strong></p><blockquote><p>readPreFerence 是类别，Tag 是可以做分组，tag的粒度可以做得比前者细</p></blockquote><p>readPreference 只能控制使用一类节点。Tag 则可以将节点选择控制到一个或几个节点。考虑以下场景： • 一个 5 个节点的复制集； • 3 个节点硬件较好，专用于服务线上客户； • 2 个节点硬件较差，专用于生成报表； 可以使用 Tag 来达到这样的控制目的： • 为 3 个较好的节点打上 {purpose: “online”}； • 为 2 个较差的节点打上 {purpose: “analyse”}； • 在线应用读取时指定 online，报表读取时指定 reporting；</p><p><a href="https://www.mongodb.com/docs/manual/core/read-preference/">https://www.mongodb.com/docs/manual/core/read-preference/</a></p><p><strong>readPreference 配置</strong></p><p>通过 MongoDB 的连接串参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mongodb://host1:27107,host2:27107,host3:27017/?replicaSet=rs&amp;readPreference=secondary<br></code></pre></td></tr></table></figure><p>通过 MongoDB 驱动程序 API：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">MongoCollection.withReadPreference(ReadPreferencereadPref)<br></code></pre></td></tr></table></figure><p>Mongo Shell：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">db.collection.find(&#123;&#125;).readPref( “secondary” )<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong>:</p><ol><li>指定 readPreference 时也应注意高可用问题。例如将 readPreference 指定 primary，则发生故障转移不存在 primary 期间将没有节点可读。如果业务允许，则应选择 primaryPreferred； </li><li>使用 Tag 时也会遇到同样的问题，如果只有一个节点拥有一个特定 Tag，则在这个节点失效时将无节点可读。这在有时候是期望的结果，有时候不是。</li><li>如果报表使用的节点失效，即使不生成报表，通常也不希望将报表负载转移到其他节点上，此时只有一个节点有报表 Tag 是合理的选择； </li><li>如果线上节点失效，通常希望有替代节点，所以应该保持多个节点有同样的 Tag；</li><li> Tag 有时需要与优先级、选举权综合考虑。例如做报表的节点通常不会希望它成为主节点，则优先级应为 0。</li></ol><h3 id="2-3-读操作事务-readConcern"><a href="#2-3-读操作事务-readConcern" class="headerlink" title="2.3 读操作事务-readConcern"></a>2.3 读操作事务-readConcern</h3><blockquote><p>数据的隔离级别</p></blockquote><p>在 readPreference 选择了指定的节点后，readConcern 决定这个节点上的数据哪些是可读的，类似于关系数据库的隔离级别。可选值包括：</p><p>• available：读取所有可用的数据; （mongo 默认的级别） </p><p>• local：读取所有可用且属于当前分片的数据; （很少用） </p><p>• majority：读取在大多数节点上提交完成的数据; （解决脏读，达到读已提交，通过MVCC去解决的）</p><p>• linearizable：可线性化读取文档; （线性化读取） </p><p>• snapshot：读取最近快照中的数据; （解决脏读、不可重复读、 幻读，达到可重复读，通过快照去解决的）</p><h4 id="2-3-1-readConcern-local-和-available"><a href="#2-3-1-readConcern-local-和-available" class="headerlink" title="2.3.1 readConcern: local 和 available"></a>2.3.1 readConcern: local 和 available</h4><p>在复制集中 local 和 available 是没有区别的。两者的区别主要体现在分片集上。考虑以下场景：</p><p>• 一个 chunk x 正在从 shard1 向 shard2 迁移的场景下； • 整个迁移过程中 chunk x 中的部分数据会在 shard1 和 shard2 中 同时存在，但源分片 shard1仍然是 chunk x 的负责方： • 所有对 chunk x 的读写操作仍然进入 shard1； • config 中记录的信息 chunk x 仍然属于 shard1； • 此时如果读 shard2，则会体现出 local 和 available 的区别： • local：只取应该由 shard2 负责的数据（不包括 x）； • available：shard2 上有什么就读什么（包括 x）；</p><p><strong>注意事项：</strong></p><p>• 虽然看上去总是应该选择 local，但毕竟对结果集进行过滤会造成额外消耗。在一些无关紧要的场景（例如统计）下，也可以考虑 available； </p><p>• MongoDB &lt;=3.6 不支持对从节点使用 {readConcern: “local”}；</p><p> • 从主节点读取数据时默认 readConcern 是 local，从从节点读取数据时默认 readConcern 是 available（向前兼容原因）。</p><h4 id="2-3-2-readConcern-majority"><a href="#2-3-2-readConcern-majority" class="headerlink" title="2.3.2 readConcern: majority"></a>2.3.2 readConcern: majority</h4><p>只读取大多数据节点上都提交了的数据，这个时候数据的不会被回滚的是安全的。</p><p>使用 writeConcern + readConcern majority 来实现安全的读写分离。</p><h4 id="2-3-3-readConcern-linearizable"><a href="#2-3-3-readConcern-linearizable" class="headerlink" title="2.3.3 readConcern: linearizable"></a>2.3.3 readConcern: linearizable</h4><p>只读取大多数节点确认过的数据。和 majority 最大差别是保证绝对的操作线性顺序：在写操作自然时间后面的发生的读，一定可以读到之前的写；只对读取单个文档时有效； 可能导致非常慢的读，因此总是建议配合使用 maxTimeMS；</p><p>这种情况是为了解决，主节点在写入数据后宕机，数据没有同步到其他节点，其他节点成为主节点，在后面的时间节点恢复变为 Secondary,因为之前作为主节点执行写数据又与其他节点不一样的情况，这个时候希望他能读到正常的数据，而不是旧数据。</p><h4 id="2-3-4-readConcern-snapshot"><a href="#2-3-4-readConcern-snapshot" class="headerlink" title="2.3.4 readConcern: snapshot"></a>2.3.4 readConcern: snapshot</h4><p>{readConcern: “snapshot”} 只在多文档事务中生效。 将一个事务的 readConcern 设置为 snapshot，将保证在事务中的读： • 不出现脏读； • 不出现不可重复读； • 不出现幻读。 因为所有的读都将使用同一个快照，直到事务提交为止该快照才被释放。</p><h4 id="2-3-5-readConcern-小结"><a href="#2-3-5-readConcern-小结" class="headerlink" title="2.3.5 readConcern: 小结"></a>2.3.5 readConcern: 小结</h4><p>• available：读取所有可用的数据 </p><p>• local：读取所有可用且属于当前分片的数据，默认设置 </p><p>• majority：数据读一致性的充分保证，可能你最需要关注的 </p><p>• linearizable：增强处理 majority 情况下主节点失联时候的例外情况</p><p> • snapshot：最高隔离级别，接近于 Seriazable</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB入门</title>
    <link href="/2023/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%E5%85%A5%E9%97%A8/"/>
    <url>/2023/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/MongoDB%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-初始MongoDB"><a href="#1-初始MongoDB" class="headerlink" title="1 初始MongoDB"></a>1 初始MongoDB</h2><p>MongoDB是一个以JSON为数据模型的文档数据库，文档来自于”JSON Document”，并非一般理解的PDF、WORD文档。是由上市公司MongoDB Inc.开发，位于美国纽约。是一个应用数据库，非关系型数据库，即NOSQL。主要特点：建模可选，JSON数据模型比较适合开发者，横向扩展可以支持很大数据量和并发，理论无上限。MongoDB的文档指的是JSON对象，对应Java中更像是一个Object对象的概念，而不是文件的概念。</p><p>MongoDB的使用场景：电商，物联网，内容管理(Web前端)，社交，航空业，电信业等。</p><h3 id="1-1-MongoDB特点"><a href="#1-1-MongoDB特点" class="headerlink" title="1.1 MongoDB特点"></a>1.1 MongoDB特点</h3><p>数据模型不一样：MongoDB是JSON模型。</p><p>开发模式不一样：传统的数据库是需要建模的，MongoDB是不要求先建模的，可以按照程序的模型，直接把程序的数据模型直接扔到MongoDB就可以直接保存，支持数据库的操作。</p><p>面向对象的数据模型：在Java和Python中都是使用面向对象的方式开发，一般后端返回给前端的数据交互都是JSON，所以MongoDB数据库模型是直接和Java对象吻合的，JSON其实就是一种对象。</p><h3 id="1-2-MongoDB-VS-关系型数据库"><a href="#1-2-MongoDB-VS-关系型数据库" class="headerlink" title="1.2 MongoDB VS 关系型数据库"></a>1.2 MongoDB VS 关系型数据库</h3><table><thead><tr><th></th><th>MongoDB</th><th>RDBMS</th></tr></thead><tbody><tr><td>数据模型</td><td>文档类型</td><td>关系类型</td></tr><tr><td>数据库类型</td><td>OLTP</td><td>OLTP</td></tr><tr><td>CRUD操作</td><td>MQL/SQL</td><td>SQL</td></tr><tr><td>高可用</td><td>复制集</td><td>集群模式</td></tr><tr><td>横向扩展能力</td><td>通过原生分片完善支持</td><td>中间件/应用入侵式</td></tr><tr><td>索引支持</td><td>B树，全文索引，地理位置索引，多键值索引，TTL索引</td><td>B树</td></tr><tr><td>开发难度</td><td>容易</td><td>困难</td></tr><tr><td>数据容量</td><td>没有理论上限</td><td>千万、亿</td></tr><tr><td>扩展方式</td><td>垂直扩展+水平扩展</td><td>垂直扩展</td></tr></tbody></table><blockquote><p>OLTP: OLTP(Online Transaction Processing)数据库，也称交易型数据库，是能够提供实时在线处理事务时保证强一致性（ACID） 的关系型数据库。事务(Transaction)是操作数据库中数据的操作序列，要求保证ACID，即原子性(Atomicity)、 一致性 (Consistency)、隔离性(Isolation)、持久性(Durability)。</p></blockquote><p>OLTP(Online Transaction Processing)) 是用来做前端交互式应用的</p><p>OLAP(Online analytical processing) 是在线分析处理，顾名思义就是OLAP是用于数据分析的</p><h2 id="2-MongoDB优势"><a href="#2-MongoDB优势" class="headerlink" title="2 MongoDB优势"></a>2 MongoDB优势</h2><ol><li>JSON 结构和对象模型接近，开发代码量低 </li><li> JSON 的动态模型意味着更容易响应新的业务需求 </li><li>复制集提供99.999% 高可用 </li><li>分表架构支持海量数据和无缝扩容</li></ol><h2 id="3-MongoDB安装与使用"><a href="#3-MongoDB安装与使用" class="headerlink" title="3 MongoDB安装与使用"></a>3 MongoDB安装与使用</h2><h3 id="3-1-MongoDB安装"><a href="#3-1-MongoDB安装" class="headerlink" title="3.1 MongoDB安装"></a>3.1 MongoDB安装</h3><p>下载地址：<a href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a></p><p>安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> -p /data /data/db<br><span class="hljs-built_in">mkdir</span> -p /data /data/logs<br><span class="hljs-built_in">cd</span> data<br><br><span class="hljs-comment">#https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.2.24.tgz</span><br>curl -O https://fastdl.mongodb.org/linux/mongodblinux-x86_64-rhel70-4.2.24.tgz<br>tar -xvf mongodb-linux-x86_64-rhel70-4.2.24.tgz<br><br><span class="hljs-comment">#设置环境变量</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/data/mongodb-linux-x86_64-rhel70-4.2.24/bin<br>vim /etc/profile<br><span class="hljs-built_in">source</span> /etc/profile<br><span class="hljs-built_in">cd</span> /data/mongodb-linux-x86_64-rhel70-4.2.24/bin<br></code></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">dbpath</span> = <span class="hljs-string">/data/db #数据文件存放目录</span><br><span class="hljs-attr">logpath</span> = <span class="hljs-string">/data/logs/mongodb.log #日志文件存放目录</span><br><span class="hljs-attr">port</span> = <span class="hljs-string">27017 #端口</span><br><span class="hljs-attr">fork</span> = <span class="hljs-string">true #以守护程序的方式启用，即在后台运行</span><br><span class="hljs-comment">#auth=true #需要认证。如果放开注释，就必须创建MongoDB的账号，使用账号与密码才可远程访问，第一次安装建议注释</span><br><span class="hljs-attr">bind_ip</span>=<span class="hljs-string">0.0.0.0 #允许远程访问，或者直接注释，127.0.0.1是只允许本地访问</span><br></code></pre></td></tr></table></figure><p>启动mongodb:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 以command line 设置参数的方式启动</span><br>mongod --dbpath /data/db --port 27017 --logpath /data/logs/mongod.log --fork -bind_ip 0.0.0.0<br><span class="hljs-comment"># 以文件方式启动</span><br>mongod -f mongodb.conf<br><br><span class="hljs-comment">#测试安装结果</span><br>mongod<br><br><span class="hljs-comment">#关闭</span><br>pkill mongod<br>mongod --shutdown<br><br><span class="hljs-comment">#测试启动结果</span><br>netstat -nltp | grep mongod<br>ps -ef | grep mongo<br><br><span class="hljs-comment">#开放端口</span><br>firewall-cmd --zone=public --add-port=27017/tcp --permanent<br>firewall-cmd --zone=public --add-port=28017/tcp --permanent<br><span class="hljs-comment"># 使配置生效</span><br>firewall-cmd --reload<br><span class="hljs-comment"># 查看开放端口操作是否成功</span><br>firewall-cmd --zone=public --list-ports<br></code></pre></td></tr></table></figure><p>浏览器访问：ip:27017</p><p>导入样本数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#官网下载</span><br><span class="hljs-comment">#解压</span><br>tar -xvf dump.tar.gz<br><span class="hljs-comment">#还原数据</span><br>mongorestore -h localhost:27017<br></code></pre></td></tr></table></figure><h3 id="3-2-基本操作"><a href="#3-2-基本操作" class="headerlink" title="3.2 基本操作"></a>3.2 基本操作</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata">&gt;<span class="hljs-keyword">use</span> DATABASE_NAME<br>如果数据库不存在，则创建数据库，否则切换到指定数据库。<br>&gt;<span class="hljs-keyword">use</span> crud<br>switched to <span class="hljs-keyword">db</span> crud<br>&gt;<span class="hljs-keyword">db</span><br>crud<br></code></pre></td></tr></table></figure><h4 id="3-2-1-使用-insert-完成插入操作"><a href="#3-2-1-使用-insert-完成插入操作" class="headerlink" title="3.2.1 使用 insert 完成插入操作"></a>3.2.1 使用 insert 完成插入操作</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">使用 <span class="hljs-keyword">insert</span> 完成插入操作<br>操作格式：<br>db.&lt;集合&gt;.insertOne(&lt;<span class="hljs-type">JSON</span>对象&gt;)<br>db.&lt;集合&gt;.insertMany([&lt;<span class="hljs-type">JSON</span> <span class="hljs-number">1</span>&gt;, &lt;<span class="hljs-type">JSON</span> <span class="hljs-number">2</span>&gt;, …&lt;<span class="hljs-type">JSON</span> n&gt;])<br>示例：<br>db.fruit.insertOne(&#123;<span class="hljs-type">name</span>: &quot;apple&quot;&#125;)<br>db.fruit.insertMany([<br>   &#123;<span class="hljs-type">name</span>: &quot;apple&quot;&#125;,<br>   &#123;<span class="hljs-type">name</span>: &quot;pear&quot;&#125;,<br>   &#123;<span class="hljs-type">name</span>: &quot;orange&quot;&#125;<br>])<br></code></pre></td></tr></table></figure><h4 id="3-2-2-使用-find-查询文档"><a href="#3-2-2-使用-find-查询文档" class="headerlink" title="3.2.2 使用 find 查询文档"></a>3.2.2 使用 find 查询文档</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">关于 find:<br> find 是 MongoDB 中查询数据的基本指令，相当于 SQL 中的SELECT。<br> find 返回的是游标。<br> find 示例：<br>db<span class="hljs-selector-class">.movies</span><span class="hljs-selector-class">.find</span>( &#123; <span class="hljs-string">&quot;year&quot;</span> : <span class="hljs-number">1975</span> &#125; ) <span class="hljs-comment">//单条件查询</span><br>db<span class="hljs-selector-class">.movies</span><span class="hljs-selector-class">.find</span>( &#123; <span class="hljs-string">&quot;year&quot;</span> : <span class="hljs-number">1989</span>, <span class="hljs-string">&quot;title&quot;</span> : <span class="hljs-string">&quot;Batman&quot;</span>&#125; ) <span class="hljs-comment">//多条件and查询</span><br>db<span class="hljs-selector-class">.movies</span><span class="hljs-selector-class">.find</span>( &#123; <span class="hljs-variable">$and</span> : <span class="hljs-selector-attr">[ &#123;<span class="hljs-string">&quot;title&quot;</span> : <span class="hljs-string">&quot;Batman&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;category&quot;</span> : <span class="hljs-string">&quot;action&quot;</span> &#125;]</span> &#125; ) <span class="hljs-comment">// and的另一种形式</span><br>db<span class="hljs-selector-class">.movies</span><span class="hljs-selector-class">.find</span>( &#123; <span class="hljs-variable">$or</span>: <span class="hljs-selector-attr">[&#123;<span class="hljs-string">&quot;year&quot;</span> : 1989&#125;, &#123;<span class="hljs-string">&quot;title&quot;</span> :<span class="hljs-string">&quot;Batman&quot;</span>&#125;]</span> &#125; ) <span class="hljs-comment">//多条件or查询</span><br>db<span class="hljs-selector-class">.movies</span><span class="hljs-selector-class">.find</span>( &#123; <span class="hljs-string">&quot;title&quot;</span> : /^B/&#125; ) <span class="hljs-comment">//按正则表达式查找</span><br></code></pre></td></tr></table></figure><p>空的查询文档{}会匹配集合的全部内容。若是不指定查询文档，默认就是{}</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>linit(n)</td><td>限制查询结果返回数量n</td></tr><tr><td>skip(n)</td><td>跳过指定数目的文档</td></tr><tr><td>sort({key:1 or -1})</td><td>对查询结果进行排序</td></tr><tr><td>explain()</td><td>用于获取查询执行过程报告</td></tr><tr><td>snapshot()</td><td>对查询结果使用快照</td></tr><tr><td>count()</td><td>查询文档的总数量</td></tr></tbody></table><p>游标使用过程：</p><p>（1）声明游标：var cursor=db.collectioName.find({query}, {projection})</p><p>（2）打开游标：cursor.hasNext()判断游标是否已经取到尽头</p><p>（3）读取数据：cursor.Next()取出游标的下一个文档</p><p>（4）关闭游标：cursor.close()此步骤可省略,通常为自动关闭,也可 以显示关闭</p><p>（5）使用print输出游标结果集</p><p>示例： </p><p>1.声明游标 var cursor = db.orders.find() </p><p>2.使用printjson输出游标结果集： while (cursor.hasNext()) { print(tojson(cursor.next())) }</p><p><strong>查询条件对照表</strong></p><table><thead><tr><th>SQL</th><th>MQL</th></tr></thead><tbody><tr><td>a = 1</td><td>{ a : 1 }</td></tr><tr><td>a &lt;&gt; 1</td><td>{ a: {$ne: 1}}</td></tr><tr><td>a &gt; 1</td><td>{ a: {$gt: 1}}</td></tr><tr><td>a &gt;= 1</td><td>{ a: {$gte: 1}}</td></tr><tr><td>a &lt; 1</td><td>{ a: {$lt: 1}}</td></tr><tr><td>a &lt;= 1</td><td>{ a: {$lte: 1}}</td></tr></tbody></table><p><strong>查询逻辑对照表</strong></p><table><thead><tr><th>SQL</th><th>MQL</th></tr></thead><tbody><tr><td>a = 1 ADN b = 1</td><td>{a: 1,b: 1} 或{$and: [{a:1}，{b: 1}]}</td></tr><tr><td>a = 1 OR b = 1</td><td>{$or:[{a:1},{b:1}]}</td></tr><tr><td>a IS NULL</td><td>{a: {$exists: false}}</td></tr><tr><td>a IN (1,2,3)</td><td>{a:{$in: [1,2,3]}}</td></tr></tbody></table><table><thead><tr><th>查询逻辑逻辑运算符</th></tr></thead><tbody><tr><td>$lt: 存在并小于</td></tr><tr><td>$lte: 存在并小于等于</td></tr><tr><td>$gt: 存在并大于</td></tr><tr><td>$gte: 存在并大于等于</td></tr><tr><td>$ne: 不存在或存在但不等于</td></tr><tr><td>$in: 存在并在指定数组中</td></tr><tr><td>$nin: 不存在或不在指定数组中</td></tr><tr><td>$or: 匹配两个或多个条件中的一个</td></tr><tr><td>$and: 匹配全部条件</td></tr></tbody></table><h4 id="3-2-3-使用-find-搜索子文档"><a href="#3-2-3-使用-find-搜索子文档" class="headerlink" title="3.2.3 使用 find 搜索子文档"></a>3.2.3 使用 find 搜索子文档</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">find</span> 支持使用“field.sub_field”的形式查询子文档。假设有一个文档：<br>db.fruit.insertOne(&#123;<br>    name: <span class="hljs-string">&quot;apple&quot;</span>,<br>    <span class="hljs-keyword">from</span>: &#123;<br>        country: <span class="hljs-string">&quot;China&quot;</span>,<br>        province: <span class="hljs-string">&quot;Guangdon&quot;</span><br>   &#125;<br>&#125;)<br>考虑以下查询的意义：<br>db.fruit.<span class="hljs-built_in">find</span>( &#123; <span class="hljs-string">&quot;from.country&quot;</span> : <span class="hljs-string">&quot;China&quot;</span> &#125; ) 上面这条是要查询 要查询子文档，<span class="hljs-keyword">from</span>.country<br>db.fruit.<span class="hljs-built_in">find</span>( &#123; <span class="hljs-string">&quot;from&quot;</span> : &#123;country: <span class="hljs-string">&quot;China&quot;</span>&#125; &#125;) 这条要找文档里面有一个<span class="hljs-keyword">from</span>字段，<span class="hljs-keyword">from</span>字段的值为<span class="hljs-attribute">country</span>=<span class="hljs-string">&quot;China&quot;</span><br>如果要查询子文档，必须在子文档里写上路径<br></code></pre></td></tr></table></figure><h4 id="3-2-4-使用-find-搜索数组"><a href="#3-2-4-使用-find-搜索数组" class="headerlink" title="3.2.4 使用 find 搜索数组"></a>3.2.4 使用 find 搜索数组</h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mel">find 支持对数组中的元素进行搜索。假设有一个文档：<br>db.fruit.insert([<br>   &#123; <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-keyword">color</span>: [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span> ] &#125;,<br>   &#123; <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;Mango&quot;</span>, <span class="hljs-keyword">color</span>: [<span class="hljs-string">&quot;yellow&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>] &#125;<br>])<br>考虑以下查询的意义：db.fruit.find(&#123;<span class="hljs-keyword">color</span>: <span class="hljs-string">&quot;red&quot;</span>&#125;) <span class="hljs-comment">//查找颜色为红色的水果有哪些</span><br>db.fruit.find(&#123;$or: [&#123;<span class="hljs-keyword">color</span>: <span class="hljs-string">&quot;red&quot;</span>&#125;, &#123;<span class="hljs-keyword">color</span>:<span class="hljs-string">&quot;yellow&quot;</span>&#125;]&#125;) <span class="hljs-comment">// 查找颜色为红色和黄色的水果有哪些</span><br></code></pre></td></tr></table></figure><h4 id="3-2-5-使用-find-搜索数组中的对象"><a href="#3-2-5-使用-find-搜索数组中的对象" class="headerlink" title="3.2.5 使用 find 搜索数组中的对象"></a>3.2.5 使用 find 搜索数组中的对象</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stata">考虑以下文档，在其中搜索<br><span class="hljs-keyword">db</span>.movies.insertOne( &#123;<br>    <span class="hljs-string">&quot;title&quot;</span> : <span class="hljs-string">&quot;Raiders of the Lost Ark&quot;</span>,<br>    <span class="hljs-string">&quot;filming_locations&quot;</span> : [<br>       &#123; <span class="hljs-string">&quot;city&quot;</span> : <span class="hljs-string">&quot;Los Angeles&quot;</span>, <span class="hljs-string">&quot;state&quot;</span> : <span class="hljs-string">&quot;CA&quot;</span>, <span class="hljs-string">&quot;country&quot;</span> : <span class="hljs-string">&quot;USA&quot;</span> &#125;,<br>       &#123; <span class="hljs-string">&quot;city&quot;</span> : <span class="hljs-string">&quot;Rome&quot;</span>, <span class="hljs-string">&quot;state&quot;</span> : <span class="hljs-string">&quot;Lazio&quot;</span>, <span class="hljs-string">&quot;country&quot;</span> : <span class="hljs-string">&quot;Italy&quot;</span> &#125;,<br>       &#123; <span class="hljs-string">&quot;city&quot;</span> : <span class="hljs-string">&quot;Florence&quot;</span>, <span class="hljs-string">&quot;state&quot;</span> : <span class="hljs-string">&quot;SC&quot;</span>, <span class="hljs-string">&quot;country&quot;</span> : <span class="hljs-string">&quot;USA&quot;</span> &#125;<br>     ]<br>&#125;)<br><span class="hljs-comment">// 查找城市是 Rome 的记录</span><br><span class="hljs-keyword">db</span>.movies.find(&#123;<span class="hljs-string">&quot;filming_locations.city&quot;</span>: <span class="hljs-string">&quot;Rome&quot;</span>&#125;).pretty()<br></code></pre></td></tr></table></figure><h4 id="3-2-6-模糊查询Like"><a href="#3-2-6-模糊查询Like" class="headerlink" title="3.2.6 模糊查询Like"></a>3.2.6 模糊查询Like</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">db.movies.<span class="hljs-keyword">find</span>(&#123;<span class="hljs-string">&quot;filming_locations.city&quot;</span>: <span class="hljs-regexp">/Rome/</span>&#125;).pretty()<br>采用 <span class="hljs-regexp">/ /</span>,中间就是模糊查询的内容，比如：“<span class="hljs-regexp">/ Rome /</span>”，查询名字包含：Rome,如果是以什么开头就在左边增加^ 反之亦然<br></code></pre></td></tr></table></figure><h4 id="3-2-7-正则使用"><a href="#3-2-7-正则使用" class="headerlink" title="3.2.7 正则使用"></a>3.2.7 正则使用</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">&#123;&lt;field&gt;: &#123;<span class="hljs-symbol">$rege</span>x: <span class="hljs-regexp">/pattern/</span>, <span class="hljs-symbol">$optio</span>ns: <span class="hljs-string">&#x27;&#x27;</span>&#125; &#125;<br>db.movies.<span class="hljs-built_in">find</span>(&#123;<span class="hljs-string">&quot;filming_locations.city&quot;</span>: &#123;<span class="hljs-symbol">$rege</span>x:<span class="hljs-regexp">/Rome/</span>&#125; &#125;).pretty()<br></code></pre></td></tr></table></figure><h4 id="3-2-8-使用-find-搜索数组中的对象，相当于是内联外联"><a href="#3-2-8-使用-find-搜索数组中的对象，相当于是内联外联" class="headerlink" title="3.2.8 使用 find 搜索数组中的对象，相当于是内联外联"></a>3.2.8 使用 find 搜索数组中的对象，相当于是内联外联</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">在数组中搜索子对象的多个字段时，如果使用 <span class="hljs-variable">$elemMatch</span>，它表示必须是同一个子对象满足多个条件。考虑以下两个查询：<br>db.getCollection(<span class="hljs-string">&#x27;movies&#x27;</span>).<span class="hljs-built_in">find</span>(&#123;<br>        <span class="hljs-string">&quot;filming_locations.city&quot;</span>: <span class="hljs-string">&quot;Rome&quot;</span>,<br>        <span class="hljs-string">&quot;filming_locations.country&quot;</span>: <span class="hljs-string">&quot;USA&quot;</span><br>&#125;)<br>db.getCollection(<span class="hljs-string">&#x27;movies&#x27;</span>).<span class="hljs-built_in">find</span>(&#123; <span class="hljs-string">&quot;filming_locations&quot;</span>: &#123; <span class="hljs-variable">$elemMatch</span>:&#123;<span class="hljs-string">&quot;city&quot;</span>:<span class="hljs-string">&quot;Rome&quot;</span>, <span class="hljs-string">&quot;country&quot;</span>: <span class="hljs-string">&quot;USA&quot;</span>&#125;&#125;&#125;)<br></code></pre></td></tr></table></figure><h4 id="3-2-9-控制-find-返回的字段"><a href="#3-2-9-控制-find-返回的字段" class="headerlink" title="3.2.9 控制 find 返回的字段"></a>3.2.9 控制 find 返回的字段</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">find</span> 可以指定只返回指定的字段：_id字段必须明确指明不返回，否则默认返回；在 MongoDB 中我们称这为投影（projection）；<br> <span class="hljs-attribute">db</span>.movies.find(&#123;<span class="hljs-string">&quot;category&quot;</span>: <span class="hljs-string">&quot;action&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-number">0</span> (<span class="hljs-number">0</span>代表不返回id), title:<span class="hljs-number">1</span> (<span class="hljs-number">1</span> 代表返回title)&#125;)<br> <span class="hljs-attribute">db</span>.movies.find(&#123;&#125;,&#123;<span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-number">0</span> , title:<span class="hljs-number">1</span> &#125;)<br></code></pre></td></tr></table></figure><h4 id="3-2-10-使用-remove-删除文档"><a href="#3-2-10-使用-remove-删除文档" class="headerlink" title="3.2.10 使用 remove 删除文档"></a>3.2.10 使用 remove 删除文档</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">remove 命令需要配合查询条件使用；<br>● 匹配查询条件的的文档会被删除；<br>● 指定一个空文档条件会删除所有文档；<br>● 以下示例：<br>db<span class="hljs-selector-class">.testcol</span><span class="hljs-selector-class">.remove</span>( &#123; <span class="hljs-selector-tag">a</span> : <span class="hljs-number">1</span> &#125; ) <span class="hljs-comment">// 删除a等于1的记录</span><br>db<span class="hljs-selector-class">.testcol</span><span class="hljs-selector-class">.remove</span>( &#123; <span class="hljs-selector-tag">a</span> : &#123; <span class="hljs-variable">$lt</span> : <span class="hljs-number">5</span> &#125; &#125; ) <span class="hljs-comment">// 删除a小于5的记录</span><br>db<span class="hljs-selector-class">.testcol</span><span class="hljs-selector-class">.remove</span>( &#123;&#125; ) <span class="hljs-comment">// 删除所有记录</span><br>db<span class="hljs-selector-class">.testcol</span><span class="hljs-selector-class">.remove</span>() <span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure><h4 id="3-2-11-使用-update-更新文档"><a href="#3-2-11-使用-update-更新文档" class="headerlink" title="3.2.11 使用 update 更新文档"></a>3.2.11 使用 update 更新文档</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php">Update 操作执行格式：db.&lt;集合&gt;.<span class="hljs-title function_ invoke__">update</span>(&lt;查询条件&gt;, &lt;更新字段&gt;)<br>以下数据为例：<br>db.fruit.<span class="hljs-title function_ invoke__">insertMany</span>([<br>   &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;apple&quot;</span>&#125;,<br>   &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;pear&quot;</span>&#125;,<br>   &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;orange&quot;</span>&#125;<br>])<br>db.fruit.<span class="hljs-title function_ invoke__">updateOne</span>(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;apple&quot;</span>&#125;, &#123;<span class="hljs-variable">$set</span>: &#123;<span class="hljs-attr">from</span>:<span class="hljs-string">&quot;China&quot;</span>&#125;&#125;)<br>查询 name 为 apple 的记录，将找到记录的 <span class="hljs-keyword">from</span> 设置为 China<br><br>使用 updateOne 表示无论条件匹配多少条记录，始终只更新第一条；<br>使用 updateMany 表示条件匹配多少条就更新多少条；<br>updateOne/updateMany 方法要求更新条件部分必须具有以下之一，否则将报错：<br><span class="hljs-variable">$set</span>/<span class="hljs-variable">$unset</span><br><span class="hljs-variable">$push</span>/<span class="hljs-variable">$pushAll</span>/<span class="hljs-variable">$pop</span><br><span class="hljs-variable">$pull</span>/<span class="hljs-variable">$pullAll</span><br><span class="hljs-variable">$addToSet</span><br><span class="hljs-comment">// 报错</span><br>db.fruit.<span class="hljs-title function_ invoke__">updateOne</span>(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;apple&quot;</span>&#125;, &#123;<span class="hljs-attr">from</span>: <span class="hljs-string">&quot;China&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><h4 id="3-2-12-使用-update-更新数组"><a href="#3-2-12-使用-update-更新数组" class="headerlink" title="3.2.12 使用 update 更新数组"></a>3.2.12 使用 update 更新数组</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">● <span class="hljs-symbol">$pus</span>h: 增加一个对象到数组底部<br>● <span class="hljs-symbol">$pus</span>hAll: 增加多个对象到数组底部<br>● <span class="hljs-symbol">$pop</span>: 从数组底部删除一个对象<br>● <span class="hljs-symbol">$pull</span>: 如果匹配指定的值，从数组中删除相应的对象<br>● <span class="hljs-symbol">$pullAll</span>: 如果匹配任意的值，从数据中删除相应的对象<br>● <span class="hljs-symbol">$addToSet</span>: 如果不存在则增加一个值到数组<br></code></pre></td></tr></table></figure><h4 id="3-2-13-使用-drop-删除集合"><a href="#3-2-13-使用-drop-删除集合" class="headerlink" title="3.2.13 使用 drop 删除集合"></a>3.2.13 使用 drop 删除集合</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">● 使用 <span class="hljs-keyword">db</span>.&lt;集合&gt;.<span class="hljs-keyword">drop</span>() 来删除一个集合<br>● 集合中的全部文档都会被删除<br>● 集合相关的索引也会被删除<br><span class="hljs-keyword">db</span>.colToBeDropped.<span class="hljs-keyword">drop</span>()<br></code></pre></td></tr></table></figure><h4 id="3-2-14-使用-dropDatabase-删除数据库"><a href="#3-2-14-使用-dropDatabase-删除数据库" class="headerlink" title="3.2.14 使用 dropDatabase 删除数据库"></a>3.2.14 使用 dropDatabase 删除数据库</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss">● 使用 db.dropDatabase() 来删除数据库<br>● 数据库相应文件也会被删除，磁盘空间将被释放<br><span class="hljs-keyword">use</span> tempDB<br>db.dropDatabase()<br><span class="hljs-keyword">show</span> collections <span class="hljs-comment">// No collections</span><br><span class="hljs-keyword">show</span> dbs <span class="hljs-comment">// The db is gone</span><br></code></pre></td></tr></table></figure><h3 id="3-3-SpringBoot整合"><a href="#3-3-SpringBoot整合" class="headerlink" title="3.3 SpringBoot整合"></a>3.3 SpringBoot整合</h3><p>添加pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-lang<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">## 端口号</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">8084</span><br><span class="hljs-comment">## 服务名称</span><br><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">mongodb-application</span><br><span class="hljs-comment">## mongodb配置</span><br><span class="hljs-attr">spring.data.mongodb.host</span>=<span class="hljs-string">47.113.147.179</span><br><span class="hljs-attr">spring.data.mongodb.port</span>=<span class="hljs-string">27017</span><br><span class="hljs-comment">#spring.data.mongodb.username=</span><br><span class="hljs-comment">#spring.data.mongodb.password=</span><br><span class="hljs-attr">spring.data.mongodb.database</span>=<span class="hljs-string">springboot_db</span><br><span class="hljs-comment">#spring.data.mongodb.uri=mongodb://name:password@localhost:27017/test</span><br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> MongoTemplate mongoTemplate;<br></code></pre></td></tr></table></figure><h3 id="3-4-聚合查询"><a href="#3-4-聚合查询" class="headerlink" title="3.4 聚合查询"></a>3.4 聚合查询</h3><blockquote><p>分析性、统计型的场景、复杂数据的计算和处理</p></blockquote><p>MongoDB 聚合框架（Aggregation Framework）是一个计算框架，它可以：作用在一个或几个集合上；对集合中的数据进行的一系列运算，比如数据的计算；将这些数据转化为期望的形式，比如类型的处理。从效果而言，聚合框架相当于 SQL 查询中的：GROUP BY，LEFT OUTER JOIN，AS 等</p><h4 id="3-4-1-管道-Pipeline-和步骤-Stage"><a href="#3-4-1-管道-Pipeline-和步骤-Stage" class="headerlink" title="3.4.1 管道(Pipeline)和步骤(Stage)"></a>3.4.1 管道(Pipeline)和步骤(Stage)</h4><p>整个聚合运算过程称为管道（Pipeline），它是由多个步骤 （Stage）组成的， 每个管道：</p><ol><li>接受一系列文档（原始数据）；</li><li> 每个步骤对这些文档进行一系列运算；</li><li> 结果文档输出给下一个步骤；</li></ol><h4 id="3-4-2-聚合运算的基本格式"><a href="#3-4-2-聚合运算的基本格式" class="headerlink" title="3.4.2 聚合运算的基本格式"></a>3.4.2 聚合运算的基本格式</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">pipeline = [<span class="hljs-variable">$stage1</span>, <span class="hljs-variable">$stage2</span>, ...<span class="hljs-variable">$stageN</span>]; // 这个pipeline 就是一系列的计算步骤组成<br>db.&lt;COLLECTION&gt;.aggregate(<br>   pipeline,<br>   &#123; options &#125;<br>);<br></code></pre></td></tr></table></figure><p><strong>常见步骤</strong></p><table><thead><tr><th>步骤</th><th>作用</th><th>SQL等价运算符</th></tr></thead><tbody><tr><td>$match</td><td>过滤</td><td>WHERE</td></tr><tr><td>$project</td><td>投影</td><td>AS</td></tr><tr><td>$sort</td><td>排序</td><td>ORDER BY</td></tr><tr><td>$group</td><td>分组</td><td>GROUP BY</td></tr><tr><td>$skip/$limit</td><td>结果限制</td><td>SKIP/LIMIT</td></tr><tr><td>$lookup</td><td>左外连接</td><td>LEFT OUTER JOIN</td></tr><tr><td>$unwind</td><td>展开数组</td><td></td></tr><tr><td>$graphLookup</td><td>图搜索</td><td></td></tr><tr><td>$facet/$bucket</td><td>分面搜索</td><td></td></tr></tbody></table><p><strong>常见步骤中的运算符</strong></p><table><thead><tr><th>$match</th><th>$project</th><th>$group</th></tr></thead><tbody><tr><td>查询过滤 $eq/ $gt/ $gte/ $lt/ $lte/</td><td>选择需要的或者排除不 需要的字段 $map/ $reduce/ $filter</td><td>聚合计算 $sum/ $avg</td></tr><tr><td>$and/ $or/ $not/ $in</td><td>$range</td><td>$push/ $addToSet</td></tr><tr><td>$geoWithin/ $intersect …</td><td>$multipy/ $divide/ $substract/ $add …</td><td>$first/ $last/ $max/ $min …</td></tr></tbody></table><p><strong>MQL 常用步骤与 SQL 对比</strong></p><p><img src="/image/MongoDB/1.png"></p><p><img src="/image/MongoDB/2.png"></p><h4 id="3-4-3-MQL特有步骤-unwind"><a href="#3-4-3-MQL特有步骤-unwind" class="headerlink" title="3.4.3 MQL特有步骤 $unwind"></a>3.4.3 MQL特有步骤 $unwind</h4><p>在做报表的时候，可能需要把用户的分数展出来，可以利用 MongoDB的 $unwind 把整个数组的数据展出来变成一行一行展示。</p><p><img src="/image/MongoDB/3.png"></p><h4 id="3-4-4-MQL特有步骤-bucket"><a href="#3-4-4-MQL特有步骤-bucket" class="headerlink" title="3.4.4 MQL特有步骤 $bucket"></a>3.4.4 MQL特有步骤 $bucket</h4><p>如果是在做电商目录和产品数量会非常有用，需要统计一下商品，100块钱的商品有多少、200的有多少，这个运算的话就不需要一个个去查询，然后再后面通过union或者是程序代码来汇总了.</p><p><img src="/image/MongoDB/4.png"></p><h4 id="3-4-5-MQL-特有步骤-facet"><a href="#3-4-5-MQL-特有步骤-facet" class="headerlink" title="3.4.5 MQL 特有步骤 $facet"></a>3.4.5 MQL 特有步骤 $facet</h4><p>更高阶的应用，把$bucket 组合起来使用，比如需要统计更多纬度和更复杂的需求的时候，这个$facet ，可以把多个纬度的需求放在同一个查询来完成</p><p><img src="/image/MongoDB/5.png"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Minio原理分析</title>
    <link href="/2023/05/10/%E4%B8%AD%E9%97%B4%E4%BB%B6/minio/Minio%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <url>/2023/05/10/%E4%B8%AD%E9%97%B4%E4%BB%B6/minio/Minio%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Minio分布式存储原理"><a href="#1-Minio分布式存储原理" class="headerlink" title="1 Minio分布式存储原理"></a>1 Minio分布式存储原理</h2><p>MinIO是一款自称是高性能，分布式对象存储服务器的软件，在MinIO的设计中，每个MinIO服务器都是相互独立的节点，共同存储对象数据，MinIO采用分布式架构，并将这些节点联合起来形成一个集群，以便更好的负载均衡，提高性能和可伸缩性，是一个去中心化的设计。</p><p>MinIO在分布式存储实现中引入了一种可扩展哈希表数据结构，其具有很好的可扩展性和动态伸缩性，同时还能够支持高并发读取和写入操作。当一个新对象存储到MinIO集群中时，MinIO节点会根据哈希函数计算出该对象的存储地址，对该对象进行切分和编码，然后将切分片段和冗余因子存储在不同的MinIO节点上。</p><p>MinIO集群中的所有节点通过一致性哈希（Consistent Hashing）算法实现数据的负载均衡与故障恢复。一致性哈希算法是一种用于动态增删节点的分布式哈希算法，它能保证极高的数据迁移效率。</p><p>具体的处理流程如下：</p><ol><li><p>通过哈希函数计算出对象的存储节点。</p></li><li><p>将对象切分为多个数据块，并通过Reed-Solomon纠删码技术编码，生成校验块。</p></li><li><p>将数据块和校验块按块组合的方式存储在各个节点中。</p></li><li><p>在对象读取时，根据哈希函数计算出对象对应的节点地址，到该节点地址所在的MinIO节点上读取数据。</p></li><li><p>如果某个MinIO节点出现故障，那么它上面的数据就会自动迁移到其他存储节点上，从而保证数据的高可用性和冗余机制。</p></li></ol><p>通过以上的数据分片和分散，保证了数据安全、高可用性、高负载均衡和高读写性能等多方面的需求。</p><p><strong>Minio数据一致性问题</strong>，是通过dsync分布式锁管理器解决的：</p><ul><li>任何一个节点的锁请求都会广播给集群内的所有在线节点</li><li>如果收到N/2+1个节点的同意，则获取所成功 </li><li>通过stale lock检测机制，判断节点的状态及持有锁情况</li></ul><h2 id="2-Minio对象存储和元数据"><a href="#2-Minio对象存储和元数据" class="headerlink" title="2 Minio对象存储和元数据"></a>2 Minio对象存储和元数据</h2><p>MinIO是一款对象存储服务器，主要用于存储非结构化的数据，例如各种类型的文件等。在存储对象的同时，MinIO还会生成对象的元数据，用于描述对象的基本信息。</p><p>在MinIO中，每个对象都有一个唯一的对象名（Object Name），类似于文件系统中的文件名。而Bucket则用于组织和管理对象，相当于文件系统中的目录。</p><p>除了Object Name和Bucket，每个对象还有一些其他的元数据，包括对象大小、对象的创建和修改时间、对象的MIME type等。这些元数据可以在创建对象时一并设置，也可以通过修改元数据接口进行修改。另外MinIO还支持自定义元数据，用户可以通过配置存储策略来自动添加自定义元数据。</p><p>MinIO的元数据存储采用了键-值(key-value)的存储方式，并且将元数据存储在一个扁平的键值对集合中，其中键值对可以表示出对象所属的Bucket和Object。元数据存储使用了etcd这样的轻量级分布式键值存储系统，确保元数据的高可靠性和实时更新，同时也保证了元数据的高效读写。</p><p>除了以上的元数据，MinIO还支持用户在使用过程中自定义一些额外的元数据，例如某个对象的归属者、某个对象的使用权限等等。这些元数据分别对应不同的系统配置，有利于实现更加复杂的对象访问控制、元数据管理以及其他高级功能，如利用元数据来实现搜索等功能。</p><p>综上所述，MinIO提供了完善的对象存储和元数据管理机制，帮助用户高效存储和管理大量的非结构化数据，并支持自定义元数据来实现更加复杂的业务需求。</p><h2 id="3-Minio纠删码"><a href="#3-Minio纠删码" class="headerlink" title="3 Minio纠删码"></a>3 Minio纠删码</h2><p>MinIO是一个基于对象存储的开源云存储服务。纠删码是MinIO用于数据容错的关键技术之一。</p><p>纠删码是一种冗余数据存储技术，可以将原始数据切分成多个片段，并计算出若干冗余数据进行存储。当部分数据片段损坏或者丢失时，通过计算冗余数据，可以恢复出原始数据。</p><p>MinIO的纠删码实现采用了Reed-Solomon纠删码算法。Reed-Solomon算法通过布洛赫乘法（Blomberger Multiplication）在有限域上进行计算，将原始数据切分成若干个数据块（Data Block），并计算出若干个校验块（Parity Block）进行冗余存储。具体步骤如下：</p><ol><li><p>将原始数据划分为多个数据块。</p></li><li><p>计算出若干校验块。</p></li><li><p>将所有数据块和校验块按顺序拼接成一个大的数据块，并对其进行编码。</p></li><li><p>对编码后的数据块进行切分，得到多个“条带”（Stripe）。</p></li><li><p>在实际存储时，将每个条带拆分为若干数据块和校验块，并在不同的存储节点上进行存储。具体方式可以采用多个存储节点进行副本存储、通过容错码实现块的冗余存储等。</p></li><li><p>当数据损坏或丢失时，通过计算校验块进行数据恢复。</p></li></ol><p>MinIO中的Reed-Solomon实现比较高效，通常情况下只需要4-6个校验块就可以实现数据冗余，极大提高了数据的容错能力。同时，在存储大文件时，MinIO会自动将文件切分成若干个条带，可以充分利用存储节点的存储带宽和磁盘读写能力。</p><h2 id="4-Minio权限控制策略"><a href="#4-Minio权限控制策略" class="headerlink" title="4 Minio权限控制策略"></a>4 Minio权限控制策略</h2><p>MinIO提供了细粒度的权限控制策略，方便管理员根据需要对存储桶、对象和目录设置各项权限。</p><p>MinIO权限控制采用AWS S3的访问策略来设置权限。一个访问策略是一个JSON格式的文本，描述了用户或者群组能够对MinIO上的哪些资源进行哪些操作。</p><p>下面是一个权限控制示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;s3:ListBucket&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;arn:aws:s3:::mybucket&quot;</span><span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;s3:GetObject&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;arn:aws:s3:::mybucket/myfolder/*&quot;</span><span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>本示例中，权限控制规则包括两项：允许用户列出 mybucket 里面的内容；允许用户读取 mybucket/myfolder 文件夹下的所有对象。</p><p>下面是一个常见的权限控制策略的代码示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;s3:GetBucketLocation&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;s3:ListBucket&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;arn:aws:s3:::my-bucket&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;s3:GetObject&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;s3:PutObject&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;arn:aws:s3:::my-bucket/my-folder/*&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;AWS&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>          <span class="hljs-string">&quot;arn:aws:iam::123456789012:user/username&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-string">&quot;arn:aws:iam::123456789012:role/rolename&quot;</span><br>        <span class="hljs-punctuation">]</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>本策略允许任何人进行 my-bucket 存储桶的读和列出操作，允许指定的用户或角色进行 my-bucket/my-folder 存储桶下文件夹中的对象的读和写操作。</p><p>除了上述的简单设置外，MinIO还支持更加复杂的权限控制规则，例如基于 IP 地址、时间戳、Requester、Referer 来限制访问等等。</p><p>总之，MinIO提供了完善而细致的权限控制策略，可以根据业务需要灵活设置，同时也支持更加高级的权限控制方式的实现。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Minio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Minio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes存储与进阶</title>
    <link href="/2023/05/08/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/k8s/Kubernetes%E5%AD%98%E5%82%A8%E4%B8%8E%E8%BF%9B%E9%98%B6/"/>
    <url>/2023/05/08/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/k8s/Kubernetes%E5%AD%98%E5%82%A8%E4%B8%8E%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="1-K8s-Storage"><a href="#1-K8s-Storage" class="headerlink" title="1 K8s Storage"></a>1 K8s Storage</h2><p><a href="https://kubernetes.io/docs/concepts/storage/">https://kubernetes.io/docs/concepts/storage/</a></p><h3 id="1-1-Volume"><a href="#1-1-Volume" class="headerlink" title="1.1 Volume"></a>1.1 Volume</h3><p>（1）定义一个pod，其中包含两个container</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">volume-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volume-pod</span> <span class="hljs-comment"># 使用哪个volume</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/nginx-volume</span> <span class="hljs-comment"># 对应container中的路径</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">busybox-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&#x27;echo The app is running! &amp;&amp; sleep 3600&#x27;</span>]<br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volume-pod</span> <span class="hljs-comment"># 使用哪个volume</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/busybox-volume</span> <span class="hljs-comment"># 对应container中的路径</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volume-pod</span> <span class="hljs-comment"># volume名称</span><br>    <span class="hljs-attr">hostPath:</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/tmp/volume-pod</span> <span class="hljs-comment"># volume对应的宿主机路径</span><br></code></pre></td></tr></table></figure><p>（2）根据文件创建Pod并查看运行情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建Pod</span><br>kubectl apply -f volume-pod.yaml<br><span class="hljs-comment"># 查看Pod运行情况</span><br>kubectl get pods -o wide<br>kubectl describe pod volume-pod<br><span class="hljs-comment"># 来到Pod运行的worker节点，比如w1</span><br>docker ps | grep volume-pod<br><span class="hljs-comment"># 查看Pod Volume对应的宿主机路径</span><br><span class="hljs-built_in">ls</span> /tmp/volume-pod<br><span class="hljs-comment"># 进入到两个容器中，查看容器对应的路径</span><br>docker <span class="hljs-built_in">exec</span> -it containerid sh<br><span class="hljs-built_in">ls</span> /busybox-volume<br><span class="hljs-built_in">ls</span> /nginx-volume<br><span class="hljs-comment"># 在容器中创建文件或者在宿主机上创建文件，看看是否同步，发现是同步的，说明Pod里面的Container是共享volume的</span><br><span class="hljs-comment"># 查看两个container中的hosts文件是否一样，发现也是一样的，说明Pod里面的Container是共享network的</span><br>docker <span class="hljs-built_in">exec</span> -it containerid <span class="hljs-built_in">cat</span> /etc/hosts<br></code></pre></td></tr></table></figure><h3 id="1-2-PV-PVC-Pod介绍"><a href="#1-2-PV-PVC-Pod介绍" class="headerlink" title="1.2 PV PVC Pod介绍"></a>1.2 PV PVC Pod介绍</h3><h4 id="1-2-1-PersistentVolume-PV"><a href="#1-2-1-PersistentVolume-PV" class="headerlink" title="1.2.1 PersistentVolume-PV"></a>1.2.1 PersistentVolume-PV</h4><p><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistent-volumes">https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistent-volumes</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pv</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">capacity:</span><br>    <span class="hljs-attr">storage:</span> <span class="hljs-string">5Gi</span> <span class="hljs-comment"># 存储空间大小</span><br>  <span class="hljs-attr">volumeMode:</span> <span class="hljs-string">Filesystem</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span> <span class="hljs-comment"># 只允许一个Pod进行独占式读写操作</span><br>  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-string">Recycle</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">slow</span><br>  <span class="hljs-attr">mountOptions:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">hard</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">nfsvers=4.1</span><br>  <span class="hljs-attr">nfs:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/tmp</span> <span class="hljs-comment"># 远端服务器的目录</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span> <span class="hljs-comment"># 远端的服务器</span><br></code></pre></td></tr></table></figure><h4 id="1-2-2-PersistentVolumeClaim-PVC"><a href="#1-2-2-PersistentVolumeClaim-PVC" class="headerlink" title="1.2.2 PersistentVolumeClaim-PVC"></a>1.2.2 PersistentVolumeClaim-PVC</h4><p><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims">https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">myclaim</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>  <span class="hljs-attr">volumeMode:</span> <span class="hljs-string">Filesystem</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">8Gi</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">slow</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">release:</span> <span class="hljs-string">&quot;stable&quot;</span><br>    <span class="hljs-attr">matchExpressions:</span><br>      <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">key:</span> <span class="hljs-string">environment</span>, <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span>, <span class="hljs-attr">values:</span> [<span class="hljs-string">dev</span>]&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-3-Pod使用PVC"><a href="#1-2-3-Pod使用PVC" class="headerlink" title="1.2.3  Pod使用PVC"></a>1.2.3  Pod使用PVC</h4><p><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#claims-as-volumes">https://kubernetes.io/docs/concepts/storage/persistent-volumes/#claims-as-volumes</a></p><p>（1）前提是PV和PVC已经绑定在一起，也就是PV能够满足PVC的要求 </p><p>（2）同时PV和PVC的storageClassName要一样</p><p>（3）PersistentVolumeController会发现两者有关系，然后将PV的名字添加在PVC中，这样就建立了绑定关系</p><h3 id="1-3-PV-PVC-Pod实战"><a href="#1-3-PV-PVC-Pod实战" class="headerlink" title="1.3 PV PVC Pod实战"></a>1.3 PV PVC Pod实战</h3><p>需求：Nginx持久化存储，步骤：1.共享存储使用NFS，比如选择在master节点 。2.创建PV和PV。3.Nginx Pod中使用PVC</p><p><strong>NFC简介</strong>：NFS(network file system)网络文件系统，是FreeBSD支持的文件系统中的一种，允许网络中的计算机之间通过TCP/IP网络共享资源</p><ol><li>Master节点搭建NFS</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#安装nfs</span><br>yum install -y nfs-utils<br><span class="hljs-comment"># 创建nfs目录</span><br><span class="hljs-built_in">mkdir</span> -p /nfs/data/<br><span class="hljs-built_in">mkdir</span> -p /nfs/data/nginx<br><span class="hljs-comment"># 授予权限</span><br><span class="hljs-built_in">chmod</span> -R 777 /nfs/data<br><span class="hljs-comment"># 配置exports文件</span><br>: vi /etc/exports<br>/nfs/data *(rw,no_root_squash,<span class="hljs-built_in">sync</span>)<br><span class="hljs-comment"># 使得配置生效</span><br>exportfs -r<br><span class="hljs-comment"># 查看生效</span><br>exportfs<br><span class="hljs-comment"># 启动rpcbind、nfs服务</span><br>systemctl restart rpcbind &amp;&amp; systemctl <span class="hljs-built_in">enable</span> rpcbind<br>systemctl restart nfs &amp;&amp; systemctl <span class="hljs-built_in">enable</span> nfs<br><span class="hljs-comment"># 查看rpc服务的注册情况</span><br>rpcinfo -p localhost<br><span class="hljs-comment"># showmount测试</span><br>showmount -e master-ip<br></code></pre></td></tr></table></figure><ol start="2"><li>定义PV，PVC和Pod文件</li></ol><blockquote><p>nginx-pv-pvc-demo.yaml</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 定义PV</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-pv</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteMany</span><br>  <span class="hljs-attr">capacity:</span><br>    <span class="hljs-attr">storage:</span> <span class="hljs-string">2Gi</span><br>  <span class="hljs-attr">nfs:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/nfs/data/nginx</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.51</span> <span class="hljs-comment"># master节点的ip</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 定义PVC，用于绑定PV,自动根据accessModes和storage绑定，多种参数绑定形式。</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-pvc</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteMany</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">2Gi</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 定义Nginx Pod，指定需要使用的PVC</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-persistent-storage</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>      <span class="hljs-attr">volumes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-persistent-storage</span><br>          <span class="hljs-attr">persistentVolumeClaim:</span><br>          <span class="hljs-attr">claimName:</span> <span class="hljs-string">nginx-pvc</span><br></code></pre></td></tr></table></figure><ol start="3"><li>创建资源并测试</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 根据yaml文件创建资源：pod、pv、pvc</span><br>kubectl apply -f nginx-pv-pvc-demo.yaml<br><span class="hljs-comment"># 查看资源</span><br>kubectl get pv,pvc<br>kubectl get pods -o wide<br>kubectl describe pod nginx<br>kubectl describe pv nginx-pv<br>kubectl describe pvc nginx-pvc<br><span class="hljs-comment"># 在master对应的nfs/data/nginx中新建jack.html</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello jack pv pvc pod.&quot;</span> &gt; jack.html<br><span class="hljs-comment"># 进入nginx容器查看/usr/share/nginx/html</span><br>kubectl get pods -o wide<br>docker <span class="hljs-built_in">exec</span> -it containerid sh<br><span class="hljs-built_in">ls</span> /usr/share/nginx/html<br><span class="hljs-built_in">cat</span> /usr/share/nginx/html/jack.html<br><span class="hljs-comment"># 查看nginx pod ip并访问资源</span><br>kubectl get pods -o wide<br>curl nginx_pod_ip/jack.html<br><span class="hljs-comment"># 删除nginx pod并查看新nginx pod的资源</span><br>kubectl delete pod nginx-pod<br>curl nginx-new-pod-ip/jack.html<br></code></pre></td></tr></table></figure><p>手动创建PV是比较麻烦的，可以交给StorageClass操作。</p><h2 id="2-Resouce"><a href="#2-Resouce" class="headerlink" title="2 Resouce"></a>2 Resouce</h2><p><a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#example-1">https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#example-1</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">frontend</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">app</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">images.my-company.example/app:v4</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;64Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;250m&quot;</span><br>      <span class="hljs-attr">limits:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;128Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;500m&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">log-aggregator</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">images.my-company.example/log-aggregator:v6</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;64Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;250m&quot;</span><br>      <span class="hljs-attr">limits:</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;128Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;500m&quot;</span><br></code></pre></td></tr></table></figure><h2 id="3-Dashboard"><a href="#3-Dashboard" class="headerlink" title="3 Dashboard"></a>3 Dashboard</h2><p><a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/</a></p><p>（1）创建dashboard.yaml文件，记得把image替换成阿里云的，以及配置成NodePort访问形式.</p><p>（2）定义访问dashboard需要的account文件并运行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">admin-user</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kubernetes-dashboard</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">admin-user</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">cluster-admin</span><br><span class="hljs-attr">subjects:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">admin-user</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">kubernetes-dashboard</span><br></code></pre></td></tr></table></figure><p>（3）创建访问dashboard需要的token</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl -n kubernetes-dashboard get secret $(kubectl -n kubernetes-dashboard get sa/admin-user -o jsonpath=<span class="hljs-string">&quot;&#123;.secrets[0].name&#125;&quot;</span>) -o go-template=<span class="hljs-string">&quot;&#123;&#123;.data.token | base64decode&#125;&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>（4）访问K8s_ip:30018，输入token</p><p><img src="/image/k8s/19.png"></p><h2 id="4-Controller进阶"><a href="#4-Controller进阶" class="headerlink" title="4 Controller进阶"></a>4 Controller进阶</h2><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/">https://kubernetes.io/docs/concepts/workloads/controllers/</a></p><h3 id="4-1-Job"><a href="#4-1-Job" class="headerlink" title="4.1 Job"></a>4.1 Job</h3><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/job/">https://kubernetes.io/docs/concepts/workloads/controllers/job/</a></p><p>对于RS，RC之类的控制器，能够保持Pod按照预期数目持久地运行下去，它们针对的是持久性的任 务，比如web服务。而有些操作其实不需要持久，比如压缩文件，希望任务完成之后，Pod就结束运行，不需要保持在系统中，此时就需要用到Job。所以可以这样理解，Job是对RS、RC等持久性控制器的补充。负责批量处理短暂的一次性任务，仅执行一次，并保证处理的一个或者多个Pod成功结束。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">job-demo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">job-demo</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">counter</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>        <span class="hljs-attr">command:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;bin/sh&quot;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;-c&quot;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i; done&quot;</span><br></code></pre></td></tr></table></figure><h3 id="4-2-CronJob"><a href="#4-2-CronJob" class="headerlink" title="4.2 CronJob"></a>4.2 CronJob</h3><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/">https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/</a></p><p>相当于定时任务</p><h3 id="4-3-StatefulSet"><a href="#4-3-StatefulSet" class="headerlink" title="4.3 StatefulSet"></a>4.3 StatefulSet</h3><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/</a></p><p>之前接触的Pod的管理对象比如RC、Deployment、DaemonSet和Job都是面向无状态的服务，但是现实中有很多服务是有状态的，比如MySQL集群、MongoDB集群、ZK集群等。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 定义Service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 定义StatefulSet</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">&quot;nginx&quot;</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">terminationGracePeriodSeconds:</span> <span class="hljs-number">10</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br></code></pre></td></tr></table></figure><h3 id="4-4-DaemonSet"><a href="#4-4-DaemonSet" class="headerlink" title="4.4 DaemonSet"></a>4.4 DaemonSet</h3><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/">https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看kube-proxy类型</span><br>kubectl get pods kube-proxy-9jgb6 -n kube-system -o yaml | grep kind<br><span class="hljs-comment"># 查看calico.yaml文件</span><br><span class="hljs-comment"># 搜索&quot;DaemonSet&quot;，发现calico-node也是DaemonSet类型</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes使用CICD实战</title>
    <link href="/2023/05/06/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/k8s/Kubernetes%E4%BD%BF%E7%94%A8CICD%E5%AE%9E%E6%88%98/"/>
    <url>/2023/05/06/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/k8s/Kubernetes%E4%BD%BF%E7%94%A8CICD%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1-部署SpringBoot项目"><a href="#1-部署SpringBoot项目" class="headerlink" title="1 部署SpringBoot项目"></a>1 部署SpringBoot项目</h2><p>（1）得到Spring Boot项目的image，这块之前Docker中聊过，就不具体展开，镜像已经推送到阿里仓库</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">registry.cn-hangzhou.aliyuncs.com<span class="hljs-regexp">/jack-kubernetes/</span>springboot-demo-image<br></code></pre></td></tr></table></figure><p>（2）编写springboot-demo.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#以Deployment部署Pod</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-demo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">springboot-demo</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">springboot-demo</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-demo</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">registry.cn-hangzhou.aliyuncs.com/jack-kubernetes/springbootdemo-image</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 创建Pod的Service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">springboot-demo</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 创建Ingress，定义访问规则，一定要记得提前创建好nginx ingress controller</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-ingress</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">kubernetes.io/ingress.class:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">springboot.jack.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">service:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-service</span><br>          <span class="hljs-attr">port:</span><br>            <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>（3）根据yaml文件创建资源并查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f springboot-demo.yaml<br>kubectl get all<br></code></pre></td></tr></table></figure><p>（4）在win上配置hosts文件</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.0.52</span> springboot.jack.com<br></code></pre></td></tr></table></figure><p>（5）浏览器访问</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>springboot.jack.com/K8s<br></code></pre></td></tr></table></figure><h2 id="2-Windows上准备"><a href="#2-Windows上准备" class="headerlink" title="2 Windows上准备"></a>2 Windows上准备</h2><p>（1）修改代码，即更新项目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMappiing(&quot;/k8s&quot;)</span><br>String <span class="hljs-title function_">k8s</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">hostAddress</span> <span class="hljs-operator">=</span> InetAddress.getLocalHost().getHostAddress();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello k8s, 当前服务的地址是：&quot;</span> + hostAddress;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）安装配置Git</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">（1）下载安装git[略]<br>（2）配置并生成ssh_key<br>git config --global user.name <span class="hljs-string">&quot;hiourearth&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;hiourearth@gmail.com&quot;</span><br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;hiourearth@gmail.com&quot;</span><br>（3）打开C:\Users\Jack\.ssh，查看id_rsa.pub文件中的值<br></code></pre></td></tr></table></figure><h2 id="3-搭建并配置Gitlab"><a href="#3-搭建并配置Gitlab" class="headerlink" title="3 搭建并配置Gitlab"></a>3 搭建并配置Gitlab</h2><blockquote><p>使用192.168.0.8 这台机器</p></blockquote><p><a href="https://about.gitlab.com/install/#centos-7">https://about.gitlab.com/install/#centos-7</a></p><p>（1）说明：安装gitlab的机器至少要有4G的内存，因为gitlab比较消耗内存</p><p>（2）安装必要的依赖并配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum install -y curl policycoreutils-python openssh-server<br>sudo systemctl <span class="hljs-built_in">enable</span> sshd<br>sudo systemctl start sshd<br>sudo firewall-cmd --permanent --add-service=http<br>sudo systemctl reload firewalld<br></code></pre></td></tr></table></figure><p>（3）添加gitlab仓库地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建gitlab-ce.repo文件</span><br><span class="hljs-built_in">cd</span> /etc/yum.repos.d/<br>vim gitlab-ce.repo<br><span class="hljs-comment"># 文件内容为</span><br>[gitlab-ce]<br>name=Gitlab CE Repository<br>baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el<span class="hljs-variable">$releasever</span>/<br>gpgcheck=0<br>enabled=1<br></code></pre></td></tr></table></figure><p>（4）设置gitlab域名并安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo EXTERNAL_URL=<span class="hljs-string">&quot;https://gitlab.jack.com&quot;</span> yum install -y gitlab-ce<br></code></pre></td></tr></table></figure><p>（5）配置windows的hosts文件 </p><p>（6）访问：<a href="https://gitlab.jack.com/">https://gitlab.jack.com</a> </p><p>（7）查看root账号的密码，后面可以修改一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> /etc/gitlab/initial_root_password<br></code></pre></td></tr></table></figure><p>（8）gitlab常见操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">（1）vim /etc/gitlab/gitlab.rb 找到对应修改内容<br>（2）gitlab-ctl reconfigure 重新加载一下配置<br>（3）gitlab-ctl status 查看gitlab状态<br>（4）sudo gitlab-ctl stop 停止gitlab<br>（5）sudo gitlab-ctl start 开启gitlab<br></code></pre></td></tr></table></figure><h2 id="4-项目关联Gitlab"><a href="#4-项目关联Gitlab" class="headerlink" title="4  项目关联Gitlab"></a>4  项目关联Gitlab</h2><p>（1）将公钥上传到gitlab：右上角-&gt;Preferences-&gt;SSH Keys</p><p>（2）在gitlab上创建名称为“springboot-demo”的project</p><p>（3）将本地项目push到gitlab上</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 使用terminal打开项目的根目录</span><br>git init<br>git add .<br>git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br>git remote add jack-gitlab git@gitlab.jack.com:root/springboot-demo.git<br>git remote -v<br>git push -u jack-gitlab master<br></code></pre></td></tr></table></figure><h2 id="5-安装配置Jenkins"><a href="#5-安装配置Jenkins" class="headerlink" title="5 安装配置Jenkins"></a>5 安装配置Jenkins</h2><blockquote><p>因为后面需要在jenkins的目录下创建文件执行，所以选择K8s集群中的一台node作为Jenkins的安装机器，比如这里选用w2，也就是192.168.0.53</p></blockquote><p>官网：<a href="https://jenkins.io/">https://jenkins.io/</a></p><p>（1）下载jenkins.war </p><p>（2）运行jenkins</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">nohup</span> java -jar jenkins.war --httpPort=8888 &amp;<br>lsof -i:8888<br><span class="hljs-built_in">tail</span> -f nohup.out<br></code></pre></td></tr></table></figure><p>（3）浏览器访问：192.168.0.53:8888</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">密码: cat <span class="hljs-regexp">/root/</span>.jenkins<span class="hljs-regexp">/secrets/i</span>nitialAdminPassword<br>然后会等待一会，包括镜像拉取以及插件安装[选择推荐的插件]<br></code></pre></td></tr></table></figure><p>（4）新建用户</p><p>（5）配置Jenkins URL</p><p><img src="/image/k8s/10.png"></p><p>（7）配置java maven和git等：Dashboard-&gt; Manage Jenkins-&gt; Global Tool Configuration</p><p><img src="/image/k8s/11.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 配置一下w2这台机器的git信息</span><br>git config --global user.name <span class="hljs-string">&quot;hiourearth&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;hiourearth@gmail.com&quot;</span><br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;hiourearth@gmail.com&quot;</span><br><span class="hljs-built_in">cat</span> /root/.ssh/id_rsa.pub<br><span class="hljs-comment"># 将公钥上传到gitlab上</span><br></code></pre></td></tr></table></figure><p><img src="/image/k8s/12.png"></p><h2 id="6-准备Docker-Hub和K8s集群"><a href="#6-准备Docker-Hub和K8s集群" class="headerlink" title="6 准备Docker Hub和K8s集群"></a>6 准备Docker Hub和K8s集群</h2><p>（1）Docker Hub：直接使用阿里容器镜像仓库，在w2这台机器上登录一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo docker login --username=hiourearth registry.cn-hangzhou.aliyuncs.com<br></code></pre></td></tr></table></figure><p>（2）K8s集群：就用之前搭建的3台机器组成的K8s集群</p><p>（3）目前的环境：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Gitlab</span>: git@gitlab.jack.com:root/springboot-demo.git<br><span class="hljs-attribute">Jenkins</span>: <span class="hljs-number">192.168.2.53:8888</span><br><span class="hljs-attribute">Docker</span> hub: hiourearth<br><span class="hljs-attribute">K8s</span> cluster: <span class="hljs-number">192.168.0.51</span> <span class="hljs-number">52</span> <span class="hljs-number">53</span><br></code></pre></td></tr></table></figure><h2 id="7-Jenkins拉取项目"><a href="#7-Jenkins拉取项目" class="headerlink" title="7 Jenkins拉取项目"></a>7 Jenkins拉取项目</h2><p>（1）创建Jenkins的Task</p><p><img src="/image/k8s/13.png"></p><p>（2）在w2上配置hosts： vim /etc/hosts</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">192.168.0.8 gitlab.jack.com<br><span class="hljs-comment"># 测试git是否配置成功</span><br>ssh -T git@gitlab.jack.com<br></code></pre></td></tr></table></figure><p>（3）流水线中编写拉取代码的脚本，然后点击“保存”</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">node &#123;<br>def mvnHome<br>stage(<span class="hljs-string">&#x27;Git Pull&#x27;</span>) &#123; // <span class="hljs-keyword">for</span> display purposes<br>git <span class="hljs-string">&#x27;git@gitlab.jack.com:root/springboot-demo.git&#x27;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）来到“Dashboard”，并点击执行按钮</p><p>（5）到w2这台机器上，观察/root/.jenkins/workspace目录，看看项目是否拉取成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> /root/.jenkins/workspace/springbootdemo/src/main/java/com/jack/springbootdemo/SpringbootDemoApplication.java<br></code></pre></td></tr></table></figure><h2 id="8-Jenkins-Maven打包"><a href="#8-Jenkins-Maven打包" class="headerlink" title="8  Jenkins Maven打包"></a>8  Jenkins Maven打包</h2><p>（1）新增一个脚本语句</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">node &#123;<br>def mvnHome<br>stage(<span class="hljs-string">&#x27;Git Pull&#x27;</span>) &#123; // <span class="hljs-keyword">for</span> display purposes<br>git <span class="hljs-string">&#x27;git@gitlab.jack.com:root/springboot-demo.git&#x27;</span><br>&#125;<br>stage(<span class="hljs-string">&#x27;Maven Build&#x27;</span>) &#123;<br>sh <span class="hljs-string">&quot;mvn clean package&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）观察worspace目录下是否生成target文件</p><h2 id="9-构建和push镜像"><a href="#9-构建和push镜像" class="headerlink" title="9 构建和push镜像"></a>9 构建和push镜像</h2><p>（1）来到w2上的workspace目录：cd /root/.jenkins/workspace</p><p>（2）在scripts目录下准备一个文件，名称为springboot-demo-build-image.sh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> /root/.jenkins/workspace/scripts/<br>vim /root/.jenkins/workspace/scripts/springboot-demo-build-image.sh<br></code></pre></td></tr></table></figure><p>（3）编辑sh文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入到kubernetes-demo目录</span><br><span class="hljs-built_in">cd</span> ../springboot-demo<br><span class="hljs-comment"># 编写Dockerfile文件</span><br><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt; Dockerfile</span><br><span class="hljs-string">FROM openjdk:8-jre-alpine</span><br><span class="hljs-string">COPY target/springboot-demo-0.0.1-SNAPSHOT.jar springboot-demo.jar</span><br><span class="hljs-string">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;springboot-demo.jar&quot;]</span><br><span class="hljs-string">EOF</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Dockerfile created successfully!&quot;</span><br><span class="hljs-comment"># 基于指定目录下的Dockerfile构建镜像</span><br>docker build -t registry.cn-hangzhou.aliyuncs.com/jack-kubernetes/springbootdemo-image .<br><span class="hljs-comment"># push镜像，这边需要阿里云镜像仓库登录，记得提前在w2上登录一下</span><br>docker push registry.cn-hangzhou.aliyuncs.com/jack-kubernetes/springboot-demoimage<br></code></pre></td></tr></table></figure><p>（4）踩坑经验</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 01 文件权限</span><br>/root/.jenkins/workspace/scripts/springboot-demo-build-image.sh: Permission denied<br><span class="hljs-comment"># 解决</span><br><span class="hljs-built_in">chmod</span> +x /root/.jenkins/workspace/scripts/springboot-demo-build-image.sh<br><br><span class="hljs-comment"># 02 docker没有运行</span><br>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?<br><span class="hljs-comment"># 解决</span><br>systemctl start docker<br>systemctl <span class="hljs-built_in">enable</span> docker<br><br><span class="hljs-comment"># 03 push权限</span><br>docker login --username=hiourearth registry.cn-hangzhou.aliyuncs.com<br></code></pre></td></tr></table></figure><p>（5）jenkins上添加脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">node &#123;<br>def mvnHome<br>stage(<span class="hljs-string">&#x27;Git Pull&#x27;</span>) &#123; // <span class="hljs-keyword">for</span> display purposes<br>git <span class="hljs-string">&#x27;git@gitlab.jack.com:root/dockerfile-demo.git&#x27;</span><br>&#125;<br>stage(<span class="hljs-string">&#x27;Maven Build&#x27;</span>) &#123;<br>sh <span class="hljs-string">&quot;mvn clean package&quot;</span><br>&#125;<br>stage(<span class="hljs-string">&#x27;Build Image&#x27;</span>) &#123;<br>sh <span class="hljs-string">&quot;/root/.jenkins/workspace/scripts/springboot-demo-build-image.sh&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（6）jenkins构建，并查看阿里镜像仓库</p><h2 id="10-K8s拉取镜像并运行"><a href="#10-K8s拉取镜像并运行" class="headerlink" title="10  K8s拉取镜像并运行"></a>10  K8s拉取镜像并运行</h2><p>（1）在/root/.jenkins/workspace/scripts/目录下创建springboot-demo.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 以Deployment部署Pod</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-demo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">springboot-demo</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">springboot-demo</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-demo</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">registry.cn-hangzhou.aliyuncs.com/jack-kubernetes/springbootdemo-image</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 创建Pod的Service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">springboot-demo</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 创建Ingress，定义访问规则，一定要记得提前创建好nginx ingress controller</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-ingress</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">kubernetes.io/ingress.class:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">springboot.jack.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-service</span><br>            <span class="hljs-attr">port:</span><br>              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>（2）在/root/.jenkins/workspace/scripts/目录创建K8s-deploy-springboot-demo.sh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl delete -f /root/.jenkins/workspace/scripts/springboot-demo.yaml<br>kubectl apply -f /root/.jenkins/workspace/scripts/springboot-demo.yaml<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;K8s deploy success!&quot;</span><br></code></pre></td></tr></table></figure><p>（3）踩坑经历</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 01 权限</span><br>/root/.jenkins/workspace/scripts/K8s-deploy-springboot-demo.sh: Permission denied<br><span class="hljs-comment"># 解决</span><br><span class="hljs-built_in">chmod</span> +x /root/.jenkins/workspace/scripts/K8s-deploy-springboot-demo.sh<br><br><span class="hljs-comment"># 02 w2执行不了kubectl</span><br>切换到master上，<span class="hljs-built_in">cd</span> ~ ---&gt; <span class="hljs-built_in">cat</span> .kube/config ---&gt;复制内容<br>切换到worker02上 <span class="hljs-built_in">cd</span> ~ ---&gt; 新建文件 .kube/config ---&gt;粘贴内容<br></code></pre></td></tr></table></figure><p>（4）增加Jenkins中的脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">node &#123;<br>def mvnHome<br>stage(<span class="hljs-string">&#x27;Git Pull&#x27;</span>) &#123; // <span class="hljs-keyword">for</span> display purposes<br>git <span class="hljs-string">&#x27;git@gitlab.jack.com:root/springboot-demo.git&#x27;</span><br>&#125;<br>stage(<span class="hljs-string">&#x27;Maven Build&#x27;</span>) &#123;<br>sh <span class="hljs-string">&quot;mvn clean package&quot;</span><br>&#125;<br>stage(<span class="hljs-string">&#x27;Build Image&#x27;</span>) &#123;<br>sh <span class="hljs-string">&quot;/root/.jenkins/workspace/scripts/springboot-demo-build-image.sh&quot;</span><br>&#125;<br>stage(<span class="hljs-string">&#x27;K8S Deploy&#x27;</span>) &#123;<br>sh <span class="hljs-string">&quot;/root/.jenkins/workspace/scripts/K8s-deploy-springboot-demo.sh&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）jenkins构建，并查看K8s集群中image和资源</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get pods<br>kubectl get deploy<br>kubectl get service<br></code></pre></td></tr></table></figure><p>（6）浏览器访问</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>springboot.jack.com/K8s<br></code></pre></td></tr></table></figure><h2 id="11-webhook测试自动化部署"><a href="#11-webhook测试自动化部署" class="headerlink" title="11 webhook测试自动化部署"></a>11 webhook测试自动化部署</h2><p>（1）当用户进行git push提交代码到github时，能够通知jenkins自动构建 </p><p>注意：jenkins的ip一定要是gitlab能够访问到的地址 </p><p>（2）打开jenkins中springboot-demo pipeline，构建触发器，记录下触发器的地址：<a href="http://192.168.0.53:8888/project/springboot-demo">http://192.168.0.53:8888/project/springboot-demo</a></p><p><img src="/image/k8s/14.png"></p><p>（3）在gitlab上配置webhook的地址，即jenkins对应的触发器地址： <a href="http://192.168.0.53:8888/project/springboot-demo%EF%BC%8C%E7%84%B6%E5%90%8E%E7%82%B9%E5%87%BB%E4%B8%8B%E6%96%B9%E7%9A%84%E2%80%9CAdd">http://192.168.0.53:8888/project/springboot-demo，然后点击下方的“Add</a> webhook”</p><p><img src="/image/k8s/15.png"></p><p>（4）当提示“Url is blocked: Requests to the local network are not allowed”，需要做一下设置，以 root账号登录gitlab，然后再配置一下第（2）步</p><p><img src="/image/k8s/16.png"></p><p>（5）安装Jenkins插件</p><blockquote><p>Dashboard-&gt; Manage Jenkins-&gt; Manage Plugins-&gt; 可选插件</p><p>搜索 : gitlab plugin和gitlab hook 并安装</p></blockquote><p><img src="/image/k8s/17.png"></p><p>（6）因为是测试环境，所以暂时可以先不配置jenkins需要的token，也就是说在Jenkins中取消Gitlab Server的认证</p><blockquote><p>Dashboard-&gt; Manage Jenkins-&gt; Configure System</p></blockquote><p><img src="/image/k8s/18.png"></p><p>（7）测试一下Push Event</p><p>（8）整体测试 </p><p>打开idea工程，更改代码，git add/commit/push，观察springboot-demo构建任务的变化，最终通过浏览器访问springboot.jack.com</p>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes基础使用以及网络分析</title>
    <link href="/2023/04/28/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/k8s/Kubernetes%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90/"/>
    <url>/2023/04/28/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/k8s/Kubernetes%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基础操作"><a href="#1-基础操作" class="headerlink" title="1 基础操作"></a>1 基础操作</h2><h3 id="1-1-Pod"><a href="#1-1-Pod" class="headerlink" title="1.1 Pod"></a>1.1 Pod</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#查看Pod详情信息</span><br>kubectl describe pod pod-name -n ns<br><br><span class="hljs-comment">#Status</span><br>挂起（Pending）：Pod已被K8s系统接受，但有一个或多个容器镜像尚未创建，等待时间包括调度Pod的时间和通过网络下载镜像的时间，着可能需要花点时间。<br>运行中（Running）：Pod已经绑定到了一个节点上，Pod中所有的容器都已被创建，至少有一个容器正在运行，或者正处于启动或重启状态。<br>成功（Successed）：Pod中的所有容器都被成功终止，并且不会再次重启。<br>失败（Failed）：Pod中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非0状态退出或者被系统终止。<br>未知（Unknown）：因为某些原因无法取得Pod的状态，通常是因为与Pod所在主机通信失败。<br></code></pre></td></tr></table></figure><h3 id="1-2-ReplicaSet-RS"><a href="#1-2-ReplicaSet-RS" class="headerlink" title="1.2 ReplicaSet(RS)"></a>1.2 ReplicaSet(RS)</h3><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/</a></p><p>（1）创建frontend.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">aapiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">frontend</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">guestbook</span><br>    <span class="hljs-attr">tier:</span> <span class="hljs-string">frontend</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-comment"># modify replicas according to your case</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">tier:</span> <span class="hljs-string">frontend</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">tier:</span> <span class="hljs-string">frontend</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">php-redis</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">gcr.io/google_samples/gb-frontend:v3</span><br></code></pre></td></tr></table></figure><p>（2）常见操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#创建Pod</span><br>kubectl apply -f frontend.yaml<br><br><span class="hljs-comment">#查看Pod</span><br>kubectl get pods<br>kubectl get pods -o wide<br><br><span class="hljs-comment">#查看rs资源</span><br>kubectl get rs<br>kubectl describe rs frontend<br><br><span class="hljs-comment">#对Pod进行扩缩容</span><br>kubectl scale rs frontend --replicas=5<br><br><span class="hljs-comment">#删除单个Pod</span><br>kubectl delete pods frontendd-21tc9<br><br><span class="hljs-comment">#删除rs</span><br>kubectl delete -f frontend.yaml<br></code></pre></td></tr></table></figure><h3 id="1-3-Deployment"><a href="#1-3-Deployment" class="headerlink" title="1.3 Deployment"></a>1.3 Deployment</h3><p>（1）创建nginx-deployment.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.14.2</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>（2）常见操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建Pod</span><br>kubectl apply -f nginx-deployment.yaml<br><br><span class="hljs-comment"># 查看Pod</span><br>kubectl get pods<br>kubectl get pods -o wide<br><br><span class="hljs-comment"># 查看deployment资源</span><br>kubectl get deploy<br>kubectl describe deploy nginx-deployment<br><br><span class="hljs-comment"># 对Pod进行扩缩容</span><br>kubectl scale deploy nginx-deployment --replicas=5<br><br><span class="hljs-comment"># 删除单个Pod</span><br>kubectl delete pods nginx-deployment-9456bbbf9-77ljp<br><br><span class="hljs-comment"># 删除rs</span><br>kubectl delete -f nginx-deployment.yaml<br><br><span class="hljs-comment"># 查看当前nginx的版本</span><br>kubectl get deploy -o wide<br><br><span class="hljs-comment"># 更新nginx的版本为1.16.1</span><br>kubectl <span class="hljs-built_in">set</span> image deployment/nginx-deployment nginx=nginx:1.16.1<br>kubectl get deploy -o wide<br></code></pre></td></tr></table></figure><h3 id="1-4-Label-and-Selector"><a href="#1-4-Label-and-Selector" class="headerlink" title="1.4  Label and Selector"></a>1.4  Label and Selector</h3><p><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/">https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-comment"># 表示该deployment具有一个label，key为app，value为nginx，可以通过kubectl getdeploy --show-labels 查看</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span> <span class="hljs-comment"># 表示该deployment管理的Pod匹配条件，而这个条件是根据label进行匹配的</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span> <span class="hljs-comment"># 定义一个Pod的模板</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span> <span class="hljs-comment"># 表示该pod具有一个label，key为app，value为nginx，可以通过kubectl get pods --show-labels 查看</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.14.2</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h3 id="1-5-Namespace"><a href="#1-5-Namespace" class="headerlink" title="1.5 Namespace"></a>1.5 Namespace</h3><p><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/">https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#查看命名空间</span><br>kubectl get namespace<br>kubectl get ns<br><br><span class="hljs-comment">#创建命名空间</span><br>kubectl create namespace test-ns<br>kubectl get ns<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#定义podyaml：nginx-pod-ns.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">jack-ns</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#构建Pod</span><br>kubectl apply -f nginx-pod-ns.yaml<br><br><span class="hljs-comment">#查看指定命名空间下的资源</span><br>kubectl get pods<br>kubectl get pods -n test-ns<br>kubectl get all -n test-ns<br>kubectl get pods --all-namespaces<br></code></pre></td></tr></table></figure><h2 id="2-Network"><a href="#2-Network" class="headerlink" title="2 Network"></a>2 Network</h2><h3 id="2-1-Pod-Network"><a href="#2-1-Pod-Network" class="headerlink" title="2.1 Pod Network"></a>2.1 Pod Network</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建两个Pod</span><br>kubectl run nginx --image=nginx<br>kubectl run tomcat --image=tomcat:8.0<br><span class="hljs-comment"># 查看两个Pod详情</span><br>kubectl get pods -o wide<br><span class="hljs-comment"># 结果输出</span><br>NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES<br>nginx 1/1 Running 0 2m 10.244.190.76 w1 &lt;none&gt; &lt;none&gt;<br>tomcat 1/1 Running 0 17s 10.244.80.205 w2 &lt;none&gt; &lt;none&gt;<br><span class="hljs-comment"># 任意一台node访问pod_ip</span><br>curl 10.244.190.76<br>curl 10.244.80.205:8080<br><span class="hljs-comment"># 进入nginx pod中访问tomcat pod</span><br>kubectl <span class="hljs-built_in">exec</span> -it nginx bash<br>curl 10.244.80.205:8080<br><span class="hljs-comment"># 进入tomcat pod中访问物理机</span><br>kubectl <span class="hljs-built_in">exec</span> -it tomcat bash<br>ping 192.168.0.52<br>ping 192.168.0.53<br></code></pre></td></tr></table></figure><p>在K8s Cluster中，通过Calico网络插件，可以实现Node访问Pod、Pod之间通信以及Pod访问 Node</p><p><img src="/image/k8s/9.png"></p><h3 id="2-2-Service"><a href="#2-2-Service" class="headerlink" title="2.2 Service"></a>2.2 Service</h3><p>对于上述的Pod虽然实现了集群内部互相通信，但是Pod是不稳定的，比如通过Deployment管理 Pod，随时可能对Pod进行扩缩容，这时候Pod的IP地址是变化的。能够有一个固定的IP，使得集群内能够访问。也就是之前在架构描述的时候所提到的，能够把相同或者具有关联的Pod，打上Label，组成 Service。而Service有固定的IP，不管Pod怎么创建和销毁，都可以通过Service的IP进行访问。</p><p><a href="https://kubernetes.io/docs/concepts/services-networking/service/">https://kubernetes.io/docs/concepts/services-networking/service/</a></p><h4 id="2-2-1-ClusterIP"><a href="#2-2-1-ClusterIP" class="headerlink" title="2.2.1  ClusterIP"></a>2.2.1  ClusterIP</h4><p>（1）创建whoami-deployment.yaml文件，并且apply</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">whoami-deployment</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">whoami</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">whoami</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">whoami</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">whoami</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">jwilder/whoami</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8000</span><br></code></pre></td></tr></table></figure><p>（2）查看pod以及service</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get pods -o wide<br>kubectl get service<br></code></pre></td></tr></table></figure><p>（3）通过pod_ip进行访问</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl pod_ip:8000<br></code></pre></td></tr></table></figure><p>（4）创建whoami pod的service，定义whoami-serivce.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">whoami-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">whoami</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8000</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span><br></code></pre></td></tr></table></figure><p>（5）查看service</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get service<br>kubectl describe service whoami-service<br></code></pre></td></tr></table></figure><p>（6）访问service</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl service_ip<br><span class="hljs-keyword">while</span> <span class="hljs-built_in">sleep</span> 0.2; <span class="hljs-keyword">do</span> curl service_ip; <span class="hljs-keyword">done</span>;<br></code></pre></td></tr></table></figure><p>（7）对pod进行扩容，然后再次访问</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl scale deployment whoami-deployment --replicas=5<br>kubectl get pods<br><span class="hljs-keyword">while</span> <span class="hljs-built_in">sleep</span> 0.2; <span class="hljs-keyword">do</span> curl service_ip; <span class="hljs-keyword">done</span>;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-NodePort"><a href="#2-2-2-NodePort" class="headerlink" title="2.2.2  NodePort"></a>2.2.2  NodePort</h4><p>因为外部能够访问到集群的物理机器IP，所以就是在集群中每台物理机器上暴露一个相同的 IP，比如32008</p><p>（1）修改whoami-service.yaml文件中的类型为NodePort</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">whoami-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">whoami</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8000</span><br>    <span class="hljs-attr">nodePort:</span> <span class="hljs-number">32008</span> <span class="hljs-comment"># 可以指定一个物理机上不重复的端口，范围在20000-40000之间</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span> <span class="hljs-comment"># 把ClusterIP修改成NodePort</span><br></code></pre></td></tr></table></figure><p>（2）查看service</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get service<br>kubectl describe service whoami-service<br></code></pre></td></tr></table></figure><p>（3）访问测试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl centos_ip:32008<br></code></pre></td></tr></table></figure><h4 id="2-2-3-Ingress"><a href="#2-2-3-Ingress" class="headerlink" title="2.2.3  Ingress"></a>2.2.3  Ingress</h4><p>（1）创建tomcat pod和tomcat service，定义在tomcat.yaml文件中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">tomcat-deployment</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">tomcat</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">tomcat</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">tomcat</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tomcat</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">tomcat:8.0</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">tomcat-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">tomcat</span><br></code></pre></td></tr></table></figure><p>（2）运行tomcat.yaml并查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f tomcat.yaml<br>kubectl get svc<br>kubectl get pods<br>curl tomcat-pod_ip:8080<br>curl tomcat-service_ip<br></code></pre></td></tr></table></figure><p>（3）以Deployment Pod的方式创建Nginx Ingress Controller，文件名称为nginx-ingresscontroller.yaml</p><blockquote><p>文件内容：<a href="https://kubernetes.github.io/ingress-nginx/deploy/#quick-start">https://kubernetes.github.io/ingress-nginx/deploy/#quick-start</a></p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 给w1添加label，这样在nginx-ingress-controller.yaml中搜索&quot;nodeSelector&quot;时，就可以根据name: ingress进行匹配了</span><br>kubectl label node w1 name=ingress<br>kubectl get nodes --show-labels<br>kubectl get node w1 --show-labels<br><span class="hljs-comment"># 在nginx-ingress-controller.yaml中添加一行配置，可以在nodeSelector上面一行添加</span><br>hostNetwork: <span class="hljs-literal">true</span><br><span class="hljs-comment"># 将nginx-ingress-controller.yaml中的3个image替换成阿里镜像仓库中的内容</span><br>registry.cn-hangzhou.aliyuncs.com/jack-kubernetes/ingress-nginx-controller<br>registry.cn-hangzhou.aliyuncs.com/jack-kubernetes/kube-webhook-certgen<br>registry.cn-hangzhou.aliyuncs.com/jack-kubernetes/kube-webhook-certgen<br><span class="hljs-comment"># 运行yaml文件</span><br>kubectl apply -f nginx-ingress-controller.yaml<br><span class="hljs-comment"># 这样w1上的80和443端口就会被nginx-ingress-controller使用</span><br>lsof -i:80<br>lsof -i:443<br><span class="hljs-comment"># 查看资源</span><br>kubectl get pods -n ingress-nginx -o wide<br>kubectl get all -n ingress-nginx<br></code></pre></td></tr></table></figure><p>（4）定义ingress规则</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#ingress</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-ingress</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">tomcat.jack.tomcat</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>          <span class="hljs-attr">backend:</span><br>            <span class="hljs-attr">serviceName:</span> <span class="hljs-string">tomcat-service</span><br>            <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>（5）应用并查看ingress规则</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f nginx-ingress.yaml<br>kubectl get ingress<br>kubectl describe ingress nginx-ingress<br>kubectl get service<br>kubectl get pods<br></code></pre></td></tr></table></figure><p>（6）在win上配置hosts文件</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.0.52</span> tomcat.jack.com<br></code></pre></td></tr></table></figure><p>（7）访问tomcat.jack.com</p>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes初识</title>
    <link href="/2023/04/27/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/k8s/Kubernetes%E5%88%9D%E8%AF%86/"/>
    <url>/2023/04/27/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/k8s/Kubernetes%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-K8s基本概念"><a href="#1-K8s基本概念" class="headerlink" title="1 K8s基本概念"></a>1 K8s基本概念</h2><p>官网：<a href="https://kubernetes.io/">https://kubernetes.io/</a></p><p>Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态，其服务、支持和工具的使用范围相当广泛。Kubernetes 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有八个字符的关系。</p><h3 id="1-1-核心组件概念"><a href="#1-1-核心组件概念" class="headerlink" title="1.1 核心组件概念"></a>1.1 核心组件概念</h3><h4 id="1-1-1-Container-容器"><a href="#1-1-1-Container-容器" class="headerlink" title="1.1.1 Container-容器"></a>1.1.1 Container-容器</h4><p>每个运行的容器都是可重复的； 包含依赖环境在内的标准，意味着无论你在哪里运行它都会得到相同的行为。容器将应用程序从底层的主机设施中解耦。 这使得在不同的云或 OS 环境中部署更加容易。Kubernetes 集群中的每个<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点</a>都会运行容器， 这些容器构成分配给该节点的 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a>。也就是Docker通过Image创建的Container。</p><p><img src="/image/k8s/1.png"></p><h4 id="1-1-2-Pod"><a href="#1-1-2-Pod" class="headerlink" title="1.1.2 Pod"></a>1.1.2 Pod</h4><p>Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。其中包含一个或多个Container。</p><p><img src="/image/k8s/2.png"></p><p>下面是一个 Pod 示例，它由一个运行镜像 <code>nginx:1.14.2</code> 的容器组成。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#simple-pod.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.14.2</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>要创建上面显示的 Pod，请运行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f simple-pod.yaml<br></code></pre></td></tr></table></figure><h4 id="1-1-3-ReplicaSet"><a href="#1-1-3-ReplicaSet" class="headerlink" title="1.1.3 ReplicaSet"></a>1.1.3 ReplicaSet</h4><p>ReplicaSet 的目的是维护一组在任何时候都处于运行状态的 Pod 副本的稳定集合。 因此，它通常用来保证给定数量的、完全相同的 Pod 的可用性。</p><p>ReplicaSet 确保任何时间都有指定数量的 Pod 副本在运行。 然而，Deployment 是一个更高级的概念，它管理 ReplicaSet，并向 Pod 提供声明式的更新以及许多其他有用的功能。 因此，我们建议使用 Deployment 而不是直接使用 ReplicaSet， 除非你需要自定义更新业务流程或根本不需要更新。这实际上意味着，可能永远不需要操作 ReplicaSet 对象：而是使用 Deployment。</p><p><img src="/image/k8s/3.png"></p><h4 id="1-1-4-Deployment"><a href="#1-1-4-Deployment" class="headerlink" title="1.1.4 Deployment"></a>1.1.4 Deployment</h4><p>一个 Deployment 为 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a> 和 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a> 提供声明式的更新能力。</p><p><img src="/image/k8s/4.png"></p><h4 id="1-1-5-Label-标签"><a href="#1-1-5-Label-标签" class="headerlink" title="1.1.5 Label-标签"></a>1.1.5 Label-标签</h4><p><strong>标签（Labels）</strong> 是附加到 Kubernetes 对象（比如 Pod）上的键值对。 标签旨在用于指定对用户有意义且相关的对象的标识属性，但不直接对核心系统有语义含义。 标签可以用于组织和选择对象的子集。标签可以在创建时附加到对象，随后可以随时添加和修改。 每个对象都可以定义一组键/值标签。每个键对于给定对象必须是唯一的。标签能够支持高效的查询和监听操作。</p><p><img src="/image/k8s/5.png"></p><h4 id="1-1-6-Service-服务"><a href="#1-1-6-Service-服务" class="headerlink" title="1.1.6 Service-服务"></a>1.1.6 Service-服务</h4><p>Kubernetes 中 Service 是 将运行在一个或一组 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a> 上的网络应用程序公开为网络服务的方法。具有相同标签Label的pod的集合。</p><p><img src="/image/k8s/6.png"></p><h4 id="1-1-7-Node-节点"><a href="#1-1-7-Node-节点" class="headerlink" title="1.1.7 Node-节点"></a>1.1.7 Node-节点</h4><p>Kubernetes 通过将容器放入在节点（Node）上运行的 Pod 中来执行你的工作。节点可以是一个虚拟机或者物理机器，取决于所在的集群配置。</p><p><img src="/image/k8s/7.png"></p><h4 id="1-1-8-Node-Cluster"><a href="#1-1-8-Node-Cluster" class="headerlink" title="1.1.8 Node Cluster"></a>1.1.8 Node Cluster</h4><p><img src="/image/k8s/8.png"></p><h3 id="1-2-K8s架构"><a href="#1-2-K8s架构" class="headerlink" title="1.2 K8s架构"></a>1.2 K8s架构</h3><p><img src="/image/k8s/K8s%E6%9E%B6%E6%9E%84.jpg"></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-number">01</span>-总得要有一个操作集群的客户端，也就是和集群打交道<br>kubectl<br><span class="hljs-number">02</span>-请求肯定是到达<span class="hljs-keyword">Master</span> <span class="hljs-title">Node</span>，然后再分配给Worker <span class="hljs-keyword">Node</span><span class="hljs-title">创建Pod</span>之类的<br>关键是命令通过kubectl过来之后，需要认证授权<br><span class="hljs-number">03</span>-请求过来之后，<span class="hljs-keyword">Master</span> <span class="hljs-title">Node</span>中谁来接收？<br>APIServer<br><span class="hljs-number">04</span>-API收到请求之后，接下来调用哪个Worker <span class="hljs-keyword">Node</span><span class="hljs-title">创建Pod</span>，Container之类的，得要有调度策略<br>Scheduler<br>[https://kubernetes.io/docs/concepts/scheduling/kube-scheduler/]<br><span class="hljs-number">05</span>-Scheduler通过不同的策略，真正要分发请求到不同的Worker <span class="hljs-keyword">Node</span><span class="hljs-title">上创建内容，具体谁负责？</span><br><span class="hljs-title">Controller</span> Manager<br><span class="hljs-number">06</span>-Worker <span class="hljs-keyword">Node</span><span class="hljs-title">接收到创建请求之后，具体谁来负责</span><br><span class="hljs-title">Kubelet</span>服务，最终Kubelet会调用Docker Engine，创建对应的容器[这边是不是也反应出一点，在<span class="hljs-keyword">Node</span><span class="hljs-title">上需要有Docker</span> Engine，不然怎么创建维护容器？]<br><span class="hljs-number">07</span>-会不会涉及到域名解析的问题？<br>DNS<br><span class="hljs-number">08</span>-是否需要有监控面板能够监测整个集群的状态？<br>Dashboard<br><span class="hljs-number">09</span>-集群中节点的数据如何保存？分布式存储<br>ETCD<br><span class="hljs-number">10</span>-至于像容器的持久化存储，网络等可以先类比一下Docker中的内容<br></code></pre></td></tr></table></figure><h2 id="2-K8s安装"><a href="#2-K8s安装" class="headerlink" title="2 K8s安装"></a>2 K8s安装</h2><h3 id="2-1-K8s的常见安装方式"><a href="#2-1-K8s的常见安装方式" class="headerlink" title="2.1 K8s的常见安装方式"></a>2.1 K8s的常见安装方式</h3><ol><li>最难的方式，需要自己手动安装搭建K8s架构中的各个组件</li></ol><p><a href="https://github.com/kelseyhightower">https://github.com/kelseyhightower</a></p><ol start="2"><li>最简单的方式，在线体验</li></ol><p><a href="https://labs.play-with-k8s.com/">https://labs.play-with-k8s.com/</a></p><ol start="3"><li>第三方服务：阿里ACK，腾讯TKE</li></ol><p>阿里ACK：<a href="https://www.aliyun.com/product/kubernetes">https://www.aliyun.com/product/kubernetes</a></p><p>腾讯TKE：<a href="https://cloud.tencent.com/product/tke">https://cloud.tencent.com/product/tke</a></p><ol start="4"><li>minikube</li></ol><p><a href="https://minikube.sigs.k8s.io/docs/start/">https://minikube.sigs.k8s.io/docs/start/</a></p><ol start="5"><li>kubeadm</li></ol><p><a href="https://github.com/kubernetes/kubeadm">https://github.com/kubernetes/kubeadm</a></p><h3 id="2-2-kubeadm搭建K8s集群"><a href="#2-2-kubeadm搭建K8s集群" class="headerlink" title="2.2 kubeadm搭建K8s集群"></a>2.2 kubeadm搭建K8s集群</h3><h4 id="2-2-1-版本选择"><a href="#2-2-1-版本选择" class="headerlink" title="2.2.1 版本选择"></a>2.2.1 版本选择</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">centos7</span><br><span class="hljs-attribute">Docker</span> Community: <span class="hljs-number">20</span>.<span class="hljs-number">10</span>.<span class="hljs-number">7</span><br><span class="hljs-attribute">K8s</span> Version: v1.<span class="hljs-number">23</span>.<span class="hljs-number">14</span><br><span class="hljs-attribute">Calico</span> Version: v3.<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h4 id="2-2-2-准备centos机器"><a href="#2-2-2-准备centos机器" class="headerlink" title="2.2.2 准备centos机器"></a>2.2.2 准备centos机器</h4><blockquote><p>配置要求：每台机器至少2C2G，不然运行不起来</p></blockquote><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.0.51</span> master<br><span class="hljs-number">192.168.0.52</span> worker01<br><span class="hljs-number">192.168.0.53</span> worker02<br></code></pre></td></tr></table></figure><h4 id="2-2-3-安装Docker"><a href="#2-2-3-安装Docker" class="headerlink" title="2.2.3 安装Docker"></a>2.2.3 安装Docker</h4><blockquote><p>3台机器</p></blockquote><p>安装步骤查看docker专题</p><h4 id="2-2-4-安装依赖和更新"><a href="#2-2-4-安装依赖和更新" class="headerlink" title="2.2.4 安装依赖和更新"></a>2.2.4 安装依赖和更新</h4><blockquote><p>3台机器</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum -y update<br>yum install -y conntrack ipvsadm ipset jq sysstat curl iptables libseccomp<br></code></pre></td></tr></table></figure><h4 id="2-2-5-修改hosts文件"><a href="#2-2-5-修改hosts文件" class="headerlink" title="2.2.5 修改hosts文件"></a>2.2.5 修改hosts文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#1.master</span><br>sudo hostnamectl set-hostname m<br>vi /etc/hosts<br>192.168.0.51 m<br>192.168.0.52 w1<br>192.168.0.53 w2<br><br><span class="hljs-comment">#2.2台worker</span><br>sudo hostnamectl set-hostname w1/w2<br>vi /etc/hosts<br>192.168.0.51 m<br>192.168.0.52 w1<br>192.168.0.53 w2<br><br><span class="hljs-comment">#3.彼此ping测试一下</span><br></code></pre></td></tr></table></figure><h4 id="2-2-6-系统基础配置"><a href="#2-2-6-系统基础配置" class="headerlink" title="2.2.6 系统基础配置"></a>2.2.6 系统基础配置</h4><blockquote><p>3台机器</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># (1)关闭防火墙</span><br>systemctl stop firewalld &amp;&amp; systemctl <span class="hljs-built_in">disable</span> firewalld<br><br><span class="hljs-comment"># (2)关闭selinux</span><br><span class="hljs-comment">#【SELinux 全称 Security Enhanced Linux (安全强化 Linux)，是 MAC (Mandatory Access Control，强制访问控制系统)的一个实现，目的在于明确的指明某个进程可以访问哪些资源(文件、网络端口等)。】</span><br>setenforce 0<br>sed -i <span class="hljs-string">&#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27;</span> /etc/selinux/config<br><br><span class="hljs-comment"># (3)关闭swap</span><br><span class="hljs-comment">#【在Linux下，SWAP的作用类似Windows系统下的“虚拟内存”。当物理内存不足时，拿出部分硬盘空间当SWAP分区（虚拟成内存）使用，从而解决内存容量不足的情况。】</span><br>swapoff -a<br>sed -i <span class="hljs-string">&#x27;/swap/s/^\(.*\)$/#\1/g&#x27;</span> /etc/fstab<br><br><span class="hljs-comment"># (4)配置iptables的ACCEPT规则</span><br>iptables -F &amp;&amp; iptables -X &amp;&amp; iptables -F -t nat &amp;&amp; iptables -X -t nat &amp;&amp; iptables -P FORWARD ACCEPT<br><br><span class="hljs-comment"># (5)设置系统参数</span><br><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt; /etc/sysctl.d/k8s.conf</span><br><span class="hljs-string">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="hljs-string">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="hljs-string">EOF</span><br>sysctl --system<br></code></pre></td></tr></table></figure><h4 id="2-2-7-配置K8s的yum源"><a href="#2-2-7-配置K8s的yum源" class="headerlink" title="2.2.7  配置K8s的yum源"></a>2.2.7  配置K8s的yum源</h4><blockquote><p>3台机器</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="hljs-string">[kubernetes]</span><br><span class="hljs-string">name=Kubernetes</span><br><span class="hljs-string">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="hljs-string">enabled=1</span><br><span class="hljs-string">gpgcheck=0</span><br><span class="hljs-string">repo_gpgcheck=0</span><br><span class="hljs-string">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="hljs-string">       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><h4 id="2-2-8-安装kubeadm、kubectl和kubelet"><a href="#2-2-8-安装kubeadm、kubectl和kubelet" class="headerlink" title="2.2.8  安装kubeadm、kubectl和kubelet"></a>2.2.8  安装kubeadm、kubectl和kubelet</h4><blockquote><p>3台机器</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#（1）列出可以安装的版本</span><br>yum list kubeadm --showduplicates | <span class="hljs-built_in">sort</span> -r<br><span class="hljs-comment">#（2）安装kubeadm、kubectl和kubelet</span><br>yum install -y kubeadm-1.23.14 kubelet-1.23.14 kubectl-1.23.14<br></code></pre></td></tr></table></figure><h4 id="2-2-9-设置Docker与K8s为同一个cgroup"><a href="#2-2-9-设置Docker与K8s为同一个cgroup" class="headerlink" title="2.2.9 设置Docker与K8s为同一个cgroup"></a>2.2.9 设置Docker与K8s为同一个cgroup</h4><blockquote><p>3台机器</p></blockquote><p>（1）Docker</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># docker</span><br>vi /etc/docker/daemon.json<br><span class="hljs-comment"># 添加这行</span><br><span class="hljs-string">&quot;exec-opts&quot;</span>: [<span class="hljs-string">&quot;native.cgroupdriver=systemd&quot;</span>],<br><span class="hljs-comment"># 重启docker</span><br>systemctl restart docker<br></code></pre></td></tr></table></figure><p>（2）K8s</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># kubelet</span><br>sed -i <span class="hljs-string">&quot;s/cgroup-driver=systemd/cgroup-driver=cgroupfs/g&quot;</span> /etc/systemd/system/kubelet.service.d/10-kubeadm.conf<br><span class="hljs-comment"># 重启kubelet</span><br>systemctl restart kubelet &amp;&amp; systemctl <span class="hljs-built_in">enable</span> kubelet<br></code></pre></td></tr></table></figure><h4 id="2-2-10-准备安装K8s组件需要的image"><a href="#2-2-10-准备安装K8s组件需要的image" class="headerlink" title="2.2.10 准备安装K8s组件需要的image"></a>2.2.10 准备安装K8s组件需要的image</h4><blockquote><p>3台机器</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubeadm config images list<br><br>k8s.gcr.io/kube-apiserver:v1.23.14<br>k8s.gcr.io/kube-controller-manager:v1.23.14<br>k8s.gcr.io/kube-scheduler:v1.23.14<br>k8s.gcr.io/kube-proxy:v1.23.14<br>k8s.gcr.io/pause:3.6<br>k8s.gcr.io/etcd:3.5.5-0<br>k8s.gcr.io/coredns/coredns:v1.8.6<br></code></pre></td></tr></table></figure><p>下载镜像需要科学上网，可以通过香港服务器下载后再上传到自己的镜像仓库中使用。</p><p>拉取镜像的sh：kubeadm-pull-image.sh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">set</span> -e<br><br>KUBE_VERSION=v1.23.14<br>KUBE_PAUSE_VERSION=3.6<br>ETCD_VERSION=3.5.5-0<br><br>ALIYUN_URL=registry.cn-hangzhou.aliyuncs.com/jack-kubernetes<br>GCR_URL=k8s.gcr.io<br><br>images=(kube-proxy:<span class="hljs-variable">$&#123;KUBE_VERSION&#125;</span><br>kube-scheduler:<span class="hljs-variable">$&#123;KUBE_VERSION&#125;</span><br>kube-controller-manager:<span class="hljs-variable">$&#123;KUBE_VERSION&#125;</span><br>kube-apiserver:<span class="hljs-variable">$&#123;KUBE_VERSION&#125;</span><br>pause:<span class="hljs-variable">$&#123;KUBE_PAUSE_VERSION&#125;</span><br>etcd:<span class="hljs-variable">$&#123;ETCD_VERSION&#125;</span><br>)<br><br><span class="hljs-keyword">for</span> imageName <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;images[@]&#125;</span> ; <span class="hljs-keyword">do</span><br>docker pull <span class="hljs-variable">$ALIYUN_URL</span>/<span class="hljs-variable">$imageName</span><br>docker tag <span class="hljs-variable">$ALIYUN_URL</span>/<span class="hljs-variable">$imageName</span> <span class="hljs-variable">$GCR_URL</span>/<span class="hljs-variable">$imageName</span><br>docker rmi <span class="hljs-variable">$ALIYUN_URL</span>/<span class="hljs-variable">$imageName</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull registry.cn-hangzhou.aliyuncs.com/jack-kubernetes/coredns:v1.8.6<br>docker tag registry.cn-hangzhou.aliyuncs.com/jack-kubernetes/coredns:v1.8.6 k8s.gcr.io/coredns/coredns:v1.8.6<br>docker rmi registry.cn-hangzhou.aliyuncs.com/jack-kubernetes/coredns:v1.8.6<br></code></pre></td></tr></table></figure><h4 id="2-2-11-搭建Master"><a href="#2-2-11-搭建Master" class="headerlink" title="2.2.11 搭建Master"></a>2.2.11 搭建Master</h4><blockquote><p>Master Node</p></blockquote><p>（1）初始化Master</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># --pod-network-cidr可以随意设置，推荐10.**.**.**开头，用于pod之间通信</span><br>kubeadm init --kubernetes-version=1.23.14 --apiserver-advertiseaddress=192.168.0.51 --pod-network-cidr=10.244.0.0/16<br><span class="hljs-comment">#记录下初始化过程中重要的日志信息</span><br></code></pre></td></tr></table></figure><p>（2）记录下join的内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubeadm <span class="hljs-built_in">join</span> 192.168.0.51:6443 --token bi2z4y.nmwqwaz5e5scqhb3 \ --discovery-token-ca-cert-hash sha256:5791deaa7119c6536cd4869ea9a152b00ae4b70b1aa19750137a077e4c6afed0<br></code></pre></td></tr></table></figure><p>（3）根据日志提示进行如下操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$HOME</span>/.kube<br>sudo <span class="hljs-built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/config<br>sudo <span class="hljs-built_in">chown</span> $(<span class="hljs-built_in">id</span> -u):$(<span class="hljs-built_in">id</span> -g) <span class="hljs-variable">$HOME</span>/.kube/config<br></code></pre></td></tr></table></figure><p>（4）查看cluster-info和健康检查</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl cluster-info<br>curl -k https://localhost:6443/healthz<br></code></pre></td></tr></table></figure><p>（5）查看系统Pod</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get pods -n kube-system<br></code></pre></td></tr></table></figure><p>（6）kube init流程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进行一系列检查，以确定这台机器可以部署kubernetes</span><br><span class="hljs-comment"># 生成kubernetes对外提供服务所需要的各种证书可对应目录</span><br><span class="hljs-built_in">ls</span> /etc/kubernetes/pki/*<br><span class="hljs-comment"># 为其他组件生成访问kube-ApiServer所需的配置文件</span><br><span class="hljs-built_in">ls</span> /etc/kubernetes/<br><span class="hljs-comment"># 生成master节点需要的Pod文件。</span><br><span class="hljs-built_in">ls</span> /etc/kubernetes/manifests/*.yaml<br><span class="hljs-comment"># 一旦这些 YAML 文件出现在被 kubelet 监视的/etc/kubernetes/manifests/目录下，kubelet就</span><br>会自动创建这些yaml文件定义的pod，即master组件的容器。<br><span class="hljs-comment"># master容器启动后，kubeadm会通过检查localhost：6443/healthz这个master组件的健康状态检查URL，等待master组件完全运行起来</span><br><span class="hljs-comment"># 为集群生成一个bootstrap token</span><br><span class="hljs-comment"># 将ca.crt等master节点的重要信息，通过ConfigMap的方式保存在etcd中，工后续部署node节点使用</span><br><span class="hljs-comment"># 最后一步是安装默认插件。kubernetes默认kube-proxy和DNS两个插件是必须安装的</span><br></code></pre></td></tr></table></figure><p>（7）安装calico网络插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 选择网络插件</span><br>https://kubernetes.io/docs/concepts/cluster-administration/addons/<br><span class="hljs-comment"># calico网络插件</span><br>https://projectcalico.docs.tigera.io/getting-started/kubernetes/<br><span class="hljs-comment"># 提前拉取镜像</span><br>docker pull docker.io/calico/kube-controllers:v3.20.3<br>docker pull docker.io/calico/pod2daemon-flexvol:v3.20.3<br>docker pull docker.io/calico/node:v3.20.3<br>docker pull docker.io/calico/cni:v3.20.3<br><span class="hljs-comment"># 安装calico:v3.20</span><br>kubectl apply -f https://docs.projectcalico.org/v3.20/manifests/calico.yaml<br><span class="hljs-comment"># 查看calico是否安装成功</span><br>watch kubectl get pods --all-namespaces<br></code></pre></td></tr></table></figure><h4 id="2-2-12-搭建Worker-Node"><a href="#2-2-12-搭建Worker-Node" class="headerlink" title="2.2.12 搭建Worker Node"></a>2.2.12 搭建Worker Node</h4><p>（1）查看node状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get nodes<br></code></pre></td></tr></table></figure><p>（2）在2台worker node上执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubeadm <span class="hljs-built_in">join</span> 192.168.0.51:6443 --token bi2z4y.nmwqwaz5e5scqhb3 \ --discovery-token-ca-cert-hash sha256:5791deaa7119c6536cd4869ea9a152b00ae4b70b1aa19750137a077e4c6afed0<br></code></pre></td></tr></table></figure><p>（3）查看node状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get nodes -w<br></code></pre></td></tr></table></figure><h4 id="2-2-13-K8s搭建之后的常见问题"><a href="#2-2-13-K8s搭建之后的常见问题" class="headerlink" title="2.2.13  K8s搭建之后的常见问题"></a>2.2.13  K8s搭建之后的常见问题</h4><ol><li>Node NotReady</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 问题描述</span><br>kubectl get nodes<br>NAME STATUS ROLES<br>k8s-master Ready control-plane,master<br>k8s-worker01 NotReady &lt;none&gt;<br>k8s-worker02 NotReady &lt;none&gt;<br><span class="hljs-comment"># 问题排查思路</span><br>在NotReady的node上执行：journalctl -f -u kubelet<br>查看其出错可能的原因：<br>（1）kubelet服务没有设置为开机启动：systemctl restart kubelet &amp;&amp; systemctl <span class="hljs-built_in">enable</span> kubelet<br>（2）网络环境发生了变化<br>（3）机器资源不足<br>...<br><span class="hljs-comment">#如果找不到问题，可以使用reset命令重新搭建</span><br></code></pre></td></tr></table></figure><ol start="2"><li> Worker如何使用kubectl</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 问题描述，在w1节点上通过kubectl get pods查看资源，发现报错</span><br>The connection to the server localhost:8080 was refused - did you specify the right host or port?<br><span class="hljs-comment"># 解决方案</span><br>需要在worker节点上添加可以操作集群的权限，具体设置如下：<br>切换到master上，<span class="hljs-built_in">cd</span> ~ ---&gt; <span class="hljs-built_in">cat</span> .kube/config ---&gt;复制内容<br>切换到worker02上 <span class="hljs-built_in">cd</span> ~ ---&gt; 新建文件 .kube/config ---&gt;粘贴内容<br></code></pre></td></tr></table></figure><ol start="3"><li>token忘记了怎么办</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># token是用于worker节点加入master节点的凭证，默认有效期是24小时，格式如下</span><br>kubeadm <span class="hljs-built_in">join</span> 192.168.0.51:6443 --token bi2z4y.nmwqwaz5e5scqhb3 \ --discovery-token-ca-cert-hash sha256:5791deaa7119c6536cd4869ea9a152b00ae4b70b1aa19750137a077e4c6afed0<br><br><span class="hljs-comment"># 查看token是否还在有效期内</span><br>kubeadm token list<br>[root@~]<span class="hljs-comment"># kubeadm token list</span><br>TOKEN TTL EXPIRES USAGES<br>DESCRIPTION<br>ykv2ae.fsa5wj7rrxrm1xsd 21h 2022-12-06T06:17:45Z<br>authentication,signing The default bootstrap token generated by <span class="hljs-string">&#x27;kubeadm init&#x27;</span>.<br><br><span class="hljs-comment"># 如果在有效期内，则生成一个token-hash，和token一起组成用于join的内容</span><br>openssl x509 -pubkey -<span class="hljs-keyword">in</span> /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed <span class="hljs-string">&#x27;s/^.* //&#x27;</span><br><br><span class="hljs-comment"># 如果token已经过期了，则先生成一个新的token和token-hash，用于join的内容</span><br>kubeadm token create --print-join-command<br>kubeadm token list<br><br><span class="hljs-comment"># 默认token有效期是24小时，如果想设置有效期，则可以通过--ttl来设置，0表示永不过期</span><br>kubeadm token create --print-join-command --ttl=0<br><br><span class="hljs-comment"># 如果要删除token，则执行如下命令</span><br>kubeadm token delete 3nc3wu.pfn3mlgxafuut606<br></code></pre></td></tr></table></figure><h2 id="3-K8s初体验"><a href="#3-K8s初体验" class="headerlink" title="3  K8s初体验"></a>3  K8s初体验</h2><p><a href="https://kubernetes.io/docs/concepts/workloads/pods/">https://kubernetes.io/docs/concepts/workloads/pods/</a></p><p>（1）定义一个名称为simple-pod.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.14.2</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br><br></code></pre></td></tr></table></figure><p>（2）通过kubectl apply创建Pod</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f simple-pod.yaml<br></code></pre></td></tr></table></figure><p>（3）查看Pod</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看Pod</span><br>kubectl get pods<br>kubectl get pods -w<br><span class="hljs-comment"># 查看pod运行详情</span><br>kubectl get pods -o wide<br><span class="hljs-comment"># 查看pod详情</span><br>kubectl describe pod nginx<br><span class="hljs-comment"># 比如pod被调度在了w2节点上，此时来到w2机器，使用docker的方式查看container的情况</span><br>docker ps<br></code></pre></td></tr></table></figure><p>（4）删除Pod</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl delete -f simple-pod.yaml<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker实战</title>
    <link href="/2023/04/26/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/docker/Docker%E5%AE%9E%E6%88%98/"/>
    <url>/2023/04/26/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/docker/Docker%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1-MySQL高可用集群-PXC"><a href="#1-MySQL高可用集群-PXC" class="headerlink" title="1 MySQL高可用集群-PXC"></a>1 MySQL高可用集群-PXC</h2><p>PXC官网：<a href="https://www.percona.com/">https://www.percona.com/</a></p><p><strong>多主 + 同步复制的方案 + 强一致性</strong></p><p>docker中PXC镜像就是将mysql镜像包装了一层，以便进行高可用集群的搭建，搭建步骤如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#拉取percona-xtradb-cluster的镜像</span><br>docker pull percona/percona-xtradb-cluster:5.7.21<br><br><span class="hljs-comment">#tag一下</span><br>docker tag percona/percona-xtradb-cluster:5.7.21 pxc<br>docker images<br><br><span class="hljs-comment">#创建一个单独的网段，给mysql数据库集群使用</span><br>docker network create --subnet=172.19.0.0/24 pxc-cluster-net<br>docker network <span class="hljs-built_in">ls</span><br>docker network inspect pxc-cluster-net<br><br><span class="hljs-comment">#创建volume，为了给3个container持久化数据使用</span><br>docker volume create pxc-v1<br>docker volume create pxc-v2<br>docker volume create pxc-v3<br>docker volume <span class="hljs-built_in">ls</span><br><br><span class="hljs-comment">#创建node1容器</span><br>docker run -d --name=node1 -p 3301:3306 -v pxc-v1:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=test666 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=test666 --net=pxc-cluster-net --priviledge pxc<br>docker ps<br>docker inspect node1<br><span class="hljs-comment">#创建node2容器</span><br>docker run -d --name=node2 -p 3302:3306 -v pxc-v2:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=test666 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=test666 --net=pxc-cluster-net -e CLUSTER_JOIN=node1 pxc<br>docker ps<br>docker inspect node2<br><span class="hljs-comment">#创建node3容器</span><br>docker run -d --name=node3 -p 3303:3306 -v pxc-v3:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=test666 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=test666 --net=pxc-cluster-net -e CLUSTER_JOIN=node1 pxc<br>docker ps<br>docker inspect node3<br></code></pre></td></tr></table></figure><p>MYSQL其他高可用集群方案：</p><ol><li>MMM: Master-Master Replication Manager for MySQL：支持故障转移、主从切换</li><li>MHA：Master High Availability：支持故障主持、主从切换</li></ol><h2 id="2-Docker-Compose-实战"><a href="#2-Docker-Compose-实战" class="headerlink" title="2 Docker Compose-实战"></a>2 Docker Compose-实战</h2><p>官网：<a href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a></p><p>Docker Compose能够在 Docker 节点上，以单引擎模式(Single-Engine Mode)进行多容器应用的部署和管理。也就是单节点的容器编排工具。</p><h3 id="2-1-需求"><a href="#2-1-需求" class="headerlink" title="2.1 需求"></a>2.1 需求</h3><p>访问一个网页地址，每次能够得到访问的次数，采用Python+Redis实现 Python写后台代码，Redis作为次数存储 python写好业务代码，将其通过Dockerfile生成image，然后创建一个container redis镜像直接从镜像仓库获取。</p><h3 id="2-2-创建py业务代码的image"><a href="#2-2-创建py业务代码的image" class="headerlink" title="2.2 创建py业务代码的image"></a>2.2 创建py业务代码的image</h3><ol><li>创建文件夹compose-case</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> compose-case<br><span class="hljs-built_in">cd</span> compose-case<br></code></pre></td></tr></table></figure><ol start="2"><li>编写app.py文件</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">import</span> redis<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br>app = Flask(__name__)<br>cache = redis.Redis(host=<span class="hljs-string">&#x27;redis&#x27;</span>, port=<span class="hljs-number">6379</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_hit_count</span>():<br>    retries = <span class="hljs-number">5</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> cache.incr(<span class="hljs-string">&#x27;hits&#x27;</span>)<br>        <span class="hljs-keyword">except</span> redis.exceptions.ConnectionError <span class="hljs-keyword">as</span> exc:<br>            <span class="hljs-keyword">if</span> retries == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">raise</span> exc<br>            retries -= <span class="hljs-number">1</span><br>            time.sleep(<span class="hljs-number">0.5</span>)<br>            <br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():<br>    count = get_hit_count()<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;</span>.<span class="hljs-built_in">format</span>(count)<br></code></pre></td></tr></table></figure><ol start="3"><li>在compose-case下新建requirements.txt文件</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">flask</span><br><span class="hljs-attribute">redis</span><br></code></pre></td></tr></table></figure><ol start="4"><li>编写Dockerfile</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span>-alpine<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /code</span><br><span class="hljs-keyword">ENV</span> FLASK_APP app.py<br><span class="hljs-keyword">ENV</span> FLASK_RUN_HOST <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apk add --no-cache gcc musl-dev linux-headers</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> requirements.txt requirements.txt</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;flask&quot;</span>, <span class="hljs-string">&quot;run&quot;</span>]</span><br></code></pre></td></tr></table></figure><ol start="5"><li>根据Dockerfile构建image并查看</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker build -t python-app-image .<br>docker images<br></code></pre></td></tr></table></figure><h3 id="2-3-之前的方式"><a href="#2-3-之前的方式" class="headerlink" title="2.3 之前的方式"></a>2.3 之前的方式</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建网络</span><br>docker network create --subnet=172.20.0.0/24 app-net<br><span class="hljs-comment"># 创建python程序的container，并指定网段</span><br>docker run -d --name web -p 5000:5000 --network app-net python-app-image<br><span class="hljs-comment"># 创建redis的container，并指定网段</span><br>docker run -d --name redis --network app-net redis:alpine<br><span class="hljs-comment"># 访问测试</span><br>curl centosip:5000<br></code></pre></td></tr></table></figure><h3 id="2-4-docker-compose实现"><a href="#2-4-docker-compose实现" class="headerlink" title="2.4 docker-compose实现"></a>2.4 docker-compose实现</h3><ol><li> 安装docker-compose</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#或者手动下载安装包并放到指定目录下重命名</span><br>sudo curl -L <span class="hljs-string">&quot;https://github.com/docker/compose/releases/download/1.24.1/dockercompose-<span class="hljs-subst">$(uname -s)</span>-<span class="hljs-subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose<br><br><span class="hljs-built_in">chmod</span> +x /usr/local/bin/docker-compose<br>docker-compose version<br></code></pre></td></tr></table></figure><ol start="2"><li>创建docker-compose.yaml文件</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5000:5000&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">app-net</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;redis:alpine&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">app-net</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">app-net:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br></code></pre></td></tr></table></figure><ol start="3"><li> 启动并访问测试</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker-compose up -d<br>curl centosip:5000<br></code></pre></td></tr></table></figure><ol start="4"><li>扩容</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker-compose up --scale web=5 -d<br>docker-compose ps<br>docker-compose logs web<br></code></pre></td></tr></table></figure><ol start="5"><li>docker-compose使用指南</li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vim">(<span class="hljs-number">1</span>) 查看版本<br>docker-compose <span class="hljs-keyword">version</span><br>(<span class="hljs-number">2</span>) 根据yml创建service<br>docker-compose <span class="hljs-keyword">up</span><br>指定yml：docker-compose <span class="hljs-keyword">up</span> -<span class="hljs-keyword">f</span> xxx.yml<br>后台运行：docker-compose <span class="hljs-keyword">up</span> -d<br>(<span class="hljs-number">3</span>) 查看启动成功的service<br>docker-compose <span class="hljs-keyword">ps</span><br>也可以使用docker <span class="hljs-keyword">ps</span><br>(<span class="hljs-number">4</span>) 查看images<br>docker-compose images<br>(<span class="hljs-number">5</span>) 停止/启动service<br>docker-compose <span class="hljs-keyword">stop</span>/start<br>(<span class="hljs-number">6</span>) 删除service[同时会删除掉network和volume]<br>docker-compose down<br>(<span class="hljs-number">7</span>) 进入到某个service<br>docker-compose exec redis <span class="hljs-keyword">sh</span><br></code></pre></td></tr></table></figure><h2 id="3-Docker-Swarm"><a href="#3-Docker-Swarm" class="headerlink" title="3 Docker Swarm"></a>3 Docker Swarm</h2><p>Docker Swarm是管理跨节点容器的编排工具，相较于Docker Compose而言，Compose只能编排单节点上的容器，Swarm将一群Docker节点虚拟化为一个主机，使得用户只要在单一主机上操作就能完成对整个容器集群的管理工作。</p><p>目前使用较多的是K8S，Swarm使用较少</p>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Minio初识</title>
    <link href="/2023/04/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/minio/Minio%E5%88%9D%E8%AF%86/"/>
    <url>/2023/04/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/minio/Minio%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-MinIO介绍"><a href="#1-MinIO介绍" class="headerlink" title="1 MinIO介绍"></a>1 MinIO介绍</h2><blockquote><p>官网：<a href="https://min.io/">https://min.io/</a></p><p>官方示例：<a href="https://gitcode.net/mirrors/minio/minio-java/-/tree/master">https://gitcode.net/mirrors/minio/minio-java/-/tree/master</a></p><p>下载(国内加速镜像)：<a href="https://dl.min.io/">https://dl.min.io/</a></p></blockquote><p>MinIO是一个分布式文件存储系统，基于Apache License V2.0协议开发，Go语言编写。完全兼容Amazon S3。易于使用、快速与其他应用结合。为海量数据存储、人工智能、大数据分析而设计。</p><p>优点：</p><ol><li>高性能   2. 可扩展性  3. 云原生支持  4. 代码开源</li></ol><p>特性：</p><ol><li>纠删编码   2. 提供bit rot保护   3.数据加密保护   4.连续复制  5.WORM防篡改   6. 全局统一性   7.多云网关</li></ol><h2 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2 环境搭建"></a>2 环境搭建</h2><h3 id="2-1-单机"><a href="#2-1-单机" class="headerlink" title="2.1 单机"></a>2.1 单机</h3><ol><li>下载MinIO</li></ol><p>地址-1：<a href="https://dl.min.io/">https://dl.min.io/</a>  (建议)  (server ==&gt; minio ==&gt; release ==&gt; linux-amd64 ==&gt; minio)</p><p>地址-2：<a href="https://min.io/download#/linux">https://min.io/download#/linux</a>  (国外镜像，很慢)</p><p><img src="/image/minio/1.png"></p><ol start="2"><li>部署MinIO</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 1、minio安装目录（创建|定位）</span><br><span class="hljs-built_in">mkdir</span> -p /data/minio/<br><span class="hljs-built_in">cd</span> /data/minio/<br><br><span class="hljs-comment"># 2、将下载的文件上传到安装目录</span><br><span class="hljs-comment">##--------【此处直接指定账号密码、采用后台启动的方式运行MinIO】----------------##</span><br><span class="hljs-comment"># 创建账号</span><br><span class="hljs-comment">#export MINIO_ACCESS_KEY=admin</span><br><span class="hljs-comment"># 创建密码</span><br><span class="hljs-comment">#export MINIO_SECRET_KEY=minio123456</span><br><span class="hljs-comment"># 后台启动（打印日志）</span><br><span class="hljs-comment">#nohup /data/minio/minio server /data/minio/ &gt; /data/minio/minio.log &amp;</span><br><span class="hljs-comment">##---------------------------------------------------------------------##</span><br><br><span class="hljs-comment">##--------【下方配置成系统服务、启动运行的方式 较为方便】----------------------##</span><br><span class="hljs-comment"># 3、创建启动脚本</span><br>vim /data/minio/start.sh<br><span class="hljs-comment">##--------写入内容-------------------------------------------------##</span><br><span class="hljs-comment">#####写入内容#####</span><br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">export</span> MINIO_ACCESS_KEY=admin<br><span class="hljs-built_in">export</span> MINIO_SECRET_KEY=minio123456<br>/data/minio/minio server /data/minio/ &gt; /data/minio/minio.log<br><span class="hljs-comment"># 默认端口：9000；还可以使用 自定义启动端口 和 控制台端口（默认端口不冲突的话 可以不设置）</span><br><span class="hljs-comment"># /data/minio/minio server --address :9000 --console-address :9001 /data/minio/ &gt; /data/minio/minio.log</span><br><span class="hljs-comment">##----------------------------------------------------------------##</span><br><br><span class="hljs-comment"># 4、创建停止脚本</span><br>vim /data/minio/stop.sh<br><span class="hljs-comment">#---写入内容-------------------------------------------------------------#</span><br><span class="hljs-comment">#!/bin/bash</span><br>ps -ef | grep minio | grep -v <span class="hljs-string">&#x27;grep&#x27;</span> | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>| xargs <span class="hljs-built_in">kill</span> -9<br><span class="hljs-keyword">if</span> $? != 0;<span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;minio service stop failed.&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><span class="hljs-comment">#-----------------------------------------------------------------------#</span><br><br><span class="hljs-comment"># 5、创建minio系统服务（将其加入系统服务）</span><br>vim /usr/lib/systemd/system/minio.service<br><span class="hljs-comment">#---写入内容------------------------------#</span><br>[Unit]<br>Description=Minio service<br>Documentation=https://docs.minio.io/<br>[Service]<br>WorkingDirectory=/data/minio/<br>ExecStart=/data/minio/start.sh<br>ExecStop=/data/minio/stop.sh<br>Restart=on-failure<br>RestartSec=5<br>[Install]<br>WantedBy=multi-user.target<br><span class="hljs-comment">#----------------------------------------#</span><br><br><span class="hljs-comment"># 6、修改相关文件权限</span><br><span class="hljs-built_in">chmod</span> +x /usr/lib/systemd/system/minio.service &amp;&amp; <span class="hljs-built_in">chmod</span> +x /data/minio/minio &amp;&amp; <span class="hljs-built_in">chmod</span> +x /data/minio/start.sh &amp;&amp; <span class="hljs-built_in">chmod</span> +x /data/minio/stop.sh<br><br><span class="hljs-comment"># 7、服务操作</span><br><span class="hljs-comment"># 7-1、重写加载服务（使配置文件变更生效）</span><br>systemctl daemon-reload<br><span class="hljs-comment"># 7-2、启动服务</span><br>systemctl start minio<br><span class="hljs-comment"># 7-3、关闭服务</span><br><span class="hljs-comment"># systemctl stop minio</span><br><span class="hljs-comment"># 7-4、加入自启动</span><br>systemctl <span class="hljs-built_in">enable</span> minio<br><span class="hljs-comment">##---------------------------------------------------------------------##</span><br><br><span class="hljs-comment"># 8、检查状态</span><br>ps -ef|grep minio<br></code></pre></td></tr></table></figure><ol start="3"><li>使用</li></ol><p>浏览器访问地址：<a href="http://ip:9000/">http://ip:9000</a> （登录输入之前配置的 access_key 和 secret_key）</p><p><img src="/image/minio/2.png"></p><h3 id="2-2-集群"><a href="#2-2-集群" class="headerlink" title="2.2 集群"></a>2.2 集群</h3><h4 id="2-2-1-系统环境"><a href="#2-2-1-系统环境" class="headerlink" title="2.2.1 系统环境"></a>2.2.1 系统环境</h4><p>Linux（CentOS 7、IP：192.168.61.142、192.168.61.143）</p><p>集群部署方式分为以下两种： </p><p>​    直接部署（未分组、不支持集群扩容） </p><p>​    分组扩容部署（支持 MinIO 官方方式扩容）【<strong>建议</strong>】</p><h4 id="2-2-2-挂载新硬盘"><a href="#2-2-2-挂载新硬盘" class="headerlink" title="2.2.2 挂载新硬盘"></a>2.2.2 挂载新硬盘</h4><p>MinIO在集群部署时，数据目录所对应的要求是一块物理盘，启动时MinIO会去格式化硬盘，不能是系统盘，若不然 会提示错误，所以系统预装没有新硬盘的情况下，需要执行系统挂载新硬盘操作。</p><h5 id="2-2-2-1-添加硬盘"><a href="#2-2-2-1-添加硬盘" class="headerlink" title="2.2.2.1 添加硬盘"></a>2.2.2.1 添加硬盘</h5><p>虚拟机关机</p><p><img src="/image/minio/3.png"></p><p><img src="/image/minio/4.png"></p><p><img src="/image/minio/5.png"></p><p>查看设备挂载情况，开启虚拟机</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">lsblk -f<br></code></pre></td></tr></table></figure><p><img src="/image/minio/6.png"></p><h5 id="2-2-2-2-新硬盘分区"><a href="#2-2-2-2-新硬盘分区" class="headerlink" title="2.2.2.2 新硬盘分区"></a>2.2.2.2 新硬盘分区</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># sdb（新磁盘名）</span><br>fdisk /dev/sdb<br><span class="hljs-comment"># 分区操作参考：</span><br><span class="hljs-comment"># n（回车）==&gt; p（回车）==&gt; &#123;1 | 2 | 3 | 4&#125;（回车）==&gt; 起始扇区[默认值]（回车）==&gt; 扇区大小[+xxxxM按需指定]（回车）</span><br><span class="hljs-comment"># w（保存分区信息</span><br></code></pre></td></tr></table></figure><p><img src="/image/minio/7.png"></p><h5 id="2-2-2-3-分区格式化"><a href="#2-2-2-3-分区格式化" class="headerlink" title="2.2.2.3 分区格式化"></a>2.2.2.3 分区格式化</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">mkfs -t ext4 /dev/sdb1<br>mkfs -t ext4 /dev/sdb2<br>mkfs -t ext4 /dev/sdb3<br>mkfs -t ext4 /dev/sdb4<br></code></pre></td></tr></table></figure><p><img src="/image/minio/8.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#查看结果</span><br>lsblk -f<br></code></pre></td></tr></table></figure><p><img src="/image/minio/9.png"></p><h5 id="2-2-2-4-挂载硬盘目录"><a href="#2-2-2-4-挂载硬盘目录" class="headerlink" title="2.2.2.4 挂载硬盘目录"></a>2.2.2.4 挂载硬盘目录</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">mount /dev/sdb1 /data/minio/data1<br>mount /dev/sdb2 /data/minio/data2<br>mount /dev/sdb3 /data/minio/data3<br>mount /dev/sdb4 /data/minio/data4<br><br><span class="hljs-comment">#查看结果</span><br>lsblk -f<br></code></pre></td></tr></table></figure><p><img src="/image/minio/10.png"></p><h5 id="2-2-2-5-设置自动挂载"><a href="#2-2-2-5-设置自动挂载" class="headerlink" title="2.2.2.5 设置自动挂载"></a>2.2.2.5 设置自动挂载</h5><p><img src="/image/minio/11.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim /etc/fstab<br><span class="hljs-comment"># 文件末尾添加</span><br><span class="hljs-comment">#UUID=33c07641-bae6-4f7b-987a-c58f1d370cc3 /dev/sdb1 /data/minio/data1/ ext4 defaults 0 0</span><br><span class="hljs-comment">#UUID=78c7e4b5-756e-4b14-9627-85b4cb11a388 /dev/sdb2 /data/minio/data2/ ext4 defaults 0 0</span><br><span class="hljs-comment">#UUID=f8c05a74-4f9c-447d-8d9f-0771bb6e493f /dev/sdb3 /data/minio/data3/ ext4 defaults 0 0</span><br><span class="hljs-comment">#UUID=aa96b070-bf21-4d13-9c00-9bf390d69618 /dev/sdb4 /data/minio/data4/ ext4 defaults 0 0</span><br>/dev/sdb1 /data/minio/data1/ ext4 defaults 0 0<br>/dev/sdb2 /data/minio/data2/ ext4 defaults 0 0<br>/dev/sdb3 /data/minio/data3/ ext4 defaults 0 0<br>/dev/sdb4 /data/minio/data4/ ext4 defaults 0 0<br></code></pre></td></tr></table></figure><p><img src="/image/minio/12.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#重新加载</span><br>mount -a<br></code></pre></td></tr></table></figure><h4 id="2-2-3-下载MinIO"><a href="#2-2-3-下载MinIO" class="headerlink" title="2.2.3 下载MinIO"></a>2.2.3 下载MinIO</h4><p>同单机一样</p><h4 id="2-2-4-安装部署"><a href="#2-2-4-安装部署" class="headerlink" title="2.2.4 安装部署"></a>2.2.4 安装部署</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#【注意：以下操作均在两节点上进行】</span><br><span class="hljs-comment"># 1、创建数据目录</span><br><span class="hljs-built_in">mkdir</span> -p /data/minio/&#123;data1,data2,data3,data4&#125;<br><br><span class="hljs-comment"># 2、创建配置目录【两个节点均操作】</span><br><span class="hljs-built_in">mkdir</span> -p /etc/minioconfig<br><br><span class="hljs-comment"># 3、定位到minio安装目录、将下载的文件上传到安装目录【两个节点均操作】</span><br><span class="hljs-built_in">cd</span> /data/minio/<br><br><span class="hljs-comment"># 4、创建MinIO启动脚本文件【两个节点均操作】</span><br>vim /data/minio/start.sh<br><span class="hljs-comment">##---【192.168.61.142】写入内容------------------------------##</span><br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">export</span> MINIO_ACCESS_KEY=admin<br><span class="hljs-built_in">export</span> MINIO_SECRET_KEY=minio123456<br>/data/minio/minio server --config-dir /etc/minioconfig \<br>--address <span class="hljs-string">&quot;192.168.61.142:9000&quot;</span> \<br>http://192.168.61.&#123;142...143&#125;/data/minio/data&#123;1...4&#125;<br><span class="hljs-comment">##---------------------------------------------------------##</span><br><span class="hljs-comment">##---【192.168.61.143】写入内容------------------------------##</span><br><span class="hljs-comment">#!/bin/bash</span><br><span class="hljs-built_in">export</span> MINIO_ACCESS_KEY=admin<br><span class="hljs-built_in">export</span> MINIO_SECRET_KEY=minio123456<br>/data/minio/minio server --config-dir /etc/minioconfig \<br>--address <span class="hljs-string">&quot;192.168.61.143:9000&quot;</span> \<br>http://192.168.61.&#123;142...143&#125;/data/minio/data&#123;1...4&#125;<br><span class="hljs-comment">##---------------------------------------------------------##</span><br><br><span class="hljs-comment"># 5、创建MinIO停止脚本文件【两个节点均操作】</span><br>vim /data/minio/stop.sh<br><span class="hljs-comment">##---【192.168.61.142】写入内容-------------------------------------------##</span><br><span class="hljs-comment">#!/bin/bash</span><br>ps -ef | grep minio | grep -v <span class="hljs-string">&#x27;grep&#x27;</span> | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>| xargs <span class="hljs-built_in">kill</span> -9<br><span class="hljs-keyword">if</span> $? != 0;<span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;minio service stop failed.&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><span class="hljs-comment">##----------------------------------------------------------------------##</span><br><br><span class="hljs-comment"># 6、创建minio系统服务（将其加入系统服务）</span><br>vim /usr/lib/systemd/system/minio.service<br><span class="hljs-comment">##---写入内容----------------------------------##</span><br>[Unit]<br>Description=Minio service<br>Documentation=https://docs.minio.io/<br>[Service]<br>WorkingDirectory=/data/minio/<br>ExecStart=/data/minio/start.sh<br>ExecStop=/data/minio/stop.sh<br>Restart=on-failure<br>RestartSec=5<br>[Install]<br>WantedBy=multi-user.target<br><span class="hljs-comment">##--------------------------------------------##</span><br><br><span class="hljs-comment"># 7、修改相关文件权限</span><br><span class="hljs-built_in">chmod</span> +x /usr/lib/systemd/system/minio.service &amp;&amp; <span class="hljs-built_in">chmod</span> +x /data/minio/minio &amp;&amp; <span class="hljs-built_in">chmod</span> +x<br>/data/minio/start.sh &amp;&amp; <span class="hljs-built_in">chmod</span> +x /data/minio/stop.sh<br><span class="hljs-comment">#chmod +x /usr/lib/systemd/system/minio.service</span><br><span class="hljs-comment">#chmod +x /data/minio</span><br><span class="hljs-comment">#chmod +x /data/minio/start-run.sh</span><br><br><span class="hljs-comment"># 8、服务操作</span><br><span class="hljs-comment"># 8-1、重写加载服务（使配置文件变更生效）</span><br>systemctl daemon-reload<br><span class="hljs-comment"># 8-2、启动服务</span><br>systemctl start minio<br><span class="hljs-comment"># 8-3、关闭服务</span><br><span class="hljs-comment"># systemctl stop minio</span><br><span class="hljs-comment"># 8-4、加入自启动</span><br>systemctl <span class="hljs-built_in">enable</span> minio<br><br><span class="hljs-comment"># 9、查看minon集群状态</span><br>systemctl status minio.service -l<br></code></pre></td></tr></table></figure><h4 id="2-2-5-MinIO使用"><a href="#2-2-5-MinIO使用" class="headerlink" title="2.2.5 MinIO使用"></a>2.2.5 MinIO使用</h4><p>通过任意节点的ip都可以访问。</p><p>备注：实际场景中，如果想要实现对各个节点的均衡访问，还可以安装配置 Nginx 实现负载均衡，通过 Nginx 负载均衡进行反向代理，统一一个地址进行转发</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 1、安装nginx</span><br>yum install epel-release -y<br>yum install nginx -y<br>systemctl start nginx<br>systemctl status nginx<br>systemctl <span class="hljs-built_in">enable</span> nginx<br><br><span class="hljs-comment"># 2、添加配置文件</span><br>vim /etc/nginx/conf.d/minio.conf<br><span class="hljs-comment">## 配置如下内容 ##</span><br>upstream minio_api &#123;<br>    server 192.168.61.142:9000;<br>    server 192.168.61.143:9000;<br>&#125;<br>upstream minio_console &#123;<br>    server 192.168.61.142:9001;<br>    server 192.168.61.143:9001;<br>&#125;<br>server&#123;<br>    listen 19000;<br>    server_name 192.168.61.142;<br>    <br>    ignore_invalid_headers off;<br>    client_max_body_size 0;<br>    proxy_buffering off;<br>     <br>    location / &#123;<br>        proxy_set_header X-Forwarded-Proto <span class="hljs-variable">$scheme</span>;<br>        proxy_set_header Host <span class="hljs-variable">$http_host</span>;<br>        proxy_set_header X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>        <br>        proxy_connect_timeout 300;<br>        proxy_http_version 1.1;<br>        chunked_transfer_encoding off;<br>        proxy_ignore_client_abort on;<br>        proxy_pass http://minio_api;<br>    &#125;<br>&#125;<br><br>server&#123;<br>    listen 19001;<br>    server_name 192.168.61.142;<br>    <br>    ignore_invalid_headers off;<br>    client_max_body_size 0;<br>    proxy_buffering off;<br>    <br>    location / &#123;<br>        proxy_set_header X-Forwarded-Proto <span class="hljs-variable">$scheme</span>;<br>        proxy_set_header Host <span class="hljs-variable">$http_host</span>;<br>        proxy_set_header X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>        <br>        proxy_connect_timeout 300;<br>        proxy_http_version 1.1;<br>        chunked_transfer_encoding off;<br>        proxy_ignore_client_abort on;<br>        <br>        proxy_pass http://minio_console;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"># 3、重启加载配置</span><br>nginx -t<br>nginx -s reload<br><span class="hljs-comment">#或者 systemctl reload nginx</span><br></code></pre></td></tr></table></figure><h3 id="2-3-客户端操作"><a href="#2-3-客户端操作" class="headerlink" title="2.3 客户端操作"></a>2.3 客户端操作</h3><h4 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1 概述"></a>2.3.1 概述</h4><p>MinIO Client 简称 mc，是 MinIO 服务器的客户端，对 ls，cat，cp，mirror，diff，find 等 UNIX 命令提供了一种替代方案，它支持文件系统和兼容Amazon S3的云存储服务（AWS Signature v2和v4），常见 mc 指令：</p><table><thead><tr><th>指令</th><th>说明</th><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>ls</td><td>列出文件和文件夹</td><td>rm</td><td>删除文件和对象</td></tr><tr><td>mb</td><td>创建一个存储桶或文件夹</td><td>events</td><td>管理对象通知</td></tr><tr><td>cat</td><td>显示文件和对象内容</td><td>watch</td><td>监听文件和对象的事件</td></tr><tr><td>pipe</td><td>将一个STDIN重定向到一个对象或者文件或者STDOUT</td><td>policy</td><td>管理访问策略</td></tr><tr><td>share</td><td>生成用于共享的URL</td><td>session</td><td>为cp命令管理保存的会话</td></tr><tr><td>cp</td><td>拷贝文件和对象</td><td>config</td><td>管理mc配置文件</td></tr><tr><td>mirror</td><td>给存储桶和文件夹做镜像</td><td>update</td><td>检查软件更新</td></tr><tr><td>find</td><td>基于参数查找文件</td><td>version</td><td>输出版本信息</td></tr><tr><td>diff</td><td>对两个文件夹或者存储桶比较差异</td><td></td><td></td></tr></tbody></table><h4 id="2-3-2-下载mc"><a href="#2-3-2-下载mc" class="headerlink" title="2.3.2 下载mc"></a>2.3.2 下载mc</h4><p>地址：<a href="https://dl.min.io/">https://dl.min.io/</a>    (client ==&gt; mc ==&gt; release ==&gt; linux-amd64 ==&gt; mc)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 若没有下载文件 也可直接安装</span><br><span class="hljs-comment"># wget http://dl.minio.org.cn/client/mc/release/linux-amd64/mc</span><br><br><span class="hljs-comment"># 1、mc安装目录（创建|定位）</span><br><span class="hljs-built_in">mkdir</span> -p /data/minio/mc<br><span class="hljs-built_in">cd</span> /data/minio/mc<br><br><span class="hljs-comment"># 2、将下载的文件上传到安装目录</span><br><br><span class="hljs-comment"># 3、授予权限</span><br><span class="hljs-built_in">chmod</span> +x mc<br><br><span class="hljs-comment"># 4、查看帮助</span><br>./mc -h<br><br><span class="hljs-comment"># 5、添加服务器节点</span><br>./mc config host add q1 http://192.168.61.142:9000 admin minio123456<br>./mc config host <span class="hljs-built_in">ls</span><br><br><span class="hljs-comment"># 6、查看信息</span><br><span class="hljs-comment"># 6-1、查看q1下的所有存储桶</span><br>./mc <span class="hljs-built_in">ls</span> q1<br><span class="hljs-comment"># 6-2、获取q1的服务器信息</span><br>./mc admin info q1<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Minio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Minio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker数据持久化与网络</title>
    <link href="/2023/04/21/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/docker/Docker%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%8E%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/04/21/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/docker/Docker%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%8E%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="1-数据持久化"><a href="#1-数据持久化" class="headerlink" title="1 数据持久化"></a>1 数据持久化</h2><p>官网：<a href="https://docs.docker.com/storage/">https://docs.docker.com/storage/</a></p><h3 id="1-1-Volume"><a href="#1-1-Volume" class="headerlink" title="1.1 Volume"></a>1.1 Volume</h3><h4 id="1-1-1-初始Volume"><a href="#1-1-1-初始Volume" class="headerlink" title="1.1.1 初始Volume"></a>1.1.1 初始Volume</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">rm</span> -f $(docker ps -aq)<br><br>docker volume <span class="hljs-built_in">ls</span><br><br>docker run -d --name test-mysql -e MYSQL_ROOT_PASSWORD=jack123 mysql:5.7<br><br><span class="hljs-comment"># 查看volume</span><br>docker volume <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 查看mysql Dockerfile文件</span><br>VOLUME /var/lib/mysql<br><span class="hljs-comment"># 在容器中寻找该目录/var/lib/mysql</span><br>docker <span class="hljs-built_in">exec</span> -it test-mysql bash<br><span class="hljs-built_in">ls</span> /var/lib/mysql<br><span class="hljs-comment"># 在centos物理机中寻找与之对应的目录</span><br>docker volume inspect volume_name<br><span class="hljs-comment"># 查看物理机中的目录</span><br><span class="hljs-built_in">ls</span> /var/lib/docker/volumes/e2ca4be02931e3310f6f136eb663e173d314bb3b3f243bacef776936898d4926/_data<br></code></pre></td></tr></table></figure><h4 id="1-1-2-自定义Volume"><a href="#1-1-2-自定义Volume" class="headerlink" title="1.1.2  自定义Volume"></a>1.1.2  自定义Volume</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#创建并查看volume</span><br>docker volume create test-mysql-volume<br>docker volume <span class="hljs-built_in">ls</span><br>docker volume inspect test-mysql-volume<br><span class="hljs-built_in">ls</span> /var/lob/docker/volumes/test-mysql-volume/_data<br><br><span class="hljs-comment">#创建容器并使用自定义的volume</span><br>docker run -d --name test-mysql -v test-mysql-volume:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=test123 mysql:5.7<br><br><span class="hljs-comment">#再次查看volume对应的物理目录</span><br><span class="hljs-built_in">ls</span> /var/lib/docker/volumes/test-mysql-volume/_data<br><br><span class="hljs-comment"># 可以这样理解</span><br>-v test-mysql-volume:/var/lib/mysql  就等同于在Dockerfile中定义的VOLUME命令<br></code></pre></td></tr></table></figure><h4 id="1-1-3-Volume数据修改"><a href="#1-1-3-Volume数据修改" class="headerlink" title="1.1.3 Volume数据修改"></a>1.1.3 Volume数据修改</h4><p>（1）修改container目录的数据，观察物理机的数据变化</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it test-mysql bash<br><span class="hljs-built_in">cd</span> /var/lib/mysql<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;test volume test.&quot;</span> &gt; test-volume.txt<br><span class="hljs-built_in">exit</span><br><span class="hljs-built_in">cd</span> /var/lib/docker/volumes/test-mysql-volume/_data<br><span class="hljs-built_in">ls</span><br><span class="hljs-built_in">cat</span> test-volume.txt<br></code></pre></td></tr></table></figure><p>（2）修改物理机的数据，观察container目录的数据变化</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;test-centos.&quot;</span> &gt; test-centos.txt<br>docker <span class="hljs-built_in">exec</span> -it test-mysql bash<br><span class="hljs-built_in">cd</span> /var/lib/mysql<br><span class="hljs-built_in">ls</span><br><span class="hljs-built_in">cat</span> test-centos.txt<br></code></pre></td></tr></table></figure><h4 id="1-1-4-默认Volume"><a href="#1-1-4-默认Volume" class="headerlink" title="1.1.4 默认Volume"></a>1.1.4 默认Volume</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d --name test-nginx -p 60:80 nginx<br>docker volume <span class="hljs-built_in">ls</span> <span class="hljs-comment"># 发现并没有自动创建volume，是因为在nginx的Dockerfile文件中没有指定VOLUME</span><br></code></pre></td></tr></table></figure><h4 id="1-1-5-验证持久化效果"><a href="#1-1-5-验证持久化效果" class="headerlink" title="1.1.5 验证持久化效果"></a>1.1.5 验证持久化效果</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建容器并使用自定义volume</span><br>docker run -d --name test-mysql -v test-mysql-volume:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=test123 mysql:5.7<br><span class="hljs-comment"># 进入容器并创建数据库</span><br>docker <span class="hljs-built_in">exec</span> -it test-mysql bash<br>create database db_test<br>show databases;<br><span class="hljs-comment"># 删除mysql容器并查看volume是否存在</span><br>docker <span class="hljs-built_in">rm</span> -f test-mysql<br>docker volume <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 重新创建一个mysql container并使用test-mysql-volume</span><br>docker run -d --name any-mysql -v test-mysql-volume:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=test123 mysql:5.7<br><span class="hljs-comment"># 进入容器并查看数据</span><br>docker <span class="hljs-built_in">exec</span> -it any-mysql bash<br>mysql -uroot -ptest123<br>show databases;<br></code></pre></td></tr></table></figure><h3 id="1-2-Bind-Mounting"><a href="#1-2-Bind-Mounting" class="headerlink" title="1.2 Bind Mounting"></a>1.2 Bind Mounting</h3><p>想把容器中任意的目录和centos的目录做一个绑定，比如centos中的~/shop 与tomcat container中的/usr/local/tomcat/webapps/shop进行绑定</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建tomcat容器，并指定目录绑定关系</span><br>docker run -d --name my-tomcat -p 8888:8080 -v ~/shop:/usr/local/tomcat/webapps/shop tomcat:8.0<br><span class="hljs-comment"># 查看两个目录是否存在</span><br>centos: <span class="hljs-built_in">ls</span> ~<br>tomcat容器:<br>docker <span class="hljs-built_in">exec</span> -it my-tomcat bash<br><span class="hljs-built_in">ls</span> /usr/local/tomcat/webapps<br><span class="hljs-comment"># 在centos的shop文件夹下创建文件</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;p style=&#x27;color:orange; font-size:20pt;&#x27;&gt;Bind Mounting.&lt;/p&gt;&quot;</span> &gt; index.html<br><span class="hljs-comment"># 访问该页面</span><br>centosip:8888/shop/index.html<br></code></pre></td></tr></table></figure><h2 id="2-网络"><a href="#2-网络" class="headerlink" title="2 网络"></a>2 网络</h2><p>官网：<a href="https://docs.docker.com/network/">https://docs.docker.com/network/</a></p><h3 id="2-1-网卡"><a href="#2-1-网卡" class="headerlink" title="2.1 网卡"></a>2.1 网卡</h3><h4 id="2-1-1-查看linux中的网卡"><a href="#2-1-1-查看linux中的网卡" class="headerlink" title="2.1.1 查看linux中的网卡"></a>2.1.1 查看linux中的网卡</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 方式1</span><br>ip <span class="hljs-built_in">link</span> show<br><span class="hljs-comment"># 方式2</span><br><span class="hljs-built_in">ls</span> /sys/class/net<br><span class="hljs-comment"># 方式3</span><br>ip a<br></code></pre></td></tr></table></figure><h4 id="2-1-2-分析ip-a"><a href="#2-1-2-分析ip-a" class="headerlink" title="2.1.2 分析ip a"></a>2.1.2 分析ip a</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 状态: UP、DOWN、UNKNOW</span><br><span class="hljs-comment"># link/ether：MAC地址</span><br><span class="hljs-comment"># inet：该网卡绑定的IP4地址</span><br>eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group<br>default qlen 1000<br><span class="hljs-built_in">link</span>/ether 52:54:00:8a:fe:e6 brd ff:ff:ff:ff:ff:ff<br>inet 10.0.2.15/24 brd 10.0.2.255 scope global noprefixroute dynamic eth0<br>valid_lft 83668sec preferred_lft 83668sec<br>inet6 fe80::5054:ff:fe8a:fee6/64 scope <span class="hljs-built_in">link</span><br>valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><h4 id="2-1-3-网卡对应的配置文件"><a href="#2-1-3-网卡对应的配置文件" class="headerlink" title="2.1.3 网卡对应的配置文件"></a>2.1.3 网卡对应的配置文件</h4><blockquote><p>在Linux中网卡对应的其实就是文件，所以找到对应的网卡文件即可 </p><p>具体目录为：/etc/sysconfig/network-scripts/ </p></blockquote><p>比如打开ifcfg-eth0</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">DEVICE=<span class="hljs-string">&quot;eth0&quot;</span> <span class="hljs-comment"># 表示网卡名称</span><br>BOOTPROTO=<span class="hljs-string">&quot;dhcp&quot;</span> <span class="hljs-comment"># 表示网卡类型：dhcp-动态 static-静态 none-固定</span><br>ONBOOT=<span class="hljs-string">&quot;yes&quot;</span> <span class="hljs-comment"># 开机或重启网卡的时候，是否启用该网卡</span><br>TYPE=<span class="hljs-string">&quot;Ethernet&quot;</span> <span class="hljs-comment"># 表示接口类型：Ethernet-以太网 Bridge-桥接接口</span><br>HWADDR=00:0c:29:90:89:d9 <span class="hljs-comment"># HWADDR HardWare Address 硬件地址 MAC地址</span><br>NETMASK=255.255.255.0 <span class="hljs-comment"># 子网掩码 决定这个局域网中最多有多少台机器</span><br>IPADDR=192.168.0.100<br>GATEWAY=10.0.0.2 <span class="hljs-comment"># 网关</span><br>USERCTL=no <span class="hljs-comment"># 普通用户是否能控制网卡</span><br>PERSISTENT_DHCLIENT=<span class="hljs-string">&quot;yes&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-Network-Namespace"><a href="#2-2-Network-Namespace" class="headerlink" title="2.2 Network Namespace"></a>2.2 Network Namespace</h3><p>linux上，网络的隔离是通过network namespace来管理的，不同的network namespace是互相隔离的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看</span><br>ip netns list<br><span class="hljs-comment"># 添加</span><br>ip netns add ns1<br><span class="hljs-comment"># 删除</span><br>ip netns delete ns1<br></code></pre></td></tr></table></figure><h4 id="2-2-1-创建Namespace"><a href="#2-2-1-创建Namespace" class="headerlink" title="2.2.1 创建Namespace"></a>2.2.1 创建Namespace</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建一个network namespace</span><br>ip netns add ns1<br><span class="hljs-comment"># 查看该namespace下网卡的情况</span><br>ip netns <span class="hljs-built_in">exec</span> ns1 ip a<br><span class="hljs-comment"># 启动ns1上的lo网卡</span><br>ip netns <span class="hljs-built_in">exec</span> ns1 ifup lo 或 ip netns <span class="hljs-built_in">exec</span> ns1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> lo up<br>ip netns <span class="hljs-built_in">exec</span> ns1 ip a<br><span class="hljs-comment"># 再次创建一个network namespace</span><br>ip netns add ns2<br></code></pre></td></tr></table></figure><p><img src="/image/docker/4.png"></p><h4 id="2-2-2-连接Namespace之间的网络"><a href="#2-2-2-连接Namespace之间的网络" class="headerlink" title="2.2.2  连接Namespace之间的网络"></a>2.2.2  连接Namespace之间的网络</h4><p>veth pair：virtual ethernet pair，是一个成对的端口，可以实现上述功能</p><p><img src="/image/docker/5.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建一对link，也就是接下来要通过veth pair连接的link</span><br>ip <span class="hljs-built_in">link</span><br>ip <span class="hljs-built_in">link</span> add veth-ns1 <span class="hljs-built_in">type</span> veth peer name veth-ns2<br>ip <span class="hljs-built_in">link</span><br><span class="hljs-comment"># 将veth-ns1加入ns1中，将veth-ns2加入ns2中</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth-ns1 netns ns1<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth-ns2 netns ns2<br><span class="hljs-comment"># 查看宿主机和ns1，ns2的link情况</span><br>ip <span class="hljs-built_in">link</span><br>ip netns <span class="hljs-built_in">exec</span> ns1 ip <span class="hljs-built_in">link</span><br>ip netns <span class="hljs-built_in">exec</span> ns2 ip <span class="hljs-built_in">link</span><br><span class="hljs-comment"># 给veth-ns1和veth-ns2添加IP地址并启动</span><br>ip netns <span class="hljs-built_in">exec</span> ns1 ip addr add 192.168.0.11/24 dev veth-ns1<br>ip netns <span class="hljs-built_in">exec</span> ns1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth-ns1 up<br>ip netns <span class="hljs-built_in">exec</span> ns2 ip addr add 192.168.0.12/24 dev veth-ns2<br>ip netns <span class="hljs-built_in">exec</span> ns2 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth-ns2 up<br>ip netns <span class="hljs-built_in">exec</span> ns1 ip a<br>ip netns <span class="hljs-built_in">exec</span> ns2 ip a<br><span class="hljs-comment"># 彼此ping测试一下</span><br>ip netns <span class="hljs-built_in">exec</span> ns1 ping 192.168.0.12<br>ip netns <span class="hljs-built_in">exec</span> ns2 ping 192.168.0.11<br></code></pre></td></tr></table></figure><h4 id="2-2-3-容器的Network-Namespace"><a href="#2-2-3-容器的Network-Namespace" class="headerlink" title="2.2.3  容器的Network Namespace"></a>2.2.3  容器的Network Namespace</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建两个tomcat容器</span><br>docker run -d --name tomcat01 -p 8081:8080 tomcat:8.0<br>docker run -d --name tomcat02 -p 8082:8080 tomcat:8.0<br><span class="hljs-comment"># 进入容器并安装ip命令</span><br>docker <span class="hljs-built_in">exec</span> -it tomcat01 bash<br>apt update<br>apt install -y iproutes<br>docker <span class="hljs-built_in">exec</span> -it tomcat02 bash<br>apt update<br>apt install -y iproutes<br><span class="hljs-comment"># 查看容器的IP</span><br>docker <span class="hljs-built_in">exec</span> -it tomcat01 ip a<br>docker <span class="hljs-built_in">exec</span> -it tomcat02 ip a<br><span class="hljs-comment"># ping一下</span><br>docker <span class="hljs-built_in">exec</span> -it tomcat01 ping 172.17.0.3<br>docker <span class="hljs-built_in">exec</span> -it tomcat02 ping 172.17.0.2<br>ping 172.17.0.2<br>ping 172.17.0.3<br></code></pre></td></tr></table></figure><h3 id="2-3-Docker常见网络类型"><a href="#2-3-Docker常见网络类型" class="headerlink" title="2.3 Docker常见网络类型"></a>2.3 Docker常见网络类型</h3><h4 id="2-3-1-Bridge之docker0"><a href="#2-3-1-Bridge之docker0" class="headerlink" title="2.3.1 Bridge之docker0"></a>2.3.1 Bridge之docker0</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看centos的veth</span><br>ip <span class="hljs-built_in">link</span><br><span class="hljs-comment"># 查看两个tomcat容器的veth</span><br>docker <span class="hljs-built_in">exec</span> -it tomcat01 ip <span class="hljs-built_in">link</span><br>docker <span class="hljs-built_in">exec</span> -it tomcat02 ip <span class="hljs-built_in">link</span><br></code></pre></td></tr></table></figure><p><img src="/image/docker/6.png"></p><p><img src="/image/docker/7.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看docker中的网络模式</span><br>docker network <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 查看bridge的细节</span><br>docker network inspect bridge<br></code></pre></td></tr></table></figure><p><img src="/image/docker/8.png"></p><h4 id="2-3-2-Bridge网络模式实战"><a href="#2-3-2-Bridge网络模式实战" class="headerlink" title="2.3.2 Bridge网络模式实战"></a>2.3.2 Bridge网络模式实战</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建一个network，类型为bridge</span><br>docker network create --subnet=172.18.0.0/24 tomcat-net<br>docker network <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 查看tomcat-net细节</span><br>docker network inspect tomcat-net<br><span class="hljs-comment"># 创建tomcat容器并指定网络为tomcat-net</span><br>docker run -d --name custom-net-tomcat --network tomcat-net tomcat:8.0<br>docker <span class="hljs-built_in">exec</span> -it custom-net-tomcat ip <span class="hljs-built_in">link</span><br>ip <span class="hljs-built_in">link</span><br></code></pre></td></tr></table></figure><p><img src="/image/docker/9.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 此时在custom-net-tomcat容器中ping一下tomcat01的ip会如何？发现无法ping通</span><br>docker <span class="hljs-built_in">exec</span> -it custom-net-tomcat ping 172.17.0.2<br><span class="hljs-comment"># 让tomcat01网络连接tomcat-net</span><br>docker network connect tomcat-net tomcat01<br>docker network inspect tomcat-net<br><span class="hljs-comment"># 再次尝试在custom-net-tomcat中ping一下tomcat01</span><br>docker <span class="hljs-built_in">exec</span> -it custom-net-tomcat ping 172.18.0.2<br>docker <span class="hljs-built_in">exec</span> -it custom-net-tomcat ping tomcat01<br><span class="hljs-comment"># ping tomcat02，发现是不能ping通的</span><br>docker <span class="hljs-built_in">exec</span> -it custom-net-tomcat ping tomcat02<br></code></pre></td></tr></table></figure><p><img src="/image/docker/10.png"></p><h4 id="2-3-3-Host"><a href="#2-3-3-Host" class="headerlink" title="2.3.3 Host"></a>2.3.3 Host</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建一个tomcat容器，并且指定网络为host</span><br>docker run -d --name my-tomcat-host --network host tomcat:8.0<br><span class="hljs-comment"># 查看ip地址，可以发现和centos是一样的</span><br>docker <span class="hljs-built_in">exec</span> -it my-tomcat-host ip a<br><span class="hljs-comment"># 直接访问8080端口</span><br>curl centosip:8080<br><span class="hljs-comment"># 查看host网络细节</span><br>docker network inspect host<br></code></pre></td></tr></table></figure><h4 id="2-3-4-None"><a href="#2-3-4-None" class="headerlink" title="2.3.4 None"></a>2.3.4 None</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建一个tomcat容器，并且指定网络为none</span><br>docker run -d --name my-tomcat-none --network none tomcat:8.0<br><span class="hljs-comment"># 查看ip地址</span><br>docker <span class="hljs-built_in">exec</span> -it my-tomcat-none ip a<br><span class="hljs-comment"># 检查none网络</span><br>docker network inspect none<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker安装与基础使用</title>
    <link href="/2023/04/21/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/docker/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/04/21/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/docker/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Docker介绍与安装"><a href="#1-Docker介绍与安装" class="headerlink" title="1 Docker介绍与安装"></a>1 Docker介绍与安装</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p><img src="/image/docker/1.png"></p><p>Container是一种轻量级的虚拟化技术，不用模拟硬件创建虚拟机。</p><p>Docker是基于Linux Kernel的Namespace、CGroups、UnionFileSystem等技术封装成的一种自定义容器格式，从而提供一套虚拟运行环境。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Chroot：Change Root 隔离文件<br>Namespace：用来做隔离的，比如pid<span class="hljs-comment">[进程]</span>、net<span class="hljs-comment">[网络]</span>、mnt<span class="hljs-comment">[挂载点]</span>等<br>CGroups: Controller Groups用来做资源限制，比如内存和CPU等<br>Union file systems：用来做image和<span class="hljs-keyword">container</span>分层<br></code></pre></td></tr></table></figure><h3 id="1-2-安装-CentOS"><a href="#1-2-安装-CentOS" class="headerlink" title="1.2 安装(CentOS)"></a>1.2 安装(CentOS)</h3><p>参考文档：<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p><p>在线使用：<a href="https://labs.play-with-docker.com/">https://labs.play-with-docker.com/</a></p><ol><li>卸载之前的docker</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum remove docker \<br>docker-client \<br>docker-client-latest \<br>docker-common \<br>docker-latest \<br>docker-latest-logrotate \<br>docker-logrotate \<br>docker-engine<br></code></pre></td></tr></table></figure><ol start="2"><li>安装必要的依赖</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum install -y yum-utils \ <br>device-mapper-persistent-data \ <br>lvm2<br></code></pre></td></tr></table></figure><ol start="3"><li>设置docker仓库</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo yum-config-manager \ <br>--add-repo \ <br>https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><ol start="4"><li>查看可以安装的版本</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum list docker-ce --showduplicates | <span class="hljs-built_in">sort</span> -r<br></code></pre></td></tr></table></figure><ol start="5"><li>安装最新或指定版本</li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">安装最新版本：sudo yum install -y docker-ce docker-ce-<span class="hljs-keyword">cli</span> containerd.io dockercompose-<span class="hljs-keyword">plugin</span><br>安装指定版本：sudo yum install -y docker-ce-20.10.7 docker-ce-<span class="hljs-keyword">cli</span>-20.10.7 containerd.io docker-compose-<span class="hljs-keyword">plugin</span><br></code></pre></td></tr></table></figure><ol start="6"><li>启动docker并设置为开机启动</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo systemctl start docker &amp;&amp; sudo systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></td></tr></table></figure><ol start="7"><li>测试docker安装是否成功</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo docker run hello-world<br></code></pre></td></tr></table></figure><ol start="8"><li>配置镜像加速器</li></ol><p>镜像加速器设置方式: <a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><h3 id="1-3-Docker体验"><a href="#1-3-Docker体验" class="headerlink" title="1.3 Docker体验"></a>1.3 Docker体验</h3><p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p>（1）tomcat:8.0</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">拉取镜像：docker pull tomcat:8.0<br>根据镜像创建容器：docker run -d --name tomcat01 -p 8088:8080 tomcat:8.0<br></code></pre></td></tr></table></figure><p>（2）mysql</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d --name my-mysql -p 3301:3306 -e MYSQL_ROOT_PASSWORD=jack666 --privileged mysql:5.7<br></code></pre></td></tr></table></figure><h2 id="2-Image"><a href="#2-Image" class="headerlink" title="2 Image"></a>2 Image</h2><p><img src="/image/docker/2.png"></p><h3 id="2-1-根据Dockerfile构建镜像"><a href="#2-1-根据Dockerfile构建镜像" class="headerlink" title="2.1 根据Dockerfile构建镜像"></a>2.1 根据Dockerfile构建镜像</h3><p>MySQL Dockerfile：<a href="https://github.com/docker-library">https://github.com/docker-library</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker build -t custom-mysql-image<br></code></pre></td></tr></table></figure><h3 id="2-2-制作jar包镜像"><a href="#2-2-制作jar包镜像" class="headerlink" title="2.2 制作jar包镜像"></a>2.2 制作jar包镜像</h3><p>（1）创建一个Spring Boot项目 </p><p>（2）写一个controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DockerController</span>&#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    String <span class="hljs-title function_">dockerFile</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello docker&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）mvn clean package，并在target下找到”dockerfile-demo-0.0.1-SNAPSHOT.jar” </p><p>（4）上传”dockerfile-demo-0.0.1-SNAPSHOT.jar”到centos，并创建Dockerfile文件 </p><p>（5）编写Dockerfile内容</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">8</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> dockerfile-demo-0.0.1-SNAPSHOT.jar dockerfile-image.jar</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;dockerfile-image.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>（6）基于Dockerfile构建镜像并查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker build -t custom-docker-image<br>docker images<br></code></pre></td></tr></table></figure><p>（7）基于image创建container</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d -name docker01 -p 6666:8080 custom-docker-image<br></code></pre></td></tr></table></figure><p>（8）查看启动日志docker logs docker01 </p><p>（9）宿主机上访问curl localhost:6666/hello</p><h3 id="2-3-阿里镜像仓库"><a href="#2-3-阿里镜像仓库" class="headerlink" title="2.3 阿里镜像仓库"></a>2.3 阿里镜像仓库</h3><p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances">https://cr.console.aliyun.com/cn-hangzhou/instances</a></p><p>（1）进入个人实例：<a href="https://cr.console.aliyun.com/cn-hangzhou/instance/dashboard">https://cr.console.aliyun.com/cn-hangzhou/instance/dashboard</a> </p><p>（2）创建命名空间，比如test-kubernetes </p><p>（3）在centos上登录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo docker login --username=&#123;your name&#125; registry.cn-hangzhou.aliyuncs.com<br></code></pre></td></tr></table></figure><p>（4）给image打tag</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo docker tag 91b27814153f registry.cn-hangzhou.aliyuncs.com/test-kubernetes/custom-docker-image:v1.0<br><br>docker images<br></code></pre></td></tr></table></figure><p>（5）推送镜像到镜像仓库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo docker push registry.cn-hangzhou.aliyuncs.com/test-kubernetes/custom-docker-image:v1.0<br></code></pre></td></tr></table></figure><p>（6）下载镜像并运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull registry.cn-hangzhou.aliyuncs.com/test-kubernetes/custom-docker-image:v1.0<br>docker run -d --name docker01 -p 6661:8080 registry.cn-hangzhou.aliyuncs.com/test-kubernetes/custom-docker-image:v1.0<br></code></pre></td></tr></table></figure><h3 id="2-4-Image基本操作"><a href="#2-4-Image基本操作" class="headerlink" title="2.4 Image基本操作"></a>2.4 Image基本操作</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mel">(<span class="hljs-number">1</span>) 查看本地<span class="hljs-keyword">image</span>列表<br>docker images<br>docker <span class="hljs-keyword">image</span> <span class="hljs-keyword">ls</span><br>(<span class="hljs-number">2</span>) 获取远端镜像<br>docker pull<br>(<span class="hljs-number">3</span>) 删除镜像[注意此镜像如果正在使用，或者有关联的镜像，则需要先处理完] （-f 强制）<br>docker <span class="hljs-keyword">image</span> rm imageid<br>docker rmi -f imageid<br>docker rmi -f $(docker <span class="hljs-keyword">image</span> <span class="hljs-keyword">ls</span>) 删除所有镜像<br>(<span class="hljs-number">4</span>) 运行镜像<br>docker run <span class="hljs-keyword">image</span><br>(<span class="hljs-number">5</span>) 推送镜像<br>docker push<br></code></pre></td></tr></table></figure><h2 id="3-Container"><a href="#3-Container" class="headerlink" title="3 Container"></a>3 Container</h2><p>container是基于image之后的layer，也就是可以通过docker run image创建出 一个container出来。</p><p><img src="/image/docker/3.png"></p><h3 id="3-1-通过Container制作Image"><a href="#3-1-通过Container制作Image" class="headerlink" title="3.1  通过Container制作Image"></a>3.1  通过Container制作Image</h3><p>(1) 拉取tomcat镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull tomcat<br>docker images<br></code></pre></td></tr></table></figure><p>(2) 根据tomcat镜像创建出一个tomcat container</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d -it --name test-tomcat tomcat<br>docker ps<br></code></pre></td></tr></table></figure><p>(3) 进入test-tomcat容器中[这里也可以看出container其实就是一个最小内核的linux系统]</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it test-tomcat bash<br><span class="hljs-built_in">pwd</span><br><span class="hljs-built_in">cat</span> /etc/issue<br></code></pre></td></tr></table></figure><p>(4) 在tomcat的webapps目录下创建test文件夹，并且新建wel.html文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> <span class="hljs-built_in">test</span><br><span class="hljs-built_in">cd</span> <span class="hljs-built_in">test</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;welcome to java.&quot;</span> &gt; wel.html<br></code></pre></td></tr></table></figure><p>(5) 退出容器，将其生成一个新的tomcat，名称为: customized-tomcat</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">exit</span><br>docker commit test-tomcat customized-tomcat<br>docker images<br></code></pre></td></tr></table></figure><p>(6) 基于customized-tomcat镜像创建新的容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d -it --name customized-tomcat01 -p 8001:8080 customized-tomcat <br>docker ps<br></code></pre></td></tr></table></figure><p>(7) 进入到customized-tomcat01容器中，看看文件是否存在</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it customized-tomcat01 bash<br><span class="hljs-built_in">cd</span> webapps<br><span class="hljs-built_in">ls</span><br><span class="hljs-built_in">cat</span> <span class="hljs-built_in">test</span>/wel.html<br></code></pre></td></tr></table></figure><p>(8) 访问centosip:8081/test/wel.html</p><h3 id="3-2-Container常见操作"><a href="#3-2-Container常见操作" class="headerlink" title="3.2  Container常见操作"></a>3.2  Container常见操作</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mel">(<span class="hljs-number">1</span>) 根据镜像创建容器<br>docker run -d --name -p <span class="hljs-number">9090</span>:<span class="hljs-number">8080</span> my-tomcat tomcat<br>(<span class="hljs-number">2</span>) 查看运行中的<span class="hljs-keyword">container</span><br>docker ps<br>(<span class="hljs-number">3</span>) 查看所有的<span class="hljs-keyword">container</span>[包含退出的]<br>docker ps -a<br>docker ps -aq<br>(<span class="hljs-number">4</span>) 删除<span class="hljs-keyword">container</span><br>docker rm containerid<br>docker rm -f $(docker ps -a) 删除所有<span class="hljs-keyword">container</span><br>(<span class="hljs-number">5</span>) 进入到一个<span class="hljs-keyword">container</span>中<br>docker <span class="hljs-keyword">exec</span> -it <span class="hljs-keyword">container</span> bash<br>(<span class="hljs-number">6</span>) 根据<span class="hljs-keyword">container</span>生成<span class="hljs-keyword">image</span><br>docker commit jack-tomcat gupao-customized-tomcat<br>(<span class="hljs-number">7</span>) 查看某个<span class="hljs-keyword">container</span>的日志<br>docker logs <span class="hljs-keyword">container</span><br>(<span class="hljs-number">8</span>) 查看容器资源使用情况<br>docker stats<br>docker stats <span class="hljs-keyword">container</span><br>(<span class="hljs-number">9</span>) 查看容器详情信息<br>docker inspect <span class="hljs-keyword">container</span><br>(<span class="hljs-number">10</span>) 停止/启动容器<br>docker stop/start <span class="hljs-keyword">container</span><br></code></pre></td></tr></table></figure><h3 id="3-3-设置Container资源限制"><a href="#3-3-设置Container资源限制" class="headerlink" title="3.3  设置Container资源限制"></a>3.3  设置Container资源限制</h3><p>（1）内存限制：–memory 如果不设置 –memory-swap，其大小和memory一样</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d -memory 100M --name test-tomcat-memory-limit tomcat<br>docker status<br></code></pre></td></tr></table></figure><p>（2）CPU限制：–cpu-shares 权重</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -d --cpu-shares 10 test-tomcat-cpu-limit tomcat<br>docker status<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcd高级应用</title>
    <link href="/2023/04/20/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/etcd/etcd%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    <url>/2023/04/20/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/etcd/etcd%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-分布式锁"><a href="#1-分布式锁" class="headerlink" title="1 分布式锁"></a>1 分布式锁</h2><h3 id="1-1-Redis分布式锁"><a href="#1-1-Redis分布式锁" class="headerlink" title="1.1 Redis分布式锁"></a>1.1 Redis分布式锁</h3><p>➢ Set实现分布式锁：</p><p>⚫ SET key value [EX seconds] [NX|XX]，获取不到 锁的线程只能轮询去尝试获取锁（可用性） </p><p>⚫ NX参数实现互斥，一次性只能一个（互斥性）</p><p> ⚫ EX保证拿到锁的服务器挂掉了，能自动释放锁（活 性）</p><p> ⚫ SETNX无法原子性设置过期时间，所以并不常用</p><p>➢ 优点 </p><p>⚫ 快、简单，在允许偶发锁失效的场景下推荐使用 </p><p>➢ 缺点 </p><p>⚫ 通过轮询抢占锁的机制不是很可靠，当某线程占用锁时间较长时可能导致其他线程抢占锁失 败 </p><p>⚫ 如果master和slave结构，如果存在脑裂或者数据丢失情况，导致锁的数据没有同步，就导致 了分布式锁的失效 </p><p>⚫ 解锁时，为了保证原子性（查询锁，判断值并删除），需要在redis服务端用脚本来实现查询 并删除</p><h3 id="1-2-Zookeeper分布式锁"><a href="#1-2-Zookeeper分布式锁" class="headerlink" title="1.2 Zookeeper分布式锁"></a>1.2 Zookeeper分布式锁</h3><h4 id="1-2-1-基于唯一节点实现"><a href="#1-2-1-基于唯一节点实现" class="headerlink" title="1.2.1 基于唯一节点实现"></a>1.2.1 基于唯一节点实现</h4><p>⚫ 唯一节点保证互斥性 ⚫ Zap协议保证一致性 ⚫ 临时节点保证活性 ⚫ Watch机制保证可用性</p><p><img src="/image/etcd/2.png"></p><p>缺点：会发生惊群效应，当释放锁时所有竞争都将被唤醒</p><h4 id="1-2-2-基于有序节点实现"><a href="#1-2-2-基于有序节点实现" class="headerlink" title="1.2.2 基于有序节点实现"></a>1.2.2 基于有序节点实现</h4><p><img src="/image/etcd/4.png"></p><p>流程：<br><img src="/image/etcd/5.png"></p><h3 id="1-3-Etcd实现分布式锁"><a href="#1-3-Etcd实现分布式锁" class="headerlink" title="1.3 Etcd实现分布式锁"></a>1.3 Etcd实现分布式锁</h3><p>Etcd是具备事务特性的，所以天然能保证原子性操作 ；可以根据key的create_revision来保证互斥性； Etcd集群通过Raft保证了数据的强一致性 ； Etcd通过Lease来保证活性 ；Etcd通过Watch来保证可用性</p><p><img src="/image/etcd/6.png"></p><p>流程：</p><ol><li><p>准备：</p><p> 客户端连接Etcd，以/lock为前缀创建全局唯一的key；客户端分别为自己的key创建租约 Lease，租约的过期时间默认60s；每个客户端创建的具体key为/lock/leaseId</p></li><li><p>创建定时任务作为租约的“心跳”：</p><p> 当一个客户端持有锁期间，其它客户端只能等待，为了避免等待期间租约失效，客户端会调 用keepalive进行自动续约。此外，如果持有锁期间客户端崩溃，心跳停止，key 将因租约 到期而被删除，从而锁释放，避免死锁。</p></li><li><p>客户端将自己全局唯一的 key 写入 Etcd</p><p> 进行 put 操作，将步骤 1 中创建的 key 绑定租约写入 Etcd，根据 Etcd 的 Revision 机 制，假设两个客户端 put 操作返回的 Revision 分别为 1、2，客户端需记录 Revision 用 以接下来判断自己是否获得锁。</p></li><li><p>客户端判断是否获得锁</p><p> 客户端以前缀 /lock/ 读取 keyValue 列表（keyValue 中带有 key 对应的 Revision）， 判断自己 key 的 Revision 是否为当前列表中最小的，如果是则认为获得锁；否则监听列 表中前一个 Revision 比自己小的 key 的删除事件，一旦监听到删除事件或者因租约失效 而删除的事件，则自己获得锁。</p></li><li><p>执行业务</p></li><li><p>释放锁</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>etcd</category>
      
    </categories>
    
    
    <tags>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Quarkus入门</title>
    <link href="/2023/04/20/spring%E6%A1%86%E6%9E%B6/Quarkus/Quarkus%E5%85%A5%E9%97%A8/"/>
    <url>/2023/04/20/spring%E6%A1%86%E6%9E%B6/Quarkus/Quarkus%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>官网：<a href="https://quarkus.io/">https://quarkus.io/</a></p><p>快速开始：</p><ol><li>new project</li></ol><p><img src="/image/Quarkus/1.png"></p><ol start="2"><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.26<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>编写代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br><span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>&#125;<br><br><span class="hljs-meta">@ApplicationScoped</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span>&#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(User user)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;say hello: &quot;</span> + user.getUserName() + <span class="hljs-string">&quot;  &quot;</span> + user.getPassword();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Path(&quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleResource</span>&#123;<br>    <span class="hljs-meta">@Inject</span><br>    UserService userService;<br>    <br>    <span class="hljs-meta">@GET</span><br>    <span class="hljs-meta">@Produces(MediaType.TEXT_PLAIN)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setUsername(<span class="hljs-string">&quot;test&quot;</span>);<br>        user.setPassword(<span class="hljs-string">&quot;666&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.userService.sayHello(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>修改端口</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">quarlkus.http.port</span>=<span class="hljs-string">6060</span><br></code></pre></td></tr></table></figure><ol start="5"><li>启动程序，访问localhost:6060/hello</li></ol>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>Quarkus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>Quarkus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcd的MVCC和租约和Watch原理分析</title>
    <link href="/2023/04/18/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/etcd/etcdMVCC%E5%92%8C%E7%A7%9F%E7%BA%A6%E5%92%8CWatch%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <url>/2023/04/18/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/etcd/etcdMVCC%E5%92%8C%E7%A7%9F%E7%BA%A6%E5%92%8CWatch%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-MVCC流程"><a href="#1-MVCC流程" class="headerlink" title="1 MVCC流程"></a>1 MVCC流程</h2><p>mvcc(多版本并发控制，mysql中也使用到了)解决的就是读写时的线程安全问题，线程不用去争抢读写锁。</p><p><img src="/image/etcd/MVCC-%E6%9E%B6%E6%9E%84%E6%B5%81%E7%A8%8B.jpg"></p><p>查询</p><p><img src="/image/etcd/MVCC-%E6%9F%A5%E8%AF%A2.jpg"></p><p>更新</p><p><img src="/image/etcd/MVCC-%E6%9B%B4%E6%96%B0.jpg"></p><h2 id="2-Lease-租约-流程"><a href="#2-Lease-租约-流程" class="headerlink" title="2 Lease(租约)流程"></a>2 Lease(租约)流程</h2><p>一个key一个TTL太占内存，同时性能不高。说白了就相当于租房的一个合同而已，这个合同可以管理很多key，在合同的时间围之内，我的key存在你那里是有效的，你不能删除我关联到此Lease上的key-value。</p><h3 id="2-1-架构"><a href="#2-1-架构" class="headerlink" title="2.1 架构"></a>2.1 架构</h3><ol><li>创建Lease流程（跟put流程差不多）最 终会保存LeaseId到ItemMap和boltdb中</li><li>Lease关联key流程：在put的时候会 根据参数去掉Attach方法，将Key关 联到Lease的key内存集合ItemSet中</li><li>过期自动淘汰流程</li></ol><p><img src="/image/etcd/Lease%E6%9E%B6%E6%9E%84.jpg"></p><h3 id="2-2-源码"><a href="#2-2-源码" class="headerlink" title="2.2 源码"></a>2.2 源码</h3><p><img src="/image/etcd/Lease%E6%BA%90%E7%A0%81.jpg"></p><h3 id="2-3-优化"><a href="#2-3-优化" class="headerlink" title="2.3 优化"></a>2.3 优化</h3><p>➢ 续期的优化 </p><p>⚫ 从网络通信上优化，http转成了gRPC </p><p>⚫ 从TTL上优化，以前一个key要创建一个TTL，现在多个key绑定同一个Lease </p><p>➢ 淘汰优化 </p><p>⚫ 以前是遍历所有的TTL，看到没到期 </p><p>⚫ 现在所有的Lease存一个对象到最小堆里，按到期时间升序排，只要找堆顶的少数数据就可以停止循环找了</p><h2 id="3-Watch流程"><a href="#3-Watch流程" class="headerlink" title="3 Watch流程"></a>3 Watch流程</h2><h3 id="3-1-推拉模式"><a href="#3-1-推拉模式" class="headerlink" title="3.1 推拉模式"></a>3.1 推拉模式</h3><p>➢ 拉模式   </p><p>⚫ Etcdv2的实现方式 </p><p>⚫ 一般通过定时任务定时拉取，时效性不高，一般不会发生消息堆积 </p><p>⚫ 当watch过多的时候，QPS过高会导致接口崩溃，同时销毁大量的socket资源 </p><p>➢ 推模式</p><p>⚫ Etcdv3的实现方式 </p><p>⚫ 一般基于发布订阅的方式去实现，时效性高，可能造成消息堆积 </p><p>⚫ 当client因网络等异常出现连接闪断后，通过版本号，它就可从server端的boltdb中获取错过的 历史事件，而无需全量同步，它是etcd Watch机制数据增量同步的核心</p><h3 id="3-2-事件存储"><a href="#3-2-事件存储" class="headerlink" title="3.2 事件存储"></a>3.2 事件存储</h3><p>➢ 滑动窗口 </p><p>⚫ Etcdv2的实现方式 </p><p>⚫ 仅保存有限的最近历史版本到内存中（EventHistory中的eventQueue） </p><p>⚫ 优点就是eventQueue固定容量是1000，最多保存1000条事件，超过了就删除最早的事件，这不会 造成OOM，缺点就是不可靠啊 </p><p> ➢ MVCC</p><p>⚫ Etcdv3的实现方式 </p><p>⚫ MVCC机制则将历史版本保存在磁盘中，避免了历史版本的丢失，极大的提升了Watch机制的可靠性</p><h3 id="3-3-可靠的事件推送机制"><a href="#3-3-可靠的事件推送机制" class="headerlink" title="3.3 可靠的事件推送机制"></a>3.3 可靠的事件推送机制</h3><p>➢ 整体架构 ➢ 最新的事件推送 ➢ 发生异常了重试机制 ➢ 历史事件推送</p><h3 id="3-4-架构"><a href="#3-4-架构" class="headerlink" title="3.4 架构"></a>3.4 架构</h3><p><img src="/image/etcd/Watch%E6%9E%B6%E6%9E%84.jpg"></p><h3 id="3-5-源码"><a href="#3-5-源码" class="headerlink" title="3.5 源码"></a>3.5 源码</h3><p><img src="/image/etcd/Watch%E6%BA%90%E7%A0%81.jpg"></p><h3 id="3-6-异常场景重试流程"><a href="#3-6-异常场景重试流程" class="headerlink" title="3.6 异常场景重试流程"></a>3.6 异常场景重试流程</h3><p>➢ 发生异常比如网络波动，或者channel满了，事件没有被执行怎么办？ </p><ol><li><p>Etcd的watch并不会丢弃，这个时候会将watch从synced watcherGroup删除，并放到victim  watchBatch中 </p></li><li><p>然后上面说的那个sync VictimLoop协程开始干活，就是不断去看victim watchBatch里面有没有watch，有就重试事件的执行</p></li></ol><p>➢ syncVictimsLoop工作流程 </p><ol><li> 遍历victim watcherBatch数据结构，尝试将堆积的事件再次推送到watcher的接收channel中。若推送失败，则再次加入到victim watcherBatch数据结构中等待下次重试。 </li><li>若推送成功，watcher监听的最小版本号(minRev)小于等于server当前版本号(currentRev)，说明可能还有历史事件未推送，需加入到unsynced watcherGroup中，由下面介绍的历史事件推送机制， 推送minRev到currentRev之间的事件。 </li><li>若watcher的最小版本号大于server当前版本号，则加入到synced watcher集合中，进入上面介绍的最新事件通知机制。</li></ol><h3 id="3-7-高效匹配watch"><a href="#3-7-高效匹配watch" class="headerlink" title="3.7 高效匹配watch"></a>3.7 高效匹配watch</h3><p>➢ 监听单个key的watch ⚫ 使用map进行存储匹配</p><p>➢ 监听key范围或者前缀的watch ⚫ 使用区间树进行匹配</p><p><img src="/image/etcd/1.png"></p>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>etcd</category>
      
    </categories>
    
    
    <tags>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcd读写以及数据一致性原理分析</title>
    <link href="/2023/04/17/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/etcd/etcd%E8%AF%BB%E5%86%99%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <url>/2023/04/17/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/etcd/etcd%E8%AF%BB%E5%86%99%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-读流程"><a href="#1-读流程" class="headerlink" title="1 读流程"></a>1 读流程</h2><p>架构：</p><p><img src="/image/etcd/etcd%E8%AF%BB%E6%B5%81%E7%A8%8B%E6%9E%B6%E6%9E%84.jpg"></p><p>流程1：etcd客户端发起一个get请求，这个 请求底层是基于gRPC完成的</p><p>流程2：然后etcd服务端通过gRPC接收请求， 在gRPC中会注册多个过滤器，不过最终会调 用到KVServer中的接口</p><p>流程3：KVServer接收到请求后会调Raft模块， 去拿集群中最新的版本号</p><p>流程4：拿到版本号之后，KVServer继续调用 MVCC模块，根据key和版本号去拿treeIndex中的一个版本，根据上面那个版本去boltdb拿真实的value</p><h3 id="1-1-客户端"><a href="#1-1-客户端" class="headerlink" title="1.1 客户端"></a>1.1 客户端</h3><p>也就是流程1，具体步骤：</p><ol><li>etcdctl启动客户端（实际就是Go语言底层执行main方法）</li><li>启动过程中拿底层操作系统的cmd指令，并根据不同的参数封装各种命令，然后通过传进来的参数选择执行不同的命令</li><li>在客户端进行负载均衡，etcd默认的是round-robin算法</li><li>最终etcd客户端创建gRPC客户端，调etcd服务端的KVServer模块</li></ol><p>源码流程：</p><p><img src="/image/etcd/etcd%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%BB%E6%BA%90%E7%A0%81.jpg"></p><h3 id="1-2-服务端"><a href="#1-2-服务端" class="headerlink" title="1.2 服务端"></a>1.2 服务端</h3><p>前置：启动etcdserver端</p><p>流程2：KVServer接收get请求</p><p>流程3：等待数据同步</p><p>流程4：去数据库里面拿数据</p><h4 id="1-2-1-前置"><a href="#1-2-1-前置" class="headerlink" title="1.2.1 前置"></a>1.2.1 前置</h4><ol><li>启动server/main.go中的main方法</li><li>创建一个Etcd的实例，里面有个etcdserver</li><li>创建一个etcdserver对象然后赋值给上面</li><li>创建了各种异步协程、通道、注册各种模块 （KVServer、拦截器）到gRPC</li><li>启动</li></ol><p><img src="/image/etcd/etcd%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%BB%E6%B5%81%E7%A8%8B%E5%89%8D%E7%BD%AE.jpg"></p><h4 id="1-2-2-流程"><a href="#1-2-2-流程" class="headerlink" title="1.2.2 流程"></a>1.2.2 流程</h4><ol><li>Etcdserver接收get请求，被拦截器给拦截</li><li>执行Key.go中Range，判断是否是线性读（默认线性读）</li><li>跟Leader进行通信，判断ReadIndex是不是最新的</li><li>不是的话就等着Raft那个携程进行数据同步</li><li>拿到最新的ReadIndex，然后根据key去数据库拿数据</li></ol><p><img src="/image/etcd/etcd%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%BB%E6%B5%81%E7%A8%8B.jpg"></p><h2 id="2-写流程"><a href="#2-写流程" class="headerlink" title="2 写流程"></a>2 写流程</h2><p> 写只能Leader处理，Follower只能读</p><p>⚫ 如何保证数据不丢失——集群来保证 </p><p>⚫ 写命令如何不重复执行——幂等性来保证</p><p>架构：</p><p><img src="/image/etcd/etcd%E5%86%99%E6%B5%81%E7%A8%8B%E6%9E%B6%E6%9E%84.jpg"></p><p>流程1：etcd客户端发起一个put请求</p><p>流程2：etcd服务端中的拦截器接收请求，先做配额限制</p><p>流程3：如果没有没有超过配额，进入KV模块</p><p>流程4：走Raft模块保证各节点的数据一致</p><p>流程5：各节点将Raft日志进行持久化，防止节点在数据存到 boltdb之前挂掉导致数据丢失</p><p>流程6：将要持久化到boltdb的数据发送给Apply</p><p>流程7：数据基于MVCC进行持久化</p><h3 id="2-1-客户端"><a href="#2-1-客户端" class="headerlink" title="2.1 客户端"></a>2.1 客户端</h3><p>与读流程差不多，不重复讲述</p><h3 id="2-2-服务端"><a href="#2-2-服务端" class="headerlink" title="2.2 服务端"></a>2.2 服务端</h3><h4 id="2-2-1-Quota-配额-模块"><a href="#2-2-1-Quota-配额-模块" class="headerlink" title="2.2.1 Quota(配额)模块"></a>2.2.1 Quota(配额)模块</h4><p>就是etcd boltdb中能存的最大字节，默认是2GB， 如果超过配额会报NO SPACE告警，调大配额，还需要执行etcdctl alarm disarm取消告警。⚫ 修改配额：启动服务端的时候加参数：–quota-backendbytes=20(20表示字节)</p><p><img src="/image/etcd/etcd%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%86%99%E6%B5%81%E7%A8%8B-Quota(%E9%85%8D%E9%A2%9D).jpg"></p><h4 id="2-2-2-KV模块"><a href="#2-2-2-KV模块" class="headerlink" title="2.2.2 KV模块"></a>2.2.2 KV模块</h4><p><img src="/image/etcd/etcd%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%86%99%E6%B5%81%E7%A8%8B-KV%E6%A8%A1%E5%9D%97.jpg"></p><h4 id="2-2-3-整体源码"><a href="#2-2-3-整体源码" class="headerlink" title="2.2.3 整体源码"></a>2.2.3 整体源码</h4><p><img src="/image/etcd/etcd%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%86%99%E6%BA%90%E7%A0%81.jpg"></p><h2 id="3-数据一致性—强一致性"><a href="#3-数据一致性—强一致性" class="headerlink" title="3 数据一致性—强一致性"></a>3 数据一致性—强一致性</h2><p>Raft协议：<a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p><p>➢ Leader，集群领导者， 唯一性，拥有同步日志的特权，需定时广播心跳给 Follower节点，以维持领导者身份 </p><p>➢ Candidate，竞选者，可以发起Leader选举 </p><p>➢ Follower，跟随者， 同步从Leader收到的日志，etcd启动的时候默认为此状态</p><p>数据同步过程：</p><p><img src="/image/etcd/etcd%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E8%BF%87%E7%A8%8B.jpg"></p><p>安全性：</p><p>➢ 选举规则 </p><p>⚫ 检查候选者的最后一条日志中的任期号，若小于自己则拒绝投票。如果任期号相同，日志却比自己短，也拒绝为其投票。 </p><p>⚫ 每个节点在同一个任期内只能为一个节点投票</p><p>➢ 日志复制规则 </p><p>⚫ Leader完全特性：如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大 任期号的所有Leader中 </p><p>⚫ 只附加原则：Leader只能追加日志条目，不能删除已持久化的日志条目 </p><p>⚫ 日志匹配原则：Leader在发送追加日志RPC消息时，会把新的日志条目紧接着之前的条目的索引 位置和任期号包含在里面。Follower节点会检查相同索引位置的任期号是否与Leader一致，一致 才能追加</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>➢ Etcd客户端读写流程</p><p> ⚫ 解析参数并选择命令 ⚫ 进行负载均衡重试等操作 ⚫ 发起gRPC请求</p><p>➢ Etcd服务端读流程</p><p>⚫ 前置开启服务以及各种携程，并注册拦截器，最终调KVServer模块 ⚫ 发起线性读保证安全</p><p>➢ Etcd服务端写流程</p><p> ⚫ 前置开启服务以及各种携程，并注册拦截器，调Quota进行配额限制、然后调KVServer进行限流、 校验、限制大小等操作 ⚫ 走Raft模块，保证各节点数据同步 ⚫ 收到各节点同步日志成功通知则走Apply模块，进行幂等性判断 ⚫ 走MVCC模块保存不同版本的KV</p>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>etcd</category>
      
    </categories>
    
    
    <tags>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcd基础使用</title>
    <link href="/2023/04/17/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/etcd/etcd%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/04/17/%E4%BA%91%E5%8E%9F%E7%94%9F(%E5%AE%B9%E5%99%A8%E5%8C%96)/etcd/etcd%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://etcd.io/">https://etcd.io/</a></p><p><a href="https://www.etcd.cn/">https://www.etcd.cn/</a></p><h2 id="1-etcd架构"><a href="#1-etcd架构" class="headerlink" title="1 etcd架构"></a>1 etcd架构</h2><p><img src="/image/etcd/etcd%E6%9E%B6%E6%9E%84.jpg"></p><h2 id="2-特征，使用场景"><a href="#2-特征，使用场景" class="headerlink" title="2 特征，使用场景"></a>2 特征，使用场景</h2><h3 id="2-1-特征"><a href="#2-1-特征" class="headerlink" title="2.1 特征"></a>2.1 特征</h3><blockquote><p>使用简单</p><p>存储结构是key-value类型</p><p>能实时感知变化</p><p>权限校验</p><p>性能高</p><p>集群数据一致性</p></blockquote><h3 id="2-2-使用场景"><a href="#2-2-使用场景" class="headerlink" title="2.2 使用场景"></a>2.2 使用场景</h3><blockquote><p>存储数据</p><p>注册中心、配置中心</p><p>消息发布订阅</p><p>分布式锁</p><p>leader选举</p></blockquote><p>适当参考中文网，描述有些夸大</p><h2 id="3-部署"><a href="#3-部署" class="headerlink" title="3 部署"></a>3 部署</h2><h3 id="3-1-单节点"><a href="#3-1-单节点" class="headerlink" title="3.1 单节点"></a>3.1 单节点</h3><p>linux环境的二进制部署</p><p>1、下载软件：<a href="https://github.com/etcd-io/etcd/releases/">https://github.com/etcd-io/etcd/releases/</a> </p><p>2、复制到你的centos7系统的任意目录</p><p> 3、解压并配置 </p><p>4、注册系统服务 </p><p>5、启动</p><h3 id="3-2-集群"><a href="#3-2-集群" class="headerlink" title="3.2 集群"></a>3.2 集群</h3><p>集群部署分为仨方式：静态发现、动态发现、DNS发现</p><p>1、下载软件：<a href="https://github.com/etcd-io/etcd/releases/">https://github.com/etcd-io/etcd/releases/</a> </p><p>2、复制到三台服务器中 </p><p>3、解压并配置（配置不同了） </p><p>4、注册系统服务 </p><p>5、启动</p><h3 id="3-3-可视化控制台-Etcdkeeper"><a href="#3-3-可视化控制台-Etcdkeeper" class="headerlink" title="3.3 可视化控制台(Etcdkeeper)"></a>3.3 可视化控制台(Etcdkeeper)</h3><h4 id="3-3-1-centos7"><a href="#3-3-1-centos7" class="headerlink" title="3.3.1 centos7"></a>3.3.1 centos7</h4><p>1、下载软件：<a href="https://github.com/evildecay/etcdkeeper/releases/">https://github.com/evildecay/etcdkeeper/releases/</a> </p><p>2、复制到任意服务器并解压 </p><p>3、给权限 </p><p>4、注册系统服务 </p><p>5、启动并测试：http:192.168.8.137:8080/etcdkeeper </p><h4 id="3-3-2-windows"><a href="#3-3-2-windows" class="headerlink" title="3.3.2 windows"></a>3.3.2 windows</h4><p>1、下载软件：<a href="https://github.com/evildecay/etcdkeeper/releases/">https://github.com/evildecay/etcdkeeper/releases/</a> </p><p>2、复制到任意服务器并解压 </p><p>3、启动</p><h2 id="4-基础操作"><a href="#4-基础操作" class="headerlink" title="4 基础操作"></a>4 基础操作</h2><h3 id="4-1-查看命令"><a href="#4-1-查看命令" class="headerlink" title="4.1 查看命令"></a>4.1 查看命令</h3><p>输入etcdctl –h可以查看etcdctl的命令，注释如下：</p><table><thead><tr><th align="left">命令</th><th>注释</th><th>命令</th><th>注释</th><th>命令</th><th>注释</th></tr></thead><tbody><tr><td align="left">alarm disarm</td><td>解除所有的报警</td><td>elect</td><td>加入leader选举</td><td>lease timetolive</td><td>获取租约信息</td></tr><tr><td align="left">alarm list</td><td>列出所有报警</td><td>endpoint hashkv</td><td>打印指定实例的历史键值对的hash值</td><td>lock</td><td>获取命名锁</td></tr><tr><td align="left">auth disable</td><td>禁用Authentication</td><td>endpoint health</td><td>打印指定etcd实例的健康信息</td><td>make-mirror</td><td>指定一个etcd集群为镜像集群</td></tr><tr><td align="left">auth status</td><td>返回Authentication状态</td><td>endpoint status</td><td>打印指定etcd实例的状态信息</td><td>member add</td><td>为集群增加一个成员</td></tr><tr><td align="left">check datascale</td><td>对于给定服务实例检查持有数据的存储使用率</td><td>get</td><td>获取键值对</td><td>member list</td><td>罗列集群所有成员</td></tr><tr><td align="left">check perf</td><td>检查集群的性能</td><td>help</td><td>帮助</td><td>member promote</td><td>提升集群中的一个non-voting成员</td></tr><tr><td align="left">compaction</td><td>压缩历史事件</td><td>lease grant</td><td>创建租约</td><td>member remove</td><td>移除集群中的成员</td></tr><tr><td align="left">auth enable</td><td>启用Authentication</td><td>lease keep-alive</td><td>续约</td><td>member update</td><td>更新集群中的成员信息</td></tr><tr><td align="left">del</td><td>移除指定的或者范围的键值对</td><td>lease list</td><td>罗列所有有效的租约</td><td>move-leader</td><td>替换进群中的leader</td></tr><tr><td align="left">defrag</td><td>整理存储碎片</td><td>lease revoke</td><td>撤销租约</td><td>put</td><td>写入键值对</td></tr><tr><td align="left">role add</td><td>增加一个角色</td><td>role delete</td><td>删除一个角色</td><td>role get</td><td>获取一个角色的详细信息</td></tr><tr><td align="left">role grant-permission</td><td>给某个角色授予key</td><td>role list</td><td>罗列所有的角色</td><td>role revoke-permission</td><td>撤销一个角色的key</td></tr><tr><td align="left">snapshot restore</td><td>恢复快照</td><td>snapshot save</td><td>存储某个etcd节点的快照到指定位置</td><td>snapshot status</td><td>获取指定文件的后端快照文件状态</td></tr><tr><td align="left">txn</td><td>在一个事务内处理所有的请求</td><td>user add</td><td>增加一个用户</td><td>user delete</td><td>删除一个用户</td></tr><tr><td align="left">user get</td><td>获取用户的详细信息</td><td>user grant-role</td><td>给用户授予角色</td><td>user list</td><td>罗列所有用户</td></tr><tr><td align="left">user passwd</td><td>给用户修改密码</td><td>user revoke-role</td><td>撤销某个用户的角色</td><td>version</td><td>打印etcd版本</td></tr><tr><td align="left">watch</td><td>监测指定键或者前缀的事件流</td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="4-2-增、该"><a href="#4-2-增、该" class="headerlink" title="4.2 增、该"></a>4.2 增、该</h3><p> 命令格式：etcdctl put &lt; key&gt; &lt; value&gt;[options]</p><blockquote><p>Options选项： </p><p>⚫ –lease ： 设置key所使用的lease ID </p><p>⚫ –prev-kv：返回该key修改之前的值 </p><p>⚫ –ignore-lease：使用当前的lease更新key </p><p>⚫ –ignore-value：使用当前的value更新key</p></blockquote><h3 id="4-3-查"><a href="#4-3-查" class="headerlink" title="4.3 查"></a>4.3 查</h3><p>命令格式：etcdctl get &lt; key&gt; [options]</p><blockquote><p>Options选项： </p><p>⚫ –form-key： 按照字节序，筛选大于或等于的key </p><p>⚫ –prefix：筛选以该前缀的key </p><p>⚫ –keys-only：只输出key </p><p>⚫ –print-value-only：只输出value </p><p>⚫ –limit ：限制输出条数，当为0时不做限制 </p><p>⚫ –sort-by &lt;”create”|”key”|”modify”|”value”|”version”&gt;：按照创建时间、键、修改时间、值或版本号排序 </p><p>⚫ –order &lt;“ascend”|“descend”&gt; ：按照升序或降序排列 </p><p>⚫ –rev  ：指定 key 的版本。etcd 对 key 的写操作，会更新全局修订版本， 通过指定版本可以读取旧的数据 </p><p>⚫ –consistency &lt;“l”|“s”&gt; ：一致性，默认是 Linearizable，可以设置为 Serializable</p></blockquote><h3 id="4-4-删"><a href="#4-4-删" class="headerlink" title="4.4 删"></a>4.4 删</h3><p>命令格式：etcdctl del &lt; key&gt; [options]</p><blockquote><p>Options选项： </p><p>⚫ –form-key： 按照字节序，筛选大于或等于的key </p><p>⚫ –prefix：筛选以该前缀的key </p><p>⚫ –prev-kv：返回该key修改之前的值 </p><p>⚫ –range：该选项避免删除延迟，默认延迟2s</p></blockquote><h3 id="4-5-watch"><a href="#4-5-watch" class="headerlink" title="4.5 watch"></a>4.5 watch</h3><p>命令格式：etcdctl watch &lt; key&gt; [options]</p><blockquote><p> Options选项： </p><p>⚫ –prev-kv：返回该key修改之前的值 </p><p>⚫ –prefix：筛选以该前缀的key</p></blockquote><h3 id="4-6-租约"><a href="#4-6-租约" class="headerlink" title="4.6 租约"></a>4.6 租约</h3><blockquote><p> 命令格式：</p><p> ⚫ etcdctl lease grant ：创建租约 </p><p>⚫ etcdctl lease list：返回说有为过时或未被废弃的租约 </p><p>⚫ etcdctl lease revoke ：废弃租约 </p><p>⚫ etcdctl lease keep-alive [–once] ：周期性续约，–once只续约一次 </p><p>⚫ etcdctl lease timetolive [–once]  [–keys]：获取租约信息，–keys附带关键的key信息</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>云原生(容器化)</category>
      
      <category>etcd</category>
      
    </categories>
    
    
    <tags>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GraalVM安装与基本介绍</title>
    <link href="/2023/04/13/java%E5%9F%BA%E7%A1%80/GraalVM/GraalVM/"/>
    <url>/2023/04/13/java%E5%9F%BA%E7%A1%80/GraalVM/GraalVM/</url>
    
    <content type="html"><![CDATA[<h2 id="1-GraalVM基础使用"><a href="#1-GraalVM基础使用" class="headerlink" title="1 GraalVM基础使用"></a>1 GraalVM基础使用</h2><p>官网： <a href="https://www.graalvm.org/">https://www.graalvm.org/</a></p><p>github：<a href="https://github.com/oracle/graal">https://github.com/oracle/graal</a></p><p>SpringFramework6.x，SpringBoot 3.x 支持JDK17，GraalVM</p><h3 id="1-1-安装GraalVM"><a href="#1-1-安装GraalVM" class="headerlink" title="1.1 安装GraalVM"></a>1.1 安装GraalVM</h3><p><a href="https://www.graalvm.org/latest/docs/getting-started/#install-graalvm">https://www.graalvm.org/latest/docs/getting-started/#install-graalvm</a></p><p>以在Win10安装为例：<a href="https://www.graalvm.org/latest/docs/getting-started/windows/">https://www.graalvm.org/latest/docs/getting-started/windows/</a></p><p>（1）下载地址：<a href="https://github.com/graalvm/graalvm-ce-builds/releases">https://github.com/graalvm/graalvm-ce-builds/releases</a></p><p><img src="/image/GraalVM/1.png"></p><p>（2）将graalvm-ce-java17-windows-amd64-22.3.1.zip压缩包解压</p><p>（3）设置环境变量JAVA_HOME，可以通过图形化界面也可以通过命令行</p><p><img src="/image/GraalVM/2.png"></p><p>（4）打开cmd，输入java命令，验证是否安装配置成功 </p><p>（5）以管理员身份打开cmd窗口，验证是否配置成功</p><blockquote><p>如果发生修改完环境变量不生效的情况，</p><ol><li><p>删除C:\Windows\System32目录下的java.exe、javaw.exe、javaws.exe三个文件（如果没有就不用删）</p></li><li><p>删除环境变量Path中  ……\Oracle\Java\javapath的配置</p></li></ol></blockquote><p><img src="/image/GraalVM/3.png"></p><h3 id="1-2-安装Native-Image"><a href="#1-2-安装Native-Image" class="headerlink" title="1.2 安装Native Image"></a>1.2 安装Native Image</h3><p><a href="https://www.graalvm.org/latest/reference-manual/native-image/#install-native-image">https://www.graalvm.org/latest/reference-manual/native-image/#install-native-image</a></p><p>（1）查看默认graalvm中是否包含了native-image，发现没有</p><p><img src="/image/GraalVM/4.png"></p><p>（2）安装native-image，在graalvm目录下执行命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 也就是说配置好了graalvm之后，gu是可以直接使用的</span><br>gu install native-image<br></code></pre></td></tr></table></figure><p>（3）查看native-image是否安装成功</p><h3 id="1-3-安装使用Native-Image在Windows上的环境"><a href="#1-3-安装使用Native-Image在Windows上的环境" class="headerlink" title="1.3 安装使用Native Image在Windows上的环境"></a>1.3 安装使用Native Image在Windows上的环境</h3><p><a href="https://www.graalvm.org/latest/docs/getting-started/windows/#prerequisites-for-using-native-image-on-windows">https://www.graalvm.org/latest/docs/getting-started/windows/#prerequisites-for-using-native-image-on-windows</a></p><p>（1）下载VS Code 2022 Community安装程序</p><p><a href="https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=Community&amp;channel=Release&amp;version=VS2022&amp;source=VSLandingPage&amp;cid=2030&amp;passive=false">https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=Community&amp;channel=Release&amp;version=VS2022&amp;source=VSLandingPage&amp;cid=2030&amp;passive=false</a></p><p>（2）选择安装的内容及目录</p><p><img src="/image/GraalVM/6.png"></p><p><img src="/image/GraalVM/7.png"></p><p>（4）在Path中配置VS的环境变量</p><p>我的路径是：E:\Visual Studio\IDE</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">E</span>:\Visual Studio\IDE\VC\Tools\MSVC\<span class="hljs-number">14</span>.<span class="hljs-number">35</span>.<span class="hljs-number">32215</span>\bin\Hostx64\x64<br><span class="hljs-attribute">E</span>:\Visual Studio\IDE\VC\Tools\MSVC\<span class="hljs-number">14</span>.<span class="hljs-number">35</span>.<span class="hljs-number">32215</span>\include<br><span class="hljs-attribute">E</span>:\Visual Studio\IDE\VC\Tools\MSVC\<span class="hljs-number">14</span>.<span class="hljs-number">35</span>.<span class="hljs-number">32215</span>\lib\x64<br></code></pre></td></tr></table></figure><p>（5）安装完重启一下电脑</p><p>（6）查看是否安装成功</p><p><img src="/image/GraalVM/5.png"></p><p>（7）每次都要打开上述工具比较麻烦，所有添加以下配置可以在任意地方打开cmd执行。打开native-image.cmd文件，向其他添加一行即可</p><blockquote><p>我的路径：E:\JDK\graalvm-ce-java17-22.3.1\bin\native-image.cmd</p></blockquote><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">call</span> <span class="hljs-string">&quot;E:\Visual Studio\IDE\VC\Auxiliary\Build\vcvars64.bat&quot;</span><br></code></pre></td></tr></table></figure><h3 id="1-4-Hello-World测试"><a href="#1-4-Hello-World测试" class="headerlink" title="1.4 Hello World测试"></a>1.4 Hello World测试</h3><p>（1）准备HelloWorld的java源码文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, Native World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）编译成Class文件并用java命令运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh'">javac HelloWorld.java<br>java HelloWorld<br></code></pre></td></tr></table></figure><p>（3）打开PowerShell窗口，查看运行时间</p><blockquote><p>Measure-Command{java HelloWorld}</p></blockquote><p><img src="/image/GraalVM/8.png"></p><p>（4）将Class文件打包成本地可执行文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">native-image HelloWorld<br></code></pre></td></tr></table></figure><p>（5）打开PowerShell窗口，运行这个可执行文件</p><p><img src="/image/GraalVM/9.png"></p><p>可见，运行速度提升了很多</p><h3 id="1-5-JVM-and-GraalVM"><a href="#1-5-JVM-and-GraalVM" class="headerlink" title="1.5 JVM and GraalVM"></a>1.5 JVM and GraalVM</h3><ol><li>JVM and GraalVM</li></ol><p><a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html</a></p><p><img src="/image/GraalVM/10.png"></p><ol start="2"><li>GraalVM</li></ol><p><img src="/image/GraalVM/11.png"></p><h2 id="2-GraalVM编译普通的Maven项目"><a href="#2-GraalVM编译普通的Maven项目" class="headerlink" title="2  GraalVM编译普通的Maven项目"></a>2  GraalVM编译普通的Maven项目</h2><h3 id="2-1-静态代码"><a href="#2-1-静态代码" class="headerlink" title="2.1 静态代码"></a>2.1 静态代码</h3><p>（1）创建一个普通的maven工程</p><p>（2）打开idea的terminal窗口，检查java和mvn版本</p><p><img src="/image/GraalVM/12.png"></p><p>（3）创建包和类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello world, GraalVM Simple Maven!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）引入native plugin</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">native.maven.plugin.version</span>&gt;</span>0.9.20<span class="hljs-tag">&lt;/<span class="hljs-name">native.maven.plugin.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>native<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.graalvm.buildtools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>native-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;native.maven.plugin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">extensions</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>build-native<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile-no-fork<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>test-native<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>graalvm-demo<span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span><br>                        <span class="hljs-comment">&lt;!-- 你的启动类路径 --&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>org.example.Main<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">verbose</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">verbose</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（5）打开terminal，打包该工程为可执行文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn -Pnative native:compile<br></code></pre></td></tr></table></figure><p>（6）执行文件</p><p><img src="/image/GraalVM/13.png"></p><h3 id="2-2-动态代码-Reachebility-Metadata"><a href="#2-2-动态代码-Reachebility-Metadata" class="headerlink" title="2.2 动态代码-Reachebility Metadata"></a>2.2 动态代码-Reachebility Metadata</h3><p><a href="https://www.graalvm.org/latest/reference-manual/native-image/metadata/">https://www.graalvm.org/latest/reference-manual/native-image/metadata/</a></p><p>GraalVm会将各种动态代码在编译过程中生成Reachebility Metadata（各种JSON文件），包括动态代理，泛型等</p><p>（1）定义接口和实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Protocol</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DubboProtocol</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Protocol</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Dubbo Protocol!&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GrpcProtocol</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Protocol</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Grpc Protocol!&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）创建反射使用的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;org.example.service.impl.&quot;</span>+args[<span class="hljs-number">0</span>]);<br>clazz.getMethod(<span class="hljs-string">&quot;sayHello&quot;</span>).invoke(clazz.getConstructor().newInstance());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）正常运行程序，发现会报错，因为没有指定args[0]</p><p>（4）指定args参数</p><p><img src="/image/GraalVM/14.png"></p><p>（5）再次运行程序，发现运行正常</p><p>（6）native打包成本地可执行文件，然后运行可执行文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn -Pnative native:compile<br>.\target\graalvm-demo.exe<br>.\target\graalvm-demo.exe DubboProtocol<br></code></pre></td></tr></table></figure><p><img src="/image/GraalVM/15.png"></p><p>（7）在JVM Options中添加一段配置，用于生成各种json文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">-agentlib:native-image-agent=config-output-dir=src/main/resources/META-INF/native-image/<br></code></pre></td></tr></table></figure><p><img src="/image/GraalVM/20.png"></p><p>（8）以JVM的形式正常运行主函数，然后观察对应目录下的变化</p><p><img src="/image/GraalVM/16.png"></p><p>（9）再次native image这段代码，同时查看target目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn -Pnative native:compile<br></code></pre></td></tr></table></figure><p><img src="/image/GraalVM/17.png"></p><p>（10）再次运行可执行文件</p><p><img src="/image/GraalVM/18.png"></p><p>GrpcProtocol找不到，只需要打开resources目录下的reflect-config.json文件，配置一下GrpcProtocol，然后再native-image 打包成可执行文件</p><p><img src="/image/GraalVM/19.png"></p><h2 id="3-Spring-Boot-3-0集成"><a href="#3-Spring-Boot-3-0集成" class="headerlink" title="3 Spring Boot 3.0集成"></a>3 Spring Boot 3.0集成</h2><p>相关文档：</p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.introducing-graalvm-native-images">https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.introducing-graalvm-native-images</a></p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.introducing-graalvm-native-images.key-differences-with-jvm-deployments">https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.introducing-graalvm-native-images.key-differences-with-jvm-deployments</a></p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.introducing-graalvm-native-images.understanding-aot-processing">https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.introducing-graalvm-native-images.understanding-aot-processing</a></p><p>（1）创建Spring Boot 3.x工程</p><p><img src="/image/GraalVM/21.png"></p><p><img src="/image/GraalVM/22.png"></p><p>（2）编写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot3GrallvmDemoApplication</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(Springboot3GrallvmDemoApplication.class, args);<br>&#125;<br><br><span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World Spring Boot3 GraalVM demo&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）以JVM的形式运行Spring Boot，查看启动时间并访问hello</p><h3 id="3-1-使用GraalVM编译"><a href="#3-1-使用GraalVM编译" class="headerlink" title="3.1 使用GraalVM编译"></a>3.1 使用GraalVM编译</h3><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.developing-your-first-application.native-build-tools">https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.developing-your-first-application.native-build-tools</a></p><p>（1）打开terminal，执行如下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn -Pnative native:compile<br></code></pre></td></tr></table></figure><p>或者打开maven的plugins，执行native:compile</p><p><img src="/image/GraalVM/23.png"></p><p>（2）直接运行可执行文件，并查看启动时间</p><p><img src="/image/GraalVM/24.png"></p><h3 id="3-2-编译成docker-image"><a href="#3-2-编译成docker-image" class="headerlink" title="3.2 编译成docker image"></a>3.2 编译成docker image</h3><p>（1）在pom文件中指定镜像名称</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">spring-boot.build-image.imageName</span>&gt;</span>s3gb:v1<span class="hljs-tag">&lt;/<span class="hljs-name">spring-boot.build.image.imageName</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）使用如下命令打包成docker image</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn -Pnative spring-boot:build-image<br></code></pre></td></tr></table></figure><p><img src="/image/GraalVM/25.png"></p><h2 id="4-GraalVM内存管理"><a href="#4-GraalVM内存管理" class="headerlink" title="4  GraalVM内存管理"></a>4  GraalVM内存管理</h2><p><a href="https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/MemoryManagement/">https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/MemoryManagement/</a></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>GraalVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDK</tag>
      
      <tag>GraalVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Sleuth+Zipkin</title>
    <link href="/2023/04/12/spring%E6%A1%86%E6%9E%B6/springcloud/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/Spring%20Cloud%20Sleuth+Zipkin/"/>
    <url>/2023/04/12/spring%E6%A1%86%E6%9E%B6/springcloud/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/Spring%20Cloud%20Sleuth+Zipkin/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Spring-Cloud-Sleuth"><a href="#1-Spring-Cloud-Sleuth" class="headerlink" title="1 Spring Cloud Sleuth"></a>1 Spring Cloud Sleuth</h2><p><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2022.0-Release-Notes">https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2022.0-Release-Notes</a></p><h3 id="1-1-目前调用链路存在的问题及解决方案"><a href="#1-1-目前调用链路存在的问题及解决方案" class="headerlink" title="1.1 目前调用链路存在的问题及解决方案"></a>1.1 目前调用链路存在的问题及解决方案</h3><p>存在的问题：整个微服务调用的链路是怎么样的？以及调用发生了问题该如何定位？每个服务调用到 底花了多长时间？</p><p>解决方案：链路追踪 </p><p>常见的链路追踪产品：Spring Cloud Sleuth+Zipkin、SkyWalking、阿里鹰眼、Jaeger、Pinpoint、 大众点评Cat等</p><h3 id="1-2-Sleuth介绍"><a href="#1-2-Sleuth介绍" class="headerlink" title="1.2 Sleuth介绍"></a>1.2 Sleuth介绍</h3><p><a href="https://spring.io/projects/spring-cloud-sleuth#overview">https://spring.io/projects/spring-cloud-sleuth#overview</a></p><p>SC Sleuth是通过扩展Logging日志的方式实现链路追踪的。</p><p><img src="/image/springcloud/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/SpringCloudSleuth+Zipkin/1.png"></p><h3 id="1-3-微服务整合Sleuth"><a href="#1-3-微服务整合Sleuth" class="headerlink" title="1.3 微服务整合Sleuth"></a>1.3 微服务整合Sleuth</h3><p>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">sleuth:</span><br>    <span class="hljs-attr">sampler:</span><br>      <span class="hljs-attr">probability:</span> <span class="hljs-number">1.0</span><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">root:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h3 id="1-4-Tracer"><a href="#1-4-Tracer" class="headerlink" title="1.4  Tracer"></a>1.4  Tracer</h3><p>如果想要通过代码方式获取到traceid、spanid等，可以查看brave包下的Tracer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">tracer.currentSpan().context().traceId()<br>tracer.currentSpan().context().spanId()<br></code></pre></td></tr></table></figure><h2 id="2-Zipkin"><a href="#2-Zipkin" class="headerlink" title="2  Zipkin"></a>2  Zipkin</h2><p><a href="https://zipkin.io/">https://zipkin.io/</a></p><p><img src="/image/springcloud/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/SpringCloudSleuth+Zipkin/2.png"></p><p>工作流程：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">┌─────────────┐ ┌───────────────────────┐  ┌─────────────┐  ┌──────────────────┐<br>│ <span class="hljs-keyword">User</span> Code   │ │ Trace Instrumentation │  │ Http Client │  │ Zipkin Collector │<br>└─────────────┘ └───────────────────────┘  └─────────────┘  └──────────────────┘<br>       │                 │                         │                 │<br>           ┌─────────┐<br>       │ ──┤<span class="hljs-keyword">GET</span> /foo ├─▶ │ ────┐                   │                 │<br>           └─────────┘         │ <span class="hljs-type">record</span> tags<br>       │                 │ ◀───┘                   │                 │<br>                           ────┐<br>       │                 │     │ <span class="hljs-keyword">add</span> trace headers │                 │<br>                           ◀───┘<br>       │                 │ ────┐                   │                 │<br>                               │ <span class="hljs-type">record</span> <span class="hljs-type">timestamp</span><br>       │                 │ ◀───┘                   │                 │<br>                             ┌─────────────────┐<br>       │                 │ ──┤<span class="hljs-keyword">GET</span> /foo         ├─▶ │                 │<br>                             │X-B3-TraceId: aa │     ────┐<br>       │                 │   │X-B3-SpanId: <span class="hljs-number">6</span>b  │   │     │           │<br>                             └─────────────────┘         │ invoke<br>       │                 │                         │     │ request   │<br>                                                         │<br>       │                 │                         │     │           │<br>                                 ┌────────┐          ◀───┘<br>       │                 │ ◀─────┤<span class="hljs-number">200</span> OK  ├─────── │                 │<br>                           ────┐ └────────┘<br>       │                 │     │ <span class="hljs-type">record</span> duration   │                 │<br>            ┌────────┐     ◀───┘<br>       │ ◀──┤<span class="hljs-number">200</span> OK  ├── │                         │                 │<br>            └────────┘       ┌────────────────────────────────┐<br>       │                 │ ──┤ asynchronously report span     ├────▶ │<br>                             │                                │<br>                             │&#123;                               │<br>                             │  &quot;traceId&quot;: &quot;aa&quot;,              │<br>                             │  &quot;id&quot;: &quot;6b&quot;,                   │<br>                             │  &quot;name&quot;: &quot;get&quot;,                │<br>                             │  &quot;timestamp&quot;: <span class="hljs-number">1483945573944000</span>,│<br>                             │  &quot;duration&quot;: <span class="hljs-number">386000</span>,           │<br>                             │  &quot;annotations&quot;: [              │<br>                             │<span class="hljs-comment">--snip--                        │</span><br>                             └────────────────────────────────┘<br></code></pre></td></tr></table></figure><h3 id="2-1-下载搭建Zipkin-Server"><a href="#2-1-下载搭建Zipkin-Server" class="headerlink" title="2.1 下载搭建Zipkin Server"></a>2.1 下载搭建Zipkin Server</h3><p>（1）下载链接：<a href="https://repo1.maven.org/maven2/io/zipkin/zipkin-server/">https://repo1.maven.org/maven2/io/zipkin/zipkin-server/</a></p><p>（2）启动zipkin server</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -jar zipkin-server-2.23.2-exec.jar<br></code></pre></td></tr></table></figure><p>（3）浏览器访问9411端口</p><p><img src="/image/springcloud/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/SpringCloudSleuth+Zipkin/3.png"></p><h3 id="2-2-微服务整合Zipkin客户端"><a href="#2-2-微服务整合Zipkin客户端" class="headerlink" title="2.2 微服务整合Zipkin客户端"></a>2.2 微服务整合Zipkin客户端</h3><p>（1）引入依赖：此时就不需要单独的sleuth依赖了，因为zipkin中包含了sleuth</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）写配置：注意zipkin和sleuth的父级配置项都是spring</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">zipkin:</span><br>    <span class="hljs-attr">base-url:</span> <span class="hljs-string">http://localhost:9411</span><br>  <span class="hljs-attr">sleuth:</span><br>    <span class="hljs-attr">sampler:</span><br>      <span class="hljs-attr">probability:</span> <span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><h3 id="2-3-Data-Model"><a href="#2-3-Data-Model" class="headerlink" title="2.3 Data Model"></a>2.3 Data Model</h3><p><a href="https://zipkin.io/pages/data_model.html">https://zipkin.io/pages/data_model.html</a></p><p>向Zipkin报告数据的最流行方式是通过HTTP或Kafka，尽管许多其他方式存在选项，例如Apache ActiveMQ，gRPC和RabbitMQ。</p><h3 id="2-4-持久化到MySQL"><a href="#2-4-持久化到MySQL" class="headerlink" title="2.4  持久化到MySQL"></a>2.4  持久化到MySQL</h3><p>（1）执行mysql.sql</p><p><a href="https://github.com/openzipkin/zipkin/blob/master/zipkin-storage/mysql-v1/src/main/resources/mysql.sql">https://github.com/openzipkin/zipkin/blob/master/zipkin-storage/mysql-v1/src/main/resources/mysql.sql</a></p><p>（2）重启zipkin server，设置其数据持久化方式为MySQL</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -jar zipkin-server-2.23.2-exec.jar --STORAGE_TYPE=mysql --MYSQL_HOST=127.0.0.1 --MYSQL_TCP_PORT=3306 --MYSQL_USER=root --MYSQL_PASS=root123 --MYSQL_DB=db_zipkin<br></code></pre></td></tr></table></figure><h3 id="2-5-持久化到ElasticSearch"><a href="#2-5-持久化到ElasticSearch" class="headerlink" title="2.5 持久化到ElasticSearch"></a>2.5 持久化到ElasticSearch</h3><p>（1）下载es</p><p><a href="https://www.elastic.co/cn/downloads/past-releases#elasticsearch">https://www.elastic.co/cn/downloads/past-releases#elasticsearch</a></p><p>（2）启动es</p><p>以windows环境为例，解压es的压缩包，来到bin文件夹之下，执行elasticsearch.bat文件，默认会监 听在9200端口</p><p>（3）重启zipkin server，设置其数据持久化方式为es</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -jar zipkin-server-2.23.2-exec.jar --STORAGE_TYPE=elasticsearch --ES_HOSTS=127.0.0.1:9200<br></code></pre></td></tr></table></figure><h2 id="3-Micrometer"><a href="#3-Micrometer" class="headerlink" title="3 Micrometer"></a>3 Micrometer</h2><p>在Spring Boot 3.X中Sleuth被替换成Micrometer</p><p><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2022.0-Release-Notes">https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2022.0-Release-Notes</a></p><p><a href="https://docs.spring.io/spring-boot/docs/3.0.0/reference/html/actuator.html#actuator.observability">https://docs.spring.io/spring-boot/docs/3.0.0/reference/html/actuator.html#actuator.observability</a></p><p><a href="https://micrometer.io/docs/observation">https://micrometer.io/docs/observation</a></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>链路追踪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zipkin</tag>
      
      <tag>Sleuth</tag>
      
      <tag>链路追踪</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx安装</title>
    <link href="/2023/04/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx%E5%AE%89%E8%A3%85/"/>
    <url>/2023/04/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/nginx%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>地址从<code>http://nginx.org/en/download.html</code>复制</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft<br>wget http://nginx.org/download/nginx-1.20.2.tar.gz<br></code></pre></td></tr></table></figure><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xzvf nginx-1.20.2.tar.gz<br></code></pre></td></tr></table></figure><h2 id="安装依赖环境"><a href="#安装依赖环境" class="headerlink" title="安装依赖环境"></a>安装依赖环境</h2><p>gcc环境：基本运行环境</p><p>pcre：用于nginx的http模块解析正则表达式</p><p>zlib：用户进行gzip压缩</p><p>openssl：用于nginx https协议的传输</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum install -y gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel<br></code></pre></td></tr></table></figure><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>–prefix=/usr/local/soft/nginx ：把nginx安装到/usr/local/soft/nginx，可以自定义修改目录。所以后面会有一个源码目录nginx-1.20.2，一个编译安装后的目录nginx。</p><p>–with-http_ssl_module ：启用ssl模块，使用ssl功能</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft/nginx-1.20.2<br>./configure --prefix=/usr/local/soft/nginx --with-http_ssl_module<br>make &amp;&amp; sudo make install<br><span class="hljs-built_in">cd</span> /usr/local/soft/nginx/<br></code></pre></td></tr></table></figure><p>测试配置是否成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/usr/local/soft/nginx/sbin/nginx -t -c /usr/local/soft/nginx/conf/nginx.conf<br></code></pre></td></tr></table></figure><h2 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/soft/</span>nginx<span class="hljs-regexp">/sbin/</span>nginx<br></code></pre></td></tr></table></figure><p>浏览器直接访问IP（HTTP协议默认80端口，不需要输入）</p><h2 id="copy-vimfile"><a href="#copy-vimfile" class="headerlink" title="copy vimfile"></a>copy vimfile</h2><p>为了让VIM查看nginx配置文件时语法高亮，需要把相应文件copy到VIM目录。先确定本机的vimfiles目录在哪个位置。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">find / -name vimfiles<br><span class="hljs-built_in">cd</span> /usr/local/soft/nginx-1.20.2<br><span class="hljs-built_in">cp</span> -r contrib/vim/* /usr/share/vim/vimfiles/<br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sh">nginx -s reopen <span class="hljs-comment">#重启Nginx</span><br><br>nginx -s reload <span class="hljs-comment">#重新加载Nginx配置文件，然后以优雅的方式重启Nginx</span><br><br>nginx -s stop <span class="hljs-comment">#强制停止Nginx服务</span><br><br>nginx -s quit <span class="hljs-comment">#优雅地停止Nginx服务（即处理完所有请求后再停止服务）</span><br><br>nginx -t <span class="hljs-comment">#检测配置文件是否有语法错误，然后退出</span><br><br>nginx -?,-h <span class="hljs-comment">#打开帮助信息</span><br><br>nginx -v <span class="hljs-comment">#显示版本信息并退出</span><br><br>nginx -V <span class="hljs-comment">#显示版本和配置选项信息，然后退出</span><br><br>nginx -t <span class="hljs-comment">#检测配置文件是否有语法错误，然后退出</span><br><br>nginx -T <span class="hljs-comment">#检测配置文件是否有语法错误，转储并退出</span><br><br>nginx -q <span class="hljs-comment">#在检测配置文件期间屏蔽非错误信息</span><br><br>nginx -p prefix <span class="hljs-comment">#设置前缀路径(默认是:/usr/share/nginx/)</span><br><br>nginx -c filename <span class="hljs-comment">#设置配置文件(默认是:/etc/nginx/nginx.conf)</span><br><br>nginx -g directives <span class="hljs-comment">#设置配置文件外的全局指令</span><br><br>killall nginx <span class="hljs-comment">#杀死所有nginx进程</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ保证消息可靠性</title>
    <link href="/2023/04/06/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7/"/>
    <url>/2023/04/06/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Producer保证消息高可靠"><a href="#1-Producer保证消息高可靠" class="headerlink" title="1  Producer保证消息高可靠"></a>1  Producer保证消息高可靠</h2><p>（1）尽量采用同步或者异步的方式发送消息，最好不要使用oneway的方式发送，也就是说当把消息发到broker之后，一定要得到broker的响应 </p><p>（2）建立数据库消息发送表，防止消息还没来得及发送当前系统就宕机了，这样等系统恢复的时候，可以根据消息发送表中的记录决定是否需要重新发送，发送成功之后要将对应表中的记录删除或者更新成发送成功状态，可以避免重复发送消息 </p><p>（3）消息发送的重试机制，当producer向broker发送消息时，因为网络原因或者broker挂了，这样情况下肯定得不到broker的 响应，解决方案就是要做好重试机制，默认重试的次数是2，如果2次依然不能满足要求，这时候可以考虑开启一个定时任务，不断重试，或者人工补偿。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultMQProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRetryTimeWhenSendFailed</span><span class="hljs-params">(<span class="hljs-type">int</span> retryTimeWhenSendFailed)</span> &#123;<br>        <span class="hljs-built_in">this</span>.retryTimeWhenSendFailed = retryTimeWhenSendFailed; <span class="hljs-comment">//默认为2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）消息最大大小为4M，如果消息超过了这个大小，发送会有限制，并且在broker端其实对于消息的处理默认上线也是4MB， 所以producer要发送的消息如果超过4M，记得做划分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultMQProducer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">masMessageSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">4</span>; <span class="hljs-comment">//4M</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-集群保证消息高可靠"><a href="#2-集群保证消息高可靠" class="headerlink" title="2 集群保证消息高可靠"></a>2 集群保证消息高可靠</h2><h3 id="2-1-集群搭建"><a href="#2-1-集群搭建" class="headerlink" title="2.1 集群搭建"></a>2.1 集群搭建</h3><p>（1）NameServer集群部署在不同的节点上：可以防止单点故障 </p><p>（2）Broker集群部署[比如采用双主双从架构]：可以防止单点故障、提高读写性能、增加消息的可靠性等 </p><p>（3）Producer、Consumer、Broker都要设置好nameserver的集群地址，防止获取不到最新的路由信息</p><h3 id="2-2-Broker主从复制策略"><a href="#2-2-Broker主从复制策略" class="headerlink" title="2.2 Broker主从复制策略"></a>2.2 Broker主从复制策略</h3><p>两种选择：同步复制[同步双写]和异步复制 </p><p>一般情况下，broker的刷盘策略选择异步刷盘，而复制策略选择同步双写，这样做是为了在消息可靠性与性能之间能够平衡一下</p><h3 id="2-3-Broker刷盘策略"><a href="#2-3-Broker刷盘策略" class="headerlink" title="2.3 Broker刷盘策略"></a>2.3 Broker刷盘策略</h3><p>两种选择：同步刷盘和异步刷盘 </p><p>在同步刷盘的策略下，只要producer收到了SEND_OK，那么消息一定是被持久化到了broker的磁盘中，以commitlog的形式保存，这样消息就不容易丢失了 </p><p>而在异步刷盘的策略下，即使producer把消息发送到broker，但是不能完全保证消息被持久化到了磁盘，所以消息可能会丢失 </p><p>这两种方式虽然同步刷盘的消息可靠性更高，但是在一般场景下，为了追求更好的性能，通常采用异步刷盘的方式</p><h3 id="2-4-Broker磁盘选择"><a href="#2-4-Broker磁盘选择" class="headerlink" title="2.4 Broker磁盘选择"></a>2.4 Broker磁盘选择</h3><p><a href="https://zh.wikipedia.org/wiki/RAID">https://zh.wikipedia.org/wiki/RAID</a></p><p>Broker磁盘的存储介质可以选择RAID 10或者分布式存储，避免磁盘损坏导致消息丢失</p><h2 id="3-DLedger"><a href="#3-DLedger" class="headerlink" title="3 DLedger"></a>3 DLedger</h2><p>DLedger，它是基于RAFT协议的commitlog存储库，解决了自动选举brokermaster和日志复制的问题。</p><p><a href="https://github.com/openmessaging/dledger">https://github.com/openmessaging/dledger</a></p><p>DLedger作为RocketMQ的消息存储</p><p>搭建：<a href="https://rocketmq.apache.org/zh/docs/bestPractice/02dledger">https://rocketmq.apache.org/zh/docs/bestPractice/02dledger</a></p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E5%8F%AF%E9%9D%A0%E6%80%A7/RocketMQ%E6%9E%B6%E6%9E%84-DLedger.jpg"></p><h2 id="4-Consumer保证消息高可靠性"><a href="#4-Consumer保证消息高可靠性" class="headerlink" title="4 Consumer保证消息高可靠性"></a>4 Consumer保证消息高可靠性</h2><h3 id="4-1-消息重试机制"><a href="#4-1-消息重试机制" class="headerlink" title="4.1 消息重试机制"></a>4.1 消息重试机制</h3><p>当一条消息初次消费失败，消息队列 RocketMQ 会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 RocketMQ 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。在消息队列 RocketMQ 中，这种正常情况下无法被消费的消息称为死信消息（Dead-LetterMessage）</p><p>存储死信消息的特殊队列称为死信队列 （Dead-Letter Queue）。 一条消息进入死信队列，意味着某些因素导致消费者无法正常消费该消息，因此，通常需要对其进行特殊处理。排查可疑因素并解决问题后，可以在消息队列 RocketMQ控制台重新发送该消息，让消费者 重新消费一次。</p><h3 id="4-2-给Broker一个反馈"><a href="#4-2-给Broker一个反馈" class="headerlink" title="4.2 给Broker一个反馈"></a>4.2 给Broker一个反馈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br>   <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            System.out.println(msgs);<br>            <span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="4-3-消费消息幂等处理"><a href="#4-3-消费消息幂等处理" class="headerlink" title="4.3 消费消息幂等处理"></a>4.3 消费消息幂等处理</h3><p>如何避免消息重复消费？可以使用唯一的msgid，或者业务id，比如orderid，利用数据库日志表或 redis主键进行幂等处理。</p><h2 id="5-如何处理消息积压"><a href="#5-如何处理消息积压" class="headerlink" title="5 如何处理消息积压"></a>5 如何处理消息积压</h2><p>（1）消费者出错，肯定是程序或者其他问题导致的，如果容易修复，先把问题修复，让consumer恢复正常消费 </p><p>（2）如果时间来不及处理很麻烦，做转发处理，写一个临时的consumer消费方案，先把消息消费，然后再转发到一个新的topic和MQ资源，这个新的topic的机器资源单独申请，要能承载住当前积压的消息 </p><p>（3）处理完积压数据后，修复consumer，去消费新的MQ和现有的MQ数据，新MQ消费完成后恢复原状 </p><p>（4）增加consumer的数量 </p><p>（5）限流</p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
      <category>RocketMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ源码解析</title>
    <link href="/2023/04/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/04/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-NameServer"><a href="#1-NameServer" class="headerlink" title="1 NameServer"></a>1 NameServer</h2><h3 id="1-1-NameServer启动流程"><a href="#1-1-NameServer启动流程" class="headerlink" title="1.1 NameServer启动流程"></a>1.1 NameServer启动流程</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/NameServer%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.jpg"></p><h3 id="1-2-NameServer处理Broker注册信息"><a href="#1-2-NameServer处理Broker注册信息" class="headerlink" title="1.2 NameServer处理Broker注册信息"></a>1.2 NameServer处理Broker注册信息</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/NameServer%E5%A4%84%E7%90%86Broker%E6%B3%A8%E5%86%8C%E4%BF%A1%E6%81%AF.jpg"></p><h2 id="2-Broker"><a href="#2-Broker" class="headerlink" title="2 Broker"></a>2 Broker</h2><h3 id="2-1-Broker启动与注册信息"><a href="#2-1-Broker启动与注册信息" class="headerlink" title="2.1 Broker启动与注册信息"></a>2.1 Broker启动与注册信息</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Broker%E5%90%AF%E5%8A%A8%E4%B8%8E%E6%B3%A8%E5%86%8C%E4%BF%A1%E6%81%AF.jpg"></p><h3 id="2-2-Broker消息的存储结构"><a href="#2-2-Broker消息的存储结构" class="headerlink" title="2.2 Broker消息的存储结构"></a>2.2 Broker消息的存储结构</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Broker%E6%B6%88%E6%81%AF%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg"></p><h4 id="2-2-1-CommitLog"><a href="#2-2-1-CommitLog" class="headerlink" title="2.2.1 CommitLog"></a>2.2.1 CommitLog</h4><p>默认大小是1G，可以通过MessageStoreConfig中的mappedFileSizeCommitLog属性查看。</p><p>CommitLog是消息存储的真正物理文件，文件名按照文件偏移量递增。</p><p>一个CommitLog是被多个ConsumerQueue所共享的。</p><p>CommitLog采用的是顺序写随机读的方式</p><h4 id="2-2-2-ConsumerQueue"><a href="#2-2-2-ConsumerQueue" class="headerlink" title="2.2.2 ConsumerQueue"></a>2.2.2 ConsumerQueue</h4><p>consumerqueue是逻辑消息队列，一个topic下有几个队列，则会在对应的目录存储相应的 consumerqueue文件。</p><p>consumerqueue不会存储具体的消息，只负责记录所属topic在commitlog中的偏移量，是消息的逻辑队列，类似于数据库的索引文件，存储的是指向物理存储的地址。</p><h4 id="2-2-3-IndexFile"><a href="#2-2-3-IndexFile" class="headerlink" title="2.2.3 IndexFile"></a>2.2.3 IndexFile</h4><p>IndexFile则提供了一种可以通过key或时间区间来查询消息的方法</p><h3 id="2-3-Broker消息处理整体流程"><a href="#2-3-Broker消息处理整体流程" class="headerlink" title="2.3 Broker消息处理整体流程"></a>2.3 Broker消息处理整体流程</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Broker%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.jpg"></p><h4 id="2-3-1-Broker接收消息流程SendMessageProcessor"><a href="#2-3-1-Broker接收消息流程SendMessageProcessor" class="headerlink" title="2.3.1 Broker接收消息流程SendMessageProcessor"></a>2.3.1 Broker接收消息流程SendMessageProcessor</h4><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Broker%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8BSendMessageProcessor.jpg"></p><h4 id="2-3-2-Broker分发消息流程ReputMessageService"><a href="#2-3-2-Broker分发消息流程ReputMessageService" class="headerlink" title="2.3.2 Broker分发消息流程ReputMessageService"></a>2.3.2 Broker分发消息流程ReputMessageService</h4><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Broker%E5%88%86%E5%8F%91%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8BReputMessageService.jpg"></p><h4 id="2-3-3-Broker消费消息流程PullMessageProcessor"><a href="#2-3-3-Broker消费消息流程PullMessageProcessor" class="headerlink" title="2.3.3 Broker消费消息流程PullMessageProcessor"></a>2.3.3 Broker消费消息流程PullMessageProcessor</h4><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Broker%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8BPullMessageProcessor.jpg"></p><h3 id="2-4-过期文件的处理"><a href="#2-4-过期文件的处理" class="headerlink" title="2.4 过期文件的处理"></a>2.4 过期文件的处理</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Broker%E8%BF%87%E6%9C%9F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4.jpg"></p><h2 id="3-Producer"><a href="#3-Producer" class="headerlink" title="3 Producer"></a>3 Producer</h2><h3 id="3-1-Producer发送消息-同步"><a href="#3-1-Producer发送消息-同步" class="headerlink" title="3.1 Producer发送消息(同步)"></a>3.1 Producer发送消息(同步)</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Producer%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF(%E5%90%8C%E6%AD%A5).jpg"></p><h2 id="4-Consumer"><a href="#4-Consumer" class="headerlink" title="4 Consumer"></a>4 Consumer</h2><p>Consumer消费消息支持两种模式：推模式和拉模式 </p><p>推模式：当producer把消息发送到broker之后，broker将消息推送给consumer，但这种推模式其实也是基于拉模式实现的 </p><p>拉模式：consumer主动向broker拉消息 </p><p>两种模式用的最多的是推模式，所以就以推模式为例进行分析</p><h3 id="4-1-Consumer启动"><a href="#4-1-Consumer启动" class="headerlink" title="4.1 Consumer启动"></a>4.1 Consumer启动</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Consumer%E5%90%AF%E5%8A%A8.jpg"></p><h3 id="4-2-Consumer线程消费消息"><a href="#4-2-Consumer线程消费消息" class="headerlink" title="4.2 Consumer线程消费消息"></a>4.2 Consumer线程消费消息</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Consumer%E7%BA%BF%E7%A8%8B%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
      <category>RocketMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ组件介绍与基本使用</title>
    <link href="/2023/03/29/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/03/29/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E#%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB">https://github.com/alibaba/spring-cloud-alibaba/wiki/版本说明#组件版本关系</a></p><h2 id="1-组件介绍"><a href="#1-组件介绍" class="headerlink" title="1 组件介绍"></a>1 组件介绍</h2><h3 id="1-1-Message-Queue"><a href="#1-1-Message-Queue" class="headerlink" title="1.1 Message Queue"></a>1.1 Message Queue</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1.png"></p><p>RocketMQ支持多master的架构。思考一个问题：当有多个master的时候，发往Topic的多条消息会在多个master的Broker上存储。那么，发往某一个Topic的多条消息，是不是在所有的Broker上存储完全相同的内容？</p><p>肯定不是的。如果所有的master存储相同的内容，而slave又跟master存储相同的内容：第一个，浪费了存储空间。第二个，无法通过增加机器数量线性的提升Broker的性能，也就是只能垂直扩展，通过升级硬件的方式提升性能，无法实现横向（水平）扩展。那么在分布式的环境中，RocketMQ的性能肯定会受到非常大的限制。一句话，不符合分片的思想。</p><p>在kafka中设计了一个partiton，一个topic可以拆分成多个partition，这些partition可以分布在不同的Broker上，这样就实现了数据的分片。也决定了kafka可以实现横向扩展。</p><p>RocketMQ中设计了一个叫做Message Queue的逻辑概念，左右跟partition类似。</p><p>首先，创建Topic的时候会指定队列的数量，一个叫writeQueueNums（写队列数量），一个readQueueNums（读队列数量）。写队列的数量决定了有几个Message Queue，读队列的数量决定了有一个线程来消费这些Message Queue（只是用来负载）。服务端创建一个Topic默认8个队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">defaultTopicQueueNums</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure><p>topic不存在，生产者发送消息时创建默认4个队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">defaultTopicNums</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><h3 id="1-2-Producer-and-Consumer"><a href="#1-2-Producer-and-Consumer" class="headerlink" title="1.2 Producer and Consumer"></a>1.2 Producer and Consumer</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/2.png"></p><h4 id="1-2-1-Producer"><a href="#1-2-1-Producer" class="headerlink" title="1.2.1 Producer"></a>1.2.1 Producer</h4><p>生产者，用于生产消息，会定时从NameServer拉取路由信息（不用配置RocketMQ的服务地址），然后路由信息与指定的Broker建立TCP长连接，从而将消息发送到Broker中。发送逻辑一致的Producer可以组成一个Group。RocketMQ的生产者同样支持批量发送，不过List要自己传进去。Producer写数据只能操作master节点。</p><h4 id="1-2-2-Consumer"><a href="#1-2-2-Consumer" class="headerlink" title="1.2.2 Consumer"></a>1.2.2 Consumer</h4><p>消息的消费者，通过NameServer 集群获得Topic的路由信息，连接到对应的Broker上消费消息。消费逻辑一致的Consumer可以组成一个Group，这时候消息会在Consumer之间负载。由于Master和Slave都可以读取消息，因此Consumer会与Master和Slave都建立连接。</p><p>注意：同一个consumer group内的消费者应该订阅同一个topic。或者反过来，消费不同topic的消费者不应该采用相同的consumer group名字。如果不一样，后面的消费者的订阅，会覆盖前面的订阅。</p><p>消费者有两种消费方式：一种是集群消费（消息轮询），一种是广播消费（全部收到相同副本）。从消费模型来说，RocketMQ支持pull和push两种模式。</p><ol><li><p>pull模式</p><p> Pull模式是consumer 轮询从broker拉取消息。pull有两种实现范式：</p><p> 一种是普通轮询（Polling）。不管服务端数据有无更新，客户端每隔定长时间请求拉取一次数据，可能有更新数据返回，也可能什么都没有。普通轮询的缺点：因为大部分时候没有数据，这些无效的请求会大大的浪费服务器的资源。而且定时请求的间隔过长的时候，会导致消息延迟。</p><p> 另一种是长轮询，RocketMQ的pull用长轮询来实现。客户端发起Long Polling，如果此时服务端没有相关数据，会hold住请求，直到服务端有相关数据，或者等待一定时间超时才会返回。返回后，客户端又会立即再次发起下一次Long Polling（所谓的hold住请求指的服务端暂时不回复结果，保存相关请求，不关闭请求连接，等相关数据准备好，写回客户端）。长轮询解决了轮询的问题，唯一的缺点是服务器在挂起的时候比较消耗内存。</p></li><li><p>push模式</p><p> push模式是Broker推送消息给consumer，RocketMQ的push模式实际上是基于pull模式实现的，只不过是在pull模式上封装了一层，所以RocketMQ push模式并不是真正意义上的“推模式”。在RokcetMQ中，PushConsumer会注册MessageListener监听器，取到消息后，唤醒MessageListener的consumeMessage()来消费，对用户而言，感觉消息是被推送过来的。</p></li></ol><h3 id="1-3-Topic"><a href="#1-3-Topic" class="headerlink" title="1.3 Topic"></a>1.3 Topic</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/3.png"></p><p>Topic用于将消息按主题做划分，比如订单消息、物流消息。注意，跟kafka不同的是，在RocketMQ中，topic是一个逻辑概念，消息不是按topic划分存储的。</p><p>Producer将消息发往指定的topic，Consumer订阅这个topic就可以收到相应的消息。跟kafka一样，如果topic不存在，会自动创建.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//BrokerConfig</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">autoCreateTopicEnable</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>Topic跟生产者和消费者都是多对多的关系，一个生产者可以发送消息到多个topic，一个消费者可以订阅多个topic。</p><h3 id="1-4-Tag"><a href="#1-4-Tag" class="headerlink" title="1.4 Tag"></a>1.4 Tag</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/4.png"></p><h3 id="1-5-Broker"><a href="#1-5-Broker" class="headerlink" title="1.5 Broker"></a>1.5 Broker</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/5.png"></p><p>RocketMQ的服务，或者说一个进程，叫做Broker，Broker的作用是存储和转发消息。RocketMQ单机大约能承受10万QPS的请求。</p><p>为了提升Broker的可用性(防止单点故障)，以及提升服务器的性能(实现负载)，通常会做集群的部署。跟kafka获取redis cluster一样，RocketMQ集群的每个Broker节点保存总数据的一部分，因此可以实现横向扩展。为了提高可靠性(防止数据丢失)，每个Broker可以有自己的副本(slave)。</p><p>默认情况下，读写都发生在master上。在slaveReadEnable=true的情况下，slave也可以参与读负载。但是默认只有BrokerId=1的slave才会参与读负载，而且是在master消费慢的情况下，由whichBrokerWhenConsumeSlowly这个参数决定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">whichBrokerWhenConsumeSlowly</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="1-6-NameServer"><a href="#1-6-NameServer" class="headerlink" title="1.6 NameServer"></a>1.6 NameServer</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/6.png"></p><p>当不同的消息存储在不同的Broker上，生产者和消费者对于Broker的选取，或者说路由选择是一个非常关键的问题。所以，跟分布式的服务调用的场景需要一个注册中心一样，在RocketMQ中需要有一个角色来管理Broker的信息。kafka是用Zookeeper管理的，RocketMQ是用NameServer。</p><p>可以把NameServer理解是RocketMQ的路由中心，每一个NameServer节点都保存着全量的路由信息，为了保证高可用，nameServer自身也可以做集群的部署，它的作用有点像Eureka或者Redis的Sentinel。也就是说，Broker会在NameServer上注册自己，Producer和Consumer用NameServer来发现Broker。</p><h3 id="1-7-RocketMQ-Cluster"><a href="#1-7-RocketMQ-Cluster" class="headerlink" title="1.7  RocketMQ Cluster"></a>1.7  RocketMQ Cluster</h3><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/7.png"></p><h2 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2 基本使用"></a>2 基本使用</h2><h3 id="2-1-简单案例"><a href="#2-1-简单案例" class="headerlink" title="2.1 简单案例"></a>2.1 简单案例</h3><p>（1）引入rocketmq-client包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.rocketmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>rocketmq-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.9.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）创建Consumer并启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-string">&quot;simple_consumer_group&quot;</span>);<br>        consumer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>        consumer.subscribe(<span class="hljs-string">&quot;simple_topic&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>        consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;<br>                System.out.printLn(<span class="hljs-string">&quot;%s Receive New Message: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);<br>                <span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>            &#125;<br>        &#125;);<br>        consumer.start();<br>        System.out.printLn(<span class="hljs-string">&quot;Consumer Started.%n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）创建Producer并启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SyncProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;simple_consumer_group&quot;</span>);<br>        producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>        producer.start();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;simple_topic&quot;</span>, <span class="hljs-string">&quot;TAGA&quot;</span>, (<span class="hljs-string">&quot;Hello ROCKETMQ&quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));<br>            <span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> producer.send(message);<br>            System.out.printLn(sendResult);<br>        &#125;<br>        producer.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-生产者发送消息方式"><a href="#2-2-生产者发送消息方式" class="headerlink" title="2.2 生产者发送消息方式"></a>2.2 生产者发送消息方式</h3><h4 id="2-2-1-同步"><a href="#2-2-1-同步" class="headerlink" title="2.2.1 同步"></a>2.2.1 同步</h4><p>producer发送消息给broker时，只有当broker服务器刷盘成功，返回sendResult.OK才算成 功，例如上述简单案例中的producer#send(msg)方法</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/8.png"></p><h4 id="2-2-2-异步"><a href="#2-2-2-异步" class="headerlink" title="2.2.2 异步"></a>2.2.2 异步</h4><p>异步发送是指发送方发出一条消息后，不等服务端返回响应，接着发送下一条消息的通讯方式。消息队列RocketMQ的异步发送，需要实现异步发送回调接口（SendCallback）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Consumer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-string">&quot;test_consumer&quot;</span>);<br>consumer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>consumer.subscribe(<span class="hljs-string">&quot;async_topic&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>);<br>consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>System.out.println(msgs);<br><span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>e.printStackTrace();<br><span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;<br>&#125;<br>&#125;<br>&#125;);<br>consumer.start();<br>System.out.println(<span class="hljs-string">&quot;Consumer Started.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//ASyncProducer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ASyncProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;async_producer&quot;</span>);<br>producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>producer.start();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;async_topic&quot;</span>,<span class="hljs-string">&quot;tag_sync&quot;</span>,<span class="hljs-string">&quot;OrderID188&quot;</span>, (<span class="hljs-string">&quot;Hello ASync &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));<br><span class="hljs-comment">// 异步回调</span><br>producer.send(message, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SendCallback</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(SendResult sendResult)</span> &#123;<br>System.out.println(sendResult);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onException</span><span class="hljs-params">(Throwable e)</span> &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;);<br>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-3-单向"><a href="#2-2-3-单向" class="headerlink" title="2.2.3 单向"></a>2.2.3 单向</h4><p>发送方只负责发送消息，不等待服务端返回响应且没有回调函数触发，即只发送请求不等待应答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Consumer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer03</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-string">&quot;oneway_consumer&quot;</span>);<br>consumer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>consumer.subscribe(<span class="hljs-string">&quot;oneway_topic&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>);<br>consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>System.out.println(msgs);<br><span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>e.printStackTrace();<br><span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;<br>&#125;<br>&#125;<br>&#125;);<br>consumer.start();<br>System.out.println(<span class="hljs-string">&quot;Consumer Started.&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//OnewayProducer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OnewayProducer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;oneway_producer&quot;</span>);<br>producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>producer.start();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;oneway_topic&quot;</span> <span class="hljs-comment">/* Topic */</span>, <span class="hljs-string">&quot;TagA&quot;</span> <span class="hljs-comment">/* Tag */</span>, (<span class="hljs-string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));<br>producer.sendOneway(msg);<br>&#125;<br>Thread.sleep(<span class="hljs-number">5000</span>);<br>producer.shutdown();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-4-三种发送模式对比"><a href="#2-2-4-三种发送模式对比" class="headerlink" title="2.2.4 三种发送模式对比"></a>2.2.4 三种发送模式对比</h4><table><thead><tr><th>发送方式</th><th>TPS</th><th>可靠性</th><th>返回值</th><th>应用场景</th></tr></thead><tbody><tr><td>Sync</td><td>快</td><td>高</td><td>有</td><td>重要消息，比如：短信、邮件等</td></tr><tr><td>ASync</td><td>较快</td><td>较高</td><td>有</td><td>对并发要求和响应时间比较高的场景，同时需要回调函数</td></tr><tr><td>Oneway</td><td>最快</td><td>不高</td><td>无</td><td>对于可靠性要求不高的场景，也不需要返回值，比如日志收集</td></tr></tbody></table><h3 id="2-3-消费消息模式"><a href="#2-3-消费消息模式" class="headerlink" title="2.3 消费消息模式"></a>2.3 消费消息模式</h3><h4 id="2-3-1-集群模式-负载均衡模式"><a href="#2-3-1-集群模式-负载均衡模式" class="headerlink" title="2.3.1 集群模式(负载均衡模式)"></a>2.3.1 集群模式(负载均衡模式)</h4><p>Clustering：也是默认的模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Consumer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer04</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(Strin[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-string">&quot;consumer_model_group&quot;</span>);<br>consumer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>consumer.setMessageModel(MessageModel.CLUSTERING);<br>consumer.subscribe(<span class="hljs-string">&quot;consumer_model_topic&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>);<br>consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>System.out.println(msgs);<br><span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>e.printStackTrace();<br><span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;<br>&#125;<br>&#125;<br>&#125;);<br>consumer.start();<br>System.out.println(<span class="hljs-string">&quot;Consumer Started.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Producer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer01</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;test_producer01&quot;</span>);<br>producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>producer.start();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;consumer_model_topic&quot;</span>, <span class="hljs-string">&quot;TAGA&quot;</span>, (<span class="hljs-string">&quot;consumer model &quot;</span>+i).getBytes(RemotingHelper.DEFAULT_CHARSET));<br><span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> producer.send(message);<br>System.out.println(sendResult);<br>&#125;<br>producer.shutdown();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>观察producer返回结果，可以发现，10条消息被发送到了consumer_model_topic下的4个队列上。</p><p>启动两个Consumer04实例，观察两个Consumer实例的输出，可以发现其中一个consumer获取到了2个队列[2和3]上的5条消 息，另外一个consumer获取到了2个队列[0和1]上的5条消息</p><h4 id="2-3-2-广播模式"><a href="#2-3-2-广播模式" class="headerlink" title="2.3.2  广播模式"></a>2.3.2  广播模式</h4><p>将Consumer的consumer.setMessageModel(MessageModel.CLUSTERING)修改成 consumer.setMessageModel(MessageModel.BROADCASTING) </p><p>（1）将Consumer04的消费模式更改为BROADCASTING </p><p>（2）重启Consumer04的两个实例 </p><p>（3）通过Producer01再次发送10条消息，观察Consumer04中的console打印，可以发现，每个Consumer04实例都会消费所有的消息</p><h4 id="2-3-3-集群模式与广播模式思考"><a href="#2-3-3-集群模式与广播模式思考" class="headerlink" title="2.3.3 集群模式与广播模式思考"></a>2.3.3 集群模式与广播模式思考</h4><p>（1）负载均衡模式下，某个topic下有4个队列，consumer有5个实例</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/9.png"></p><p>（2）负载均衡模式下，某个topic下有4个队列，consumer有2个实例</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/10.png"></p><p>（3）负载均衡模式下，某个topic下有4个队列，consumer有3个实例</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/11.png"></p><p>（4）广播模式下，某个topic下有4个队列，consumer有多少个实例</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/12.png"></p><h3 id="2-4-消息类型"><a href="#2-4-消息类型" class="headerlink" title="2.4 消息类型"></a>2.4 消息类型</h3><h4 id="2-4-1-普通消息-Normal-Message"><a href="#2-4-1-普通消息-Normal-Message" class="headerlink" title="2.4.1 普通消息-Normal Message"></a>2.4.1 普通消息-Normal Message</h4><p>普通消息</p><h4 id="2-4-2-延迟消息-Delay-Message"><a href="#2-4-2-延迟消息-Delay-Message" class="headerlink" title="2.4.2 延迟消息-Delay Message"></a>2.4.2 延迟消息-Delay Message</h4><p>msg通过producer发送到broker之后，不会立即被consumer消息，而是要等待到指定的时间 之后才能被消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Consumer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledMessageConsumer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-string">&quot;schedule_consumer_group&quot;</span>);<br>consumer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>consumer.subscribe(<span class="hljs-string">&quot;schedule_topic&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; messages, ConsumeConcurrentlyContext context)</span> &#123;<br><span class="hljs-keyword">for</span> (MessageExt message : messages) &#123;<br>System.out.println(<span class="hljs-string">&quot;Receive message[msgId=&quot;</span> + message.getMsgId() + <span class="hljs-string">&quot;] &quot;</span> + (System.currentTimeMillis() - message.getStoreTimestamp()) + <span class="hljs-string">&quot;ms later&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>&#125;<br>&#125;);<br>consumer.start();<br>System.out.println(<span class="hljs-string">&quot;Consumer Started.&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//Producer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledMessageProducer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;schedule_producer_group&quot;</span>);<br>producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>producer.start();<br><span class="hljs-type">int</span> <span class="hljs-variable">totalMessagesToSend</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; totalMessagesToSend; i++) &#123;<br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;schedule_topic&quot;</span>, (<span class="hljs-string">&quot;Hello scheduled message &quot;</span> + i).getBytes());<br><span class="hljs-comment">// String messageDelayLevel = &quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;;</span><br>message.setDelayTimeLevel(<span class="hljs-number">4</span>);<br><span class="hljs-comment">// Send the message</span><br><span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> producer.send(message);<br>System.out.println(sendResult);<br>&#125;<br>Thread.sleep(<span class="hljs-number">5000</span>);<br>producer.shutdown();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>延迟等级对应时间：<a href="https://rocketmq.apache.org/docs/4.x/producer/04message3/">https://rocketmq.apache.org/docs/4.x/producer/04message3/</a></p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/13.png"></p><h4 id="2-4-3-批量消息-Batch-Message"><a href="#2-4-3-批量消息-Batch-Message" class="headerlink" title="2.4.3 批量消息-Batch Message"></a>2.4.3 批量消息-Batch Message</h4><p><a href="https://rocketmq.apache.org/docs/4.x/producer/05message4">https://rocketmq.apache.org/docs/4.x/producer/05message4</a></p><p>Producer发送单个消息的最大限制是4M，可以通过maxMessageSize进行设置，同时broker对于单个消息的最大限制也是4M，在MessageStoreConfig中的maxMessageSize属性可以看到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Consumer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BatchConsumer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-string">&quot;batch_consumer_group&quot;</span>);<br>consumer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>consumer.subscribe(<span class="hljs-string">&quot;batch_topic&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>);<br>consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;<br>System.out.println(msgs);<br><span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>&#125;<br>&#125;);<br>consumer.start();<br>System.out.println(<span class="hljs-string">&quot;Consumer Started.&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//Producer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BatchProducer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;batch_producer_group&quot;</span>);<br>producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>producer.start();<br>List&lt;Message&gt; messages = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>messages.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;batch_topic&quot;</span>, <span class="hljs-string">&quot;TagA&quot;</span>, <span class="hljs-string">&quot;OrderID001&quot;</span>, <span class="hljs-string">&quot;Hello world 0&quot;</span>.getBytes()));<br>messages.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;batch_topic&quot;</span>, <span class="hljs-string">&quot;TagA&quot;</span>, <span class="hljs-string">&quot;OrderID002&quot;</span>, <span class="hljs-string">&quot;Hello world 1&quot;</span>.getBytes()));<br>messages.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;batch_topic&quot;</span>, <span class="hljs-string">&quot;TagA&quot;</span>, <span class="hljs-string">&quot;OrderID003&quot;</span>, <span class="hljs-string">&quot;Hello world 2&quot;</span>.getBytes()));<br><span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> producer.send(messages);<br>System.out.println(sendResult);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-4-过滤消息-Filter-Message"><a href="#2-4-4-过滤消息-Filter-Message" class="headerlink" title="2.4.4 过滤消息-Filter Message"></a>2.4.4 过滤消息-Filter Message</h4><p><a href="https://rocketmq.apache.org/docs/featureBehavior/07messagefilter">https://rocketmq.apache.org/docs/featureBehavior/07messagefilter</a></p><p>可以根据TAG和SQL语句进行过滤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Consumer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterConsumer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-string">&quot;filter_consumer_group&quot;</span>);<br>consumer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>consumer.subscribe(<span class="hljs-string">&quot;filter_topic&quot;</span>,<span class="hljs-string">&quot;TagB&quot;</span>);<br>consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;<br><span class="hljs-keyword">for</span> (MessageExt msg : msgs) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(msg.getBody());<br>System.out.println(msg);<br>System.out.println(body+<span class="hljs-string">&quot; &quot;</span>+msg.getTags());<br>&#125;<br><span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>&#125;<br>&#125;);<br>consumer.start();<br>System.out.println(<span class="hljs-string">&quot;Consumer Started.&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//Producer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterProducer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;filter_producer_group&quot;</span>);<br>producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>producer.start();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">tag</span> <span class="hljs-operator">=</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;TagA&quot;</span> : <span class="hljs-string">&quot;TagB&quot;</span>;<br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;filter_topic&quot;</span>, tag, (<span class="hljs-string">&quot;Hello Filter Message &quot;</span> + i).getBytes());<br><span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> producer.send(message);<br>System.out.println(sendResult);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-5-顺序消息-Ordered-Message"><a href="#2-4-5-顺序消息-Ordered-Message" class="headerlink" title="2.4.5 顺序消息-Ordered Message"></a>2.4.5 顺序消息-Ordered Message</h4><p><a href="https://rocketmq.apache.org/docs/featureBehavior/03fifomessage">https://rocketmq.apache.org/docs/featureBehavior/03fifomessage</a></p><p>（1）什么是顺序消息 </p><p>消息生产的顺序要与消息消费的顺序一致。 </p><p>（2）目前消息的生产和消费是怎样的 </p><p>目前的情况下，producer会使用Round Robin的方式把消息发送到不同的queue中，consumer消费消息的时候是通过多线程从各个queue上获取消息的，显然不能保证有序性。 </p><p>（3）全局有序 </p><p>全局有序：在某个topic下，所有的消息都要保证消费有序 </p><p>此时topic中的queue只能有一个，这样producer往一个queue上发送消息，并且consumer只能有一 个，并且采用单线程的方式消息。 但在高并发的场景下，性能比较低，所以一般情况下用得比较少。 </p><p>（4）局部有序 </p><p>局部有序：某个topic下有多个queue，但是每个queue中的消息被消费时都是有序的 </p><p>此时需要保证只有一个producer，并且选择指定的队列进行发送消息，同时consumer中使用单线程进行消费 这时候在高并发的场景下，性能比较高，所以这种局部有序用得比较多。</p><p>（5）局部有序的应用场景 </p><p>比如在下单场景中，用户下了一个订单，订单的orderid为order001，接下来会向指定的queue发送消息，并且是按照顺序发送的，比如：订单支付消息、订单发货消息、订单物流消息等，然后consumer消费的时候，需要按照这种顺序进行消息，所以需要保证单线程。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//局部有序demo</span><br><span class="hljs-comment">//Consumer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderlyConsumer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-string">&quot;orderly_consumer_group&quot;</span>);<br>consumer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>consumer.subscribe(<span class="hljs-string">&quot;orderly_topic&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>);<br>consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerOrderly</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ConsumeOrderlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span>&#123;<br><span class="hljs-keyword">for</span> (MessageExt msg : msgs) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 业务逻辑的处理</span><br>Thread.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">5</span>));<br>System.out.println(Thread.currentThread().getName()+ <span class="hljs-string">&quot; &quot;</span>+<span class="hljs-string">&quot;queueId:&quot;</span>+msg.getQueueId()+ <span class="hljs-string">&quot; body: &quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(msg.getBody()));<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br><span class="hljs-keyword">return</span> ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ConsumeOrderlyStatus.SUCCESS;<br>&#125;<br>&#125;);<br>consumer.start();<br>System.out.println(<span class="hljs-string">&quot;Consumer Started.&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//Producer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderlyProducer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;orderly_producer_group&quot;</span>);<br>producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>producer.start();<br>String[] flows = &#123;<span class="hljs-string">&quot;订单支付&quot;</span>, <span class="hljs-string">&quot;订单发货&quot;</span>, <span class="hljs-string">&quot;订单物流&quot;</span>,<span class="hljs-string">&quot;订单完成&quot;</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">flow</span> <span class="hljs-operator">=</span> flows[i % <span class="hljs-number">4</span>];<br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;orderly_topic&quot;</span>, <span class="hljs-string">&quot;TagA&quot;</span>, flow.getBytes());<br><span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> producer.send(message, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueueSelector</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> MessageQueue <span class="hljs-title function_">select</span><span class="hljs-params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> &#123;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">queueId</span> <span class="hljs-operator">=</span> (Integer) arg;<br>System.out.println(<span class="hljs-string">&quot;queueId: &quot;</span> + queueId);<br><span class="hljs-comment">// 也就是选择了某一个queue</span><br><span class="hljs-keyword">return</span> mqs.get(queueId);<br>&#125;<br>&#125;, <span class="hljs-number">1</span>); <span class="hljs-comment">// 选择queueId为1的queue</span><br>System.out.println(sendResult);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-6-事务消息-Transactional-Message"><a href="#2-4-6-事务消息-Transactional-Message" class="headerlink" title="2.4.6 事务消息-Transactional Message"></a>2.4.6 事务消息-Transactional Message</h4><p><a href="https://rocketmq.apache.org/docs/featureBehavior/04transactionmessage">https://rocketmq.apache.org/docs/featureBehavior/04transactionmessage</a></p><p>RocketMQ提供类似XA或Open XA的分布式事务功能，通过消息队列RocketMQ事务消息，能达到分布式事务的最终一致。 </p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Transaction Consumer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionConsumer</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQConsumer</span>(<span class="hljs-string">&quot;transaction_consumer_group&quot;</span>);<br>        consumer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>        consumer.subscribe(<span class="hljs-string">&quot;transaction_topic&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>        consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, COnsumeConcurrentlyContext context)</span> &#123;<br>                <span class="hljs-keyword">for</span>(MessageExt msg : msgs)&#123;<br>                    System.out.println(msg.getTags()+<span class="hljs-string">&quot; : &quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(msg.getBody()));<br>                &#125;<br>                <span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>            &#125;<br>        &#125;);<br>        consumer.start();<br>        System.out.println(<span class="hljs-string">&quot;Consumer started..&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Transaction Producer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionProducer</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">TransactionMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionMQProducer</span>(<span class="hljs-string">&quot;trans_producer_group&quot;</span>);<br>        <span class="hljs-comment">//执行本地事务需要用到的监听器</span><br>        <span class="hljs-type">TransactionListener</span> <span class="hljs-variable">transactionListener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionListenerImpl</span>();<br>        <span class="hljs-comment">//用于回查本地事务状态的线程池</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">100</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">2000</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>                thread.setName(<span class="hljs-string">&quot;client-transaction-msg-check-thread&quot;</span>);<br>                <span class="hljs-keyword">return</span> thread;<br>            &#125;<br>        &#125;);<br>       producer.setNamesrvAddr(<span class="hljs-string">&quot;localhost:9876&quot;</span>);<br>        producer.setExecutorService(executorService);<br>        producer.setTransactionListener(transactionListener);<br>        producer.start();<br>        String[] tags = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;TagA&quot;</span>, <span class="hljs-string">&quot;TagB&quot;</span>, <span class="hljs-string">&quot;TagC&quot;</span>, <span class="hljs-string">&quot;TagD&quot;</span>, <span class="hljs-string">&quot;TagE&quot;</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;transaction_topic&quot;</span>, tags[i % tags.length], <span class="hljs-string">&quot;KEY&quot;</span>+i, (<span class="hljs-string">&quot;Hello RocketMQ&quot;</span>+i).getBytes(RemotingHelper.DEFAULT_CHARSET));<br>               <span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> producer.sendMessageInTransaction(msg, <span class="hljs-literal">null</span>);<br>                System.out.pringln(<span class="hljs-string">&quot;%s%n&quot;</span>, sendResult);<br>                Thread.sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//用于执行本地事务</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionListenerImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransactionListener</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> LocalTransactionState <span class="hljs-title function_">executeLocalTransaction</span><span class="hljs-params">(Message msg, Object arg)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;本地事务执行。。。&quot;</span>);<br>        <br>        <span class="hljs-keyword">if</span>(msg.getTags().equals(<span class="hljs-string">&quot;TagA&quot;</span>))&#123;<br>            <span class="hljs-comment">//如果msg的tag值为TagA，则提交一个COMMIT_MESSAGE状态</span><br>            <span class="hljs-keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(msg.getTags().equals(<span class="hljs-string">&quot;TagB&quot;</span>)) &#123;<br>            <span class="hljs-comment">//如果msg的tag值为TagB，则提交一个ROLLBACK_MESSAGE状态</span><br>            <span class="hljs-keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果msg的tag为其他，则提交一个LocalTransactionState.UNKNOW，表示需要rocketmq主动向本地事务进行回查</span><br>            <span class="hljs-keyword">return</span> LocalTransactionState.UNKNOW;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> LocalTransactionState <span class="hljs-title function_">checkLocalTransaction</span><span class="hljs-params">(MessageExt msg)</span> &#123;<br>        <span class="hljs-comment">//检查本地事务</span><br>        <span class="hljs-keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-RocketMQ刷盘机制"><a href="#3-RocketMQ刷盘机制" class="headerlink" title="3 RocketMQ刷盘机制"></a>3 RocketMQ刷盘机制</h2><p>所谓的刷盘机制就是将broker application内存中的数据，持久化到commitlog文件中。 可以采用同步刷盘或者异步刷盘的方式。 </p><p>broker.conf文件中的配置项为：flushDiskType =SYNC_FLUSH / ASYNC_FLUSH</p><h3 id="3-1-同步刷盘"><a href="#3-1-同步刷盘" class="headerlink" title="3.1 同步刷盘"></a>3.1 同步刷盘</h3><p>所谓的同步刷盘如图所示，也就是说当producer发送消息给broker时，消息只要持久化到磁盘中才算成功。</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/14.png"></p><h3 id="3-2-异步刷盘"><a href="#3-2-异步刷盘" class="headerlink" title="3.2 异步刷盘"></a>3.2 异步刷盘</h3><p>所谓的异步刷盘，就是producer将消息发送给broker之后，broker虽然也会进行刷盘操作，但是对于producer而言不关心，直接返回success。</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/15.png"></p><h2 id="4-RocketMQ零拷贝"><a href="#4-RocketMQ零拷贝" class="headerlink" title="4 RocketMQ零拷贝"></a>4 RocketMQ零拷贝</h2><p>RocketMQ中使用的是mmap的方式，当然也有其他实现方式，比如sendfile。mmap适合小数据量读写，sendFile 适合大文件传输。</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/RoekctMQ%E9%9B%B6%E6%8B%B7%E8%B4%9D.jpg"></p><h2 id="5-SpringBoot集成"><a href="#5-SpringBoot集成" class="headerlink" title="5 SpringBoot集成"></a>5 SpringBoot集成</h2><p><a href="https://docs.spring.io/spring-boot/docs/2.7.6/reference/html/messaging.html#messaging">https://docs.spring.io/spring-boot/docs/2.7.6/reference/html/messaging.html#messaging</a></p><p>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.rocketmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">rocketmq:</span><br>  <span class="hljs-attr">name-server:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:9876</span><br>  <span class="hljs-attr">producer:</span><br>    <span class="hljs-attr">group:</span> <span class="hljs-string">spring-boot-producer-group</span><br>  <span class="hljs-attr">consumer:</span><br>    <span class="hljs-attr">group:</span> <span class="hljs-string">spring-boot-consumer-group</span><br></code></pre></td></tr></table></figure><p>（3）生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/rocketmq&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RocketMQController</span> &#123;<br>    <br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RocketMQTemplate rocketMQTemplate;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/produce&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">produce</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.rocketMQTemplate.convertAndSend(<span class="hljs-string">&quot;springboot-topic&quot;</span>, <span class="hljs-string">&quot;Hello Spring Boot Rocketmq&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;produce success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@RocketMQMessageListener(consumerGroup = &quot;$&#123;rocketmq.consumer.group&#125;&quot;,topic = &quot;springboot-topic&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootConsumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RocketMQListener</span>&lt;String&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String msg)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Spring Boot 获取到消息内容: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-Spring-Cloud集成-Spring-Cloud-Stream"><a href="#6-Spring-Cloud集成-Spring-Cloud-Stream" class="headerlink" title="6 Spring Cloud集成(Spring Cloud Stream)"></a>6 Spring Cloud集成(Spring Cloud Stream)</h2><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/RocketMQ-en">https://github.com/alibaba/spring-cloud-alibaba/wiki/RocketMQ-en</a></p><p><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/2.2.x/spring-cloud-alibaba-examples/rocketmq-example/readme-zh.md">https://github.com/alibaba/spring-cloud-alibaba/blob/2.2.x/spring-cloud-alibaba-examples/rocketmq-example/readme-zh.md</a></p><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rocketmq<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6-1-SC-Stream3-X之前的用法"><a href="#6-1-SC-Stream3-X之前的用法" class="headerlink" title="6.1 SC Stream3.X之前的用法"></a>6.1 SC Stream3.X之前的用法</h3><h4 id="6-1-1-默认用法"><a href="#6-1-1-默认用法" class="headerlink" title="6.1.1 默认用法"></a>6.1.1 默认用法</h4><p>（1）写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9999</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">stream:</span><br>      <span class="hljs-attr">rocketmq:</span><br>        <span class="hljs-attr">binder:</span><br>          <span class="hljs-comment"># 指定rocketmq nameserver的地址</span><br>          <span class="hljs-attr">name-server:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:9876</span><br>          <span class="hljs-comment"># 如果没有group，则启动会报错</span><br>          <span class="hljs-attr">group:</span> <span class="hljs-string">stream-group</span><br>        <span class="hljs-attr">bindings:</span><br>          <span class="hljs-comment"># 定义name为output的binding，用于发送消息给rocketmq</span><br>          <span class="hljs-attr">output:</span><br>            <span class="hljs-comment"># 发送给rocketmq上的哪个topic</span><br>            <span class="hljs-attr">destination:</span> <span class="hljs-string">springcloud-stream-topic</span><br>          <span class="hljs-comment"># 定义name为input的binding，用于从rocketmq上获取消息</span><br>          <span class="hljs-attr">input:</span><br>            <span class="hljs-comment"># 从rocketmq上的哪个topic获取消息</span><br>            <span class="hljs-attr">destination:</span> <span class="hljs-string">springcloud-stream-topic</span><br></code></pre></td></tr></table></figure><p>（2）添加注解，在入口类添加@Enable驱动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringApplication</span><br><span class="hljs-comment">//向spring ioc容器中注入这两个接口实现类，用于代码中进行依赖注入。这个地方会显示过期，跟SpringCloud Stream版本有关</span><br><span class="hljs-meta">@EnableBinding(&#123;Source.class, Sink.class&#125;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringCloudStreamDemoApplication</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(SpringCloudStreamDemoApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/producer&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerController</span>&#123;<br>    <br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> Source source;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/stream-produce&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">streamProduce</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.source.output().send(MessageBuilder.withPayload(<span class="hljs-string">&quot;stream msg...&quot;</span>).build());<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;stream produce successfully.&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamConsumer</span>&#123;<br>    <span class="hljs-meta">@StreamListener(Sink.INPUT)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveMsg</span><span class="hljs-params">(String msg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;receive msg: &quot;</span> + msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-1-2-自定义用法"><a href="#6-1-2-自定义用法" class="headerlink" title="6.1.2 自定义用法"></a>6.1.2 自定义用法</h4><p>（1）模仿官方的Source接口，自定义TextSource接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//官方</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Source</span> &#123;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">OUTPUT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;output&quot;</span>;<br><br><span class="hljs-meta">@Output(Source.OUTPUT)</span><br>MessageChannel <span class="hljs-title function_">output</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//自定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestSource</span> &#123;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">OUTPUT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test-output&quot;</span>;<br><br><span class="hljs-meta">@Output(TestSource.OUTPUT)</span><br>MessageChannel <span class="hljs-title function_">output</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）模仿官方的Sink接口，自定义TestSource接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//官方</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Sink</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">INPUT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;input&quot;</span>;<br><br><span class="hljs-meta">@Input(Sink.INPUT)</span><br>SubscribableChannel <span class="hljs-title function_">input</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//自定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestSink</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">INPUT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test-input&quot;</span>;<br>    <br><span class="hljs-meta">@Input(TestSink.INPUT)</span><br>SubscribableChannel <span class="hljs-title function_">input</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9999</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">stream:</span><br>      <span class="hljs-attr">rocketmq:</span><br>        <span class="hljs-attr">binder:</span><br>          <span class="hljs-comment"># 指定rocketmq nameserver的地址</span><br>          <span class="hljs-attr">name-server:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:9876</span><br>          <span class="hljs-comment"># 如果没有group，则启动会报错</span><br>          <span class="hljs-attr">group:</span> <span class="hljs-string">stream-group</span><br>        <span class="hljs-attr">bindings:</span><br>          <span class="hljs-comment"># 定义name为output的binding，用于发送消息给rocketmq</span><br>          <span class="hljs-attr">output:</span><br>            <span class="hljs-comment"># 发送给rocketmq上的哪个topic</span><br>            <span class="hljs-attr">destination:</span> <span class="hljs-string">springcloud-stream-topic</span><br>          <span class="hljs-comment"># 定义name为input的binding，用于从rocketmq上获取消息</span><br>          <span class="hljs-attr">input:</span><br>            <span class="hljs-comment"># 从rocketmq上的哪个topic获取消息</span><br>            <span class="hljs-attr">destination:</span> <span class="hljs-string">springcloud-stream-topic</span><br>          <br>          <span class="hljs-comment"># 自定义output和input</span><br>          <span class="hljs-comment"># 定义name为test-output的binding，用于发送消息给rocketmq</span><br>          <span class="hljs-attr">test-output:</span><br>            <span class="hljs-comment"># 发送给rocketmq上的哪个topic</span><br>            <span class="hljs-attr">destination:</span> <span class="hljs-string">springcloud-stream-topic</span><br>          <span class="hljs-comment"># 定义name为test-input的binding，用于从rocketmq上获取消息</span><br>          <span class="hljs-attr">test-input:</span><br>            <span class="hljs-comment"># 从rocketmq上的哪个topic获取消息</span><br>            <span class="hljs-attr">destination:</span> <span class="hljs-string">springcloud-stream-topic</span><br></code></pre></td></tr></table></figure><p>（4）写注解：在入口类上添加TestSource和TestSink</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableBinding(&#123;Source.class, Sink.class,TestSource.class,TestSink.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringCloudStreamDemoApplication</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(SpringCloudStreamDemoApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//生产者</span><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> TestSource testSource;<br><span class="hljs-meta">@RequestMapping(&quot;/test-stream-produce&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testStreamProduce</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">this</span>.testSource.output().send(MessageBuilder.withPayload(<span class="hljs-string">&quot;test stream msg...&quot;</span>).build());<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;test stream produce successfully.&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//消费者</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStreamConsumer</span> &#123;<br><span class="hljs-meta">@StreamListener(TestSink.INPUT)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveMsg</span><span class="hljs-params">(String msg)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;test receive msg: &quot;</span> + msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-SC-Stream-3-X之后的用法"><a href="#6-2-SC-Stream-3-X之后的用法" class="headerlink" title="6.2 SC Stream 3.X之后的用法"></a>6.2 SC Stream 3.X之后的用法</h3><p><a href="https://docs.spring.io/spring-cloud-stream/docs/current/reference/html/spring-cloud-stream.html#_producing_and_consuming_messages">https://docs.spring.io/spring-cloud-stream/docs/current/reference/html/spring-cloud-stream.html#_producing_and_consuming_messages</a></p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
      <category>RocketMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ安装与配置</title>
    <link href="/2023/03/29/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/03/29/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E#%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB">https://github.com/alibaba/spring-cloud-alibaba/wiki/版本说明#组件版本关系</a></p><h2 id="1-单机"><a href="#1-单机" class="headerlink" title="1 单机"></a>1 单机</h2><p>nameserver默认端口：9876</p><p>rocketmq默认端口：10911</p><p>路径：/usr/local/soft</p><h3 id="1-1-基于Binary搭建"><a href="#1-1-基于Binary搭建" class="headerlink" title="1.1 基于Binary搭建"></a>1.1 基于Binary搭建</h3><h4 id="1-1-1-下载"><a href="#1-1-1-下载" class="headerlink" title="1.1.1 下载"></a>1.1.1 下载</h4><p>官网：<a href="http://rocketmq.apache.org/">http://rocketmq.apache.org/</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft<br>wget https://archive.apache.org/dist/rocketmq/4.9.4/rocketmq-all-4.9.4-bin-release.zip<br></code></pre></td></tr></table></figure><h4 id="1-1-2-解压"><a href="#1-1-2-解压" class="headerlink" title="1.1.2 解压"></a>1.1.2 解压</h4><p>解压二进制包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">unzip rocketmq-all-4.9.4-bin-release.zip<br><span class="hljs-built_in">mv</span> rocketmq-all-4.9.4-bin-release rocketmq<br></code></pre></td></tr></table></figure><p>创建数据存储目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> -p /usr/local/soft/rocketmq/store/broker-a /usr/local/soft/rocketmq/store/broker-a/consumequeue /usr/local/soft/rocketmq/store/broker-a/commitlog /usr/local/soft/rocketmq/store/broker-a/index <br>/usr/local/soft/rocketmq/broker-a/logs<br></code></pre></td></tr></table></figure><h4 id="1-1-3-修改配置文件"><a href="#1-1-3-修改配置文件" class="headerlink" title="1.1.3 修改配置文件"></a>1.1.3 修改配置文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft/rocketmq/conf<br>vim broker.conf<br></code></pre></td></tr></table></figure><p>增加内容</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#Broker 对外服务的监听端口</span><br>listenPort=<span class="hljs-number">10911</span><br><span class="hljs-comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br>autoCreateTopicEnable=true<br><span class="hljs-comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br>autoCreateSubscriptionGroup=true<br><span class="hljs-comment">#nameServer地址，分号分割</span><br>namesrvAddr=localhost:<span class="hljs-number">9876</span><br><span class="hljs-comment">#存储路径</span><br>storePathRootDir=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/soft/</span>rocketmq<span class="hljs-regexp">/store/</span>broker-a<br><span class="hljs-comment">#commitLog 存储路径</span><br>storePathCommitLog=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/soft/</span>rocketmq<span class="hljs-regexp">/store/</span>broker-a/commitlog<br><span class="hljs-comment">#消费队列存储路径存储路径</span><br>storePathConsumeQueue=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/soft/</span>rocketmq<span class="hljs-regexp">/store/</span>broker-a/consumequeue<br><span class="hljs-comment">#消息索引存储路径</span><br>storePathIndex=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/soft/</span>rocketmq<span class="hljs-regexp">/store/</span>broker-a/index<br><span class="hljs-comment">#checkpoint 文件存储路径</span><br>storeCheckpoint=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/soft/</span>rocketmq<span class="hljs-regexp">/store/</span>broker-a/checkpoint<br><span class="hljs-comment">#abort 文件存储路径</span><br>abortFile=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/soft/</span>rocketmq<span class="hljs-regexp">/store/</span>broker-a/abort<br></code></pre></td></tr></table></figure><p>在虚拟机中有可能因为内存不够而启动失败，修改bin目录下的runbroker.sh 和 runserver.sh 文件，比如把8g 4g 改成512m， 4g 2g改成256m</p><h4 id="1-1-4-启动"><a href="#1-1-4-启动" class="headerlink" title="1.1.4 启动"></a>1.1.4 启动</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">nohup</span> sh mqnamesrv &amp;<br><span class="hljs-built_in">nohup</span> sh mqbroker -c /usr/local/soft/rocketmq/conf/broker.conf -n localhost:9876 &amp;<br></code></pre></td></tr></table></figure><p>验证是否启动成功，同时可以观察一下10911端口是否被占用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">tail</span> -f nohup.out<br>jps -l<br><br>lsof -i:9876<br>netstat -ano | grep <span class="hljs-string">&quot;9876&quot;</span><br><br>lsof -i:10911<br>netstat -ano | grep <span class="hljs-string">&quot;10911&quot;</span><br></code></pre></td></tr></table></figure><h4 id="1-1-5-避坑"><a href="#1-1-5-避坑" class="headerlink" title="1.1.5 避坑"></a>1.1.5 避坑</h4><ol><li>网卡问题踩坑解决方案 </li></ol><p>如果centos上有多个网卡，此时broker使用的ip地址可能不是自己想要的，可以给broker设置对应的ip地址，在conf/broker.conf中进行设置，最后一行加上 brokerIP1=192.168.1.8，然后停止broker后再启动： nohup sh bin/mqbroker -c conf/broker.conf -n localhost:9876 &amp;</p><h4 id="1-1-6-关闭服务"><a href="#1-1-6-关闭服务" class="headerlink" title="1.1.6 关闭服务"></a>1.1.6 关闭服务</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft/rocketmq/bin<br><br>sh mqshutdown namesrv<br>sh mqshutdown broker<br></code></pre></td></tr></table></figure><h4 id="1-1-7-Dashboard"><a href="#1-1-7-Dashboard" class="headerlink" title="1.1.7 Dashboard"></a>1.1.7 Dashboard</h4><p>（1）下载rocketmq-dashboard源码并解压 下载链接：<a href="https://github.com/apache/rocketmq-dashboard">https://github.com/apache/rocketmq-dashboard</a> </p><p>（2）进入源码的resources目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> rocketmq-dashboard/src/main/resources/ <br></code></pre></td></tr></table></figure><p>（3）修改application.yml文件 </p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/1.png"></p><p>（4）回到rocketmq-dashboard的根目录，执行maven打包命令</p><p>（5）进入rocketmq-dashboard的target目录，找到打包好的jar包，启动该jar包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">nohup</span> java -jar rocketmq-dashboard-1.0.1-SNAPSHOT.jar &amp;<br><span class="hljs-built_in">tail</span> -f nohup.out<br>lsof -i:18080<br></code></pre></td></tr></table></figure><p>（6）通过浏览器访问</p><h3 id="1-2-基于Source搭建"><a href="#1-2-基于Source搭建" class="headerlink" title="1.2 基于Source搭建"></a>1.2 基于Source搭建</h3><h4 id="1-2-1-源码准备"><a href="#1-2-1-源码准备" class="headerlink" title="1.2.1 源码准备"></a>1.2.1 源码准备</h4><p>（1）解压源码包 </p><p>（2）来到源码根目录，打开terminal，使用mvn构建一下 </p><p>（3）将源码导入到idea中 </p><p>（4）将distribution中的conf文件夹复制到根目录下</p><h4 id="1-2-2-启动NameServer"><a href="#1-2-2-启动NameServer" class="headerlink" title="1.2.2  启动NameServer"></a>1.2.2  启动NameServer</h4><p>（1）配置启动参数</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/2.png"></p><p>（2）通过NamesrvStartup#main方法启动</p><p>（3）查看端口监听</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">netstat -ano | findstr <span class="hljs-string">&quot;9876&quot;</span><br></code></pre></td></tr></table></figure><h4 id="1-2-3-启动Broker"><a href="#1-2-3-启动Broker" class="headerlink" title="1.2.3 启动Broker"></a>1.2.3 启动Broker</h4><p>（1）修改conf文件夹下的broker.conf配置</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">brokerClusterName = DefaultCluster<br>brokerName = broker-a<br>brokerId = 0<br>namesrvAddr=localhost:9876<br>deleteWhen = 04<br>brokerRole = ASYNC_MASTER<br>flushDiskType = ASYNC_FLUSH<br>autoCreateTopicEnable=true<br>storePathRootDir=D:<span class="hljs-symbol">\\</span>share<span class="hljs-symbol">\\</span>vip<span class="hljs-symbol">\\</span>sc<span class="hljs-symbol">\\</span>rocketmq<span class="hljs-symbol">\\</span>store<br>storePathCommitLog=D:<span class="hljs-symbol">\\</span>share<span class="hljs-symbol">\\</span>vip<span class="hljs-symbol">\\</span>sc<span class="hljs-symbol">\\</span>rocketmq<span class="hljs-symbol">\\</span>store<span class="hljs-symbol">\\</span>commitlog<br>storePathConsumeQueue=D:<span class="hljs-symbol">\\</span>share<span class="hljs-symbol">\\</span>vip<span class="hljs-symbol">\\</span>sc<span class="hljs-symbol">\\</span>rocketmq<span class="hljs-symbol">\\</span>store<span class="hljs-symbol">\\</span>consumequeue<br>storePathIndex=D:<span class="hljs-symbol">\\</span>share<span class="hljs-symbol">\\</span>vip<span class="hljs-symbol">\\</span>sc<span class="hljs-symbol">\\</span>rocketmq<span class="hljs-symbol">\\</span>store<span class="hljs-symbol">\\</span>index<br>storeCheckpoint=D:<span class="hljs-symbol">\\</span>share<span class="hljs-symbol">\\</span>vip<span class="hljs-symbol">\\</span>sc<span class="hljs-symbol">\\</span>rocketmq<span class="hljs-symbol">\\</span>store<span class="hljs-symbol">\\</span>checkpoint<br></code></pre></td></tr></table></figure><p>（2）配置启动参数</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/3.png"></p><p>（3）通过BrokerStartup#main启动Broker，观察控制台打印信息</p><p>（4）查看端口监听</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">netstat -ano | findstr <span class="hljs-string">&quot;10911&quot;</span><br></code></pre></td></tr></table></figure><h4 id="1-2-4-Dashboard"><a href="#1-2-4-Dashboard" class="headerlink" title="1.2.4 Dashboard"></a>1.2.4 Dashboard</h4><p>（1）下载rocketmq-dashboard源码并解压 下载链接：<a href="https://github.com/apache/rocketmq-dashboard">https://github.com/apache/rocketmq-dashboard</a> </p><p>（2）进入源码的resources目录 cd rocketmq-dashboard/src/main/resources/ </p><p>（3）修改application.yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">18080</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">encoding:</span><br>      <span class="hljs-attr">charset:</span> <span class="hljs-string">UTF-8</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">force:</span> <span class="hljs-literal">true</span><br>      <br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">rocketmq-dashboard</span><br>    <br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">config:</span> <span class="hljs-string">classpath:logback.xml</span><br><span class="hljs-attr">rocketmq:</span><br>  <span class="hljs-attr">config:</span><br>    <span class="hljs-comment">#nameserver地址</span><br>    <span class="hljs-attr">namesrvAddrs:</span><br>      <span class="hljs-number">-127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:9876</span><br></code></pre></td></tr></table></figure><p>（4）打开App类，启动 </p><p>（5）查看端口监听</p><p>（6）通过浏览器访问rocketmq-dashboard</p><h2 id="2-集群"><a href="#2-集群" class="headerlink" title="2 集群"></a>2 集群</h2><p>二主二从异步集群部署</p><h3 id="2-1-节点规划"><a href="#2-1-节点规划" class="headerlink" title="2.1 节点规划"></a>2.1 节点规划</h3><p>第一台机器 192.168.44.163，端口规划：<br>9876 NameServer1<br>10910 BrokerA-master<br>10921 BrokerB-slave</p><p>第二台机器 192.168.44.164，端口规划：<br>9876 NameServer2<br>10920 BrokerB-master<br>10911 BrokerA-slave</p><p><img src="/image/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/4.png"></p><h3 id="2-2-下载解压"><a href="#2-2-下载解压" class="headerlink" title="2.2 下载解压"></a>2.2 下载解压</h3><p>从官网首页最新发布版本进入下载地址 <a href="http://rocketmq.apache.org/">http://rocketmq.apache.org/</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">unzip rocketmq-all-4.7.1-bin-release.zip<br><span class="hljs-built_in">mv</span> rocketmq-all-4.7.1-bin-release rocketmq<br></code></pre></td></tr></table></figure><p>在两台机器上都下载、解压好。</p><p>在rocketmq/conf目录下，有三种建议配置模式：</p><ol><li><p>2m-2s-async(2主2从异步) —— 本文采用这种</p></li><li><p>2m-2s-sync (2主2从同步)</p></li><li><p>2m-noslave (2主)</p></li></ol><p>现在需要修改两台机器上2m-2s-async这个目录中的文件。配置文件修改之前先备份。</p><h3 id="2-3-配置第一台机器"><a href="#2-3-配置第一台机器" class="headerlink" title="2.3 配置第一台机器"></a>2.3 配置第一台机器</h3><p>192.168.44.163的两个配置文件</p><p>（1）broker-a.properties</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft/rocketmq/conf/2m-2s-async<br>vim broker-a.properties<br></code></pre></td></tr></table></figure><p>修改的内容（名字自定义，保持一致，否则不能组成集群）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">brokerClusterName</span>=<span class="hljs-string">test-cluster</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#增加的内容</span><br><span class="hljs-comment">#Broker 对外服务的监听端口</span><br><span class="hljs-attr">listenPort</span>=<span class="hljs-string">10910</span><br><span class="hljs-comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="hljs-attr">autoCreateTopicEnable</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="hljs-attr">autoCreateSubscriptionGroup</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#nameServer地址，分号分割</span><br><span class="hljs-attr">namesrvAddr</span>=<span class="hljs-string">192.168.44.163:9876;192.168.44.164:9876</span><br><span class="hljs-comment">#存储路径</span><br><span class="hljs-attr">storePathRootDir</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-a</span><br><span class="hljs-comment">#commitLog 存储路径</span><br><span class="hljs-attr">storePathCommitLog</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-a/commitlog</span><br><span class="hljs-comment">#消费队列存储路径存储路径</span><br><span class="hljs-attr">storePathConsumeQueue</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-a/consumequeue</span><br><span class="hljs-comment">#消息索引存储路径</span><br><span class="hljs-attr">storePathIndex</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-a/index</span><br><span class="hljs-comment">#checkpoint 文件存储路径</span><br><span class="hljs-attr">storeCheckpoint</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/checkpoint</span><br><span class="hljs-comment">#abort 文件存储路径</span><br><span class="hljs-attr">abortFile</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/abort</span><br></code></pre></td></tr></table></figure><p>（2）broker-b-s.properties</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim  broker-b-s.properties<br></code></pre></td></tr></table></figure><p>修改的内容（名字自定义，保持一致，否则不能组成集群）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">brokerClusterName</span>=<span class="hljs-string">test-cluster</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#增加的内容</span><br><span class="hljs-comment">#Broker 对外服务的监听端口</span><br><span class="hljs-attr">listenPort</span>=<span class="hljs-string">10921</span><br><span class="hljs-comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="hljs-attr">autoCreateTopicEnable</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="hljs-attr">autoCreateSubscriptionGroup</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#nameServer地址，分号分割</span><br><span class="hljs-attr">namesrvAddr</span>=<span class="hljs-string">192.168.44.163:9876;192.168.44.164:9876</span><br><span class="hljs-comment">#存储路径</span><br><span class="hljs-attr">storePathRootDir</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-b-s</span><br><span class="hljs-comment">#commitLog 存储路径</span><br><span class="hljs-attr">storePathCommitLog</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-b-s/commitlog</span><br><span class="hljs-comment">#消费队列存储路径存储路径</span><br><span class="hljs-attr">storePathConsumeQueue</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-b-s/consumequeue</span><br><span class="hljs-comment">#消息索引存储路径</span><br><span class="hljs-attr">storePathIndex</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-b-s/index</span><br><span class="hljs-comment">#checkpoint 文件存储路径</span><br><span class="hljs-attr">storeCheckpoint</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/checkpoint</span><br><span class="hljs-comment">#abort 文件存储路径</span><br><span class="hljs-attr">abortFile</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/abort</span><br></code></pre></td></tr></table></figure><h3 id="2-4-配置第二台机器"><a href="#2-4-配置第二台机器" class="headerlink" title="2.4 配置第二台机器"></a>2.4 配置第二台机器</h3><p>192.168.44.164的两个配置文件，修改的内容基本一致，主要是注意一下端口号、路径名。</p><p>（1）broker-b.properties</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft/rocketmq/conf/2m-2s-async<br>vim  broker-b.properties<br></code></pre></td></tr></table></figure><p>修改的内容（名字自定义，保持一致，否则不能组成集群）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">brokerClusterName</span>=<span class="hljs-string">test-cluster</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#增加的内容</span><br><span class="hljs-comment">#Broker 对外服务的监听端口</span><br><span class="hljs-attr">listenPort</span>=<span class="hljs-string">10920</span><br><span class="hljs-comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="hljs-attr">autoCreateTopicEnable</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="hljs-attr">autoCreateSubscriptionGroup</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#nameServer地址，分号分割</span><br><span class="hljs-attr">namesrvAddr</span>=<span class="hljs-string">192.168.44.163:9876;192.168.44.164:9876</span><br><span class="hljs-comment">#存储路径</span><br><span class="hljs-attr">storePathRootDir</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-b</span><br><span class="hljs-comment">#commitLog 存储路径</span><br><span class="hljs-attr">storePathCommitLog</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-b/commitlog</span><br><span class="hljs-comment">#消费队列存储路径存储路径</span><br><span class="hljs-attr">storePathConsumeQueue</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-b/consumequeue</span><br><span class="hljs-comment">#消息索引存储路径</span><br><span class="hljs-attr">storePathIndex</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-b/index</span><br><span class="hljs-comment">#checkpoint 文件存储路径</span><br><span class="hljs-attr">storeCheckpoint</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/checkpoint</span><br><span class="hljs-comment">#abort 文件存储路径</span><br><span class="hljs-attr">abortFile</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/abort</span><br></code></pre></td></tr></table></figure><p>（2）broker-a-s.properties</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft/rocketmq/conf/2m-2s-async<br>vim  broker-a-s.properties<br></code></pre></td></tr></table></figure><p>修改的内容（名字自定义，保持一致，否则不能组成集群）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">brokerClusterName</span>=<span class="hljs-string">test-cluster</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#Broker 对外服务的监听端口</span><br><span class="hljs-attr">listenPort</span>=<span class="hljs-string">10911</span><br><span class="hljs-comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="hljs-attr">autoCreateTopicEnable</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="hljs-attr">autoCreateSubscriptionGroup</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#nameServer地址，分号分割</span><br><span class="hljs-attr">namesrvAddr</span>=<span class="hljs-string">192.168.44.163:9876;192.168.44.164:9876</span><br><span class="hljs-comment">#存储路径</span><br><span class="hljs-attr">storePathRootDir</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-a-s</span><br><span class="hljs-comment">#commitLog 存储路径</span><br><span class="hljs-attr">storePathCommitLog</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-a-s/commitlog</span><br><span class="hljs-comment">#消费队列存储路径存储路径</span><br><span class="hljs-attr">storePathConsumeQueue</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-a-s/consumequeue</span><br><span class="hljs-comment">#消息索引存储路径</span><br><span class="hljs-attr">storePathIndex</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/broker-a-s/index</span><br><span class="hljs-comment">#checkpoint 文件存储路径</span><br><span class="hljs-attr">storeCheckpoint</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/checkpoint</span><br><span class="hljs-comment">#abort 文件存储路径</span><br><span class="hljs-attr">abortFile</span>=<span class="hljs-string">/usr/local/soft/rocketmq/store/abort</span><br></code></pre></td></tr></table></figure><h3 id="2-5-创建数据目录"><a href="#2-5-创建数据目录" class="headerlink" title="2.5 创建数据目录"></a>2.5 创建数据目录</h3><p>第一台机器163执行（只需要执行一次）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> -p /usr/local/soft/rocketmq/store/broker-a /usr/local/soft/rocketmq/store/broker-a/consumequeue /usr/local/soft/rocketmq/store/broker-a/commitlog /usr/local/soft/rocketmq/store/broker-a/index /usr/local/soft/rocketmq/logs /usr/local/soft/rocketmq/store/broker-b-s /usr/local/soft/rocketmq/store/broker-b-s/consumequeue /usr/local/soft/rocketmq/store/broker-b-s/commitlog /usr/local/soft/rocketmq/store/broker-b-s/index<br></code></pre></td></tr></table></figure><p>第二台机器164执行（只需要执行一次）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> -p /usr/local/soft/rocketmq/store/broker-a-s /usr/local/soft/rocketmq/store/broker-a-s/consumequeue /usr/local/soft/rocketmq/store/broker-a-s/commitlog /usr/local/soft/rocketmq/store/broker-a-s/index /usr/local/soft/rocketmq/logs /usr/local/soft/rocketmq/store/broker-b /usr/local/soft/rocketmq/store/broker-b/consumequeue /usr/local/soft/rocketmq/store/broker-b/commitlog /usr/local/soft/rocketmq/store/broker-b/index<br></code></pre></td></tr></table></figure><h3 id="2-6-启动两个NameServer"><a href="#2-6-启动两个NameServer" class="headerlink" title="2.6 启动两个NameServer"></a>2.6 启动两个NameServer</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#启动第一台机器163的NameServer</span><br><span class="hljs-built_in">nohup</span> sh /usr/local/soft/rocketmq/bin/mqnamesrv &gt;/usr/local/soft/rocketmq/logs/mqnamesrv.log 2&gt;&amp;1 &amp;<br><br><span class="hljs-comment">#启动第二台机器164的NameServer</span><br><span class="hljs-built_in">nohup</span> sh /usr/local/soft/rocketmq/bin/mqnamesrv &gt;/usr/local/soft/rocketmq/logs/mqnamesrv.log 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><h3 id="2-7-启动Broker"><a href="#2-7-启动Broker" class="headerlink" title="2.7 启动Broker"></a>2.7 启动Broker</h3><p>1、启动节点1，163的 broker-a-master，在163上面执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">nohup</span> sh /usr/local/soft/rocketmq/bin/mqbroker -c /usr/local/soft/rocketmq/conf/2m-2s-async/broker-a.properties &gt; /usr/local/soft/rocketmq/logs/broker-a.log 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><p>在虚拟机中可能由于内存不够导致无法启动，改动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim /usr/local/soft/rocketmq/bin/runbroker.sh<br><br><span class="hljs-comment">#把8g和4g改成512m和256m</span><br>JAVA_OPT=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;JAVA_OPT&#125;</span> -server -Xms512m -Xmx512m -Xmn256m&quot;</span><br></code></pre></td></tr></table></figure><p>2、启动节点2，164的broker-a-s，在164上面执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">nohup</span> sh /usr/local/soft/rocketmq/bin/mqbroker -c /usr/local/soft/rocketmq/conf/2m-2s-async/broker-a-s.properties &gt; /usr/local/soft/rocketmq/logs/broker-a-s.log 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><p>3、启动节点2，164的 broker-b-master，在164上面执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">nohup</span> sh /usr/local/soft/rocketmq/bin/mqbroker -c /usr/local/soft/rocketmq/conf/2m-2s-async/broker-b.properties &gt; /usr/local/soft/rocketmq/logs/broker-b.log 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><p>4、启动节点1，163的broker-b-s，在163上面执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">nohup</span> sh /usr/local/soft/rocketmq/bin/mqbroker -c /usr/local/soft/rocketmq/conf/2m-2s-async/broker-b-s.properties &gt; /usr/local/soft/rocketmq/logs/broker-b-s.log 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><p>查看端口启动状态：<br>netstat -an|grep 109</p><p>第一台机器 192.168.44.163，端口规划：<br>9876 NameServer1<br>10910 BrokerA-master<br>10921 BrokerB-slave</p><p>第二台机器 192.168.44.164，端口规划：<br>9876 NameServer2<br>10920 BrokerB-master<br>10911 BrokerA-slave</p><h2 id="3-常用管理命令"><a href="#3-常用管理命令" class="headerlink" title="3 常用管理命令"></a>3 常用管理命令</h2><p><a href="https://blog.csdn.net/gwd1154978352/article/details/80829534">https://blog.csdn.net/gwd1154978352/article/details/80829534</a></p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
      <category>RocketMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sentinel规则持久化</title>
    <link href="/2023/03/27/spring%E6%A1%86%E6%9E%B6/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2023/03/27/spring%E6%A1%86%E6%9E%B6/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>官网：<a href="https://github.com/alibaba/Sentinel/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95">https://github.com/alibaba/Sentinel/wiki/动态规则扩展</a></p><h2 id="1-客户端内存的规则"><a href="#1-客户端内存的规则" class="headerlink" title="1 客户端内存的规则"></a>1 客户端内存的规则</h2><h3 id="1-1-规则的存储"><a href="#1-1-规则的存储" class="headerlink" title="1.1 规则的存储"></a>1.1 规则的存储</h3><p><img src="/image/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/sentinel%E5%86%85%E5%AD%98%E8%A7%84%E5%88%99%E7%9A%84%E5%AD%98%E5%82%A8.jpg"></p><h3 id="1-2-规则的获取"><a href="#1-2-规则的获取" class="headerlink" title="1.2 规则的获取"></a>1.2 规则的获取</h3><p><img src="/image/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/sentinel%E5%86%85%E5%AD%98%E8%A7%84%E5%88%99%E7%9A%84%E8%8E%B7%E5%8F%96.jpg"></p><h2 id="2-Dashboard规则管理"><a href="#2-Dashboard规则管理" class="headerlink" title="2 Dashboard规则管理"></a>2 Dashboard规则管理</h2><h3 id="2-1-三种模式"><a href="#2-1-三种模式" class="headerlink" title="2.1 三种模式"></a>2.1 三种模式</h3><table><thead><tr><th>推送模式</th><th>说明</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>原始模式</td><td>API将规则推送至客户端并直接更新到内存中，扩展写数据源(WritableDateSource)</td><td>简单，无任何依赖</td><td>不保证一致性；规则保存在内存中，重启即消失，严重不建议用于生产环境</td></tr><tr><td>Pull模式</td><td>扩展写数据源(WritableDataSource)，客户端主动向某个规则管理中心定期轮询拉取规则，这个规则中心可以是RDBMS、文件等</td><td>简单，无任何依赖；规则持久化</td><td>不保证一致性；实时性不保证，拉取过于频繁也可能会有性能问题</td></tr><tr><td>Push模式</td><td>扩展读数据源(ReadableDataSource)，规则中心统一推送，客户端通过注册监听的方式时刻监听变化，比如使用Nacos、Zookeeper等配置中心。这种方式有更好的实时性和一致性保证。<strong>生产环境下一般采用push模式的数据源</strong></td><td>规则持久化；一致性；快速</td><td>引入第三方依赖</td></tr></tbody></table><h3 id="2-2-原始模式"><a href="#2-2-原始模式" class="headerlink" title="2.2 原始模式"></a>2.2 原始模式</h3><p><img src="/image/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/1.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">dashboard调用客户端的常见api：<br>http://localhost:8720/api                  -&gt; ApiCommandHandler<br>http://localhost:8720/getRules?<span class="hljs-built_in">type</span>=flow   -&gt; FetchActiveRuleCommandHandler<br>http://localhost:8720/setRules?<span class="hljs-built_in">type</span>=flow   -&gt; ModifyRulesCommandHandler<br></code></pre></td></tr></table></figure><h3 id="2-3-Pull模式"><a href="#2-3-Pull模式" class="headerlink" title="2.3 Pull模式"></a>2.3 Pull模式</h3><p><img src="/image/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/2.png"></p><h4 id="2-3-1-代码实现"><a href="#2-3-1-代码实现" class="headerlink" title="2.3.1 代码实现"></a>2.3.1 代码实现</h4><p>（1）创建FileDataSourceInit实现InitFunc接口，用于本地规则的读取与写入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileDataSourceInit</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitFunc</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.printLn(<span class="hljs-string">&quot;Pull模式，FileDataSourceInit...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）根据Sentinel中提供的SPI机制，在指定目录下创建文件及配置</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//文件位置</span><br>resources/META-INF/services/com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.csp</span><span class="hljs-selector-class">.sentinel</span><span class="hljs-selector-class">.init</span><span class="hljs-selector-class">.InitFunc</span><br><br><span class="hljs-comment">//文件内容</span><br>com<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.user</span><span class="hljs-selector-class">.initFuc</span>.FileDataSourceInit<br></code></pre></td></tr></table></figure><p>（3）debug测试FileDataSourceInit#init方法是否调用</p><p>（4）在C:\Users\Jack\sentinel\rules目录创建几种规则的json文件，用于在本地存储对应的规则</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">流控规则：flow-<span class="hljs-keyword">rule</span>.json<br>降级规则：degrade-<span class="hljs-keyword">rule</span>.json<br>热点参数规则：param-flow-<span class="hljs-keyword">rule</span>.json<br>授权规则：authority-<span class="hljs-keyword">rule</span>.json<br>系统规则：<span class="hljs-keyword">system</span>-<span class="hljs-keyword">rule</span>.json<br></code></pre></td></tr></table></figure><p>（5）编辑FileDataSourceInit类，定义这些规则文件对应的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileDataSourceInit</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitFunc</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.printLn(<span class="hljs-string">&quot;Pull模式，FileDataSourceInit...&quot;</span>);<br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">rulePath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.home&quot;</span>) + <span class="hljs-string">&quot;\\sentinel\\rules&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">flowRulePath</span> <span class="hljs-operator">=</span> rulePath + <span class="hljs-string">&quot;\\flow-rule.json&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">degradeRulePath</span> <span class="hljs-operator">=</span> rulePath + <span class="hljs-string">&quot;\\degrade-rule.json&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">paramFlowRulePath</span> <span class="hljs-operator">=</span> rulePath + <span class="hljs-string">&quot;\\param-flow-rule.json&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">authorityRulePath</span> <span class="hljs-operator">=</span> rulePath + <span class="hljs-string">&quot;\\authority-rule.json&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">systemRulePath</span> <span class="hljs-operator">=</span> rulePath + <span class="hljs-string">&quot;\\system-rulle.json&quot;</span>;<br>        System.out.printLn(<span class="hljs-string">&quot;流控规则的文件全路径为: &quot;</span>+flowRulePath);<br>        <br>        <span class="hljs-comment">// 不存在的话就创建对应的文件夹及文件</span><br><span class="hljs-built_in">this</span>.mkdirIfNotExits(rulePath);<br><span class="hljs-built_in">this</span>.createFileIfNotExits(flowRulePath);<br><span class="hljs-built_in">this</span>.createFileIfNotExits(degradeRulePath);<br><span class="hljs-built_in">this</span>.createFileIfNotExits(paramFlowRulePath);<br><span class="hljs-built_in">this</span>.createFileIfNotExits(authorityRulePath);<br><span class="hljs-built_in">this</span>.createFileIfNotExits(systemRulePath);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mkdirIfNotExits</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-keyword">if</span>(!file.exists())&#123;<br>            file.mkdirs();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createFileIfNotExits</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-keyword">if</span>(!file.exists())&#123;<br>            file.createNewFile();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（6）完善流控规则的读写数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileDataSourceInit</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitFunc</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.printLn(<span class="hljs-string">&quot;Pull模式，FileDataSourceInit...&quot;</span>);<br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">rulePath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.home&quot;</span>) + <span class="hljs-string">&quot;\\sentinel\\rules&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">flowRulePath</span> <span class="hljs-operator">=</span> rulePath + <span class="hljs-string">&quot;\\flow-rule.json&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">degradeRulePath</span> <span class="hljs-operator">=</span> rulePath + <span class="hljs-string">&quot;\\degrade-rule.json&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">paramFlowRulePath</span> <span class="hljs-operator">=</span> rulePath + <span class="hljs-string">&quot;\\param-flow-rule.json&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">authorityRulePath</span> <span class="hljs-operator">=</span> rulePath + <span class="hljs-string">&quot;\\authority-rule.json&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">systemRulePath</span> <span class="hljs-operator">=</span> rulePath + <span class="hljs-string">&quot;\\system-rulle.json&quot;</span>;<br>        System.out.printLn(<span class="hljs-string">&quot;流控规则的文件全路径为: &quot;</span>+flowRulePath);<br>        <br>        <span class="hljs-comment">// 不存在的话就创建对应的文件夹及文件</span><br><span class="hljs-built_in">this</span>.mkdirIfNotExits(rulePath);<br><span class="hljs-built_in">this</span>.createFileIfNotExits(flowRulePath);<br><span class="hljs-built_in">this</span>.createFileIfNotExits(degradeRulePath);<br><span class="hljs-built_in">this</span>.createFileIfNotExits(paramFlowRulePath);<br><span class="hljs-built_in">this</span>.createFileIfNotExits(authorityRulePath);<br><span class="hljs-built_in">this</span>.createFileIfNotExits(systemRulePath);<br>        <br>        ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; ds = <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileRefreshableDataSource</span>&lt;&gt;(flowRulePath, source -&gt; JSON.parseObject(source, <br>                                                                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;List&lt;FlowRule&gt;&gt;()&#123;&#125;));<br>        <span class="hljs-comment">//将可读数据源注册至FlowRuleManager</span><br>        FlowRuleManager.register2Property(ds.getProperty());<br>        WritableDataSource&lt;List&lt;FlowRule&gt;&gt; wds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWritableDataSoure</span>&lt;&gt;(flowRulePath, <span class="hljs-built_in">this</span>::encodeJson);<br>        <span class="hljs-comment">//将可写数据源注册至transport模块的WritableDataSource中</span><br>        <span class="hljs-comment">//这样收到控制台推送的规则时，Sentinel会先更新到内存，然后将规则写入到文件中</span><br>        WritableDataSourceRegistry.registerFlowDataSource(wds);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mkdirIfNotExits</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-keyword">if</span>(!file.exists())&#123;<br>            file.mkdirs();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createFileIfNotExits</span><span class="hljs-params">(String filePath)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-keyword">if</span>(!file.exists())&#123;<br>            file.createNewFile();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> &lt;T&gt; String <span class="hljs-title function_">encodeJson</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-keyword">return</span> JSON.toJSONString(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（7）测试Pull模式的流控规则是否生效，重启Spring Boot项目，访问 <a href="http://localhost:8081/user/hello%EF%BC%8C%E5%88%B7%E6%96%B0dashboard%EF%BC%8C%E7%BB%99/user/hello%E6%B7%BB%E5%8A%A0%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99%EF%BC%8C%E7%9C%8B%E7%9C%8B%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6flowrule.json%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%B0%E6%8D%AE%E3%80%82%E7%84%B6%E5%90%8E%E9%87%8D%E5%90%AFuser%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%86%8D%E6%AC%A1%E8%AE%BF%E9%97%AE%E8%AE%BF%E9%97%AEhttp://localhost:8081/user/hello%EF%BC%8C%E6%A3%80%E6%9F%A5%E8%A7%84">http://localhost:8081/user/hello，刷新dashboard，给/user/hello添加流控规则，看看本地文件flowrule.json中是否有数据。然后重启user服务，再次访问访问http://localhost:8081/user/hello，检查规</a> 则是否还存在。 </p><p>（8）通过dashboard修改流控规则，看看本地流控规则文件的数据变化。 修改本地流控规则文件，看看dashboard数据的变化。</p><p>（9）最后分别完善其他规则的代码</p><h4 id="2-3-2-源码分析"><a href="#2-3-2-源码分析" class="headerlink" title="2.3.2 源码分析"></a>2.3.2 源码分析</h4><p><img src="/image/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/sentinel-pull%E6%A8%A1%E5%BC%8F%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99%E6%BA%90%E7%A0%81.jpg"></p><h3 id="2-4-Push模式"><a href="#2-4-Push模式" class="headerlink" title="2.4 Push模式"></a>2.4 Push模式</h3><p><img src="/image/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/4.png"></p><h4 id="2-4-1-代码实现"><a href="#2-4-1-代码实现" class="headerlink" title="2.4.1 代码实现"></a>2.4.1 代码实现</h4><h5 id="2-4-1-1-sentinel-dashboard"><a href="#2-4-1-1-sentinel-dashboard" class="headerlink" title="2.4.1.1 sentinel-dashboard"></a>2.4.1.1 sentinel-dashboard</h5><p>（1）打开sentinel-dashboard pom文件，将sentinel-datasource-nacos依赖的scope[test]去掉 </p><p>（2）将sentinel-dashboard项目中的test/rule目录下的nacos文件夹复制到src的rule目录下 </p><p>（3）将src/nacos/NacosConfig中的nacos连接Bean地址更改成nacos-server所在地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> ConfigSerevice <span class="hljs-title function_">nacosConfigService</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> ConfigFactory.createCOnfigService(<span class="hljs-string">&quot;localhost:8848&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）打开src/v2文件夹，找到FlowControllerV2中如下的两个属性，将其更改成nacos的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(&quot;flowRuleDefaultProvider&quot;)</span> <span class="hljs-comment">// -&gt; flowRuleNacosProvider</span><br><span class="hljs-keyword">private</span> DynamicRuleProvider&lt;List&lt;FlowRuleEntity&gt;&gt; ruleProvider;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(&quot;flowRuleDefaultPublisher&quot;)</span> <span class="hljs-comment">// -&gt; flowRuleNacosPublisher</span><br><span class="hljs-keyword">private</span> DynamicRulePublisher&lt;List&lt;FlowRuleEntity&gt;&gt; rulePublisher;<br></code></pre></td></tr></table></figure><p>（5）找到dashboard的前端显示页面，修改一个流控规则菜单作为测试</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>文件位置<br>webapp<span class="hljs-regexp">/resources/</span>app<span class="hljs-regexp">/scripts/</span>directices<span class="hljs-regexp">/sidebar/</span>sidebar.html<br></code></pre></td></tr></table></figure><p>（6）找到流控规则V1的注释内容，将其修改为nacos</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 将下面这段代码注释去掉 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">ui-sref-active</span>=<span class="hljs-string">&quot;active&quot;</span> <span class="hljs-attr">ng-if</span>=<span class="hljs-string">&quot;entry.appType==0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">ui-sref</span>=<span class="hljs-string">&quot;dashboard.flow(&#123;app: entry.app&#125;)&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;glyhicon glyhicon-filter&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>流控规则<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（7）启动nacos-server，重启sentinel dashboard并访问</p><p>（8）访问<a href="http://localhost:8081/user/hello">http://localhost:8081/user/hello</a> ，并在sentinel dashboard中添加流控规则nacos</p><p><img src="/image/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/5.png"></p><p>（9）查看nacos-server的配置管理，可以看到对应的流控规则</p><p>（10）分别在sentinel dashboard和nacos server进行修改配置，看是否能够保证数据一致性</p><h5 id="2-4-1-2-user"><a href="#2-4-1-2-user" class="headerlink" title="2.4.1.2 user"></a>2.4.1.2 user</h5><ul><li>方式1</li></ul><p>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）注册数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosDataSourceInitFunc</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitFunc</span> &#123;<br>    <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">remoteAddress</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;localhost&quot;</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">groupId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SENTINEL_GROUP&quot;</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">dataId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.jack.user.UserApplication-flow-rules&quot;</span>;<br>ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleDataSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosDataSource</span>&lt;&gt;(remoteAddress, groupId, dataId, source -&gt; JSON.parseObject(source, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;List&lt;FlowRule&gt;&gt;() &#123;&#125;));<br>FlowRuleManager.register2Property(flowRuleDataSource.getProperty());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）添加SPI配置</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.user</span><span class="hljs-selector-class">.initfuc</span><span class="hljs-selector-class">.FileDataSourceFunc</span><br>com<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.user</span><span class="hljs-selector-class">.initfuc</span>.NacosDataSourceInitFunc<br></code></pre></td></tr></table></figure><ul><li>方式2</li></ul><p>(1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）写配置：bootstrap.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">datasource:</span><br>        <span class="hljs-comment">#可以配置为任意名称</span><br>        <span class="hljs-attr">ds1:</span><br>          <span class="hljs-attr">nacos:</span><br>            <span class="hljs-attr">server-addr:</span> <span class="hljs-string">$&#123;spring.cloud.nacos.config.server-addr&#125;</span><br>            <span class="hljs-attr">dataId:</span> <span class="hljs-string">com.test.user.UserApplication-flow-rules</span><br>            <span class="hljs-attr">groupId:</span> <span class="hljs-string">SENTINEL_GROUP</span><br>            <span class="hljs-attr">data-type:</span> <span class="hljs-string">json</span><br>            <span class="hljs-comment">#RuleType</span><br>            <span class="hljs-attr">rule-type:</span> <span class="hljs-string">flow</span><br></code></pre></td></tr></table></figure><p>（3）注释掉之前的本地持久化和手动nacos配置</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-id">#com</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.user</span><span class="hljs-selector-class">.initfuc</span><span class="hljs-selector-class">.FileDataSourceInit</span><br><span class="hljs-selector-id">#com</span><span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.user</span><span class="hljs-selector-class">.initfuc</span>.NacosDataSourceInitFunc<br></code></pre></td></tr></table></figure><p>（4）重启user服务，并进行相应的测试</p><h4 id="2-4-2-源码分析"><a href="#2-4-2-源码分析" class="headerlink" title="2.4.2 源码分析"></a>2.4.2 源码分析</h4><p><img src="/image/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/sentinel-push%E6%A8%A1%E5%BC%8F%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99%E6%BA%90%E7%A0%81.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sentinel源码解析</title>
    <link href="/2023/03/27/spring%E6%A1%86%E6%9E%B6/springcloud/sentinel/sentinel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/03/27/spring%E6%A1%86%E6%9E%B6/springcloud/sentinel/sentinel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/springcloud/sentinel/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/sentinel%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>远程通信协议</title>
    <link href="/2023/03/23/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/03/23/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="1-HTTP请求流程"><a href="#1-HTTP请求流程" class="headerlink" title="1 HTTP请求流程"></a>1 HTTP请求流程</h2><p>在分布式架构中，有一个很重要的环节，就是分布式网络中的计算机节点彼此之间需要通信。这个通信的过程一定会涉及到通信协议相关的知识点。用浏览器访问各种网站，作为用户来说，只需要输入一个网址并且正确跳转就行。但是作为程序员，看到的可能就是这个响应背后的整体流程。所以通过一个http请求的整体流程来进行整理通信的知识。</p><h3 id="1-1-DNS服务-域名解析"><a href="#1-1-DNS服务-域名解析" class="headerlink" title="1.1 DNS服务(域名解析)"></a>1.1 DNS服务(域名解析)</h3><p>首先，访问一个域名，会经过DNS解析。DNS（Domain Name System），它和http协议一样是位于应用层的协议，主要提供域名到ip的解析服务。其实不用域名也可以访问目标主机的服务，但是ip本身不是那么容易记，所以使用域名进行替换使得用户更容易记住。</p><p>在很多大型网站，会引来CDN来加速静态内容的访问，这里简单介绍一下什么是CDN（Content Delivery Network），表示的是内容分发网络。CDN其实就是一种网络缓存技术，能够把一些相对稳定的资源放到距离最终用户较近的地方，一方面可以节省整个广域网的带宽消耗，另一方面可以提升用户的访问速度，改进用户体验。一般会把静态的文件（图片，脚本，静态页面）放到CDN中。如果引入CDN，解析的流程也会稍微复杂一点。</p><h3 id="1-2-HTTP协议通信原理"><a href="#1-2-HTTP协议通信原理" class="headerlink" title="1.2 HTTP协议通信原理"></a>1.2 HTTP协议通信原理</h3><p>说到通信，就得说起TCP和UDP这两种通信协议，以及建立连接得握手过程。而http协议的通信是基于tcp/ip协议之上的一个应用层协议，应用层协议除了http，还有ftp、dns、smtp、telnet等。涉及到网络协议，一定需要知道OSI七层网络模型和TCP/IP四层概念模型，</p><p>OSI七层网络模型包含：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p><p>tcp/ip四层概念模型包含：应用层、传输层、网络层、数据链路层。</p><p><img src="/image/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B.jpg"></p><p>当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层知道被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息）</p><p><img src="/image/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.jpg"></p><p><strong>客户端如何找到目标服务：</strong></p><p>​    在客户端发起请求的时候，会在数据链路层去组装目标机器的MAC地址，目标机器的MAC地址怎么得到？这里就涉及到一个ARP协议，这个协议简单来说就是已知目标机器的ip，需要获得目标机器得MAC地址。（发送一个广播消息，这个ip是谁的，请来认领。认领ip的机器会发送一个MAC地址的响应）。</p><p>​    有了这个目标MAC地址，数据包在链路上广播，MAC的网卡才能发现，这个包是给它的。MAC的网卡把包收进来，然后打开IP包，发现IP地址也是自己的，再打开TCP包，发现端口是自己，也就是80端口，而这个时候这台机器上有一个nginx是监听80端口。于是将请求提交给nginx，nginx返回一个网页。然后将网页需要发回请求的机器。然后层层封装，最后到MAC层。因为来的时候有源MAC地址，返回的时候，源MAC就变成了目标MAC，再返回给请求的机器。</p><p>​    为了避免每次都用ARP请求，机器本地也会进行ARP缓存。当然机器会不断地上线下线，IP也可能会变，所以ARP地MAC地址缓存过一段时间就会过期。</p><p><strong>接收到数据包以后地处理过程：</strong></p><p>​    当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上地报文首部。每层协议都要去检查报文首部中的协议标识，以确定接收数据的上层协议。</p><p><img src="/image/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.jpg"></p><p><strong>为什么有了MAC层还要走IP层？</strong></p><p>​    MAC地址是唯一的，那理论上，在任何两个设备之间，应该都可以通过mac地址发送数据，为什么还需要ip地址？</p><p>​    MAC地址就好像个人的身份证号，人的身份证号和人户口所在的城市，出生的日期有关，但是和人所在的位置没有关系，人是会移动的，知道一个人的身份证号，并不能找到它这个人，MAC地址类似，它是和设备的生产者，批次，日期之类的关联起来，知道一个设备的MAC，并不能在网络中将数据发送给它，除非它和发送方的在同一个网络内。</p><p>​    所以要实现机器之间的通信，还需要有ip地址的概念，ip地址表达的是当前机器在网络中的位置，类似于城市名+道路号+门牌号的概念。通过IP层的寻址，能知道按何种路径在全世界任意两台Internet上的机器间传输数据。</p><h3 id="1-3-分层负载"><a href="#1-3-分层负载" class="headerlink" title="1.3 分层负载"></a>1.3 分层负载</h3><h4 id="1-3-1-二层负载"><a href="#1-3-1-二层负载" class="headerlink" title="1.3.1 二层负载"></a>1.3.1 二层负载</h4><p>​    二层负载是针对MAC，负载均衡服务器对外依然提供一个VIP（虚IP），集群中不同的机器采用相同IP地址，但是机器的MAC地址不一样。当负载均衡服务器接收到请求之后，通过改写报文的目标MAC地址的方式将请求转发到目标机器实现负载均衡。二层负载均衡会通过一个虚拟MAC地址接收请求，然后再分配到真实的MAC地址。</p><h4 id="1-3-2-三层负载"><a href="#1-3-2-三层负载" class="headerlink" title="1.3.2 三层负载"></a>1.3.2 三层负载</h4><p>三层负载是针对IP，和二层负载均衡类似，负载均衡服务器对外依然提供一个VIP（虚IP），但是集群中不同的机器采用不同的IP地址。当负载均衡服务器接收到请求之后，根据不同的负载均衡算法，通过ip将请求转发至不同的真实服务器。三层负载均衡会通过一个IP地址接收请求，然后再分配到真实的IP地址。</p><h4 id="1-3-3-四层负载均衡"><a href="#1-3-3-四层负载均衡" class="headerlink" title="1.3.3 四层负载均衡"></a>1.3.3 四层负载均衡</h4><p>​    四层负载均衡工作在OSI模型的传输层，由于在传输层，只有TCP/UDP协议，这两种协议中除了包含源IP、目标IP以外，还包含源端口号及目的端口号。四层负载均衡服务器在接收到客户端请求后，以后通过修改数据包的地址信息（IP+端口号）将流量转发到应用服务器。四层通过虚拟IP+端口接收请求，然后再分配到真实的服务器。</p><h4 id="1-3-4-七层负载均衡"><a href="#1-3-4-七层负载均衡" class="headerlink" title="1.3.4 七层负载均衡"></a>1.3.4 七层负载均衡</h4><p>​    七层负载均衡工作在OSI模型的应用层，应用层协议较多，常用http、radius、dns等。七层负载就可以基于这些协议来负载。这些应用层协议中会包含很多有意义的内容。比如同一个Web服务器的负载均衡，除了根据IP加端口进行负载外，还可以根据七层的URL，浏览器类别来决定是否要进行负载均衡。七层通过虚拟的URL或主机名接收请求，然后再分配到真实的服务器。</p><h2 id="2-TCP-IP协议的深入分析"><a href="#2-TCP-IP协议的深入分析" class="headerlink" title="2 TCP/IP协议的深入分析"></a>2 TCP/IP协议的深入分析</h2><h3 id="2-1-TCP握手协议"><a href="#2-1-TCP握手协议" class="headerlink" title="2.1 TCP握手协议"></a>2.1 TCP握手协议</h3><p>TCP消息的可靠性首先来自于有效的连接建立，所以在数据进行传输前，需要通过三次握手建立一个连接，所谓的三次握手，就是在建立TCP链接时，需要客户端和服务端总共发送3个包来确认链接的建立，在socket编程中，这个过程由客户端执行connect来触发。</p><p><img src="/image/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg"></p><p>第一次握手（SYN=1，seq=x）客户端发送一个tcp的SYN标志位置1的包，指明客户端打算链接的服务器的端口，以及初始序号x，保存在包头的序列号（Sequence Number）字段里。发送完毕后，客户端进入SYN_SENT状态。</p><p>第二次握手（SYN=1，ACK=1，seq=y，ACKnum=x+1）服务器发会确认包（ACK）应答。即SYN标志位和ACK标志位均为1。服务器端选择自己ISN序列号，放到Seq域中，同时将确认序号（Acknowledgement Number）设置为客户的ISN加1，即X+1。发送完毕后，服务器端进入SYN_RCVD状态。</p><p>第三次握手（ACK=1，ACKnum=y+1）客户端再次发送确认包（ACK），SYN标志位为0，ACK标志位为1，并且把服务器发来ACK的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN发送完毕后，客户端进入EXTABLISHED状态，当服务器端接收到这个包时，也进入ESTABLISHED状态，TCP握手结束。</p><h3 id="2-2-SYN攻击"><a href="#2-2-SYN攻击" class="headerlink" title="2.2 SYN攻击"></a>2.2 SYN攻击</h3><p>在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP链接称为半连接（half-open connect），此时server处于SYN-RCVD状态，当收到ACK后，Server转入ESTABLEISED状态。SYN攻击就是Client在短时间内伪造大量不存在的ip地址，并向Server不断发送SYN包，server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击是一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server 上有大量半连接状态且源ip地址是随机的，则可以断定遭到SYN攻击了。</p><h3 id="2-3-TCP四次挥手协议"><a href="#2-3-TCP四次挥手协议" class="headerlink" title="2.3 TCP四次挥手协议"></a>2.3 TCP四次挥手协议</h3><p>四次挥手表示TCP断开连接的时候，需要客户端和服务端总共发送4个包以确认连接的断开；客户端或服务器均可主动发起挥手动作（因为tcp是一个全双工协议），在socket编程中，任何一方执行close()操作即可产生挥手操作。</p><p><img src="/image/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg"></p><p>单工：数据传输只支持数据在一个方向上传输。</p><p>半双工：数据传输允许数据在两个方向上传输，但是在某一时刻，只允许在一个方向上传输，实际上优点像切换方向的单工通信。</p><p>全双工：数据通信允许数据同时在两个方向上传输，因此全双工是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。</p><p>第一次挥手（FIN=1，seq=x）：假设客户端想要关闭连接，客户端发送一个FIN标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进入FIN_WAIT_1状态。</p><p>第二次挥手（ACK=1，ACKnum=x+1）：服务器端确认客户端的FIN包，发送一个确认包，表明自己接收到了客户端关闭连接的请求，但还没有准备号关闭连接。发送完毕后，服务器端进入CLOSE_WAIT状态，客户端接收到这个确认包之后，进入FIN_WAIT_2状态，等待服务器端关闭连接。</p><p>第三次挥手（FIN=1，seq=w）：服务器端准备好关闭连接时，向客户端发送关闭连接请求，FIN设置为1.发送完毕后，服务器端进入LAST_ACK状态，等待来自客户端的最后一个ACK。</p><p>第四次挥手（ACK=1，ACKnum=w+1）：客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入TIME_WAIT状态，等待可能出现的要求重传的Ack包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入CLOSED状态。客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segement Lifetime）之后，没有收到服务器端的ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入CLOSED状态。</p><p>假设Client端发起终端连接请求，也就是发送FIN报文，Server端接收到FIN报文后，意思是说“我Client端没有数据要发给你了“，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还准备好，请继续你等我的消息“，这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文，当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了“。Client收到FIN报文后，”就知道可以关闭连接了，但是它还是不相信网络，怕server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重发。“Server端收到ACK后，”就知道可以断开连接了“。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那Client端也可以正常关闭了。</p><h3 id="2-4-问题"><a href="#2-4-问题" class="headerlink" title="2.4 问题"></a>2.4 问题</h3><p>1、为什么连接时是三次握手，关闭的时候是四次挥手？</p><p>​    三次握手是因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭Socket（因为可能还有消息没处理完），所以只能先回复一个ACK报文，告诉Client端，“你发的FIN报文我收到了“。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步挥手。</p><p>​    2、为什么TIME_WAIT状态需要经过2MSL（最大报文段生存时间）才能返回到CLOSE状态？</p><p>​    虽然按道理，四个报文都发送完毕，可以进入CLOSE状态了，但是必须假想网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p><h2 id="3-TCP协议的通信过程"><a href="#3-TCP协议的通信过程" class="headerlink" title="3 TCP协议的通信过程"></a>3 TCP协议的通信过程</h2><p>首先，对于tcp通信来说，每个tcp socket的内核中都有一个发送缓冲区和一个接受缓冲区，tcp的全双工的工作模式及tcp的滑动窗口就是依赖于这两个独立的Buffer和该Buffer的填充状态。</p><p>接收缓冲区把数据缓存到内核，若应用进程一直没有调用Socket的read方法进行读取，那么该数据会一直被缓存在接收缓冲区内。不管进程是否读取Socket，对端发来的数据都会经过内核接收并缓存到socket的内核接收缓存区。</p><p>read所要做的工作，就是把内核接收缓冲区中的数据复制到应用层用户的Buffer中。进程调用Socket的send发送数据的时候，一般情况下是将数据从应用层用户的Buffer中复制到Socket的内核发送缓冲区，然后send就会在上层返沪。换句话说，send返回时。数据不一定会被发送到对端。</p><p><img src="/image/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/1.png"></p><p>前面提到，Socket的接收缓冲区被tcp用来缓存网络上收到的数据，一直保存到应用进程读走为止。如果应用进程一直没有读取，那么Buffer满了以后，出现的情况是：通知对端tcp协议中的窗口关闭，保证tcp接收缓冲区不会移除，保证了tcp是可靠传输的。如果对方无视窗口大小发出了超过窗口大小的数据，那么接收方会把这些数据丢弃。</p><p><a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html">https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html</a> </p><h2 id="4-IO阻塞"><a href="#4-IO阻塞" class="headerlink" title="4 IO阻塞"></a>4 IO阻塞</h2><h3 id="4-1-一个客户端对应一个线程"><a href="#4-1-一个客户端对应一个线程" class="headerlink" title="4.1 一个客户端对应一个线程"></a>4.1 一个客户端对应一个线程</h3><p>为每个客户端创建一个线程实际上会存在一些弊端，因为创建一个线程需要占用CPU的资源和内存资源。另外，随着线程数增加，系统资源将会称为瓶颈最终达到一个不可控的状态，所以还可以通过线程池来实现多个客户端请求的功能，因为线程池是可控的。</p><p><img src="/image/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/2.png"></p><h3 id="4-2-非阻塞模型"><a href="#4-2-非阻塞模型" class="headerlink" title="4.2 非阻塞模型"></a>4.2 非阻塞模型</h3><p>上面这种模型虽然优化了IO的处理方式，但是，不管是线程池还是单个线程，线程本身的处理个数是由限制的，对于操作系统来说，如果线程数太多会造成CPU上下文切换的开销。因此这种方式不能解决根本问题。所以在Java1.4之后，引入了NIO的功能，</p><h4 id="4-2-1-阻塞IO"><a href="#4-2-1-阻塞IO" class="headerlink" title="4.2.1 阻塞IO"></a>4.2.1 阻塞IO</h4><p>当客户端的数据从网卡缓冲区复制到内核缓冲区之前，服务端会一直阻塞。以socket接口为例，进程空间中调用recfrom，进程从调用recvfrom开始到它返回的整段时间内都是被阻塞的，因此被称为阻塞IO模型。</p><p><img src="/image/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3.png"></p><h4 id="4-2-2-非阻塞IO"><a href="#4-2-2-非阻塞IO" class="headerlink" title="4.2.2 非阻塞IO"></a>4.2.2 非阻塞IO</h4><p>非阻塞IO模型的原理很简单，就是进程空间调用recvfrom，如果这个时候内核缓冲区没有数据的话，就直接返回一个EWOULDBLOCK错误，然后应用程序通过不断轮询来检查这个状态，看内核是不是有数据过来。</p><p><img src="/image/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/4.png"></p><h4 id="4-2-3-IO复用模型"><a href="#4-2-3-IO复用模型" class="headerlink" title="4.2.3 IO复用模型"></a>4.2.3 IO复用模型</h4><p>前面讲的非阻塞仍然需要进程不断地轮询重试。能不能实现当数据可读了以后给程序一个通知？所以这里引入了一个IO多路复用模型，IO多路复用的本质是通过一种机制（系统内核缓冲IO数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应地读写操作。</p><p>​    【什么是fd：在linux中，内核吧所有的外部设备都当成是一个文件来操作，对一个文件的读写会调用内核提供的系统命令，返回一个fd（文件描述符），而对于一个socket的读写也会有相应的文件描述符，称为socketfd】</p><p>​    常见的IO多路复用方式有【select、poll、epoll】，都是Linux API提供的IO复用方式，那么接下来重点说一下select和epoll这两个模型</p><p>​    select：进程可以通过把一个或者多个fd传递给select系统调用，进程会阻塞在select操作上，这样select可以检测多个fd是否处于就绪状态。这个模式有两个缺点：</p><p>​    1、由于它能够同时监听多个文件描述符，假如说有1000个，这个时候如果其中一个fd处于就绪状态了，那么当前进程需要线性轮询所有的fd，也就是监听的fd越多，性能开销越大。</p><p>​    2、同时，select在单个进程中能打开的fd是有限制的，默认是1024，对于那些需要支持单机上万的tcp连接来说确实有点少。</p><p>​    epoll：linux还提供了epoll的系统调用，epoll是基于时间驱动方式来代替顺序扫描，因此性能相对来说更高，主要原理是，当被监听的fd中，有fd就绪时，会告知当前进程具体哪一个fd就绪，那么当前进程只需要去从指定的fd上读取数据即可。另外，epoll所能支持的fd上线是操作系统的最大文件句柄，这个数字要远远大于1024.</p><p>​    【由于epoll能够通过事件告知应用进程哪个fd是可读的，所以我们也称这种IO为异步非阻塞IO，当然它是伪异步的，因为它还需要去把数据从内核同步复制到用户空间中，真正的异步非阻塞，应该是数据已经完全准备好了，我只需要从用户空间读就行】</p><p><img src="/image/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E8%BF%9C%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/5.png"></p><h3 id="4-3-多路复用的好处"><a href="#4-3-多路复用的好处" class="headerlink" title="4.3 多路复用的好处"></a>4.3 多路复用的好处</h3><p>IO多路复用可以通过把多个IO的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。它的最大优势是系统开销小，并且不需要创建新的进程或者线程，降低了系统的资源开销。</p><h3 id="4-4-一台机器理论能支持的连接数"><a href="#4-4-一台机器理论能支持的连接数" class="headerlink" title="4.4 一台机器理论能支持的连接数"></a>4.4 一台机器理论能支持的连接数</h3><p>首先，在确定最大连接数之前，先了解一下系统如何标识一个tcp连接。系统用一个四元组来唯一标识要给tcp连接：（source_ip, source_port, destination_ip, destination_port）。即（源ip，源端口，目的ip，目的端口）四个元素的组合。只要四个元素的组合中有一个元素不一样，那就可以区别不同的连接。</p><p>​    比如：你的IP地址是11.1.2.3，在8080端口监听，那么当一个来自22.4.5.6，端口为5555的连接到达后，那么建立的这条连接的四元组为：（11.1.2.3，8080，22.4.5.6，5555）,这时，假设上面的那个用户（22.4.5.6）发来第二条连接请求，端口为6666，那么新连接的四元组为（11.1.2.3，8080，22.4.5.6，6666）。那么，你主机的8080端口建立了两条连接。</p><p>​    通常来说，服务端是固定一个监听端口，比如8080，等待客户端的连接请求。在不考虑地址重用的情况下，即使server端口有多个ip，但是本地监听的端口是独立了的。所以对于tcp连接的4元组中，如果destination_ip和destination_port不变。那么只有source_ip和source_port是可变的，因此最大的tcp连接数应该为客户端的ip数乘以客户端的端口数。在IPV4中，不考虑IP分类等因素，最大的ip数为2的32次方；客户端最大的端口数为2的16次方，也就是65536，也就是服务端单机最大的tcp连接数约为2的48次方。</p><p>​    当然，这只是一个理论值，以linux服务器为例，实际的连接数还取决于</p><p>​    1、内存大小（因为tcp连接都要占用一定的内存）</p><p>​    2、文件句柄限制，每一个tcp连接都需要占一个文件描述符，一旦这个文件描述符使用完了，新来的连接会返回一个“Can`t open so many files“的异常。如果大家知道对于操作系统最大可以打开的文件数限制，就知道怎么去调整这个限制</p><p>​    a）可以执行【ulimit -n】得到当前一个进程最大能打开1024个文件，所以你要采用此默认配置最多也就可以并发上千个tcp连接</p><p>​    b）可以通过【vim/etc/security/limits/conf】去修改系统最大文件打开数的限制</p><p>​    * soft nofile 2048</p><p>​    * hard nofile 2048</p><p>​    * 表示修改所有用户限制、soft/hard表示软限制还是硬限制，2048表示修改以后的值</p><p>​    c）可以通过【cat/proc/sys/fs/file-max】查看linux系统级最大打开文件数限制，表示当前这个服务器最多能同时打开多少个文件</p><p>​    当然，这块还有很多其他的优化的点</p><p>​    3、带宽资源的限制</p>]]></content>
    
    
    <categories>
      
      <category>网络通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>通信协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sentinel适配开源框架</title>
    <link href="/2023/03/21/spring%E6%A1%86%E6%9E%B6/springcloud/sentinel/sentinel%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    <url>/2023/03/21/spring%E6%A1%86%E6%9E%B6/springcloud/sentinel/sentinel%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>官网：<a href="https://sentinelguard.io/zh-cn/docs/open-source-framework-integrations.html">https://sentinelguard.io/zh-cn/docs/open-source-framework-integrations.html</a></p><h2 id="1-开源生态"><a href="#1-开源生态" class="headerlink" title="1 开源生态"></a>1 开源生态</h2><p><a href="https://github.com/alibaba/Sentinel/wiki/Roadmap">https://github.com/alibaba/Sentinel/wiki/Roadmap</a></p><p><img src="/image/springcloud/sentinel/%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/2.png"></p><h2 id="2-适配RestTemplate"><a href="#2-适配RestTemplate" class="headerlink" title="2 适配RestTemplate"></a>2 适配RestTemplate</h2><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel#resttemplate-%E6%94%AF%E6%8C%81">https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel#resttemplate-%E6%94%AF%E6%8C%81</a></p><p>（1）创建RestTemplate的Bean，并添加@SentinelRestTemplate注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@SentinelRestTemplate</span><br><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplateSentinel</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）开启Sentinel对RestTemplate的支持</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">resttemplate:</span><br>  <span class="hljs-attr">sentinel:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>（3）在UserController中定义RestTemplate访问的资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RestTemplate restTemplateSentinel;<br><br><span class="hljs-meta">@RequestMapping(&quot;/resttemplate-sentinel&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">restTemplateSentinel</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:9091/order/query&quot;</span>,String.class);<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）重启Spring Boot项目，访问：<a href="http://localhost:8081/flow/resttemplate-sentine">http://localhost:8081/flow/resttemplate-sentine</a></p><p>（4）在sentinel dashboard上设置流控规则</p><p><img src="/image/springcloud/sentinel/%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/1.png"></p><p>（5）访问：<a href="http://localhost:8081/user/resttemplate-sentinel%EF%BC%8C%E6%B5%8B%E8%AF%95restTemplate%E7%9A%84%E6%B5%81%E6%8E%A7%E6%95%88%E6%9E%9C">http://localhost:8081/user/resttemplate-sentinel，测试restTemplate的流控效果</a></p><p>（6）核心源码，使用拦截器。RestTemplate发起请求：SentinelProtectInterceptor#intercept</p><h2 id="3-适配OpenFeign"><a href="#3-适配OpenFeign" class="headerlink" title="3 适配OpenFeign"></a>3 适配OpenFeign</h2><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel#feign-%E6%94%AF%E6%8C%81">https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel#feign-%E6%94%AF%E6%8C%81</a></p><p>（1）引入starter-feign依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）开启Sentinel对OpenFeign的支持</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">sentinel:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>（4）定义OpenFeign接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderFeignClient</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/order/query&quot;)</span><br>    String <span class="hljs-title function_">query</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）在UserController中定义OpenFeign访问的资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> OrderFeignClient orderFeignClient;<br><br><span class="hljs-meta">@RequestMapping(&quot;/openfeign-sentinel&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">openFeignSentinel</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.orderFeignClient.query();<br>&#125;<br></code></pre></td></tr></table></figure><p>（6）重启Spring Boot项目，访问：<a href="http://localhost:8081/user/openfeign-sentinel">http://localhost:8081/user/openfeign-sentinel</a></p><p>（7）在sentinel dashboard上设置流控规则</p><p><img src="/image/springcloud/sentinel/%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/3.png"></p><p>（8）访问：<a href="http://localhost:8081/user/openfeign-sentinel%EF%BC%8C%E6%B5%8B%E8%AF%95OpenFeign%E7%9A%84%E6%B5%81%E6%8E%A7%E6%95%88%E6%9E%9C">http://localhost:8081/user/openfeign-sentinel，测试OpenFeign的流控效果</a></p><p>（9）处理异常，定义异常处理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderFeignClientFallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderFeignClient</span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">query</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;流控或降级了...&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在OrderFeignClient的注解@FeignClient上添加属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;order&quot;,fallback = OrderFeignClientFallback.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderFeignClient</span> &#123;<br><span class="hljs-meta">@RequestMapping(&quot;/order/query&quot;)</span><br>String <span class="hljs-title function_">query</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（10）核心源码，代理类： SentinelInvocationHandler#invoke</p><h2 id="4-适配网关Gateway"><a href="#4-适配网关Gateway" class="headerlink" title="4 适配网关Gateway"></a>4 适配网关Gateway</h2><p><a href="https://github.com/alibaba/Sentinel/wiki/%E7%BD%91%E5%85%B3%E9%99%90%E6%B5%81">https://github.com/alibaba/Sentinel/wiki/%E7%BD%91%E5%85%B3%E9%99%90%E6%B5%81</a></p><p>（1）重新编辑sentinel dashboard启动命令，使其支持网关配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-Dcsp.sentinel.app.<span class="hljs-attribute">type</span>=1 -Dcsp.sentinel.dashboard.<span class="hljs-attribute">server</span>=localhost:8080 -Dproject.<span class="hljs-attribute">name</span>=sentinel-dashboard<br></code></pre></td></tr></table></figure><p><img src="/image/springcloud/sentinel/%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/4.png"></p><p>（2）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--sentinel starter--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--sentinel和gateway的整合包--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-sentinel-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（3）写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8090</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>       <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-comment"># 自定义路由规则</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-comment"># 路由匹配</span><br>        <span class="hljs-comment"># localhost:8090/jack-&gt;localhost:9091[9092/9093]</span><br>        <span class="hljs-comment"># localhost:8090/jack/order/query-&gt;localhost:9091[9092/9093]/order/query</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">jack_path_route</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://order</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/jack/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">reactor.netty:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><p>（4）修改order服务，增加一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;username&quot;,required = false)</span> String username)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;hello: &quot;</span>+username);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello: &quot;</span>+username;<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）重启服务</p><p><img src="/image/springcloud/sentinel/%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/5.png"></p><p>（6）route id微服务级别</p><p>就是相当于对jack_path_route这个route id对应的微服务进行限流，不管访问lb://order的哪个资 源，都会使用该限流规则</p><p><img src="/image/springcloud/sentinel/%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/6.png"></p><p>（7）API级别</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">精准匹配：<br>表示会对<span class="hljs-regexp">/jack/</span>order/query这个指定的路径生效<br></code></pre></td></tr></table></figure><p><img src="/image/springcloud/sentinel/%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/7.png"></p><p><img src="/image/springcloud/sentinel/%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/8.png"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">前缀匹配<br></code></pre></td></tr></table></figure><p><img src="/image/springcloud/sentinel/%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/9.png"></p><p>（8）URL参数：表示访问的url中必须有username才会生效</p><p><img src="/image/springcloud/sentinel/%E9%80%82%E9%85%8D%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/10.png"></p><p>（9）自定义异常消息：使用yaml文件配置的方式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span><br>      <span class="hljs-attr">scg:</span><br>        <span class="hljs-attr">fallback:</span><br>          <span class="hljs-attr">mode:</span> <span class="hljs-string">response</span><br>          <span class="hljs-attr">response-status:</span> <span class="hljs-number">200</span><br>          <span class="hljs-attr">response-body:</span> <span class="hljs-string">&#x27;&#123;&quot;code&quot;:200,&quot;msg&quot;:&quot;请求太多，一会再试试.&quot;&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="5-集群限流"><a href="#5-集群限流" class="headerlink" title="5 集群限流"></a>5 集群限流</h2><p><a href="https://sentinelguard.io/zh-cn/docs/cluster-flow-control.html">https://sentinelguard.io/zh-cn/docs/cluster-flow-control.html</a></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sentinel规则详解</title>
    <link href="/2023/03/20/spring%E6%A1%86%E6%9E%B6/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/03/20/spring%E6%A1%86%E6%9E%B6/springcloud/sentinel/sentinel%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>面向分布式、多语言异构化服务架构的流量治理组件</p><h2 id="1-Sentinel入门小结"><a href="#1-Sentinel入门小结" class="headerlink" title="1 Sentinel入门小结"></a>1 Sentinel入门小结</h2><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/sentinel%E5%88%9D%E8%AF%86.jpg"></p><h2 id="2-实时监控"><a href="#2-实时监控" class="headerlink" title="2 实时监控"></a>2 实时监控</h2><p>实时监控仅存储 5 分钟以内的数据，如果需要持久化，需要通过调用实时监控接口来定制。 </p><p>注意：请确保 Sentinel 控制台所在的机器时间与自己应用的机器时间保持一致，否则会导致拉不到实时的监控数据。</p><h2 id="3-簇点链路"><a href="#3-簇点链路" class="headerlink" title="3 簇点链路"></a>3 簇点链路</h2><p>簇点链路（单机调用链路）页面实时的去拉取指定客户端资源的运行情况。它一共提供两种展示模式：一种用树状结构展示资源的调用链路，另外一种则不区分调用链路展示资源的运行情况。 </p><p>注意：簇点监控是内存态的信息，它仅展示启动后调用过的资源</p><h2 id="4-流控规则"><a href="#4-流控规则" class="headerlink" title="4 流控规则"></a>4 流控规则</h2><p>资源名：相当于代码中的rule.setResource(“/user/hello”)-&gt;这个名称需要与Spring Web MVC端点的名称一致，只有这样限流时才能匹配得上</p><p>针对来源：可以根据不同的来源对/user/hello接口进行限流，比如针对来源a设置/user/hello的QPS为500，针对来源b设置/user/hello的QPS为1000 </p><p>阈值类型：QPS or 并发线程数</p><p>单机阈值：比如设置阈值类型为QPS，单机阈值为2，则表示该资源/user/hello最大能接受每秒2个查询请求 </p><p>是否集群：暂时先不关注</p><p>流控模式：直接、关联和链路 </p><p>流控效果：快速失败、Warm Up和排队等待</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/1.png"></p><h3 id="4-1-流控模式之直接"><a href="#4-1-流控模式之直接" class="headerlink" title="4.1 流控模式之直接"></a>4.1 流控模式之直接</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">资源名：<span class="hljs-regexp">/user/</span>hello<br>针对来源：default<br>阈值类型：QPS<br>单机阈值：<span class="hljs-number">2</span><br>是否集群：否<br>流控模式：直接 <span class="hljs-comment"># 表示对当前资源进行QPS为2的限流</span><br>流控效果：快速失败 <span class="hljs-comment"># 如果达到QPS阈值，则直接抛出BlockingException异常</span><br></code></pre></td></tr></table></figure><h3 id="4-2-流控模式之关联"><a href="#4-2-流控模式之关联" class="headerlink" title="4.2 流控模式之关联"></a>4.2 流控模式之关联</h3><p>（1）在UserController中添加write和read两个api接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/write&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">write</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;write ...&quot;</span>;<br>&#125;<br><span class="hljs-meta">@RequestMapping(&quot;/read&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">read</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;read ...&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）重启Spring Boot项目，分别访问write和read接口，观察sentinel dashboard的展示</p><p>（3）理解关联模式业务场景：比如在高并发的场景下，如果修改用户信息的请求达到一定的阈值，则对读取用户的接口进行限流，相当于保护了修改用户的接口</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/2.png"></p><p>（4）写一段代码访问write接口，使其QPS阈值超过2，然后访问read接口，看是否有限流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteQPS</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">RestTemplate</span> <span class="hljs-variable">restTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8081/user/write&quot;</span>, String.class);<br>            System.out.printLn(result);<br>            Thread.sleep(<span class="hljs-number">300</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）关联模式的使用条件 a. 两个资源具有竞争关系 b. 一个资源的优先级高，另外一个资源的优先级低</p><h3 id="4-3-流控模式之链路"><a href="#4-3-流控模式之链路" class="headerlink" title="4.3 流控模式之链路"></a>4.3 流控模式之链路</h3><p>（1）创建OrderService，其中有一个query方法，并使用@SentinelResource注解保护起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span>&#123;<br>    <span class="hljs-meta">@SentinelReesource(value = &quot;orderQuery&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">query</span><span class="hljs-params">()</span>&#123;<br>        System.out.printLn(<span class="hljs-string">&quot;query orders....&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;query orders....&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）创建OrderController，其实有两个接口，一个query一个update，并且这两个接口都需要调用 OrderService#query</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span>&#123;<br>    <span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> OrderService orderService;<br>    <br><span class="hljs-meta">@RequestMapping(&quot;/query&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">query</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;query: &quot;</span>+<span class="hljs-built_in">this</span>.orderService.query();<br>&#125;<br><span class="hljs-meta">@RequestMapping(&quot;/update&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;do sth.&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;update: &quot;</span>+<span class="hljs-built_in">this</span>.orderService.query();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）重启Spring Boot项目，分别访问<a href="http://localhost:8081/order/query%E5%92%8Chttp://localhost:8081/ord">http://localhost:8081/order/query和http://localhost:8081/ord</a> er/update，观察sentinel dashboard，发现update簇点链路下并没有显示orderQuery，这个问题先不管，直接进行配置 </p><p>（4）链路模式</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/3.png"></p><p>（5）配置好了之后，快速访问<a href="http://localhost:8081/order/query%E5%8F%91%E7%8E%B0%E6%98%AF%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%EF%BC%8C%E5%8E%9F%E5%9B%A0%E8%B7%9Fsentinel%E7%9A%84">http://localhost:8081/order/query发现是不生效的，原因跟sentinel的</a> 版本有关，具体可以参考<a href="https://github.com/alibaba/Sentinel/issues/1213%E8%BF%9B%E8%A1%8C%E8%A7%A3%E5%86%B3">https://github.com/alibaba/Sentinel/issues/1213进行解决</a></p><p>（6）如何解决？</p><p>添加sentinel-web-servlet依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-web-servlet<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>设置sentinel.filter.enable为false</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span><br>      <span class="hljs-attr">filter:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>新增Filter配置类，开放全部链路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterCOnfiguration</span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title function_">registrationBean</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">FilterRegistrationBean</span> <span class="hljs-variable">registrationBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterRegistrationBean</span>();<br>        registrationBean.setFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonFilter</span>());<br>        registrationBean.addUrlPatterns(<span class="hljs-string">&quot;/*&quot;</span>);<br>        registrationBean.addInitParameter(CommonFilter.WEB_CONTEXT_UNIFY, <span class="hljs-string">&quot;false&quot;</span>);<br>        registrationBean.setName(<span class="hljs-string">&quot;sentinelFilter&quot;</span>);<br>        <span class="hljs-keyword">return</span> registrationBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启Spring Boot项目，按照上述步骤进行重新测试</p><p>（7）流控异常如何处理？其实还是回到了@SentinelResource流控异常的处理</p><p>定义一个SentinelResource流控异常处理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SentinelResourceFlowExceptionHandler</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">handleBlock</span><span class="hljs-params">(BlockException e)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;流控异常: &quot;</span>+e);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;QPS超过阈值，流控了.&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改orderService#query的异常处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br><span class="hljs-meta">@SentinelResource(value = &quot;orderQuery&quot;,blockHandler = &quot;handleBlock&quot;,blockHandlerClass = SentinelResourceFlowExceptionHandler.class)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">query</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;query orders...&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;query orders...&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-流控效果"><a href="#5-流控效果" class="headerlink" title="5 流控效果"></a>5 流控效果</h2><h3 id="5-1-流控效果之快速失败"><a href="#5-1-流控效果之快速失败" class="headerlink" title="5.1 流控效果之快速失败"></a>5.1 流控效果之快速失败</h3><p>抛出异常</p><h3 id="5-2-流控效果之Warm-up"><a href="#5-2-流控效果之Warm-up" class="headerlink" title="5.2 流控效果之Warm up"></a>5.2 流控效果之Warm up</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">冷启动<br>基于令牌桶算法实现<br>适用于服务器刚启动或秒杀的场景<br></code></pre></td></tr></table></figure><p>（1）令牌桶算法</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95.jpg"></p><p>（2）配置</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/4.png"></p><p>（3）jmeter配置</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/5.png"></p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/6.png"></p><h3 id="5-3-流控效果之排队等待"><a href="#5-3-流控效果之排队等待" class="headerlink" title="5.3 流控效果之排队等待"></a>5.3 流控效果之排队等待</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">基于漏桶算法实现<br>可以用作流量整形：对于突发流量被整形以后能提供一个稳定的流量<br></code></pre></td></tr></table></figure><p>（1）漏桶算法</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95.jpg"></p><p>（2）配置</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/7.png"></p><p>（3）代码与图解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-type">RestTemplate</span> <span class="hljs-variable">restTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8081/user/hello&quot;</span>, String.class);<br>System.out.println(result);<br>Thread.sleep(<span class="hljs-number">500</span>);<br>System.out.println(<span class="hljs-string">&quot;--------------&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/8.png"></p><p>（4）增加排队等待超时时长，比如将300ms修改成600ms，再次运行代码，发现调用正常</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/9.png"></p><h2 id="6-熔断规则"><a href="#6-熔断规则" class="headerlink" title="6 熔断规则"></a>6 熔断规则</h2><h3 id="6-1-慢调用比例"><a href="#6-1-慢调用比例" class="headerlink" title="6.1 慢调用比例"></a>6.1 慢调用比例</h3><p>（1）定义一个DegradeController类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/degrade&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DegradeController</span> &#123;<br><span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>Thread.sleep(<span class="hljs-number">500</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello sentinel degrade.&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）重启Spring Boot项目，访问<a href="http://localhost:8081/degrade/hello">http://localhost:8081/degrade/hello</a> </p><p>（3）查看sentinel dashboard，可以看到该资源 </p><p>（4）配置/degrade/hello的熔断规则</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">理解慢调用比例<br>在1s秒内，最少要有10个请求，如果有10*0.1=1个请求的请求响应时间超过100ms，断路器则从<span class="hljs-keyword">Closed</span>变<br>成<span class="hljs-keyword">Open</span>状态<br>10s之后，断路器从<span class="hljs-keyword">Open</span>变成Half-<span class="hljs-keyword">Open</span>状态，会放一个请求尝试调用一下<br>如果这个请求成功响应时间&lt;100ms，则断路器从Half-<span class="hljs-keyword">Open</span>变成<span class="hljs-keyword">Closed</span><br>如果这个请求成功响应时间&gt;100ms，则断路器从Half-<span class="hljs-keyword">Open</span>变成<span class="hljs-keyword">Open</span><br></code></pre></td></tr></table></figure><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/10.png"></p><p>（5）使用jmeter进行测试</p><h3 id="6-2-异常比例"><a href="#6-2-异常比例" class="headerlink" title="6.2 异常比例"></a>6.2 异常比例</h3><p>理解异常比例：在1s之内，请求数量大于10，并且至少有1次请求有异常，接下来10s内会被熔断，10s之后，会尝试放 一个请求，若请求没有异常则断路器状态关闭，若请求有异常则断路器状态打开</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/11.png"></p><h3 id="6-3-异常数"><a href="#6-3-异常数" class="headerlink" title="6.3 异常数"></a>6.3 异常数</h3><p>理解异常数： 在1s之内，请求数量大于10，并且至少有1次请求有异常，接下来10s内会被熔断，10s之后，会尝试放 一个请求，若请求没有异常则断路器状态关闭，若请求有异常则断路器状态打开</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/12.png"></p><h3 id="6-4-热点规则"><a href="#6-4-热点规则" class="headerlink" title="6.4 热点规则"></a>6.4 热点规则</h3><p>（1）在FlowController中定义接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/say-hello&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;name&quot;,required = false)</span> String name,</span><br><span class="hljs-params">   <span class="hljs-meta">@RequestParam(value = &quot;age&quot;,required = false)</span> Integer age)</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;say hello : &quot;</span>+name+<span class="hljs-string">&quot; age: &quot;</span>+age;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）访问<a href="http://localhost:8081/flow/say-hello?name=Jack&amp;age=17%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AE%E7%83%AD%E7%82%B9%E8%A7%84%E5%88%99">http://localhost:8081/flow/say-hello?name=Jack&amp;age=17，并设置热点规则</a></p><p>表示针对say-hello接口的第0个参数进行QPS为1的限流</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/13.png"></p><p>（3）访问：<a href="http://localhost:8081/degrade/say-hello?name=Jack%EF%BC%8C%E5%8F%91%E7%8E%B0%E6%97%A0%E6%95%88">http://localhost:8081/degrade/say-hello?name=Jack，发现无效</a></p><p>（4）使用@SentinelResource注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/say-hello&quot;)</span><br><span class="hljs-meta">@SentinelResource(&quot;hot&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;name&quot;,required = false)</span> String name,</span><br><span class="hljs-params">   <span class="hljs-meta">@RequestParam(value = &quot;age&quot;,required = false)</span> Integer age)</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;say hello : &quot;</span>+name+<span class="hljs-string">&quot; age: &quot;</span>+age;<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）访问并设置热点规则</p><p><img src="/image/springcloud/sentinel/%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3/14.png"></p><p>（6）分别访问如下接口进行测试</p><p><a href="http://localhost:8081/degrade/say-hello?name=Jack">http://localhost:8081/degrade/say-hello?name=Jack</a> </p><p><a href="http://localhost:8081/degrade/say-hello?age=17">http://localhost:8081/degrade/say-hello?age=17</a> </p><p><a href="http://localhost:8081/degrade/say-hello?name=Jack&amp;age=17">http://localhost:8081/degrade/say-hello?name=Jack&amp;age=17</a></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>序列化与反序列化</title>
    <link href="/2023/03/18/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2023/03/18/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Java领域的对象如何传输"><a href="#1-Java领域的对象如何传输" class="headerlink" title="1 Java领域的对象如何传输"></a>1 Java领域的对象如何传输</h2><h3 id="1-1-基于socket进行对象传输"><a href="#1-1-基于socket进行对象传输" class="headerlink" title="1.1 基于socket进行对象传输"></a>1.1 基于socket进行对象传输</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//服务端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        serverSocket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(socket.getInputStream());<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) objectInputStream.readObject();<br>        System.out.printLn(user);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span>(in != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                in.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(serverSocket != <span class="hljs-literal">null</span>) &#123;<br>            serverSocket.close();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        out = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(socket.getOutputStream());<br>        out.writeObject(user);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span>(out != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                out.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(socket != <span class="hljs-literal">null</span>) &#123;<br>            socket.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：这段代码运行后，会报错:</p><p><img src="/image/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/1.png"></p><p>对User对象实现一个Serializable接口，再次运行就可以看到对象能够正常传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-序列化的意义"><a href="#1-2-序列化的意义" class="headerlink" title="1.2 序列化的意义"></a>1.2 序列化的意义</h3><p>发现对User这个类增加一个Serializable，就可以解决Java对象的网络传输问题。这就是序列化。</p><p>Java平台允许在内存中创建可复用的java对象，但一般情况下，只有当JVM出于运行时，这些对象才可能存在，即这些对象的生命周期不会比JVM的生命周期长。但在现实应用中，就可能要求在JVM停止运行后能够保存（持久化）指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够实现该功能。</p><p>简单来说：序列化是把对象的状态信息转化为可存储或传输的形式过程，也就是把对象转化为字节序列的过程称为对象的序列化。反序列化是序列化的逆向过程，把字节数组反序列化为对象，把字节序列恢复为对象的过程称为对象的反序列化。</p><h2 id="2-序列化的高阶认识"><a href="#2-序列化的高阶认识" class="headerlink" title="2 序列化的高阶认识"></a>2 序列化的高阶认识</h2><h3 id="2-1-简单认识以下java原生序列化"><a href="#2-1-简单认识以下java原生序列化" class="headerlink" title="2.1 简单认识以下java原生序列化"></a>2.1 简单认识以下java原生序列化</h3><p>前面的代码中演示了，如何通过JDK提供了java对象的序列化方式实现对象序列化传输，主要通过输出流java.io.ObjectOutputStream和对象输入流java.io.ObjectInputStream来实现。</p><p>​    OutputStream：表示对象输出流，它的writeObect(Object obj)方法可以对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</p><p>​    InputStream：表示对象输入流，它的readObject()方法从输入流中读取字节序列，再把他们反序列化为一个对象，并将其返回。</p><p>​    注意，被序列化的对象需要实现java.io.Serializable接口</p><h3 id="2-2-序列化的高阶认识"><a href="#2-2-序列化的高阶认识" class="headerlink" title="2.2 序列化的高阶认识"></a>2.2 序列化的高阶认识</h3><p><strong>serialVersionUID的作用</strong>，在IDEA中通过如下设置可以生成serializeid，字面上的意思是序列化的版本号，凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量。</p><p>java的序列化机制是通过判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是InvalidCastException。</p><p>从结果可以看出，文件流的class和classpath中的class，也就是修改过后的class，不兼容了，出于安全机制考虑，程序抛出了错误，并且拒绝载入。从错误结果来看，如果没有为指定的class配置serialVersionUID，那么java编译器会自动给这个class进行一个摘要算法，类似于指纹算法，只要这个文件有任何改动，得到的UID就会截然不同的，可以保证在这么多类中，这个编号是唯一的。所以，由于没有显示指定serialVersionUID，编译器又生成了一个UID，当然和前面保存在文件中的不一样了，于是出现了2个序列化版本号不一致的错误。因此，只要指定了serialVersionUID，就可以在序列化后，去添加一个字段，或者方法，而不会影响到后期的还原，还原后的对象照样可以使用，而且还多了方法或者属性可以用。</p><p>​    serialVersionUID有两种显示的生成方式：</p><p>​    1、是默认的1L，比如private static final long serialVersionUID = 1L</p><p>​    2、是根据类名，接口名，成员方法及属性等来生成要给64位的哈希字段</p><p>​    当实现java.io.Serializable接口的类没有显示的定义一个serialVersionUID变量的时候，Java序列化机制会根据编译的class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，如果Class文件（类名，方法名等）没有发生变化（增加空格，换行，增加注释等），就算再编译多次，serialVersionUID也不会变化的。</p><h3 id="2-3-Transient关键字"><a href="#2-3-Transient关键字" class="headerlink" title="2.3 Transient关键字"></a>2.3 Transient关键字</h3><p>transient关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列后，transient变量的值被设为初始值，如int型的是0，对象型的是null。</p><p>虽然name被transient修饰，但是通过写的这两个方法依然能够使得name字段正确被序列化和反序列化。</p><p>writeObject和readObject是两个私有的方法，他们是什么时候被调用的呢？从运行结果来看，它确实被调用。而且他们并不存在于java.lang.Object，也没有再Serializable中去声明。唯一的猜想应该还是和ObjectInputStream和ObjectOutputStream有关系，所以基于这个入口去看看在哪个地方有调用。从源码层面来分析可以看到，readObject是通过反射来调用的。其实可以在很多地方看到readObject和writeObject的使用，比如HashMap。</p><h3 id="2-4-java序列化的一些简单总结"><a href="#2-4-java序列化的一些简单总结" class="headerlink" title="2.4 java序列化的一些简单总结"></a>2.4 java序列化的一些简单总结</h3><p>​    1、java序列化只是针对对象的状态进行保存，至于对象中的方法，序列化不关心</p><p>​    2、当一个父类实现了序列化，那么子类会自动实现序列化，不需要显示实现序列化接口</p><p>​    3、当一个对象的实例变量引用了其他对象，序列化这个对象的时候会自动把引用的对象也进行序列化（实现深度克隆）</p><p>​    4、当某个字段被声明位transient后，默认的序列化机制会忽略这个字段</p><p>​    5、被声明为transient的字段，如果需要序列化，可以添加两个私有方法：writeObject和readObject</p><h2 id="3-分布式架构下常见的序列化技术"><a href="#3-分布式架构下常见的序列化技术" class="headerlink" title="3 分布式架构下常见的序列化技术"></a>3 分布式架构下常见的序列化技术</h2><h3 id="3-1-了解序列化的发展"><a href="#3-1-了解序列化的发展" class="headerlink" title="3.1 了解序列化的发展"></a>3.1 了解序列化的发展</h3><p>随着分布式架构、微服务架构的普及。服务与服务之间的通信成了最基本的需求。这个时候，不仅需要考虑通信的性能，也需要考虑到语言多元化的问题。所以，对于序列化来说如何去提升序列化性能以及解决跨语言问题，就成了一个重点考虑的问题。</p><p>​    由于java本身提供的序列化机制存在两个问题：</p><p>​    1、序列化的数据比较大，传输效率低</p><p>​    2、其他语言无法识别和对接</p><p>以致于在后来的很长一段时间，基于XML格式编码的对象序列化机制成为了主流，一方面解决了多语言兼容问题，另一方面比二进制的序列化方式更容易理解。以至于基于XML的SOAP协议及对应的WebService框架在很长一段时间内成为各个主流开发语言的必备的技术。</p><p>再到后来，基于json的简单文本格式编码的HTTP REST接口又基本上取代了复杂的Web Servcice接口，成为分布式架构中远程通信的首要选择。但是json序列化存储占用的空间大，性能低等问题，同时移动客户端应用需要更高效的传输数据来提升用户体验。在这种情况下与语言无关并且高效的二进制编码协议就成为了大家追求的热点技术之一，首先诞生的一个开源的二进制序列化框架-MessagePack。它比google的Prorocol Buffers出现的还要早。</p><h3 id="3-2-简单了解各种序列化技术"><a href="#3-2-简单了解各种序列化技术" class="headerlink" title="3.2 简单了解各种序列化技术"></a>3.2 简单了解各种序列化技术</h3><h4 id="3-2-1-Xml序列化框架介绍"><a href="#3-2-1-Xml序列化框架介绍" class="headerlink" title="3.2.1 Xml序列化框架介绍"></a>3.2.1 Xml序列化框架介绍</h4><p>xml序列化在于可读性好，方便阅读和调试。但是序列化以后的字节码文件比较大，而且效率不高，适用于对性能不高，而且QPS较低的企业级内部系统之间的数据交换的场景，同时XML又具有语言无关性，所以还可以用于异构系统之间的数据交换和协议。比如熟知的webservice，就是采用xml格式对数据进行序列化的。xml序列化/反序列化的实现方式有很多，熟知的方式有Xstream和java自带的xml序列化和反序列化两种。</p><h4 id="3-2-2-JSON序列化框架"><a href="#3-2-2-JSON序列化框架" class="headerlink" title="3.2.2 JSON序列化框架"></a>3.2.2 JSON序列化框架</h4><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，相对于XML来说，json的字节流更小，而且可读性也非常好，现在json数据格式在企业运用是最普遍的，json序列化常用的开源工具有很多：</p><p>​    1、Jackson <a href="https://github.com/FasterXML/jackson">https://github.com/FasterXML/jackson</a></p><p>​    2、阿里开源的fastJSON <a href="https://github.com/alibaba/fastjson">https://github.com/alibaba/fastjson</a></p><p>​    3、Google的GSON <a href="https://github.com/google/gson">https://github.com/google/gson</a></p><p>这几种json序列化工具中，Jackson和FastJson要比GSON的性能要好，但是jackson、GSON的稳定性要比fastjson好。而fastjson的优势在于提供的api非常容易使用。</p><h4 id="3-2-3-Hessian序列化框架"><a href="#3-2-3-Hessian序列化框架" class="headerlink" title="3.2.3 Hessian序列化框架"></a>3.2.3 Hessian序列化框架</h4><p>Hessian是一个支持跨语言传输的二进制序列化协议，相对于java默认的序列化机制来说，Hessian具有更好的性能和易用性，而且支持多种不同的语言，实际上Dubbo采用的就是Hessian序列化来实现，只不过Dubbo对Hessian进行了重构，性能更高。</p><h4 id="3-2-4-Avro序列化"><a href="#3-2-4-Avro序列化" class="headerlink" title="3.2.4 Avro序列化"></a>3.2.4 Avro序列化</h4><p>Avro是一个数据序列化系统，设计用于支持大批量数据交换的应用。它的主要特点有：支持二进制序列化方式，可以便捷，快速地处理大量数据；动态语言友好，Avro提供地机制使得动态语言可以方便地处理Avro数据。</p><h4 id="3-2-5-kyro序列化框架"><a href="#3-2-5-kyro序列化框架" class="headerlink" title="3.2.5 kyro序列化框架"></a>3.2.5 kyro序列化框架</h4><p>Kyro是一种非常成熟地序列化实现，已经在Hive，Storm中使用的比较广泛，不过它不能跨语言，目前dubbo已经在2.6版本中支持kyro的序列化机制。它的性能要优于之前的hessian2</p><h4 id="3-2-6-Protobuf序列化框架"><a href="#3-2-6-Protobuf序列化框架" class="headerlink" title="3.2.6 Protobuf序列化框架"></a>3.2.6 Protobuf序列化框架</h4><p>Protobuf是Google的一种数据交换格式，它独立于语言，独立于平台。Google提供了多种语言来实现，比如java，C，Go，Python，每一种实现都包含了相应语言的编译器和库文件，Protobuf是一个纯粹的表示层协议，可以和各种传输层协议一起使用。</p><p>Protobuf使用比较广泛，主要是空间开销小和性能比较好，非常适合用于公司内部对性能要求高的RPC调用。另外由于解析性能比较高，序列化以后数据量相对较少，所以也可以应用在对象的持久化场景中。但是要使用Protobuf会相对来说麻烦些，因为他有自己的语法，有自己的编译器，如果需要用到的话必须要投入成本在这个技术的学习中。Protobuf有个缺点就是要传输的每一个类的结构都要生成相应的proto文件，如果某个类发生修改，还得重新生成类对应的proto文件。</p><h2 id="4-序列化技术的选型"><a href="#4-序列化技术的选型" class="headerlink" title="4 序列化技术的选型"></a>4 序列化技术的选型</h2><h3 id="4-1-技术层面"><a href="#4-1-技术层面" class="headerlink" title="4.1 技术层面"></a>4.1 技术层面</h3><p>​    1、序列化空间开销，也就是序列化产生的结果大小，这个影响到传输的性能</p><p>​    2、序列化过程中消耗的时长，序列化消耗时间过长影响到业务的响应时间</p><p>​    3、序列化协议是否支持跨平台，跨语言。因为现在的架构更加灵活，如果存在异构系统通信需求，那么这个是必须要考虑的。</p><p>​    4、可扩展性/兼容性，在实际业务开发中，系统往往需要随着需求的快速迭代来实现快速更新，这就要求采用的序列化协议基于良好的可扩展性/兼容性，比如在现有的序列化数据结构中新增一个业务字段，不会影响到现有的服务</p><p>​    5、技术的流行程度，越流行的技术意味着使用的公司多，那么很多坑都已经淌过并且得到了解决，技术解决方案也相对成熟</p><p>​    6、学习难度和易用性</p><h3 id="4-2-选型建议"><a href="#4-2-选型建议" class="headerlink" title="4.2 选型建议"></a>4.2 选型建议</h3><p>​    1、对性能要求不高的场景，可以采用基于XML的SOAP协议</p><p>​    2、对性能和间接性有比较高要求的场景，那么Hessian，Protobuf，Thrift，Avro都可以</p><p>​    3、基于前后端分离，或者独立的对外的api服务，选用json是比较好的，对于调试，可读性都很不错</p><p>​    4、Avro设计理念偏于动态类型语言，那么这类的场景使用Avro是可以的</p><p>​    这个地址有针对不同系列化技术进行性能比较： <a href="https://github.com/eishay/jvm-serializers/wiki">https://github.com/eishay/jvm-serializers/wiki</a></p>]]></content>
    
    
    <categories>
      
      <category>网络通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sentinel入门</title>
    <link href="/2023/03/16/spring%E6%A1%86%E6%9E%B6/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/"/>
    <url>/2023/03/16/spring%E6%A1%86%E6%9E%B6/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>面向分布式、多语言异构化服务架构的流量治理组件</p><p><a href="https://sentinelguard.io/zh-cn/">https://sentinelguard.io/zh-cn/</a></p><h2 id="1-常见的容错方案"><a href="#1-常见的容错方案" class="headerlink" title="1 常见的容错方案"></a>1 常见的容错方案</h2><p>就以B调用C服务为例，怎样避免B服务因为C服务的不可用而导致自己不可用</p><ol><li>超时</li></ol><p>​        <img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/1.png"></p><ol start="2"><li><p>限流</p><p> <img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/2.png"></p></li><li><p>舱壁模式</p></li></ol><p><img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/3.png"></p><ol start="4"><li><p>断路器</p><p> <a href="https://martinfowler.com/bliki/CircuitBreaker.html">https://martinfowler.com/bliki/CircuitBreaker.html</a></p></li></ol><p><img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/4.png"></p><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2 快速入门"></a>2 快速入门</h2><p><a href="https://sentinelguard.io/zh-cn/docs/quick-start.html">https://sentinelguard.io/zh-cn/docs/quick-start.html</a></p><h3 id="2-1-原生API"><a href="#2-1-原生API" class="headerlink" title="2.1 原生API"></a>2.1 原生API</h3><p>1.引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.定义资源</p><p>资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。在接下来的文档中，都会用资源来描述代码块。 只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用 方法签名，URL，甚至服务名称作为资源名来标示资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SentinelExample</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">RESOURCE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Test&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//初始化配置规则</span><br>        initFlowRules();<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                entry = SphU.entry(RESOURCE_NAME);<br>                <span class="hljs-comment">//被保护的逻辑</span><br>                System.out.printLn(<span class="hljs-string">&quot;hello sentinel&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (BlockException ex)&#123;<br>                <span class="hljs-comment">//处理被流控的逻辑</span><br>                System.out.printLn(<span class="hljs-string">&quot;blocked!&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span>(entry != <span class="hljs-literal">null</span>)&#123;<br>                    entry.exit();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.定义规则</p><p><a href="https://sentinelguard.io/zh-cn/docs/introduction.html">https://sentinelguard.io/zh-cn/docs/introduction.html</a></p><p>围绕资源的实时状态设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initFlowRules</span><span class="hljs-params">()</span>&#123;<br>List&lt;FlowRule&gt; rules = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">FlowRule</span> <span class="hljs-variable">rule</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowRule</span>();<br>    rule.setResource(RESOURCE_NAME);<br>    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);<br>    <span class="hljs-comment">// Set limit QPS to 20</span><br>    rule.setCount(<span class="hljs-number">20</span>);<br>    rules.add(rule);<br>    FlowRuleManager.loadRules(rules);<br>&#125;<br></code></pre></td></tr></table></figure><p>4.运行方法，观察控制台</p><p>5.理解过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">initFlowRules()<br>-&gt;FlowRuleManager.loadRules(rules)<br>-&gt;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Map&lt;String, List&lt;FlowRule&gt;&gt; flowRules = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>可以理解为名称为HelloWorld的资源，目前拥有一个流控规则FlowRule，流控规则中有具体的一些值</p><p><img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/5.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">SphU.entry(RESOURCE_NAME)<br>-&gt;FlowSlot#entry<br>-&gt;checkFlow(resourceWrapper, context, node, count, prioritized)<br>-&gt;Collection&lt;FlowRule&gt; rules = ruleProvider.apply(resource.getName())<br></code></pre></td></tr></table></figure><p>也就是在SphU#entry方法中，会根据资源名称拿到对应的流控规则FlowRule</p><p><img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/6.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">canPassCheck<br>-&gt;passLocalCheck<br>-&gt;canPass<br></code></pre></td></tr></table></figure><p>最后在canPass方法中，会判断当前的QPS根据流控规则的配置是否能够通过</p><p><img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/7.png"></p><p>6.总结</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs leaf">a.加载规则到内存 FlowRuleManager<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">loadRules</span><span class="hljs-params">(<span class="hljs-variable">rules</span>)</span></span><br>b.定义被保护的资源 SphU#entry<br></code></pre></td></tr></table></figure><h3 id="2-2-原生API-Web-MVC"><a href="#2-2-原生API-Web-MVC" class="headerlink" title="2.2 原生API-Web MVC"></a>2.2 原生API-Web MVC</h3><p>（1）定义FlowRuleController及被保护的资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/flow&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlowRuleController</span> &#123;<br><span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>entry = SphU.entry(<span class="hljs-string">&quot;flow&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;web mvc hello sentinel.&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;web mvc hello sentinel.&quot;</span>;<br>&#125; <span class="hljs-keyword">catch</span> (BlockException ex) &#123;<br><span class="hljs-comment">// 处理被流控的逻辑</span><br>System.out.println(<span class="hljs-string">&quot;web mvc flow limit!&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;web mvc flow limit!&quot;</span>;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (entry != <span class="hljs-literal">null</span>) &#123;<br>entry.exit();<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）加载规则到内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostConstruct</span> <span class="hljs-comment">// Spring Bean实例化之后执行</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flowRules</span><span class="hljs-params">()</span> &#123;<br>List&lt;FlowRule&gt; rules = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">FlowRule</span> <span class="hljs-variable">rule</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowRule</span>();<br>rule.setResource(<span class="hljs-string">&quot;flow&quot;</span>);<br>rule.setGrade(RuleConstant.FLOW_GRADE_QPS);<br>rule.setCount(<span class="hljs-number">2</span>);<br>rules.add(rule);<br>FlowRuleManager.loadRules(rules);<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）启动Spring Boot项目，并调用/flow/hello接口</p><h3 id="2-3-SentinelResource注解"><a href="#2-3-SentinelResource注解" class="headerlink" title="2.3 @SentinelResource注解"></a>2.3 @SentinelResource注解</h3><p>（1）在FlowController中新增一个api接口，并且定义@SentinelResource注解，为value属性指定值， 其实这个属性值就是资源名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-meta">@SentinelResource(value=&quot;flow&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;@Sentinel hello sentinel.&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;@Sentinel hello sentinel.&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-annotation-aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（3）定义配置类，实例化SentinelResourceAspect对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SentinelConfiguration</span> &#123;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> SentinelResourceAspect <span class="hljs-title function_">sentinelResourceAspect</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SentinelResourceAspect</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）重启Spring Boot项目，测试test接口的QPS是否生效</p><p>（5）简单分析一下实现原理</p><p>其实就是通过AOP给目标代码的前后添加上了SphU#entry相关的逻辑</p><p><img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/8.png"></p><p>（6）定义流控异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-meta">@SentinelResource(value=&quot;flow&quot;,blockHandler = &quot;handleBlock&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;@Sentinel hello sentinel.&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;@Sentinel hello sentinel.&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">handleBlock</span><span class="hljs-params">(BlockException e)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;流控异常: &quot;</span>+e);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;QPS超过阈值，流控了.&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-客户端整合Sentinel控制台"><a href="#2-4-客户端整合Sentinel控制台" class="headerlink" title="2.4 客户端整合Sentinel控制台"></a>2.4 客户端整合Sentinel控制台</h3><p><a href="https://sentinelguard.io/zh-cn/docs/dashboard.html">https://sentinelguard.io/zh-cn/docs/dashboard.html</a></p><p>（1）下载控制台</p><p><a href="https://github.com/alibaba/Sentinel/releases">https://github.com/alibaba/Sentinel/releases</a></p><p>（2）启动控制台</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.8.5.jar<br></code></pre></td></tr></table></figure><p>（3）访问控制台：<a href="http://localhost:8080/">http://localhost:8080</a></p><p>（4）客户端引入与sentinel dashboard通信的jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-transport-simple-http<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（5）配置启动参数</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">Dcsp.sentinel.dashboard.server</span>=<span class="hljs-string">localhost:8080</span><br></code></pre></td></tr></table></figure><p><img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/9.png"></p><h2 id="3-整合Spring-Cloud-Alibaba-Sentinel"><a href="#3-整合Spring-Cloud-Alibaba-Sentinel" class="headerlink" title="3 整合Spring Cloud Alibaba Sentinel"></a>3 整合Spring Cloud Alibaba Sentinel</h2><p>可以注释掉sentinel-core、sentinel-annotation-aspectj、sentinel-transport-simple-http，因为 在sentinel starter中都包含了</p><p>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span><br></code></pre></td></tr></table></figure><p>（3）重启user服务，访问：<a href="http://localhost:8081/user/hello">http://localhost:8081/user/hello</a></p><p>（4）打开sentinel dashboard，配置流控规则</p><p><img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/10.png"></p><p>（5）原理</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ada">a-SphU#<span class="hljs-keyword">entry</span>核心代码在哪 <br>SentinelWebInterceptor#preHandle<br>... <br><span class="hljs-keyword">Entry</span> <span class="hljs-keyword">entry</span> = SphU.<span class="hljs-keyword">entry</span>(resourceName, ResourceTypeConstants.COMMON_WEB, EntryType.<span class="hljs-keyword">IN</span>)<br>b-规则什么时候保存到客户端的内存中的？<br>a-dashboard点击保存按钮<br>b-微服务收到dashboard推送过来的规则<br>c-微服务将规则保存到内存中<br></code></pre></td></tr></table></figure><p>（6）如何自定义流控之后的异常处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">SentinelWebInterceptor#preHandle<br>-&gt;<span class="hljs-keyword">catch</span>(Exception e)<br>-&gt;handleBlockException<br>-&gt;DefaultBlockExceptionHandler#handle<br></code></pre></td></tr></table></figure><p>（7）可以替换掉DefaultBlockExceptionHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JackWebMvcBlockExceptionHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockExceptionHandler</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, BlockException e)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">// Return 429 (Too Many Requests) by default.</span><br>response.setStatus(<span class="hljs-number">429</span>);<br><span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getWriter();<br><span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> FlowException)&#123;<br>out.print(<span class="hljs-string">&quot;Jack flow limit.&quot;</span>);<br>out.flush();<br>out.close();<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> DegradeException)&#123;<br>out.print(<span class="hljs-string">&quot;Jack degrade.&quot;</span>);<br>out.flush();<br>out.close();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-Sentinel客户端与服务端通信原理"><a href="#4-Sentinel客户端与服务端通信原理" class="headerlink" title="4 Sentinel客户端与服务端通信原理"></a>4 Sentinel客户端与服务端通信原理</h2><p><img src="/image/springcloud/sentinel/sentinel%E5%85%A5%E9%97%A8/11.png"></p><p>（1）服务注册+心跳机制：心跳时间间隔默认为10s，可以通过heartbeat-interval-ms进行修改</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">SimpleHttpHeartbeatSender<span class="hljs-meta">#sendHeartbeat</span><br></code></pre></td></tr></table></figure><p>（2）访问：<a href="http://localhost:8720/api%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0sentinel%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9Bapi">http://localhost:8720/api，就可以看到sentinel客户端提供了哪些api</a> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">客户端处理接口：CommandHandler<br></code></pre></td></tr></table></figure><p>（3）获取内存中的流控规则：<a href="http://localhost:8720/getRules?type=flow">http://localhost:8720/getRules?type=flow</a> </p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">FetchActiveRuleCommandHandler#handle<br>-&gt; <span class="hljs-string">&quot;flow&quot;</span><br></code></pre></td></tr></table></figure><p>（4）设置内存中的流控规则 </p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">ModifyRulesCommandHandler<span class="hljs-meta">#handle </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>sentinel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jvm调优</title>
    <link href="/2023/03/15/java%E5%9F%BA%E7%A1%80/jvm/jvm%E8%B0%83%E4%BC%98/"/>
    <url>/2023/03/15/java%E5%9F%BA%E7%A1%80/jvm/jvm%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1 常用命令"></a>1 常用命令</h2><p><strong>1. jps—查看java进程</strong></p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/1.png"></p><p><strong>2. jinfo：</strong></p><p>（1）实时查看和调整JVM配置参数</p><p>（2）用法：jinfo -flag name PID    查看某个java进程的name属性的值</p><p>​           例：jinfo -flag MaxHeapSize PID</p><p>​                  jinfo -flag UseG1GC PID</p><p>（3）修改：参数只有被标记为manageable的flags可以被实时修改</p><p>​           例：jinfo -flag [+|-] PID</p><p>​                   jinfo -flag <name>=<value> PID</p><p>（4）查看曾今赋过值的一些参数</p><pre><code class="hljs">               jinfo -flags PID</code></pre><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/2.png"></p><p><strong>3. jstat</strong></p><p>（1）查看虚拟机性能统计信息</p><p>（2）查看类装载信息：</p><p>​    jstat -class PID 1000 10 查看某个java进程的类装载信息，每1000毫秒输出一次，共输出10次</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/3.png"></p><p>（3）查看垃圾收集信息 ：jstat -gc PID 1000 10</p><p><strong>4. jstack</strong></p><p>（1）查看线程堆栈信息</p><p>（2）用法：jstack PID</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/4.png"></p><p>（3）排查死锁案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">DeadLock</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadLock</span>(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">DeadLock</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadLock</span>(<span class="hljs-literal">false</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(d1);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(d2);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLock</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>&#125;<br><span class="hljs-comment">//死锁代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> flag;<br>    DeadLock(<span class="hljs-type">boolean</span> flag)&#123;<br>        <span class="hljs-built_in">this</span>.flag = flag;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(flag)&#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">synchronized</span>(MyLock.obj1)&#123;<br>                    System.out.printLn(Thread.currentThread().getName() + <span class="hljs-string">&quot; -------if获得obj1的锁&quot;</span>)；<br>                    <span class="hljs-keyword">synchronized</span>(MyLock.obj2)&#123;<br>                    System.out.printLn(Thread.currentThread().getName() + <span class="hljs-string">&quot; -------否则获得obj2的锁&quot;</span>)<br>                &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">synchronized</span>(MyLock.obj2)&#123;<br>                    System.out.printLn(Thread.currentThread().getName() + <span class="hljs-string">&quot; -------if获得obj2的锁&quot;</span>)；<br>                    <span class="hljs-keyword">synchronized</span>(MyLock.obj1)&#123;<br>                    System.out.printLn(Thread.currentThread().getName() + <span class="hljs-string">&quot; -------否则获得obj1的锁&quot;</span>)<br>                &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/5.png"></p><p>jstack分析：</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/6.png"></p><p>把打印信息拉到最后发现</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/7.png"></p><p><strong>5. jmap</strong></p><p>（1）生成堆转储快照</p><p>（2）打印出堆内存相关信息</p><p>​    jmap -heap PID</p><p>​    jinfo -flag UsePSAdaptiveSurvivorSizePolicy 35352</p><p>​    -XX:SurvivorRatio=8</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/8.png"></p><p>（3）dump出堆内存相关信息</p><p>​    jmap -dump:format=b,file=heap.hprof PID</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/9.png"></p><p>（4）要是在发生堆内存溢出的时候，能自动dump出该文件就好了</p><p>​    一般在开发中，JVM参数可以加上下面两句，这样内存溢出时，会自动dump出该文件</p><p>​    -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap.hprof</p><p>​    设置堆内存大小: -Xms20M -Xmx20M</p><p>​    启动，然后访问localhost:9090/heap，使得堆内存溢出</p><h2 id="2-执行引擎"><a href="#2-执行引擎" class="headerlink" title="2 执行引擎"></a>2 执行引擎</h2><p>Person.java源码文件是Java这门高级开发语言，对程序员友好，方便我们开发。</p><p>​    javac编译器将Person.java源码文件编译成class文件[我们把这里的编译称为前期编译]，交给JVM运行，因为JVM只能认识class字节码文件。同时在不同的操作系统上安装对应版本的JDK，里面包含了各自屏蔽操作系统底层细节的JVM，这样同一份class文件就能运行在不同的操作系统平台之上，得益于JVM。这也是Write Once，Run Anywhere的原因所在。</p><p>​    最终JVM需要把字节码指令转换为机器码，可以理解为是0101这样的机器语言，这样才能运行在不同的机器上，那么由字节码转变为机器码是谁来做的呢？说白了就是谁来执行这些字节码指令的呢？这就是执行引擎。</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/10.png"></p><p><strong>1. 解释执行</strong></p><p>​    Interpreter，解释器逐条把字节码翻译成机器码并执行，跨平台的保证。 刚开始执行引擎只采用了解释执行的，但是后来发现某些方法或者代码块被调用执行的特别频繁时，就会把这些代码认定为“热点代码”。</p><p><strong>2. 即时编译器</strong></p><p>​    Just-In-Time compilation(JIT)，即时编译器先将字节码编译成对应平台的可执行文件，运行速度快。即时编译器会把这些热点代码编译成与本地平台关联的机器码，并且进行各层次的优化，保存到内存中。</p><p><strong>3. JVM采用哪种方式</strong></p><p>​    JVM采取的是混合模式，也就是解释+编译的方式，对于大部分不常用的代码，不需要浪费时间将其编译成机器码，只需要用到的时候再以解释的方式运行；对于小部分的热点代码，可以采取编译的方式，追求更高的运行效率。</p><p><strong>4. 即时编译器类型</strong></p><p>（1）HotSpot虚拟机里面内置了两个JIT：C1和C2</p><p>​    C1也称为Client Compiler，适用于执行时间短或者对启动性能有要求的程序</p><p>​    C2也称为Server Compiler，适用于执行时间长或者对峰值性能有要求的程序</p><p>（2）Java7开始，HotSpot会使用分层编译的方式</p><p>​    也就是会结合C1的启动性能优势和C2的峰值性能优势，热点方法会先被C1编译，然后热点方法中的热点会被C2再次编译。</p><p><strong>5. AOT和Graal VM</strong></p><p>（1）AOT</p><p>​    在Java9中，引入了AOT(Ahead-Of-Time)编译器，即时编译器是在程序运行过程中，将字节码翻译成机器码。而AOT是在程序运行之前，将字节码转换为机器码。</p><p>​    优势：这样不需要在运行过程中消耗计算机资源来进行即时编译</p><p>​    劣势：AOT 编译无法得知程序运行时的信息，因此也无法进行基于类层次分析的完全虚方法内联，或者基于程序 profile 的投机性优化（并非硬性限制，我们可以通过限制运行范围，或者利用上一次运行的程序 profile 来绕开这两个限制）</p><p>（2）Graal VM</p><p>​    官网：<a href="https://www.oracle.com/tools/graalvm-enterprise-edition.html">https://www.oracle.com/tools/graalvm-enterprise-edition.html</a></p><p>​    在Java10中，新的JIT编译器Graal被引入</p><p>​    它是一个以Java为主要编程语言，面向字节码的编译器。跟C++实现的C1和C2相比，模块化更加明显，也更加容易维护。</p><p>​    Graal既可以作为动态编译器，在运行时编译热点方法；也可以作为静态编译器，实现AOT编译。</p><p>​    除此之外，它还移除了编程语言之间的边界，并且支持通过即时编译技术，将混杂了不同的编程语言的代码编译到同一段二进制码之中，从而实现不同语言之间的无缝切换。</p><h2 id="3-工具"><a href="#3-工具" class="headerlink" title="3 工具"></a>3 工具</h2><h3 id="3-1-jconsole"><a href="#3-1-jconsole" class="headerlink" title="3.1 jconsole"></a>3.1 jconsole</h3><p>jconsole工具是JDK自带的可视化监控工具。查看java应用程序的运行概况、监控堆信息、永久区使用情况、类加载情况等。命令行中输入：jconsole。</p><h3 id="3-2-jvisualvm"><a href="#3-2-jvisualvm" class="headerlink" title="3.2 jvisualvm"></a>3.2 jvisualvm</h3><p>命令行中输入：jvisualvm。Visual GC插件下载地址：<a href="https://visualvm.github.io/pluginscenters.html%E3%80%82">https://visualvm.github.io/pluginscenters.html。</a></p><ol><li><p>监控本地进程：可以监控本地的java进程的CPU，类，线程等</p></li><li><p>监控远端java进程：</p></li></ol><p>​       1）在visualvm中选中“远程”，右击“添加”</p><p>​       2）主机名上写服务器的ip地址，比如39.100.39.63，然后点击“确定”</p><p>​       3）右击该主机”39.100.39.63”，添加“JMX”，就是通过JMX技术具体监控远端服务器哪个Java进程</p><p>​       4）要想让服务器上的tomcat被连接，需要改一下Catalina.sh这个文件。</p><p>​       注意下面的8998不要和服务器上其他端口冲突。</p><p>​        5）在../conf文件中添加两个文件jmxremote.access和jmxremote.password</p><p>​    jmxremote.access：guest readonly</p><p>​                   manager readwrite</p><p>​    jmxremote.password：guest guest</p><p>​                     manager manager</p><p>​    授予权限：chmod 600 jmxremot</p><pre><code class="hljs">    6）将连接服务器地址改为公网ip地址</code></pre><p>​        7）设置上述端口对应的阿里云安全策略和防火墙策略</p><pre><code class="hljs">    8）启动tomcat，来到bin目录：./startup.sh   9）查看tomcat启动日志以及端口监听</code></pre><p>​       tail -f ../logs/catalina.out      lsof -i tcp:8080</p><p>​        10）查看8998监听情况，可以发现多开了几个端口</p><p>​       lsof -i:8998 得到PID         netstat -antup | grep PID</p><pre><code class="hljs">    11）在刚才的JMX中输入8998端口，并且输入用户名和密码则登录成功</code></pre><h3 id="3-3-arthas"><a href="#3-3-arthas" class="headerlink" title="3.3 arthas"></a>3.3 arthas</h3><p><a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></p><p>Arthas 是Alibaba开源的Java诊断工具，采用命令行交互模式，是排查jvm相关问题的利器。</p><p>（1）下载安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl -o https://alibaba.github.io/arthas/arthas-boot.jar<br>java -jar artjas-boot.jar<br>or<br>java -jar arthas-boot.jar -h<br><span class="hljs-comment"># 然后可以选择一个java进程</span><br></code></pre></td></tr></table></figure><p>（2）常用命令</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">version：查看版本号<br>help：查看命名帮助信息<br>cls：清空屏幕<br>session：查看当前会话信息<br><span class="hljs-section">quit：推出客户端</span><br><span class="hljs-section">-----</span><br>dashboard：当前进程的实时数据面板<br>thread：当前JVM的线程堆栈信息<br>jvm：查看当前JVM的信息<br><span class="hljs-section">sysprop：查看JVM的系统属性</span><br><span class="hljs-section">-----</span><br>sc：查看JVM已经加载的类信息<br>dump：dump已经加载类的byte code到指定目录<br><span class="hljs-section">jad：反编译指定已加载类的源码</span><br><span class="hljs-section">-----</span><br>monitor：方法执行监控<br>watch：方法执行数据观测<br>trace：方法内部调用路径，并输出方法路径上的每个节点上耗时<br>stack：输出当前方法被调用的调用路径<br>...<br></code></pre></td></tr></table></figure><h3 id="3-4-内存分析"><a href="#3-4-内存分析" class="headerlink" title="3.4 内存分析"></a>3.4 内存分析</h3><ol><li>MAT</li></ol><p>​    Java堆分析器，用于查找内存泄漏。Heap Dump，称为堆转储文件，是Java进程在某个时间内的快照。它在触发快照的时候保存了很多信息：Java对象和类信息。通常在写Heap Dump文件前会触发一次Full GC。</p><p>下载地址 ：<a href="https://www.eclipse.org/mat/downloads.php">https://www.eclipse.org/mat/downloads.php</a></p><p>1）获取dump文件</p><p>​    手动：jmap -dump:format=b,file=heap.hprof 44808</p><p>​    自动：-XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=heap.hprof</p><p>2）使用</p><p><strong>Histogram</strong>：可以列出内存中的对象，对象的个数及其大小</p><p>​       Class Name:类名称，java类名</p><p>​       Objects:类的对象的数量，这个对象被创建了多少个</p><p>​       Shallow Heap:一个对象内存的消耗大小，不包含对其他对象的引用</p><p>​       Retained Heap:是shallow Heap的总和，即该对象被GC之后所能回收到内存的总和</p><p>​       右击类名—&gt;List Objects—&gt;with incoming references—&gt;列出该类的实例</p><p>​       右击Java对象—&gt;Merge Shortest Paths to GC Roots—&gt;exclude all …—&gt;找到GC Root以及原因</p><p><strong>Leak Suspects</strong>：查找并分析内存泄漏的可能原因</p><p><strong>Top Consumers</strong>：列出大对象</p><h3 id="3-5-GC日志分析"><a href="#3-5-GC日志分析" class="headerlink" title="3.5 GC日志分析"></a>3.5 GC日志分析</h3><p>要想分析日志的信息，得先拿到GC日志文件才行。比如打开windows中的catalina.bat，在第一行加上</p><p>​    XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps</p><p>​    -Xloggc:$CATALINA_HOME/logs/gc.log</p><p>1.不同收集器的日志</p><p>​    这样使用startup.bat启动tomcat的时候就能够在当前目录下拿到gc.log文件，可以看到默认使用的是ParallelGC。</p><p>​    （1）Parallel GC 吞吐量优先</p><p>​       【2019-06-10T23:21:53.305+0800: 1.303: [GC (Allocation Failure) [PSYoungGen:65536K[Young区回  收前]-&gt;10748K[Young区回收后]76288K[Young区总大小]] 65536K[整个堆回收前]-&gt;15039K[整个堆回    收后]251392K[整个堆总大小], 0.0113277 secs] [Times:user=0.00 sys=0.00, real=0.01 secs]】</p><p>​       注意如果回收的差值中间有出入，说明这部分空间是Old区释放出来的。</p><p>（2）CMS 停顿时间优先</p><p>​    参数设置：-XX:+UseConcMarkSweepGC -Xloggc:cms-gc.log</p><p>​    重启tomcat获取gc日志，这里的日志格式和上面差不多，不作分析。</p><p>​    （3）G1 停顿时间优先</p><p>​    G1日志格式参考链接：<a href="https://blogs.oracle.com/poonam/understanding-g1-gc-logs%E3%80%82">https://blogs.oracle.com/poonam/understanding-g1-gc-logs。</a></p><p>​    参数设置：-XX:+UseG1GC -Xloggc:g1-gc.log</p><p>-XX:+UseG1GC # 使用了G1垃圾收集器</p><p>​    # 什么时候发生的GC，相对的时间刻，GC发生的区域young，总共花费的时间，0.00478s，</p><p>​    # It is a stop-the-world activity and all</p><p>​    # the application threads are stopped at a safepoint during this time.</p><p>​    2019-12-18T16:06:46.508+0800: 0.458: [GC pause (G1 Evacuation Pause)(young), 0.0047804 secs]</p><p>​    # 多少个垃圾回收线程，并行的时间</p><p>​    [Parallel Time: 3.0 ms, GC Workers: 4]</p><p>​    # GC线程开始相对于上面的0.458的时间刻</p><p>​    [GC Worker Start (ms): Min: 458.5, Avg: 458.5, Max: 458.5, Diff: 0.0]</p><p>​    # This gives us the time spent by each worker thread scanning the roots</p><p>​    # (globals, registers, thread stacks and VM data structures).</p><p>​    [Ext Root Scanning (ms): Min: 0.2, Avg: 0.4, Max: 0.7, Diff: 0.5, Sum: 1.7]</p><p>​    # Update RS gives us the time each thread spent in updating the RememberedSets.</p><p>​    [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</p><p>​    …</p><p>​    # 主要是Eden区变大了，进行了调整</p><p>​    [Eden: 14.0M(14.0M)-&gt;0.0B(16.0M) Survivors: 0.0B-&gt;2048.0K Heap: 14.0M(256.0M)-&gt;3752.5K(256.0M)]</p><ol start="2"><li>GCViewer</li></ol><p>​    java -jar gcviewer-1.36-SNAPSHOT.jar</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/11.png"></p><ol start="3"><li><p>gceasy ： <a href="http://gceasy.io/">http://gceasy.io</a></p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/12.png"></p></li><li><p>gcplot  <a href="https://it.gcplot.com/">https://it.gcplot.com/</a></p></li></ol><h2 id="4-性能优化"><a href="#4-性能优化" class="headerlink" title="4 性能优化"></a>4 性能优化</h2><h3 id="4-1-内存"><a href="#4-1-内存" class="headerlink" title="4.1 内存"></a>4.1 内存</h3><ol><li>内存分配</li></ol><p>​    正常情况下不需要设置，那如果是促销或者秒杀的场景呢？</p><p>​    每台机器配置2c4G，以每秒3000笔订单为例，整个过程持续60秒</p><ol start="2"><li>内存溢出，一般会有两个原因：</li></ol><p>​    （1）大并发情况下</p><p>​    （2）内存泄露导致内存溢出</p><p>​    3. 大并发【秒杀】</p><p>​        浏览器缓存、本地缓存、验证码</p><p>​        CDN静态资源服务器</p><p>​        集群+负载均衡</p><p>​        动静态资源分离、限流[基于令牌桶、漏桶算法]</p><p>​        应用级别缓存、接口防刷限流、队列、Tomcat性能优化</p><p>​        异步消息中间件</p><p>​        Redis热点数据对象缓存</p><p>​        分布式锁、数据库锁</p><p>​        5分钟之内没有支付，取消订单、恢复库存等</p><p>​    4. 内存泄漏导致内存溢出</p><p>​    ThreadLocal引起的内存泄露，最终导致内存溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TLController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/tl&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">tl</span><span class="hljs-params">(HttpServletRequest request)</span>&#123;<br>        ThreadLocal&lt;Byte[]&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>        tl.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    （1）上传到阿里云服务器</p><p>​       jvm-case-0.0.1-SNAPSHOT.jar</p><p>​    （2）启动</p><p>​       java -jar -Xms1000M -Xmx1000M -XX:+HeapDumpOnOutOfMemoryError -</p><p>​       XX:HeapDumpPath=jvm.hprof jvm-case-0.0.1-SNAPSHOT.jar</p><p>​    （3）使用jmeter模拟10000次并发</p><p>​       39.100.39.63:8080/tl</p><p>​    （4）top命令查看</p><p>​       top</p><p>​       top -Hp PID</p><p>​    （5）jstack查看线程情况，发现没有死锁或者IO阻塞的情况</p><p>​       jstack PID</p><p>​       java -jar arthas.jar —&gt; thread</p><p>​    （6）查看堆内存的使用，发现堆内存的使用率已经高达88.95%</p><p>​       jmap -heap PID</p><p>​       java -jar arthas.jar —&gt; dashboard</p><p>​    （7）此时可以大体判断出来，发生了内存泄露从而导致的内存溢出，那怎么排查呢？</p><p>​       jmap -histo:live PID | more</p><p>​       获取到jvm.hprof文件，上传到指定的工具分析，比如heaphero.io</p><h3 id="4-2-GC（这里以G1垃圾收集器调优为例）"><a href="#4-2-GC（这里以G1垃圾收集器调优为例）" class="headerlink" title="4.2 GC（这里以G1垃圾收集器调优为例）"></a>4.2 GC（这里以G1垃圾收集器调优为例）</h3><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/G1.html#use_cases">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/G1.html#use_cases</a></p><p>​    （1）50%以上的堆被存活对象占用</p><p>​    （2）对象分配和晋升的速度变化非常大</p><p>​    （3）垃圾回收时间比较长</p><p><strong>G1调优</strong></p><p>（1）使用G1GC垃圾收集器: -XX:+UseG1GC</p><p>修改配置参数，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/13.png"></p><p>（2）调整内存大小再获取gc日志分析</p><p>​       -XX:MetaspaceSize=100M</p><p>​       -Xms300M</p><p>​       -Xmx300M</p><p>​       比如设置堆内存的大小，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/14.png"></p><p>（3）调整最大停顿时间</p><p>​    -XX:MaxGCPauseMillis=200 设置最大GC停顿时间指标</p><p>​    比如设置最大停顿时间，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/15.png"></p><p>（4）启动并发GC时堆内存占用百分比</p><p>​       -XX:InitiatingHeapOccupancyPercent=45</p><p>​       G1用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比例。值为 0 则表示 “一直执行GC循环)’. 默认值为 45 (例如, 全部的 45% 或者使用了45%).</p><p>​       比如设置该百分比参数，获取到gc日志，使用GCViewer分析吞吐量和响应时间</p><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/16.png"></p><p>​    <strong>G1调优最佳实战</strong></p><p>​    官网：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#recommendations">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#recommendations</a></p><p>（1）不要手动设置新生代和老年代的大小，只要设置整个堆的大小</p><p>​    why：<a href="https://blogs.oracle.com/poonam/increased-heap-usage-with-g1-gc">https://blogs.oracle.com/poonam/increased-heap-usage-with-g1-gc</a></p><p>​    G1收集器在运行过程中，会自己调整新生代和老年代的大小，其实是通过adapt代的大小来调整对象晋升的速度和年龄，从而达到为收集器设置的暂停时间目标，如果手动设置了大小就意味着放弃了G1的自动调优</p><p>​    （2）不断调优暂停时间目标</p><p>​    一般情况下这个值设置到100ms或者200ms都是可以的(不同情况下会不一样)，但如果设置成50ms就不太合理。暂停时间设置的太短，就会导致出现G1跟不上垃圾产生的速度。最终退化成Full GC。所以对这个参数的调优是一个持续的过程，逐步调整到最佳状态。暂停时间只是一个目标，并不能总是得到满足。</p><p>​    （3）使用-XX:ConcGCThreads=n来增加标记线程的数量</p><p>​    IHOP如果阀值设置过高，可能会遇到转移失败的风险，比如对象进行转移时空间不足。如果阀值设置过低，就会使标记周期运行过于频繁，并且有可能混合收集期回收不到空间。IHOP值如果设置合理，但是在并发周期时间过长时，可以尝试增加并发线程数，调高ConcGCThreads。</p><p>​    （4）MixedGC调优</p><p>​    -XX:InitiatingHeapOccupancyPercent</p><p>​    -XX:G1MixedGCLiveThresholdPercent</p><p>​    -XX:G1MixedGCCountTarger</p><p>​    -XX:G1OldCSetRegionThresholdPercent</p><p>​    （5）适当增加堆内存大小</p><p>​    （6）不正常的Full GC</p><p>​    有时候会发现系统刚刚启动的时候，就会发生一次Full GC，但是老年代空间比较充足，一般是由Metaspace区域引起的。可以通过MetaspaceSize适当增加其大家，比如256M。</p><h3 id="4-3-CPU占用率高"><a href="#4-3-CPU占用率高" class="headerlink" title="4.3 CPU占用率高"></a>4.3 CPU占用率高</h3><p>（1）top</p><p>（2）top -Hp PID</p><p>​       查看进程中占用CPU高的线程id，即tid</p><p>（3）jstack PID | grep tid</p><h2 id="5-JVM性能优化指南"><a href="#5-JVM性能优化指南" class="headerlink" title="5 JVM性能优化指南"></a>5 JVM性能优化指南</h2><p><img src="/image/jvm/jvm%E8%B0%83%E4%BC%98/17.png"></p><h2 id="6-常见问题"><a href="#6-常见问题" class="headerlink" title="6 常见问题"></a>6 常见问题</h2><ol><li>内存泄漏与内存溢出的区别</li></ol><p>​    内存泄漏是指不再使用的对象无法得到及时的回收，持续占用内存空间，从而造成内存空间的浪费。</p><p>​    内存泄漏很容易导致内存溢出，但内存溢出不一定是内存泄漏导致的。</p><ol start="2"><li>young gc会有stw吗？</li></ol><p>​    不管什么 GC，都会发送 stop-the-world，区别是发生的时间长短。而这个时间跟垃圾收集器又有关系，Serial、PartNew、Parallel Scavenge 收集器无论是串行还是并行，都会挂起用户线程，而 CMS和 G1 在并发标记时，是不会挂起用户线程的，但其它时候一样会挂起用户线程，stop the world 的时间相对来说就小很多了。</p><ol start="3"><li>major gc和full gc的区别</li></ol><p>​    Major GC在很多参考资料中是等价于 Full GC 的，也可以发现很多性能监测工具中只有 Minor GC和 Full GC。一般情况下，一次 Full GC 将会对年轻代、老年代、元空间以及堆外内存进行垃圾回收。触发 Full GC 的原因有很多：当年轻代晋升到老年代的对象大小，并比目前老年代剩余的空间大小还要大时，会触发 Full GC；当老年代的空间使用率超过某阈值时，会触发 Full GC；当元空间不足时（JDK1.7永久代不足），也会触发 Full GC；当调用 System.gc() 也会安排一次 Full GC。</p><ol start="4"><li>什么是直接内存</li></ol><p>​    Java的NIO库允许Java程序使用直接内存。直接内存是在java堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于Java堆。因此出于性能的考虑，读写频繁的场合可能会考虑使用直接内存。由于直接内存在java堆外，因此它的大小不会直接受限于Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p><ol start="5"><li>垃圾判断的方式</li></ol><p>​    引用计数法：指的是如果某个地方引用了这个对象就+1，如果失效了就-1，当为0就会回收但是JVM没有用这种方式，因为无法判定相互循环引用（A引用B,B引用A）的情况。</p><p>​    引用链法： 通过一种GC ROOT的对象（方法区中静态变量引用的对象等-static变量）来判断，如果有一条链能够到达GC ROOT就说明，不能到达GC ROOT就说明可以回收。</p><ol start="6"><li>不可达的对象一定要被回收吗？</li></ol><p>​    即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><ol start="7"><li>为什么要区分新生代和老年代？</li></ol><p>​    当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><ol start="8"><li>G1与CMS的区别是什么</li></ol><p>​    CMS 主要集中在老年代的回收，而 G1 集中在分代回收，包括了年轻代的 Young GC 以及老年代的 Mix GC；G1 使用了 Region 方式对堆内存进行了划分，且基于标记整理算法实现，整体减少了垃圾碎片的</p><p>产生；在初始化标记阶段，搜索可达对象使用到的 Card Table，其实现方式不一样。</p><ol start="9"><li>方法区中的无用类回收</li></ol><p>  方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>​    判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。</p><p>​    类需要同时满足下面 3 个条件才能算是 “无用的类” :</p><p>​    a-该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</p><p>​    b-加载该类的 ClassLoader 已经被回收。</p><p>​    c-该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gateway</title>
    <link href="/2023/03/13/spring%E6%A1%86%E6%9E%B6/springcloud/gateway/gateway/"/>
    <url>/2023/03/13/spring%E6%A1%86%E6%9E%B6/springcloud/gateway/gateway/</url>
    
    <content type="html"><![CDATA[<h2 id="1-为什么需要网关"><a href="#1-为什么需要网关" class="headerlink" title="1 为什么需要网关"></a>1 为什么需要网关</h2><p>（1）如果没有网关，各个微服务就需要对外暴露很多端口，访问不方便并且不安全 </p><p>（2）如果没有网关，很多微服务都需要单独认证授权，比较麻烦 </p><p>（3）有些微服务使用的是不同的通信协议，如果没有网关，则客户端访问变得很不方便</p><p>等等。。。</p><h2 id="2-常见的网关产品"><a href="#2-常见的网关产品" class="headerlink" title="2 常见的网关产品"></a>2 常见的网关产品</h2><p><a href="https://landscape.cncf.io/">https://landscape.cncf.io/</a></p><p><img src="/image/springcloud/gateway/1.png"></p><h2 id="3-Spring-Cloud-Gateway-Features"><a href="#3-Spring-Cloud-Gateway-Features" class="headerlink" title="3 Spring Cloud Gateway Features"></a>3 Spring Cloud Gateway Features</h2><p>Built on Spring Framework 5, Project Reactor and Spring Boot 2.0 </p><p>Able to match routes on any request attribute. </p><p>Predicates and filters are specific to routes. </p><p>Circuit Breaker integration. </p><p>Spring Cloud DiscoveryClient integration </p><p>Easy to write Predicates and Filters </p><p>Request Rate Limiting </p><p>Path Rewriting</p><p><img src="/image/springcloud/gateway/2.png"></p><h2 id="4-工作流程"><a href="#4-工作流程" class="headerlink" title="4 工作流程"></a>4 工作流程</h2><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-how-it-works">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-how-it-works</a></p><p><img src="/image/springcloud/gateway/3.png"></p><h2 id="5-Glossary-术语"><a href="#5-Glossary-术语" class="headerlink" title="5 Glossary[术语]"></a>5 Glossary[术语]</h2><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#glossary">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#glossary</a></p><h3 id="5-1-Route"><a href="#5-1-Route" class="headerlink" title="5.1 Route"></a>5.1 Route</h3><p>The basic building block of the gateway. It is defined by an ID, a destination URI, a collection of predicates, and a collection of filters. A route is matched if the aggregate predicate is true.</p><h3 id="5-2-Predicate"><a href="#5-2-Predicate" class="headerlink" title="5.2 Predicate"></a>5.2 Predicate</h3><p>This is a Java 8 Function Predicate. The input type is a Spring Framework ServerWebExchange. This lets you match on anything from the HTTP request, such as headers or parameters.</p><h3 id="5-3-Filter"><a href="#5-3-Filter" class="headerlink" title="5.3 Filter"></a>5.3 Filter</h3><p>These are instances of GatewayFilter that have been constructed with a specific factory. Here, you can modify requests and responses before or after sending the downstream request.</p><h3 id="5-4-图解"><a href="#5-4-图解" class="headerlink" title="5.4 图解"></a>5.4 图解</h3><p><img src="/image/springcloud/gateway/4.png"></p><h2 id="6-Gateway初体验"><a href="#6-Gateway初体验" class="headerlink" title="6 Gateway初体验"></a>6 Gateway初体验</h2><h3 id="6-1-基本搭建流程"><a href="#6-1-基本搭建流程" class="headerlink" title="6.1 基本搭建流程"></a>6.1 基本搭建流程</h3><p>（1）创建Spring Boot项目，名称为gateway，选择gateway的依赖，并修改端口号为8090 </p><p>（2）修改Spring Boot和Spring Cloud版本</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Spring</span> Boot: <span class="hljs-number">2</span>.<span class="hljs-number">7</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">Spring</span> Cloud: <span class="hljs-number">2021</span>.<span class="hljs-number">0</span>.<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>（3）添加SCA Dependencies管理和Nacos Discovery</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入spring cloud alibaba 版本管理--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>---<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（4）自定义路由规则和服务发现路由</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8090</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-comment"># nacos注册中心地址</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-attr">service:</span> <span class="hljs-string">gateway</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-comment"># 自定义路由规则</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-comment"># 路由的匹配条件 localhost:8090/jack/user/hello ---&gt;</span><br>      <span class="hljs-comment"># localhost:8081/jack/user/hello [没有 -StripPrefix过滤器的情况]</span><br>      <span class="hljs-comment"># 路由的匹配条件 localhost:8090/jack/user/hello ---&gt;</span><br>      <span class="hljs-comment"># localhost:8081/user/hello [有 -StripPrefix过滤器的情况]</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">jack_path_route</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8081</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/jack/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">locator:</span><br>          <span class="hljs-comment"># 开启网关服务发现的能力</span><br>          <span class="hljs-comment"># localhost:8090/user --[loadbalancer]-&gt; localhost:8081</span><br>          <span class="hljs-comment"># localhost:8090/user/user/hello ---&gt; localhost:8081/user/hello</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>（5）启动gateway</p><p>（6）访问测试 </p><p>自定义路由规则：<a href="http://localhost:8090/jack/user/hello">http://localhost:8090/jack/user/hello</a> </p><p>基于服务发现的路由规则：<a href="http://localhost:8090/user/user/hello">http://localhost:8090/user/user/hello</a>  </p><p>发现基于服务发现的路由规则访问失败，因为没有引入loadbalancer依赖</p><h3 id="6-2-引入loadbalancer依赖解决负载均衡问题"><a href="#6-2-引入loadbalancer依赖解决负载均衡问题" class="headerlink" title="6.2 引入loadbalancer依赖解决负载均衡问题"></a>6.2 引入loadbalancer依赖解决负载均衡问题</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6-3-设置日志级别"><a href="#6-3-设置日志级别" class="headerlink" title="6.3 设置日志级别"></a>6.3 设置日志级别</h3><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#troubleshooting">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#troubleshooting</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">reactor.netty:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h2 id="7-Actuator-API"><a href="#7-Actuator-API" class="headerlink" title="7 Actuator API"></a>7 Actuator API</h2><h3 id="7-1-整合actuator"><a href="#7-1-整合actuator" class="headerlink" title="7.1 整合actuator"></a>7.1 整合actuator</h3><p>（1）引入spring-boot-starter-actuator依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-comment"># 或者指定为gateway</span><br>  <span class="hljs-attr">endpoint:</span><br>    <span class="hljs-attr">health:</span><br>      <span class="hljs-attr">show-details:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></table></figure><p>（3）常见api操作</p><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#recap-the-list-of-all-endpoints">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#recap-the-list-of-all-endpoints</a></p><p><img src="/image/springcloud/gateway/5.png"></p><h3 id="7-2-动态添加路由信息"><a href="#7-2-动态添加路由信息" class="headerlink" title="7.2 动态添加路由信息"></a>7.2 动态添加路由信息</h3><p>（1）创建路由信息：使用<a href="http://localhost:8090/actuator/gateway/routes/jack_dynamic_route%EF%BC%8C%E5%8F%91">http://localhost:8090/actuator/gateway/routes/jack_dynamic_route，发</a> 送POST请求</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jack_dynamic_route&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;predicates&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Path&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_genkey_0&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/dynamic&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;filters&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;StripPrefix&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;parts&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;uri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://www.gupaoedu.com&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;order&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>（2）刷新并查看路由信息</p><p><a href="http://localhost:8090/actuator/gateway/refresh">http://localhost:8090/actuator/gateway/refresh</a></p><p><a href="http://localhost:8090/actuator/gateway/routes">http://localhost:8090/actuator/gateway/routes</a></p><p>（3）访问 <a href="http://localhost:8090/dynamic">http://localhost:8090/dynamic</a></p><h2 id="8-Gateway整合Nacos实现动态路由"><a href="#8-Gateway整合Nacos实现动态路由" class="headerlink" title="8 Gateway整合Nacos实现动态路由"></a>8 Gateway整合Nacos实现动态路由</h2><h3 id="8-1-环境搭建"><a href="#8-1-环境搭建" class="headerlink" title="8.1 环境搭建"></a>8.1 环境搭建</h3><p>（1）在nacos server上创建gateway.yaml文件，用于保存gateway的路由配置信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">nacos_route</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">https://www.baidu.com</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/nacos/**</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br></code></pre></td></tr></table></figure><p><img src="/image/springcloud/gateway/6.png"></p><p>（2）在gateway工程中引入nacos相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（3）创建bootstrap.yaml文件并配置相关值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span><br>        <span class="hljs-string">shard-config[0]:</span><br>          <span class="hljs-attr">dataId:</span> <span class="hljs-string">gateway.yaml</span><br>          <span class="hljs-attr">refresh:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>（4）重启gateway工程，通过actuator查看路由信息</p><p><a href="http://localhost:8090/actuator/gateway/routes">http://localhost:8090/actuator/gateway/routes</a></p><p>（5）访问：<a href="http://localhost:8090/nacos">http://localhost:8090/nacos</a> </p><p>（6）在nacos server上动态修改uri：比如将<a href="https://www.baidu.com/">https://www.baidu.com</a> -&gt; <a href="https://www.alibaba.com/">https://www.alibaba.com</a> </p><p>（7）重启gateway，再次访问：<a href="http://localhost:8090/nacos">http://localhost:8090/nacos</a></p><h3 id="8-2-Nacos-Gateway动态刷新原理"><a href="#8-2-Nacos-Gateway动态刷新原理" class="headerlink" title="8.2 Nacos Gateway动态刷新原理"></a>8.2 Nacos Gateway动态刷新原理</h3><p>（1）根据之前Nacos配置中心源码，可以知道在Nacos配置修改之后，会push数据给client 端 </p><p>（2）然后在nacos客户端会调用NacosContextRefresher#registerNacosListener </p><p>（3）在这段代码中发布了RefreshEvent事件，该事件由RefreshEventListener监听器监听到了 </p><p>（4）调用this#refresh#refresh()方法 </p><p>（5）调用this#scope#refreshAll()方法 </p><p>（6）发布RefreshScopeRefreshEvent事件：this#context#publishEvent(new RefreshScopeRefreshedEvent()) </p><p>（7）由RouteRefreshListener监听器监听到了，判断事件类型 </p><p>（8）调用reset方法，发布RefreshRoutesEvent事件 </p><p>（9）最终调用CachingRouteLocator#onApplicationEvent完成路由规则的更新</p><h2 id="9-Predicate与Filter的两种配置方式"><a href="#9-Predicate与Filter的两种配置方式" class="headerlink" title="9 Predicate与Filter的两种配置方式"></a>9 Predicate与Filter的两种配置方式</h2><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#configuring-route-predicate-factories-and-gateway-filter-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#configuring-route-predicate-factories-and-gateway-filter-factories</a></p><h3 id="9-1-Short-Configuration"><a href="#9-1-Short-Configuration" class="headerlink" title="9.1 Short Configuration"></a>9.1 Short Configuration</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">after_route</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span><br>        <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Cookie=mycookie,mycookievalue</span><br></code></pre></td></tr></table></figure><h3 id="9-2-Fully-Expaned-Arguments"><a href="#9-2-Fully-Expaned-Arguments" class="headerlink" title="9.2 Fully Expaned Arguments"></a>9.2 Fully Expaned Arguments</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">after_route</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://example.org</span><br>        <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cookie</span><br>          <span class="hljs-attr">args:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">mycookie</span><br>            <span class="hljs-attr">regexp:</span> <span class="hljs-string">mycookievalue</span><br></code></pre></td></tr></table></figure><h2 id="10-理解Route-Predicate-Factories"><a href="#10-理解Route-Predicate-Factories" class="headerlink" title="10 理解Route Predicate Factories"></a>10 理解Route Predicate Factories</h2><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories</a></p><h3 id="10-1-常见的Predicate"><a href="#10-1-常见的Predicate" class="headerlink" title="10.1 常见的Predicate"></a>10.1 常见的Predicate</h3><p><img src="/image/springcloud/gateway/7.png"></p><h3 id="10-2-Predicate简介"><a href="#10-2-Predicate简介" class="headerlink" title="10.2 Predicate简介"></a>10.2 Predicate简介</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PredicateTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Predicate&lt;String&gt; lenPredicate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;String&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span> &#123;<br><span class="hljs-keyword">return</span> str.length() &gt; <span class="hljs-number">8</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;;<br>List&lt;String&gt; sc = Arrays.asList(<span class="hljs-string">&quot;Nacos&quot;</span>, <span class="hljs-string">&quot;LoadBalancer&quot;</span>, <span class="hljs-string">&quot;OpenFeign&quot;</span>, <span class="hljs-string">&quot;Gateway&quot;</span>, <span class="hljs-string">&quot;Sentinel&quot;</span>, <span class="hljs-string">&quot;Seata&quot;</span>);<br>sc.stream().filter(lenPredicate).forEach(System.out::println);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-3-分析PathRoutePredicateFactory"><a href="#10-3-分析PathRoutePredicateFactory" class="headerlink" title="10.3 分析PathRoutePredicateFactory"></a>10.3 分析PathRoutePredicateFactory</h3><p>（1）Predicate配置</p><p><img src="/image/springcloud/gateway/8.png"></p><p>（2）debug查看</p><p><img src="/image/springcloud/gateway/9.png"></p><h3 id="10-4-分析AfterRoutePredicateFactory"><a href="#10-4-分析AfterRoutePredicateFactory" class="headerlink" title="10.4 分析AfterRoutePredicateFactory"></a>10.4 分析AfterRoutePredicateFactory</h3><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-after-route-predicate-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-after-route-predicate-factory</a></p><p>（1）配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">gateway:</span><br>  <span class="hljs-attr">routes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">path_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8081</span><br>      <span class="hljs-attr">predicates:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/test/**</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">After=2023-01-20T17:42:47.789-07:00[America/Denver]</span><br>      <span class="hljs-attr">filters:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br></code></pre></td></tr></table></figure><p>（2）访问：<a href="http://localhost:8090/jack/user/hello">http://localhost:8090/jack/user/hello</a> </p><p>（3）debug：AfterRoutePredicateFactory#apply</p><h3 id="10-5-体验HeaderRoutePredicateFactory"><a href="#10-5-体验HeaderRoutePredicateFactory" class="headerlink" title="10.5 体验HeaderRoutePredicateFactory"></a>10.5 体验HeaderRoutePredicateFactory</h3><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-header-route-predicate-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-header-route-predicate-factory</a></p><p>（1）添加Header的Predicate</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">gateway:</span><br>  <span class="hljs-attr">routes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">path_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8081</span><br>      <span class="hljs-attr">predicates:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/test/**</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">After=2023-01-20T17:42:47.789-07:00[America/Denver]</span><br>      <span class="hljs-attr">filters:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>       <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">header_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://order</span><br>      <span class="hljs-attr">predicates:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/test2/**</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">Header=X-Request-Id,</span> <span class="hljs-string">\d+</span><br>      <span class="hljs-attr">filters:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br></code></pre></td></tr></table></figure><h3 id="10-6-自定义Predicate"><a href="#10-6-自定义Predicate" class="headerlink" title="10.6 自定义Predicate"></a>10.6 自定义Predicate</h3><p>需求：定义一个断言工厂，实现时间区间的访问功能</p><p>（1）引入lombok依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）创建配置类JackTimeBetweenConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JackTimeBetweenConfig</span> &#123;<br><span class="hljs-keyword">private</span> LocalTime begin;<br><span class="hljs-keyword">private</span> LocalTime end;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）创建断言工厂类JackTimeBetweenRoutePredicateFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JackTimeBetweenRoutePredicateFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRoutePredicateFactory</span>&lt;JackTimeBetweenConfig&gt; &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">JackTimeBetweenRoutePredicateFactory</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>(JackTimeBetweenConfig.class);<br>&#125;<br><span class="hljs-comment">// 定义配置类与配置文件的映射关系</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">shortcutFieldOrder</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">&quot;begin&quot;</span>,<span class="hljs-string">&quot;end&quot;</span>);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Predicate&lt;ServerWebExchange&gt; <span class="hljs-title function_">apply</span><span class="hljs-params">(JackTimeBetweenConfig config)</span> &#123;<br><span class="hljs-comment">// 获取配置文件中的值</span><br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> config.getBegin();<br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> config.getEnd();<br><span class="hljs-comment">// Predicate完整语法</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;ServerWebExchange&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(ServerWebExchange serverWebExchange)</span> &#123;<br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalTime.now();<br><span class="hljs-keyword">return</span> now.isAfter(begin) &amp;&amp; now.isBefore(end);<br>&#125;<br>&#125;;<br><span class="hljs-comment">// lambda表达式写法</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">return serverWebExchange -&gt; &#123;</span><br><span class="hljs-comment">LocalTime now = LocalTime.now();</span><br><span class="hljs-comment">return now.isAfter(begin) &amp;&amp; now.isBefore(end);</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）查看时间格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// DateTimeFormatterRegistrar#getFallbackFormatter#TIME</span><br>System.out.println(DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT).format(LocalTime.now())); <br>    <span class="hljs-comment">// 上午9:00</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（5）配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">gateway:</span><br>  <span class="hljs-attr">routes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">path_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8081</span><br>      <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/test/**</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">JackTimeBetween=上午1:00,下午2:00</span><br>      <span class="hljs-attr">filters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br></code></pre></td></tr></table></figure><h2 id="11-GatewayFilter-Factories-局部"><a href="#11-GatewayFilter-Factories-局部" class="headerlink" title="11 GatewayFilter Factories[局部]"></a>11 GatewayFilter Factories[局部]</h2><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories</a></p><h3 id="11-1-常见的GatewayFilter"><a href="#11-1-常见的GatewayFilter" class="headerlink" title="11.1 常见的GatewayFilter"></a>11.1 常见的GatewayFilter</h3><p>AddRequestHeaderGatewayFilterFactory：为请求添加请求头 </p><p>AddRequestParameterGatewayFilterFactory：为请求添加请求参数 </p><p>AddResponseHeaderGatewayFilterFactory：为响应添加响应头 </p><p>RequestRateLimiterGatewayFilterFactory：请求限流 </p><p>StripPrefixGatewayFilterFactory：表示要从前截取的路径个数</p><h3 id="11-2-分析StripPrefixGatewayFilterFactory"><a href="#11-2-分析StripPrefixGatewayFilterFactory" class="headerlink" title="11.2 分析StripPrefixGatewayFilterFactory"></a>11.2 分析StripPrefixGatewayFilterFactory</h3><p>（1）类关系图</p><p><img src="/image/springcloud/gateway/10.png"></p><p>（2）配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">gateway:</span><br>  <span class="hljs-attr">routes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">path_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8081</span><br>      <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/test/**</span><br>      <span class="hljs-attr">filters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br></code></pre></td></tr></table></figure><h3 id="11-3-体验AddRequestHeaderGatewayFilterFactory"><a href="#11-3-体验AddRequestHeaderGatewayFilterFactory" class="headerlink" title="11.3 体验AddRequestHeaderGatewayFilterFactory"></a>11.3 体验AddRequestHeaderGatewayFilterFactory</h3><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-addrequestheader-gatewayfilter-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-addrequestheader-gatewayfilter-factory</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">gateway:</span><br>  <span class="hljs-attr">routes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">path_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8081</span><br>      <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/test/**</span><br>      <span class="hljs-attr">filters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=X-Request-red,</span> <span class="hljs-string">blue</span><br></code></pre></td></tr></table></figure><h3 id="11-4-体验RequestRateLimiterGatewayFilterFactory"><a href="#11-4-体验RequestRateLimiterGatewayFilterFactory" class="headerlink" title="11.4 体验RequestRateLimiterGatewayFilterFactory"></a>11.4 体验RequestRateLimiterGatewayFilterFactory</h3><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-requestratelimiter-gatewayfilter-factory">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-requestratelimiter-gatewayfilter-factory</a></p><h3 id="11-5-自定义GatewayFilter"><a href="#11-5-自定义GatewayFilter" class="headerlink" title="11.5 自定义GatewayFilter"></a>11.5 自定义GatewayFilter</h3><p>需求：自定义一个局部过滤器，实现日志打印功能 </p><p>（1）创建自定义内置过滤器类LogGatewayFilterFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogPrintGatewayFilterFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractNameValueGatewayFilterFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> GatewayFilter <span class="hljs-title function_">apply</span><span class="hljs-params">(NameValueConfig config)</span>&#123;<br>        <span class="hljs-keyword">return</span> ((exchange, chain) -&gt; &#123;<br>           log.info(<span class="hljs-string">&quot;打印日志...&#123;&#125;, &#123;&#125;&quot;</span>, config.getName(), config.getValue());<br>            <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> exchange.getRequest().mutate().build();<br>            <span class="hljs-keyword">return</span> chain.filter(exchange.mutate().request(request).build());<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">gateway:</span><br>  <span class="hljs-attr">routes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">path_route</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8081</span><br>      <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/test/**</span><br>      <span class="hljs-attr">filters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ReqeustRateLimiter</span><br>          <span class="hljs-attr">args:</span><br>            <span class="hljs-attr">redis-rate-limiter.replenishRate:</span> <span class="hljs-number">1</span><br>            <span class="hljs-attr">redis-rate-limiter.burstCapacity:</span> <span class="hljs-number">2</span><br>            <span class="hljs-attr">redis-rate-limiter.requestedTokens:</span> <span class="hljs-number">1</span><br>            <span class="hljs-attr">key-resolver:</span> <span class="hljs-string">&quot;#&#123;@pathKeyResolver&#125;&quot;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">LogPrint=test,17</span><br></code></pre></td></tr></table></figure><h2 id="12-Global-Filter-全局"><a href="#12-Global-Filter-全局" class="headerlink" title="12 Global Filter[全局]"></a>12 Global Filter[全局]</h2><p><a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#global-filters">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#global-filters</a></p><h3 id="12-1-常见的全局过滤器"><a href="#12-1-常见的全局过滤器" class="headerlink" title="12.1 常见的全局过滤器"></a>12.1 常见的全局过滤器</h3><p><img src="/image/springcloud/gateway/11.png"></p><h3 id="12-2-分析ReactiveLoadBalancerClientFilter"><a href="#12-2-分析ReactiveLoadBalancerClientFilter" class="headerlink" title="12.2 分析ReactiveLoadBalancerClientFilter"></a>12.2 分析ReactiveLoadBalancerClientFilter</h3><p>类关系图</p><p><img src="/image/springcloud/gateway/12.png"></p><h3 id="12-3-分析NettyRoutingFilter"><a href="#12-3-分析NettyRoutingFilter" class="headerlink" title="12.3 分析NettyRoutingFilter"></a>12.3 分析NettyRoutingFilter</h3><p>类关系图</p><p><img src="/image/springcloud/gateway/13.png"></p><h3 id="12-4-自定义GlobalFilter"><a href="#12-4-自定义GlobalFilter" class="headerlink" title="12.4 自定义GlobalFilter"></a>12.4 自定义GlobalFilter</h3><p>需求：校验请求头中是否携带指定的token值</p><p>创建自定义全局过滤器CheckHeaderTokenGlobalFilter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CheckHeaderTokenGlobalFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> exchange.getRequest().getHeaders().getFirst(<span class="hljs-string">&quot;token&quot;</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;jack&quot;</span>.equals(value))&#123;<br><span class="hljs-keyword">return</span> chain.filter(exchange);<br>&#125;<br>exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);<br><span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// Order值越小，执行的优先级越高</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-Gateway整合Sentinel实现容错"><a href="#13-Gateway整合Sentinel实现容错" class="headerlink" title="13 Gateway整合Sentinel实现容错"></a>13 Gateway整合Sentinel实现容错</h2><p>请查看Sentinel适配开源框架部分</p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>gateway</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>gateway</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾回收(Garbage Collect-GC)</title>
    <link href="/2023/03/10/java%E5%9F%BA%E7%A1%80/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(Garbage%20Collect-GC)/"/>
    <url>/2023/03/10/java%E5%9F%BA%E7%A1%80/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(Garbage%20Collect-GC)/</url>
    
    <content type="html"><![CDATA[<h2 id="1-对象的引用"><a href="#1-对象的引用" class="headerlink" title="1 对象的引用"></a>1 对象的引用</h2><p>Java中的引用的定义：如果reference(引用)类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。 </p><p>希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。 很多系统的缓存功能都符合这样的应用场景。四种引用类型：</p><p><strong>强引用：</strong>在Java中最常见的就是强引用，也是在开发过程中经常会使用到的引用.把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。</p><p><strong>软引用：</strong>软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SoftReferenceDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Worker</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>();<br>        <span class="hljs-comment">//业务代码使用到了a</span><br>        <span class="hljs-comment">//使用完了a，将它设置为soft引用类型，并且释放强引用</span><br>        <span class="hljs-type">SoftReference</span> <span class="hljs-variable">sr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>(a);<br>        a = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//下次使用时</span><br>        <span class="hljs-keyword">if</span>(sr != <span class="hljs-literal">null</span>)&#123;<br>            a = (worker) sr.get();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//GC由于内存资源不足，可能系统已回收了a的软引用</span><br>            <span class="hljs-comment">//因此需要重新装载</span><br>            a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>();<br>            sr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>(a);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>弱引用：</strong>弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeakReferenceDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//100M的缓存数据</span><br>        <span class="hljs-type">byte</span>[] cacheData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">100</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">//将缓存数据用软引用持有</span><br>        WeakReference&lt;<span class="hljs-type">byte</span>[]&gt; cacheRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(cacheData);<br>        System.out.printLn(<span class="hljs-string">&quot;第一次GC前&quot;</span> + cacheData);<br>        System.out.printLn(<span class="hljs-string">&quot;第一次GC前&quot;</span> + cacheRef.get());<br>        <span class="hljs-comment">//进行一次GC后查看对象的回收情况</span><br>        System.gc();<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        System.out.printLn(<span class="hljs-string">&quot;第一次GC后&quot;</span> + cacheData);<br>        System.out.printLn(<span class="hljs-string">&quot;第一次GC后&quot;</span> + cacheRef.get());<br>        <span class="hljs-comment">//将缓存数据的强引用去除</span><br>        cacheData = <span class="hljs-literal">null</span>;<br>        System.gc();<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        System.out.printLn(<span class="hljs-string">&quot;第二次GC后&quot;</span> + cacheData);<br>        System.out.printLn(<span class="hljs-string">&quot;第二次GC后&quot;</span> + cacheRef.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>虚引用：</strong>虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态，用于通知。应用场景：finalize()方法。</p><p><strong>引用队列：</strong>把对象放入引用队列中，可以实现对对象的后续操作。</p><h2 id="2-如何确定一个对象是垃圾"><a href="#2-如何确定一个对象是垃圾" class="headerlink" title="2 如何确定一个对象是垃圾"></a>2 如何确定一个对象是垃圾</h2><h3 id="2-1-算法"><a href="#2-1-算法" class="headerlink" title="2.1 算法"></a>2.1 算法</h3><p>1.引用计数法</p><p>​    对于某个对象而言，只要应用程序中持有该对象的引用，就说明该对象不是垃圾，如果一个对象没有任何指针对其引用，它就是垃圾。</p><p>​    弊端：循环引用如果AB相互持有引用，导致永远不能被回收。</p><p>2.可达性分析(根搜索)</p><p>​    通过GC Root的对象，开始向下寻找，看某个对象是否可达。</p><p>​    能作为GC Root：类加载器，Thread，虚拟机栈的局部变量表，方法区的静态变量和常量，本地方法栈的变量等。</p><h3 id="2-2-对象的生命周期"><a href="#2-2-对象的生命周期" class="headerlink" title="2.2 对象的生命周期"></a>2.2 对象的生命周期</h3><p>1.创建阶段(Created): 为对象分配存储空间 开始构造对象，从超类到子类对static成员进行初始化，超类成员变量按顺序初始化，递归调用超类的构造方法 子类成员变量按顺序初始化，子类构造方法调用，一旦对象被创建，并被分派给某些变量赋值，这个对象的状态就切换到了应用阶段。</p><p>2.应用阶段(In User)：对象至少被一个强引用持有着。</p><p>3.不可见阶段(Invisible)：当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然该这些引用仍然是存在着的。简单说就是程序的执行已经超出了该对象的作用域了。</p><p>4.不可达阶段( Unreachable)：对象处于不可达阶段是指该对象不再被任何强引用所持有。</p><p>与“不可见阶段”相比，“不可见阶段”是指程序不再持有该对象的任何强引用，这种情况下，该对象仍可能被 JVM等系统下的某些已装载的静态变量或线程或 JNI等强引用持有着，这些特殊的强引用被称为” GC root” 存在着这些 GC root会导致对象的内存泄露情况，无法被回收。</p><p>5.收集阶段( Collected)：当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了 finalize()方法，则会去执行该方法的终端操作。</p><p><em>这里要特别说明一下：不要重载ﬁnazlie()方法！原因有两点：</em></p><p>（1）会影响JVM的对象分配与回收速度。在分配该对象时，JVM需要在垃圾回收器上注册该对象，以便在回收时能够执行该重载方法；在该方法的执行时需要消耗CPU时间且在执行完该方法后才会重新执行回收操作，即至少需要垃圾回收器对该对象执行两次GC。</p><p>（2）可能造成该对象的再次“复活”。在ﬁnalize()方法中，如果有其它的强引用再次持有该对象，则会导致对象的状态由“收集阶段”又重新变为“应用阶段”。这个已经破坏了Java对象的生命周期进程，且“复活”的对象不利用后续的代码管理。</p><p>6.终结阶段(Finalized): 当对象执行完ﬁnalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。</p><p>7.对象空间重分配阶段(De-allocated): 垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”。</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg"></p><h3 id="2-3-垃圾回收的时机"><a href="#2-3-垃圾回收的时机" class="headerlink" title="2.3 垃圾回收的时机"></a>2.3 垃圾回收的时机</h3><p>GC是由JVM自动完成的，根据JVM系统环境而定，所以时机是不确定的。当然，可以手动进行垃圾回收，比如调用System.gc()方法通知JVM进行一次垃圾回收，但是具体什么时刻运行也无法控制。也就是说System.gc()只是通知要回收，什么时候回收由JVM决定。但是不建议手动调用该方法，因为GC消耗的资源比较大。</p><p>（1）当Eden区或者S区不够用了</p><p>（2）老年代空间不够用了</p><p>（3）方法区空间不够用了</p><p>（4）System.gc()</p><h2 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3 垃圾收集算法"></a>3 垃圾收集算法</h2><h3 id="3-1-标记-清除-mark-sweep"><a href="#3-1-标记-清除-mark-sweep" class="headerlink" title="3.1 标记-清除(mark-sweep)"></a>3.1 标记-清除(mark-sweep)</h3><p>1.标记：找出内存中需要回收的对象，并且把他们标记出来。此时堆中所有的对象都会被扫描一遍，从而才能确定需要回收的对象，比较耗时。</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/1.png"></p><p>2.清除：清除掉被标记需要回收的对象，释放出对应的内存空间。</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2.png"></p><p>缺点：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><p>​    （1）标记和清除两个过程都比较耗时，效率不高。</p><p>​    （2）会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中分配较大对象时，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。</p><h3 id="3-2-标记-复制-Mark-Copying"><a href="#3-2-标记-复制-Mark-Copying" class="headerlink" title="3.2 标记-复制(Mark-Copying)"></a>3.2 标记-复制(Mark-Copying)</h3><p>将内存划分为两块相等的区域，每次只使用其中一块。</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/3.png"></p><p>当其中一块内存使用完了，就将还存活的对象复制到另外一块上面，然后再把已经使用过的内存空间一次清除掉。</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/4.png"></p><p>缺点：空间利用率低。</p><h3 id="3-3-标记-整理-mark-compact"><a href="#3-3-标记-整理-mark-compact" class="headerlink" title="3.3 标记-整理(mark-compact)"></a>3.3 标记-整理(mark-compact)</h3><p>标记过程仍然和“标记-清除”算法一样，但是后续步骤不是对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清除掉边界外的内存。</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/5.png"></p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/6.png"></p><p>整理方式分为三类：</p><p>1.任意顺序整理：快，只能处理固定大小的对象。双指针算法(两次遍历)，其中快慢指针解决环：第一次遍历First指针从左往右移动直到遇到空位停下，End指针从右往左移动遇到非空位停下，两个位置交换，知道两指针碰撞到一起，此时碰撞位置左边都是非空的，右边都是空的。第二次遍历，更新移动过的内存地址。</p><p>2.线性顺序整理，相关联的在一起，会导致空间碎片，</p><p>3.滑动顺序整理： </p><p>（1）Lisp2算法(三次遍历)，处理大小不同的对象：有三个指针左边两个一起移动，右边一个不动用于判断结束，多出的那个指针会在第一次遍历进行一个记录操作，记录对象应该去哪个位置，第二次遍历修改引用，第三次进行对象移动。缺点：速度慢，浪费空间记录可达对象的预估到达位置.</p><p>（2）单次遍历：会有一张额外的表，会将内存分为很多大小相等的块，表中记录：标记位向量(对象的位置，开始位置和结束位置)，偏移位向量(到达的位置，只记录开头)，内存索引号</p><h2 id="4-JVM参数"><a href="#4-JVM参数" class="headerlink" title="4 JVM参数"></a>4 JVM参数</h2><h3 id="4-1-标准参数"><a href="#4-1-标准参数" class="headerlink" title="4.1 标准参数"></a>4.1 标准参数</h3><p>-version ；-help ；-server ；-cp</p><h3 id="4-2-X参数"><a href="#4-2-X参数" class="headerlink" title="4.2 -X参数"></a>4.2 -X参数</h3><p>非标准参数，也就是在JDK各个版本中可能会变动</p><p>-Xint   解释执行</p><p>-Xcomp   第一次使用就编译成本地代码 </p><p>-Xmixed  混合模式，JVM自己来决定</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/7.png"></p><h3 id="4-3-XX参数"><a href="#4-3-XX参数" class="headerlink" title="4.3 -XX参数"></a>4.3 -XX参数</h3><p>使用得最多的参数类型，非标准化参数，相对不稳定，主要用于JVM调优和Debug</p><ol><li><strong>Boolean类型</strong></li></ol><p>格式：-XX:[+-]<name>      +或-表示启用或者禁用name属性</p><p>比如：-XX:+UseConcMarkSweepGC  表示启用CMS类型的垃圾回收器</p><p>​            -XX:+UseG1GC        表示启用G1类型的垃圾回收器</p><ol start="2"><li><strong>非Boolean类型</strong></li></ol><p>格式：-XX<name>=<value>表示name属性的值是value </p><p>比如：-XX:MaxGCPauseMillis=500</p><h3 id="4-4-其他参数"><a href="#4-4-其他参数" class="headerlink" title="4.4 其他参数"></a>4.4 其他参数</h3><p>-Xms1000M等价于-XX:InitialHeapSize=1000M</p><p>-Xmx1000M等价于-XX:MaxHeapSize=1000M</p><p>-Xss100等价于-XX:ThreadStackSize=100 默认k为单位</p><p>所以这块也相当于是-XX类型的参数。</p><h3 id="4-5-查看参数"><a href="#4-5-查看参数" class="headerlink" title="4.5 查看参数"></a>4.5 查看参数</h3><p>java -XX:+PrintFlagsFinal -version &gt; flags.txt</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/8.png"></p><p>值得注意的是”=”表示默认值，”:=”表示被用户或JVM修改后的值</p><p>要想查看某个进程具体参数的值，可以使用jinfo，这块后面聊</p><p>一般要设置参数，可以先查看一下当前参数是什么，然后进行修改</p><h3 id="4-6-设置参数的常见方式"><a href="#4-6-设置参数的常见方式" class="headerlink" title="4.6 设置参数的常见方式"></a>4.6 设置参数的常见方式</h3><ol><li><p>开发工具中设置比如IDEA，eclipse</p></li><li><p>运行jar包的时候:java -XX:+UseG1GC xxx.jar </p></li><li><p>web容器比如tomcat，可以在脚本中的进行设置</p></li><li><p>通过jinfo实时调整某个java进程的参数(参数只有被标记为manageable的ﬂags可以被实时修改)</p></li></ol><h3 id="4-7-常用参数含义"><a href="#4-7-常用参数含义" class="headerlink" title="4.7 常用参数含义"></a>4.7 常用参数含义</h3><table><thead><tr><th>参数</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>-XX:CICompilerCount=3</td><td>最大并行编译数</td><td>如果设置大于1，虽然编译速度会提高，但是同样影响系统稳定性，会增加JVM奔溃的可能</td></tr><tr><td>-XX:InitialHeapSize=100M</td><td>初始化堆大小</td><td>简写-Xms 100M</td></tr><tr><td>-XX:MaxHeapSize=100M</td><td>最大堆大小</td><td>简写-Xmx 100M</td></tr><tr><td>-XX:NewSize=20M</td><td>设置年轻代大小</td><td></td></tr><tr><td>-XX:MaxNewSize=50M</td><td>设置年轻代最大大小</td><td></td></tr><tr><td>-XX:OldSize=50M</td><td>设置老年代大小</td><td></td></tr><tr><td>-XX:MetaspaceSize=50M</td><td>设置方法区大小</td><td></td></tr><tr><td>-XX:MaxMetaspaceSize=50M</td><td>设置方法区最大大小</td><td></td></tr><tr><td>-XX:UseParallelGC</td><td>使用ParallelGC</td><td>新生代，吞吐量优先</td></tr><tr><td>-XX:UseParallelOldGC</td><td>使用ParallelOldGC</td><td>老年代，吞吐量优先</td></tr><tr><td>-XX:UseConcMarkSweepGC</td><td>使用CMS</td><td>老年代，停顿时间优先</td></tr><tr><td>-XX:+UseG1GC</td><td>使用G1GC</td><td>新生代，老年代，停顿时间优先</td></tr><tr><td>-XX:NewRatio</td><td>新老生代的比值</td><td>比如-XX:Ratio=4，则表示新生代:老年代=1:4，也就是新生代占整个堆内存的1/5</td></tr><tr><td>-XX:SurvivorRatio</td><td>两个S区和Eden区的比值</td><td>比如-XX:SurvivorRatio=8，也就是(S0+S1):Eden=2:8，也就是一个S占整个新生代的1/10</td></tr><tr><td>-XX:+HeapDumpOnOutOfMemoryError</td><td>启动堆内存溢出打印</td><td>当JVM堆内存溢出时，也就是OOM，自动生成dump文件</td></tr><tr><td>-XX:HeapDumpPath=heap.hprof</td><td>指定堆内存溢出打印目录</td><td>表示在当前目录生成一个heap.hprof</td></tr><tr><td>-XX:+PrintGCDetails <br />-XX:+PrintGCTimeStamps <br />-XX:+PrintGCDateStamps <br />-Xloggc:g1-gc.log</td><td>打印出GC日志</td><td>可以使用不同的垃圾收集器，对比查看GC情况</td></tr><tr><td>-Xss128k</td><td>设置每个线程的堆栈大小</td><td>经验值是3000-5000最佳</td></tr><tr><td>-XX:MaxTenuringThreshold=6</td><td>提升老年代的最大临界值</td><td>默认值为15</td></tr><tr><td>-XX:InitiatingHeapOccypancyPercent</td><td>启动并发GC周期时堆内存使用占比</td><td>G1之类的垃圾收集器用它来触发并发GC周期，基于整个堆的使用率，而不是某一代内存的使用比，值为0表示一直执行GC循环，默认值为45</td></tr><tr><td>-XX:G1HeapWastePercent</td><td>允许的浪费堆空间的占比</td><td>默认值为10%，如果并发标记可回收的空间小于10%，则不会触发MixedGC</td></tr><tr><td>-XX:MaxGCPauseMillis=200ms</td><td>G1最大停顿时间</td><td>暂停时间不能太小，太小的话就会导致出现G1跟不上垃圾产生的速度，最终退化成Full GC，所以堆这个参数的调优是一个持续的过程，逐步调整到最佳状态</td></tr><tr><td>-XX:ConcGCThreads=n</td><td>并发垃圾收集器使用的线程数量</td><td>默认值随JVM运行的平台不同而不同</td></tr><tr><td>-XX:G1MixedGCLiveThresholdPercent=65</td><td>混合垃圾回收周期中要包括的旧区域设置占用率阈值</td><td>默认占用率为65%</td></tr><tr><td>-XX:G1MixedGCCountTarget=8</td><td>设置标记周期完成后，对存活数据上限为G1MixedGCLiveThresholdPercent的旧区域执行混合垃圾回收的目标次数</td><td>默认8次混合垃圾回收，混合回收的目标是要控制在次目标次数以内</td></tr><tr><td>-XX:G1OldCSetRegionThresholdPercent=1</td><td>描述Mixed GC时，Old Region被加入到CSet中</td><td>默认情况下，G1只把10%的Old Region加入到CSet中</td></tr></tbody></table><h2 id="5-垃圾收集器"><a href="#5-垃圾收集器" class="headerlink" title="5 垃圾收集器"></a>5 垃圾收集器</h2><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/9.png"></p><h3 id="5-1-Serial收集器"><a href="#5-1-Serial收集器" class="headerlink" title="5.1 Serial收集器"></a>5.1 Serial收集器</h3><p>Serial收集器是最基本，发展历史最悠久的收集器，曾经(在JDK1.3.3之前)是虚拟机新生代收集的唯一选择。它是一种单线程收集器，不仅仅意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是其在进行垃圾收集的时候需要暂停其他的线程。STW</p><p>​    优点：简单高效，拥有很高的单线程收集效率。</p><p>​    缺点：收集过程需要暂停所有线程。</p><p>​    算法：复制算法。</p><p>​    适用范围：新生代。</p><p>​    应用：Client模式下的默认新生代收集器。</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/10.png"></p><h3 id="5-2-Serial-Old收集器"><a href="#5-2-Serial-Old收集器" class="headerlink" title="5.2 Serial Old收集器"></a>5.2 Serial Old收集器</h3><p>Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，不同的是采用“<strong>标记-整理</strong>”算法，运行过程和serial收集器一样。STW</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/11.png"></p><h3 id="5-3-ParNew收集器"><a href="#5-3-ParNew收集器" class="headerlink" title="5.3 ParNew收集器"></a>5.3 ParNew收集器</h3><p>可以把这个收集器理解为Serial收集器的多线程版本。STW</p><p>​    优点：在多CPU时，比Serial效率高。</p><p>​    缺点：收集过程暂停所有应用程序线程，单CPU时比Serial效率差。</p><p>​    算法：复制算法。</p><p>​    适用范围：新生代。</p><p>​    应用：运行在server模式下的虚拟机中首选的新生代收集器。</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/12.png"></p><h3 id="5-4-Parallel-Scavenge收集器"><a href="#5-4-Parallel-Scavenge收集器" class="headerlink" title="5.4 Parallel Scavenge收集器"></a>5.4 Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，看上去和ParNew一样，但是Parallel Scavenge更关注<strong>系统的吞吐量</strong></p><p>​    吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</p><p>​    比如虚拟机总共运行了100分钟，垃圾收集时间用了1分钟，吞吐量=(100-1)/100=99%</p><p>​    若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序的运算任务。</p><p>-xx:MaxGCPauseMills控制最大的垃圾收集停顿时间</p><p>-XX:GCTimeRatio直接设置吞吐量的大小 0-100</p><p>-XX:+UserAdaptiveSizePolicy，设置用户自适应大小的策略，比如根据系统自动设置新生代大小。</p><p>​    它又叫吞吐优先垃圾收集器。</p><h3 id="5-5-Parallel-Old收集器"><a href="#5-5-Parallel-Old收集器" class="headerlink" title="5.5 Parallel Old收集器"></a>5.5 Parallel Old收集器</h3><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法进行垃圾回收。吞吐量优先。</p><h3 id="5-6-CMS收集器"><a href="#5-6-CMS收集器" class="headerlink" title="5.6 CMS收集器"></a>5.6 CMS收集器</h3><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector</a></p><p>CMS(Concurrent Mark Sweep)收集器是一种以获取<strong>最短回收停顿时间</strong>为目标的收集器。</p><p>采用的是“标记-清除”算法，整个过程分为4步：</p><p>1）初始标记：CMS initial mark 标记GC Roots能关联到的对象  stop the world -&gt; 速度很快，1.7之前是串行，1.8之后是并行。有一个参数控制：-XX: +CMSParallelIntialMarkEnablled(1.8默认开启)</p><p>2）并发标记：CMS concurrent mark 进行GC Roots Tracing，后面还有一小步：</p><p>2.5）新生代策略：并发预处理，也是标记工作。和重新标记的工作很像，尽可能的减轻重新标记的负担。</p><p>有一个问题，怎样扫描从young区指old区的对象，所以必须要在扫描新生代，把新生代中的垃圾先清理掉，执行minorGC后再扫描可达的老年代对象。其中有两个参数：CMSScheduleRemarkEdenSizeThreshold(2M)和CMSSchduleRemarkEdenPenetration(50%)意思是在Eden区使用了超过2M的内存后启动可终止的预处理策略等待minorGC，直到内存使用率达到young的50%后或者minorGC完成；或者5秒后不管是否发生了minorGC，之后自动进入重新标记，这个时间5秒由参数CMSMaxAbortPrecleanTime设置。</p><p>老年代策略：在老年代分成很多块(512k)，有一个card table(卡表)结构，为了解决跨代引用的问题。在并发标记中，如果一个对象的引用发生变化，则把该对象所在的card标记为dirty card，在重新标记阶段对其进行标识并清除dirty card标记。卡表是通过一个字节（8位）来标记对象的引用关系是否改变，例如某一位标记该对象是指向新生代的或者该对象的引用被修改过等。</p><p>3）重新标记：CMS remark 修改并发标记因用户程序变动的内容  stop the world</p><p>4）并发清除：CMS concurrent sweep 清除不可达对象回收空间，同时有新垃圾产生，留着下次清理称为浮动垃圾 </p><p>由于整个过程中，并发标记和并发清除，收集器线程可以和用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程和用户线程一起并发地执行的。</p><p>​    优点：并发收集，低停顿</p><p>​    缺点：产生大量的空间碎片，并发阶段是会降低吞吐量</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/13.png"></p><p>CMS分为两种模式：</p><p><strong>1.backgroud模式</strong>为正常模式执行上述的CMS GC流程；</p><p><strong>2.foregroud模式</strong>为Full GC模式，可能会切换到其他的老年代垃圾收集器，比如Serial Old（由并发模式失败引起），会发生MSC算法（压缩），通过两个参数设置（UseCMSCompactAtFullCollection，CMSFullGCsBeforeCompaction）。</p><p>并发模式失败：在并发标记过程中还在产生垃圾，如果快要发生OOM，会stw。如果发生这种情况则说明相关参数设置有问题。可以设置参数（CMSFullGCsBeforeCompaction，CMSInitiatingOccupancyFraction）达到内存的百分之几后进入CMS垃圾回收，该参数有一个计算公式：((100-MinHeapFreeRatio)+(double)(CMSTiggerRadio *MinHeapFreeRatio)/100.0)/100.0</p><p><strong>相关参数：</strong></p><p>-XX:+UseConcMarkSweepGC    //开启CMS垃圾收集器</p><p>-XX:+UseCMSCompactAtFullCollection     //默认开启，与-XX:CMSFullGCsBeforeCompaction配合使用 </p><p>-XX:CMSFullGCsBeforeCompaction=0    //默认0 几次Full GC后开始整理</p><p>-XX:+UseCMSInitiatingOccupancyOnly    //辅助CMSInitiatingOccupancyFraction的参数，不然CMSInitiatingOccupancyFraction只会使用一次就恢复自动调整，也就是开启手动调整。</p><p>-XX:CMSInitiatingOccupancyFraction     //取值0-100，按百分比回收，默认-1，当它默认为-1时，它=((100-MinHeapFreeRatio)+(double)(80*MinHeapFreeRatio)/100.0)/100.0</p><p><strong>CMS的缺陷：</strong></p><ol><li><p>单线程效率很低。</p></li><li><p>可能会发生并发失败，进入forgoud模式，发生full GC；可终止的预处理（默认停5秒）非常耗时。建议在晚上没人的时候进行手动full GC，手动整理，通过调整参数（UseCMSCompactAtFullCollection，CMSFullGCsBeforeCompaction），只能做为技术方案。</p></li></ol><h3 id="5-7-G1收集器"><a href="#5-7-G1收集器" class="headerlink" title="5.7 G1收集器"></a>5.7 G1收集器</h3><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection</a></p><p>使用G1（拷贝复制算法）收集器时，Java堆的内存布局与就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region(不需要连续)的集合，Region内部内存连续。每个Region大小都是一样的，可以是1M到32M之间的数值，但是必须保证是2的n次幂，默认内存中有2048个Region。如果对象太大，一个Region放不下[超过Region大小的50%]，那么就会直接放到H中，默认开启TLAB</p><p>设置Region大小：-XX:G1HeapRegionSize=M</p><p>所谓Garbage-Frist，其实就是优先回收垃圾最多的Region区域</p><p>Region的功能: 在某种程度上为了解决空间碎片会有角色转换，比如将old附近的eden转为old使得old连续，其实还是会存在空间碎片，它会有价值分析。Region分类（4大类）：1.FreeTag，空Region。2.Young分为EdenTag和SurvTag。3.HumMask分为HumStartsTag（头部区分）和HumContTag（连续区分）。4.OldTag</p><p><strong>特点：</strong></p><p>​    1. 并发和并行</p><p>​    2. 分代收集（仍然保留了分代的概念）</p><p>​    3. 空间整合（整体上属于“标记-整理”算法，不会导致空间碎片）</p><p>​    4. 可预测的停顿（比CMS更先进的地方在于能让使用者明确地指定一个长度为M毫秒地时间片段内，消耗在垃圾收集上的时间不得超过N毫秒）。</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/14.png"></p><p>工作过程分为以下几步：</p><p>​    1.初始标记（Initial Marking）：标记一下GC Roots能够关联的对象，并且修改TAMS的值，需要暂停用户线程。</p><p>​    2.并发标记（Concurrent Marking）：从GC Roots进行可达性分析，找出存活的对象，与用户线程并发执行。</p><p>​    3.最终标记（Final Marking）：修正在并发标记阶段因为用户程序的并发执行导致标动的数据，需要暂停用户线程。</p><p>​    4.筛选回收（Live Data Counting and Evacuation）：堆各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制定回收计划。</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/15.png"></p><p>G1中有三种GC：</p><p>young GC（初始标记阶段）：stw-&gt;选择新生代的region-&gt;根扫描-&gt;更新rset，记录引用变化-&gt;进行对象的复制到survivor-&gt;重构Rset-&gt;释放内存-&gt;进行大对象的回收-&gt;动态的扩展内存-&gt;动态调整Region数量-&gt;启动并发标记。</p><p>mixed GC：执行youngGC + 回收收益高的若干个old区。触发时机就是看时间够不够。</p><p>full GC：没有足够的region</p><p>可以看出三种GC都要回收young区。年轻代指向老年代的问题在G1中基本不会发生，但是相反的话就有问题了，这时引入了Rset（引用集）是卡表的升级版，是异步的，引入DCQS（Dirty Card Queue Set）的队列，当对象的引用发生变化且引用的对象位于老年代时会将数据放入队列中，当队列满了后才放入set中。两种引用关系：Point out和Point in。例如obj1 = obj2，那么Point out就是在obj1中记录obj2而Point In就是在obj2中记录obj1。G1使用的是Point in，而CMS使用的是Point out。为什么G1不适用Point out，因为它会造成扫描浪费。</p><p>Rset（大概消耗5%~10%的空间）用了三种数据结构：</p><ol><li><p>稀疏表（针对卡页），本质是hash表，它的key是Region的起始地址， Value是一个数组，数组中存储的比如说是卡页数据的索引号，其实它就是一个字典。每个Region都会划分成多个512k的card page，而card page的位置（索引号）记录在稀疏表中。</p></li><li><p>细粒度位图（针对卡页），是C语言实现的位图，记录卡页中有对新生代引用的对象。当一个卡页中有对象会引用到年轻代，则位图中相应修改该卡页的记录位脏数据，那么在minorGC扫描时只需要通过位图和稀疏表就可以找到引用到年轻代的对象，在minorGC时就只需要扫描GC root和对年轻代有引用的对象即可。</p></li><li><p>粗粒度位图，当位图的数量达到一个阈值后而且内存足够，使用粗粒度位图后一位指定一个Region。来减少位图的数量。</p></li></ol><p>因为是并发的垃圾收集器，所以Rset中会有写入乱序的问题，G1用写屏障来解决，但是会有额外的开销，很容易带来内存的伪共享。这时会有一个参数控制：-XX:+UseCondCardMark,意思是在写屏障阶段，如果一个卡页被标识了，那就不再标识了。</p><p><strong>三色标记算法</strong>：它的颜色是一种逻辑，其实是三种状态，将垃圾收集器未扫描过的标为白色，扫描完安全存在的标为黑色，正在扫描的标为灰色。CMS处理当对象引用增加时，会将引用改变的对象都标记为灰色进行重新扫描，而G1处理当对象引用消失后把它推到栈中。</p><p><strong>相关参数</strong></p><p>-XX: +UseG1GC 开启G1垃圾收集器</p><p>-XX: G1HeapReginSize 设置每个Region的大小，是2的幂次，1MB-32MB之间</p><p>-XX:MaxGCPauseMillis 最大停顿时间</p><p>-XX:ParallelGCThread 并行GC工作的线程数</p><p>-XX:ConcGCThreads 并发标记的线程数</p><p>-XX:InitiatingHeapOcccupancyPercent 默认45%，代表GC堆占用达到多少的时候开始垃圾收集，JDK8中没有</p><h3 id="5-8-ZGC"><a href="#5-8-ZGC" class="headerlink" title="5.8 ZGC"></a>5.8 ZGC</h3><p><a href="https://docs.oracle.com/en/java/javase/11/gctuning/z-garbage-collector1.html#GUID-A5A42691-095E-47BA-B6DC-FB4E5FAA43D0">https://docs.oracle.com/en/java/javase/11/gctuning/z-garbage-collector1.html#GUID-A5A42691-095E-47BA-B6DC-FB4E5FAA43D0</a></p><p>JDK11新引入的ZGC收集器，不管是物理上还是逻辑上，ZGC中已经不存在新老年代的概念了，会分为一个个page，当进行GC操作时会对page进行压缩，因此没有碎片问题只能在64位的linux上使用，目前用得还比较少。</p><p>​    （1）可以达到10ms以内的停顿时间要求</p><p>​    （2）支持TB级别的内存</p><p>​    （3）堆内存变大后停顿时间还是在10ms以内</p><p><img src="/image/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/16.png"></p><p>特点：</p><ol><li><p>读屏障</p></li><li><p>指针染色技术</p></li></ol><p>通过读屏障判断指针的颜色，判断对象引用是否被转移，这两特点时并发转移的关键点。ZGC用指针（64为操作系统一共64bit）中的4bit记录对象的引用变化（染色）。ZGC最大支持4TB，Linux中指针前18为不能用，64-18-4=42，2的42次方就是4TB。</p><h3 id="5-9-垃圾收集器的分类"><a href="#5-9-垃圾收集器的分类" class="headerlink" title="5.9 垃圾收集器的分类"></a>5.9 垃圾收集器的分类</h3><ol><li>串行收集器 -&gt; Serial和Serial Old</li></ol><p>​    只能有一个垃圾回收线程执行，用户线程暂停（适用于内存比较小的嵌入式设备）。</p><p>2.并行收集器（吞吐量优先） -&gt; Parallel Scanvenge，Parallel Old</p><p>​    多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态（适用于科学计算，后台处理等弱交互场景）。</p><p>3.并发收集器（停顿时间优先）-&gt; CMS，G1</p><p>​    用户线程和垃圾收集线程同时执行（但并不一定是并行的，可能是交替执行的），垃圾收集线程在执行的时候不会停顿用户线程的运行（适用于相对对时间有要求的场景，比如web）。</p><h3 id="5-10-常见问题"><a href="#5-10-常见问题" class="headerlink" title="5.10 常见问题"></a>5.10 常见问题</h3><p><strong>（1）理解吞吐量和停顿时间</strong></p><p>​    1. 停顿时间 -&gt;垃圾收集器进行垃圾回收终端应用执行响应的时间</p><p>​    2. 吞吐量 -&gt; 运行用户代码时间/(运行用户代码时间+垃圾收集时间)</p><p>​    停顿时间越短越适合需要和用户交互的程序，良好的响应速度能提升用户体验，高吞吐量则可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>​    小结：这两个指标也是评价垃圾回收期好处的标准，其实调优也是在观察这两个变量。</p><p><strong>（2）如何选择合适和垃圾收集器</strong></p><p>  <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28</a></p><p>​    1.优先调整堆的大小让服务器自己来选择</p><p>​    2.如果内存小于100M，使用串行收集器</p><p>​    3.如果是单核，并且没有停顿时间要求，使用串行或JVM自己选</p><p>​    4.如果允许停顿时间超过1秒，选择并行或JVM自己选</p><p>​    5.如果响应时间最重要，并且不能超过1秒，使用并发收集器</p><p><strong>（3）对于G1收集器：</strong></p><p>JDK7开始使用，JDK8非常成熟，JDK9默认的垃圾收集器，适用于新老年代。</p><p>判断是否需要使用G1收集器？（1）50%以上的堆被存活对象占用（2）对象分配和晋升的速度变化非常大（3）垃圾回收时间比较长</p><p><strong>（4）G1中的RSet</strong></p><p>​    全称Remembered Set，记录维护Region中对象的引用关系。试想，在G1垃圾收集器进行新生代的垃圾收集时，也就是Minor GC，假如该对象被老年代的Region中所引用，这时候新生代的该对象就不能被回收，怎么记录呢？不妨这样，用一个类似于hash的结构，key记录region的地址，value表示引用该对象的集合，这样就能知道该对象被哪些老年代的对象所引用，从而不能回收。</p><p><strong>（5）如何开启需要的垃圾收集器</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby">(<span class="hljs-number">1</span>)串行<br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+UseSerialGC</span><br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+UseSerialOldGC</span><br>(<span class="hljs-number">2</span>)并行(吞吐量优先)<br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+UseParallelGC</span><br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+UseParallelOldGC</span><br>(<span class="hljs-number">3</span>)并发收集器(响应时间优先)<br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:UseConcMarkSweepGC</span><br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:UseG1GC</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存模型</title>
    <link href="/2023/03/09/java%E5%9F%BA%E7%A1%80/jvm/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/03/09/java%E5%9F%BA%E7%A1%80/jvm/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-图解"><a href="#1-图解" class="headerlink" title="1 图解"></a>1 图解</h2><p>一块是非堆区，一块是堆区。堆分为两大区，old区和young区。young区分为两大快，一个是Survivor区（s0+s1），一块是Eden区。 Eden:s0:s1=8:1:1。s0和s1一样大，也可以叫做From和To。</p><p><img src="/image/jvm/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1.png"></p><h2 id="2-对象创建所在区域"><a href="#2-对象创建所在区域" class="headerlink" title="2 对象创建所在区域"></a>2 对象创建所在区域</h2><p>一般情况下，新创建的对象都会被分配到Eden区，一些特殊大的对象会直接分配到Old区。</p><p><img src="/image/jvm/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/2.png"></p><p>比如有对象A，B，C等创建在Eden区，但是Eden区的内存空间肯定有限，比如有100M，假如已经用了100M或者达到一个设定的阈值，这时就需要对Eden区内存空间进行清理，即垃圾回收（Garbage Collect），这样的GC称为Minor GC，Minor GC指的是Young区的GC。经过GC后，有些对象就会被清理掉，有些对象可能还活着，对于存活着的对象需要将其复制到Survivor区，然后再清空Eden区中的这些对象。</p><h2 id="3-Survivor区详解"><a href="#3-Survivor区详解" class="headerlink" title="3 Survivor区详解"></a>3 Survivor区详解</h2><p>由图解可知，Survivor区分为两块s0和s1，也可以叫做From和To。在同一时间点上，s0和s1只能有一个存有数据，另外一个是空的。</p><p>接着上面的GC来说，比如一开始只有Eden区和From中有对象，To中是空的。此时进行一次GC操作，From区中对象的年龄就会+1，Eden区中所有存活的对象会被复制到To区，From区中还能存活的对象会有两个去处。若对象达到之前设置好的年龄阈值，此时对象会被移动到Old区，如果Eden区和From区没有达到阈值的对象会被复制到To区。此时Eden区和From区已经被清空（被GC的对象肯定没了，没有被GC的对象都有了各自的去处）。这时候From和to交换角色，之前的from变成了to，之前的to变成了from。也就是说无论如何都要保证名为to的survivor区域是空的。Minor GC会一直重复这样的过程，直到to区被填满，然后将所有对象复制到老年代中。</p><h2 id="4-old区详解"><a href="#4-old区详解" class="headerlink" title="4 old区详解"></a>4 old区详解</h2><p>从上面的分析可以看出，一般old区都是年龄比较大的对象，或者相对超过了某个阈值的对象。在old区也会有GC的操作。</p><h2 id="5-对象的一辈子理解"><a href="#5-对象的一辈子理解" class="headerlink" title="5 对象的一辈子理解"></a>5 对象的一辈子理解</h2><p>我是一个普通的java对象，我出生在Eden区，在Eden区我还看到和我长得很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区的人实在是太多了，我被迫去了survivor区的from区，自动去了survivor区，我就开始漂了，有时候在from区，有时候在to区，居无定所，直到我18岁的时候，我成人了，于是我去了old区，old区人很多，并且年龄都比较大，我在这里认识了很多人。在old区中，我生活了20年（每次GC加一岁），然后被回收。</p><h2 id="6-常见问题"><a href="#6-常见问题" class="headerlink" title="6 常见问题"></a>6 常见问题</h2><ol><li>为什么需要survivor区？只有Eden区不行吗？</li></ol><p>​    如果没有survivor，eden区每进行一次Minor GC，并且没有年龄限制的话，存活的对象就会被送到老年代。这样依赖，老年代很快被填满，触发full GC。老年代的内存空间远大于新生代，进行一次GC消耗的时间比新生代长的多。频发的full gc消耗的时间很长，会影响大型程序的执行和响应速度。</p><p>​    那就对老年代的空间进行增加或者减少咯。假如增加老年代的空间，更多存活对象才能填满老年代。虽然减少full gc的频率，但是随着老年代的空间变大，一旦发生full gc，执行所需时间会更长。假如减少老年代的空间，虽然full gc所需要的时间减少，但是老年代很快被存活对象填满，Full gc频率增减。</p><p>​    所以survivor的存在意义，就是减少被送到老年代的对象，进而减少full gc的发生，survivor的预筛选保证，只有经历16次minor gc还能再新生代中存活的对象，才会被送到老年代中。</p><ol start="2"><li>为什么要有两个survivor区？</li></ol><p>​    最大的好处是解决了碎片化，也就是说为什么一个survivor区不行？第一问题中，知道了必须设置survivor区。假设现在只有一个survivor区，模拟一下流程：刚刚新建的对象再eden中。一旦eden满了，触发一次minor gc，eden中的存活对象就会被移动到survivor区。这样继续循环下去，下一次eden满了的时候，问题来了，此时进行minor gc，eden和survivor各有一些存活对象，如果此时把eden区的存活对象硬放到survivor，很明显这两部分对象所占有的内存是不连续的，也就导致了内存碎片化。</p><ol start="3"><li>新生代eden:s1:s2为什么是8:1:1?</li></ol><p>​    新生代中的可用内存：复制算法用来担保的内存是9:1，可用内存中eden:s1为8:1，即新生代中eden:s1:s2是8:1:1。</p><ol start="4"><li>如何理解各种GC</li></ol><p>​    Partial GC：其实也就是部分的意思。那么翻译过来也就是回收部分GC堆的模式，他并不会回收整个堆。而young GC以及Old GC都属于这种模式，young GC 只回收young区，old GC只回收Old区。</p><p>​    full GC：实际上就是对于整体回收。</p><ol start="5"><li>堆内存中都是线程共享的区域吗？</li></ol><p>JVM默认为每个线程在Eden上开辟一个buffer区域，用来加速对象的分配，称之为<strong>TLAB</strong>，全称:Thread Local Allocation Buffer。对象优先会在TLAB上分配，但是TLAB空间通常会比较小，如果对象比较大，那么还是在共享区域分配。</p><p><img src="/image/jvm/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/3.png"></p><ol start="6"><li>各种GC的触发条件</li></ol><p>Young GC：空间不够，fullGC会先触发young gc，在某些垃圾收集器在进行oldGC前会触发young GC。</p><p>Full GC：（1）悲观策略：a.之前每次晋升对象的平均大小比Old区的剩余空间大；b.minor GC后存活的对象比Old区的剩余空间大（2）常规策略：metaspace空间不足(一般是内存泄漏)；System.gc();</p><h2 id="7-体验与验证"><a href="#7-体验与验证" class="headerlink" title="7 体验与验证"></a>7 体验与验证</h2><p>使用visualvm，其中下载插件：visualgc插件下载链接：<a href="https://visualvm.github.io/pluginscenters.html">https://visualvm.github.io/pluginscenters.html</a></p><p>选择对应JDK版本链接—&gt;Tools—&gt;Visual GC。</p><h3 id="7-1-堆内存溢出"><a href="#7-1-堆内存溢出" class="headerlink" title="7.1 堆内存溢出"></a>7.1 堆内存溢出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapController</span>&#123;<br>    List&lt;Person&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-meta">@GetMapping(&quot;/heap&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">heap</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>记得设置参数比如：-Xmx20M -Xms20M</p><p><img src="/image/jvm/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/4.png"></p><h3 id="7-2-方法区内存溢出"><a href="#7-2-方法区内存溢出" class="headerlink" title="7.2 方法区内存溢出"></a>7.2 方法区内存溢出</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>asm<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>asm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//向方法区中添加Class信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMetaspace</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Class&lt;?&gt;&gt; createClasses() &#123;<br>        List&lt;Class&lt;?&gt;&gt; classes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10000000</span> ; ++i)&#123;<br>            <span class="hljs-type">CLassWriter</span> <span class="hljs-variable">cw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(<span class="hljs-number">0</span>);<br>            cw.visit(Opcodes.v1_1, Opcodes.ACC_PUBLIC, <span class="hljs-string">&quot;CLass&quot;</span> + i, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-literal">null</span>);<br>            <span class="hljs-type">MethodVisitor</span> <span class="hljs-variable">mw</span> <span class="hljs-operator">=</span> cw.visitMethod(Opcodes.ACC_PUBLIC, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>            mw.visitVarInsn(Opcodes.ALOAD, <span class="hljs-number">0</span>);<br>            mw.visitMethodInsn(Opcodes.INVOKESPECIAL, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-string">&quot;&lt;init&gt;&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>);<br>            mw.visitInsn(Opcodes.RETURN);<br>            mw.visitMaxs(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>            mw.visitEnd();<br>            <span class="hljs-type">Metaspace</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Metaspace</span>();<br>            <span class="hljs-type">byte</span>[] code = cw.toByteArray();<br>            Class&lt;?&gt; exampleClass = test.defineClass(<span class="hljs-string">&quot;Class&quot;</span> + i, code, <span class="hljs-number">0</span>, code.length);<br>            classes.add(exampleClass);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> classs NonHeapController&#123;<br>    List&lt;Class&lt;?&gt;&gt; list - <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-meta">@GetMapping(&quot;/nonheap&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">nonheap</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            list.addAll(MyMetaspace.createClasses());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置Metaspace的大小，比如-XX:MetaspaceSize=50M -XX:MaxMetaspaceSize=50M</p><p><img src="/image/jvm/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/5.png"></p><h3 id="7-3-虚拟机栈"><a href="#7-3-虚拟机栈" class="headerlink" title="7.3 虚拟机栈"></a>7.3 虚拟机栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">stackDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">long</span> i)</span>&#123;<br>        System.out.printLn(count++);<br>        method(i);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        method(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/jvm/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/6.png"></p><p>Stack Space用来做方法的递归调用时压入Stack Frame(栈帧)。所以当递归调用太深的时候，就有可能耗尽Stack Space，爆出StackOverflow的错误。</p><p>-Xss128k：设置每个线程的堆栈大小。JDK 5以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。 根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对 一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p><p>线程栈的大小是个双刃剑，如果设置过小，可能会出现栈溢出，特别是在该线程内有递归、大的循环时出现溢 出的可能性更大，如果该值设置过大，就有影响到创建栈的数量，如果是多线程的应用，就会出现内存溢出的 错误。</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运行时数据区</title>
    <link href="/2023/03/08/java%E5%9F%BA%E7%A1%80/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    <url>/2023/03/08/java%E5%9F%BA%E7%A1%80/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<p>在加载阶段的第二三步可以发现由运行时数据，堆，方法区等名词。第二步将这个字节流所代表的静态存储机构转化为方法区的运行时数据结构。第三步在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区中这些数据的访问入口。说白了就是类文件被类加载器加载进来之后，类中的内容（比如变量，常量，方法，对象等这些数据得要有个去处，也就是要存起来，存储的位置肯定是JVM中有对应的空间）</p><h2 id="1-官网概括"><a href="#1-官网概括" class="headerlink" title="1 官网概括"></a>1 官网概括</h2><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p><h2 id="2-图解"><a href="#2-图解" class="headerlink" title="2 图解"></a>2 图解</h2><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/1.png"></p><h2 id="3-常规理解"><a href="#3-常规理解" class="headerlink" title="3 常规理解"></a>3 常规理解</h2><h3 id="3-1-常量池"><a href="#3-1-常量池" class="headerlink" title="3.1 常量池"></a>3.1 常量池</h3><p>常量池分为静态常量池，运行时常量池，还有字符串常量池。</p><p><strong>静态常量池：</strong>其实储存的就是字面量以及符号引用。</p><p><strong>运行时常量池：</strong>运行时常量池就是每个类以及每个接口在JVM进行run的过程中所在内存中开辟出来 的一块用来储存静态常量池部分数据的一块特殊区域。</p><p><strong>字符串常量池：</strong>包含在动态常量池中。</p><p><strong>Jdk8中各常量池在内存中的划分：</strong></p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/2.png"></p><h3 id="3-2-方法区-Method-Area"><a href="#3-2-方法区-Method-Area" class="headerlink" title="3.2 方法区(Method Area)"></a>3.2 方法区(Method Area)</h3><p>方法区是各个线程共享的内存区域，在虚拟机启动时创建。用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译后的代码等数据。虽然java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做Non-Heap（非堆），目的是与java堆区分开。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><p>此时回看加载阶段的第二步：将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。如果这时候把从class文件到装载的第一二步合并起来理解的话，可以画个图：</p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/3.png"></p><p>方法区在JDK8中就是Metaspace（直接内存，也就是系统内存），在JDK6或7中就是Perm Space。JVM在使用类加载器时会为其分配一个内存列表，会进行线性分配，内存列表的大小取决与类加载器。在GC时1.7之前会对内存列表进行线性卸载，而1.8会对类加载器和其所属的内存列表整个卸载。</p><h3 id="3-3-堆-Heap"><a href="#3-3-堆-Heap" class="headerlink" title="3.3 堆(Heap)"></a>3.3 堆(Heap)</h3><p>java堆是java虚拟机所管理内存中最大的一块，在虚拟机启动时创建，被所有线程共享。java对象实例以及数组都在堆上分配。此时回看装载阶段的第三步：在java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/4.png"></p><h3 id="3-4-虚拟机栈-Java-Virtual-Machine-Stacks"><a href="#3-4-虚拟机栈-Java-Virtual-Machine-Stacks" class="headerlink" title="3.4 虚拟机栈(Java Virtual Machine Stacks)"></a>3.4 虚拟机栈(Java Virtual Machine Stacks)</h3><p>虚拟机栈是一个线程执行的区域，保存着一个线程中方法的调用状态。换句话说，一个java线程的运行状态，由一个虚拟机栈来保存，所以虚拟机栈肯定是线程私有的，独有的，随着线程的创建而创建。每一个被线程执行的方法，为该栈中的栈帧，即每个方法对应一个栈帧。调用一个方法，就会向栈中压入一个栈帧；一个方法调用完成，就会把该栈帧从栈中弹出。</p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/5.png"></p><p>官网：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6</a></p><p><strong>栈帧</strong>：每个栈帧对应一个被调用的方法，可以理解为一个方法的运行空间</p><p>每个栈帧中包括局部变量表，操作数栈，指向运行时常量池的引用，方法返回地址和附加信息。</p><p>（1）局部变量表 Local Variables：方法中定义的局部变量以及方法的参数存放在这张表中，局部变量表中的变量不可直接使用，如需要使用的话，必须通过相关指令将其加载到操作数栈中作为操作数使用。</p><p>（2）操作数栈 Operand Stack：以压栈和出栈的方法存储操作数的。</p><p>（3）动态链接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接(Dynamic Linking)。可能发生符号引用转为直接引用。</p><p>（4）方法返回地址：当一个方法开始执行后，只有两种方式可以退出，一种是遇到方法返回的字节码指令；一种是遇到异常，并且这个异常没有在方法体内得到处理。</p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/6.png"></p><h3 id="3-5-程序计数器-The-PC-Register"><a href="#3-5-程序计数器-The-PC-Register" class="headerlink" title="3.5 程序计数器(The PC Register)"></a>3.5 程序计数器(The PC Register)</h3><p>一个JVM进程中有多个线程在执行，而线程中的内容是否能够拥有执行权，是根据CPU调度来的。加入线程A正在执行到某个地方，突然失去了CPU的执行权，切换到线程B了，然后当线程A再获得CPU执行权的时候，怎么能继续执行？这就是需要在线程中维护一个变量，记录线程执行到的位置。</p><p>程序计数器占用的内存空间很小，由于java虚拟机的多线程是通过线程轮流切换，并分配处理器执行时间的方式来实现的。在任意时刻，一个处理器只会执行一条线程中的指令。因此，为了线程切换后能够恢复到正确的执行位置，每条线程需要有一个独立的程序计数器(线程私有)。</p><p>如果线程正在执行java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，则这个计数器为空。</p><h3 id="3-6-本地方法栈-Native-Method-Stacks"><a href="#3-6-本地方法栈-Native-Method-Stacks" class="headerlink" title="3.6 本地方法栈(Native Method Stacks)"></a>3.6 本地方法栈(Native Method Stacks)</h3><p>​    如果当前线程执行的方法是Native类型的，这些方法就会在本地方法栈中执行。</p><h3 id="3-7-另外"><a href="#3-7-另外" class="headerlink" title="3.7 另外"></a>3.7 另外</h3><p>除了上面五块内存之外,其实JVM还会使用到其他两块内存：</p><p><strong>直接内存(Direct Memory)：</strong></p><p>并不是虚拟机运行时数据区的一部分，也不是JVM规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现。在JDK 1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buﬀer)的I/O 方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java 堆里面的DirectByteBuﬀer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能， 因为避免了在Java堆和Native堆中来回复制数据。本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存的大小及处理器寻址空间的限制。因此在分配JVM空间的时候应该考虑直接内存所带来的影响，特别是应用到NIO的场景。</p><p><strong>其他内存:</strong></p><p>Code Cache：JVM本身是个本地程序，还需要其他的内存去完成各种基本任务，比如，JIT 编译器在运行时对热点方法进行编译，就会将编译后的方法储存在Code Cache里面；GC等功能。需要运行在本地线程之中，类似部分都需要占用内存空间。这些是实现JVM的JIT等功能的需要，但规范中并不涉及。</p><h2 id="4-运行时数据区各种元素的引用"><a href="#4-运行时数据区各种元素的引用" class="headerlink" title="4 运行时数据区各种元素的引用"></a>4 运行时数据区各种元素的引用</h2><h3 id="4-1-栈指向谁"><a href="#4-1-栈指向谁" class="headerlink" title="4.1 栈指向谁"></a>4.1 栈指向谁</h3><p>如果在栈帧中有一个变量，类型为引用类型，比如Object obj=new Object()，这时候就是典型的栈中元素指向堆中的对象。</p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/7.png"></p><h3 id="4-2-方法区指向谁"><a href="#4-2-方法区指向谁" class="headerlink" title="4.2 方法区指向谁"></a>4.2 方法区指向谁</h3><p>方法区中会存放静态变量，常量等数据。如果是这种情况，就是典型的方法区中元素指向堆中的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><h3 id="4-3-堆指向方法区"><a href="#4-3-堆指向方法区" class="headerlink" title="4.3 堆指向方法区"></a>4.3 堆指向方法区</h3><p>方法区中会包含类的信息，堆中会有对象，对象与类进行联系即堆指向方法区</p><h3 id="4-4-Java对象内存模型"><a href="#4-4-Java对象内存模型" class="headerlink" title="4.4 Java对象内存模型"></a>4.4 Java对象内存模型</h3><p>一个Java对象在内存中包括3个部分：对象头、实例数据和对齐填充。</p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/8.png"></p><h3 id="4-5-验证hashcode的存储方式"><a href="#4-5-验证hashcode的存储方式" class="headerlink" title="4.5 验证hashcode的存储方式"></a>4.5 验证hashcode的存储方式</h3><p>使用到jol工具。依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jol<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jol-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>    <br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getId</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPassword</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> password;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> username;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUsername</span><span class="hljs-params">(String username)</span>&#123;<br>        <span class="hljs-built_in">this</span>.username = username;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPassword</span><span class="hljs-params">(String password)</span>&#123;<br>        <span class="hljs-built_in">this</span>.password = password;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Integer id)</span>&#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.toString();<br>    &#125;<br>    <span class="hljs-comment">//查看对象的整体结构信息，JOL工具类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(Worker p)</span>&#123;<br>        System.out.printLn(ClassLayout.parseInstance(p).toPrintalbe());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>();<br>        System.out.printLn(work);<br>        Worker.printf(work);<br>        System.out.printLn(work.hashCode());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果：</p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/9.png"></p><p>1791741888这个数字是HashCode值，转换成16进制可得6a cb cf c0，经过对比，由此可得哈希码使用的大端储存。</p><p>例如：十进制数9877，如果用小端存储表示则为： </p><p>高地址  &lt;- - - - - - - - 低地址 10010101<code>[高序字节]</code> 00100110<code>[低序字节]</code> </p><p>用大端存储表示则为：</p><p>低地址  &lt;- - - - - - - - 高地址 00100110<code>[低序字节]</code> 10010101<code>[高序字节]</code></p><p><strong>小端存储：便于数据之间的类型转换，例如：long类型转换为int类型时，高地址部分的数据可以直接截掉。</strong></p><p><strong>大端存储：便于数据类型的符号判断，因为最低地址位数据即为符号位，可以直接判断数据的正负号。</strong></p><h3 id="4-6-Class-Pointer"><a href="#4-6-Class-Pointer" class="headerlink" title="4.6 Class Pointer"></a>4.6 Class Pointer</h3><p>引用定位到对象的方式有两种，一种叫句柄池访问，一种叫直接访问。</p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/10.png"></p><p><strong>句柄池：</strong></p><p>使用句柄访问对象，会在堆中开辟一块内存作为句柄池，句柄中储存了对象实例数据(属性值结构体)的内存地址，访问类型数据的内存地址(类信息，方法类型信息)，对象实例数据一般也在heap中开辟，类型数据一般储存在方法区中。</p><p>优点：reference存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要改变。</p><p>缺点：增加了一次指针定位的时间开销。</p><p><strong>直接访问：</strong></p><p>直接指针访问方式指reference中直接储存对象在heap中的内存地址，但对应的类型数据访问地址需要在实例中存储。</p><p>优点：节省了一次指针定位的开销。</p><p>缺点：在对象被移动时(如进行GC后的内存重新排列)，reference本身需要被修改。</p><p><strong>指针压缩：</strong>在32位系统中，类型指针为4字节32位，在64位系统中类型指针为8字节64位，<em>但是JVM会默认的进行指针压缩</em>，所以上图输出结果中类型指针也是4字节32位。如果关闭指针压缩的话，就可以看到64位的类型指针了，所以通常在部署服务时，JVM内存不要超过32G，因为超过32G就无法开启指针压缩了。</p><p>关闭指针压缩 ： -XX:+UseCompressedOops</p><p>对齐填充，没有对齐填充就可能会存在数据跨内存地址区域存储的情况，在没有对齐填充的情况下，内存地址存放情况如下：</p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/11.png"></p><p>因为处理器只能0x00-0x07，0x08-0x0F这样读取数据，所以想获取这个long型的数据时，处理器必须要读两次内存，第一次(0x00-0x07)，第二次(0x08-0x0F)，然后将两次的结果才能获得真正的数值。</p><p>那么在有对齐填充的情况下，内存地址存放情况是这样的：</p><p><img src="/image/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/12.png"></p><p>现在处理器只需要直接一次读取(0x08-0x0F)的内存地址就可以获得想要的数据了。</p><p>对齐填充存在的意义就是为了提高CPU访问数据的效率，这是一种以空间换时间的做法；虽然访问效率提高了(减少了内存访问次数)，但是在0x07处产生了1bit的空间浪费。<strong>但是有一种情况，父类对象的变量是不会加入到子类对象对齐填充的中间去。</strong></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载器(ClassLoader)</title>
    <link href="/2023/03/08/java%E5%9F%BA%E7%A1%80/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <url>/2023/03/08/java%E5%9F%BA%E7%A1%80/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>负责读取Java字节代码，并转换成java.lang.Class 类的一个实例的代码模块。类加载器除了用于加载类外，还可用于确定类在Java虚拟机中的唯一性。一个类在同一个类加载器中具有唯一性(Uniqueness)，而不同类加载器中是允许同名类存在的，这里的同名是指全限定名相同。但是在整个JVM里，纵然全限定名相同，若类加载器不同，则仍然不算作是同一个类，无法通过 instanceOf 、equals 等方式的校验。</p><h2 id="1-分类"><a href="#1-分类" class="headerlink" title="1 分类"></a>1 分类</h2><p>1） Bootstrap ClassLoader 负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class或Xbootclassoath选项指定的jar，由C++实现，不是ClassLoader子类。</p><p>2） Extension ClassLoader 负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。</p><p>3） App ClassLoader 负责加载classpath中指定的jar包以及Djava.class.path所指定目录下的类和jar包。</p><p>4） Custom ClassLoader 通过java.lang.ClassLoader的子类自定义加载class，属于应用程序根据自身需要定义的ClassLoader，如tomcat，jboss都会根据j2ee规范自行实现ClassLoader。</p><h2 id="2-图解"><a href="#2-图解" class="headerlink" title="2 图解"></a>2 图解</h2><p><img src="/image/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/1.png"></p><p>为什么类加载器要分层？</p><p>​    1.2版本的JVM中，只有一个类加载器，就是现在的“Bootstrap”类加载器。也就是根类加载器。但是这样会出现一个问题。假如用户调用他编写的java.lang.String类。理论上该类可以访问和改变java.lang包下其他类的默认访问修饰符的属性和方法的能力。也就是说，其他的类使用String时也会调用这个类，因为只有一个类加载器，无法判定到底加载哪个。因为Java语言本身并没有阻止这种行为，所以会出现问题。</p><p>这个时候就想到，可不可以使用不同级别的类加载器来对信任级别做一个区分？比如用三种基础的类加载器做为三种不同的信任级别。最可信的级别是java核心API类。然后是安装的拓展类，最后才是在类路径中的类（属于本机的类）。所以，三种基础的类加载器由此生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//App ClassLoader</span><br>        System.out.printLn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>().getClass().getClassLoader());<br>        <span class="hljs-comment">//Ext ClassLoader</span><br>        System.out.printLn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>().getClass().getClassLoader().getParent());<br>        <span class="hljs-comment">//Bootstrap ClassLoader</span><br>        System.out.printLn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>().getClass().getClassLoader().getParent().getParent());<br>        <br>        System.out.printLn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>().getClass().getClassLoader());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/2.png"></p><h2 id="3-JVM类加载机制的三种方式"><a href="#3-JVM类加载机制的三种方式" class="headerlink" title="3 JVM类加载机制的三种方式"></a>3 JVM类加载机制的三种方式</h2><ol><li><p>全盘负责：当一个类加载器负责加载某个class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</p><p> 例如：系统类加载器AppClassLoader加载入口类（含有main方法的类）时，会把main方法所依赖的类及引用的类也载入，依此类推。“全盘负责”机制也可称为当前类加载器负责机制。显然，入口类所依赖的类及引用的类的当前类加载器就是入口类的类加载器。以上步骤只是调用了CLassLoader.loadClass(name)方法，并没有真正定义类。真正加载class字节码文件生成Class对象由“双亲委派”机制完成。</p></li><li><p>父类委托：“双亲委派”是指子类加载器如果没有加载过该目标类，就先委托父类加载器加载该目标类，只有在父类加载器找不到字节码文件的情况下才从自己的类路径中查找并装载目标类。父类委托别名就叫双亲委派机制。</p><p> “双亲委派”机制加载Class的具体过程是：</p></li></ol><p>​    （1）ClassLoader先判断该Class是否已加载，如果已加载，则返回Class对象；如果没有则委托给父类加载器。</p><p>​    （2）父类加载器判断是否加载过该Class，如果已加载，则返回Class对象；如果没有则委托给祖父类加载器。</p><p>​    （3）依此类推，直到始祖类加载器（引用类加载器）。</p><p>​    （4）始祖类加载器判断是否加载过该Class，如果已加载，则返回Class对象；如果没有则尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，则委托给始祖类加载器的子类加载器。</p><p>​    （5）始祖类加载器的子类加载器尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，则委托给始祖类加载器的孙类加载器。</p><p>​    （6）依此类推，直到源ClassLoader。</p><p>​    （7）源ClassLoader尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则返回Class对象；如果载入失败，源ClassLoader不会再委托其子类加载器，而是抛出异常。</p><p>​    “双亲委派”机制只是Java推荐的机制，并不是强制的机制。可以继承java.lang.ClassLoader类，实现自己的类加载器。如果想保持双亲委派模型，就应该重写findClass(name)方法；如果想破坏双亲委派模型，可以重写loadClass(name)方法。</p><ol start="3"><li>缓存机制：缓存机制将会保证所有加载过的Class都将在内存中缓存，当程序中需要使用某个Class时，类加载器先从内存的缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效.对于一个类加载器实例来说，相同全名的类只加载一次，即 loadClass方法不会被重复调用。而这里我们JDK8使用的是直接内存，所以我们会用到直接内存进行缓存。这也就是我们的类变量为什么只会被初始化一次的由来。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">//1.在虚拟机内存中查找是否已经加载过此类。。。类缓存的主要问题所在</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span>(parent != <span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-comment">//先让上一层加载器进行加载</span><br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e)&#123;<br>                <span class="hljs-comment">//ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">//from the non-null parneet class loader</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">//调用此类加载器所实现的findClass方法进行加载</span><br>                c = findClass(name);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(resolve)&#123;<br>            <span class="hljs-comment">//resolverClass方法是当字节码加载到内存后进行链接操作，对文件格式和字节码校验，并为static字段分配空间并初始化，符号引用转为直接引用，访问控制，方法覆盖等</span><br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-打破双亲委派"><a href="#4-打破双亲委派" class="headerlink" title="4 打破双亲委派"></a>4 打破双亲委派</h2><p>双亲委派这个模型并不是强制模型，而且会带来一些的问题。就比如java.sql.Driver这个东西。JDK只能提供一个规范接口，而不能提供实现。提供实现的是实际的数据库提供商。提供商的库总不能放JDK目录里。所以java想到了几种办法可以用来打破双亲委派。</p><p>（1）<strong>SPI</strong> :比如Java从1.6搞出了SPI就是为了优雅的解决这类问题——JDK提供接口，供应商提供服务。编程人员编码时面向接口编程，然后JDK能够自动找到合适的实现。Java 在核心类库中定义了许多接口，并且还给出了针对这些接口的调用逻辑，然而并未给出实现。开发者要做的就是定制一个实现类，在 META-INF/services 中注册实现类信息，以供核心类库使用。比如JDBC中的DriverManager</p><p>（2）<strong>OSGI</strong>:比如我们更加追求程序的动态性，比如代码热部署，代码热替换。也就是就是机器不用重启，只要部署上就能用。OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块都有一个自己的类加载器，当需要更换一个程序模块时，就把程序模块连同类加载器一起换掉以实现代码的热替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>    <span class="hljs-keyword">private</span> String root;<br>    <br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-type">byte</span>[] classData = loadClassData(name);<br>        <span class="hljs-keyword">if</span>(classData == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> defineClass(name, classData, <span class="hljs-number">0</span>, classData.length);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] loadClassData(String className)&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> root + File.separatorChar + className.replace(<span class="hljs-string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="hljs-string">&quot;.class&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">ins</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(fileName);<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">bufferSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span>;<br>            <span class="hljs-type">byte</span>[] buff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[bufferSize];<br>            <br>            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>((length = ins.read(buffer)) != -<span class="hljs-number">1</span>)&#123;<br>                baos.write(buffer, <span class="hljs-number">0</span>, length);<br>            &#125;<br>            <span class="hljs-keyword">return</span> baos.toByteArray();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRoot</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRoot</span><span class="hljs-params">(String root)</span>&#123;<br>        <span class="hljs-built_in">this</span>.root = root;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">MyclassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClassLoader</span>();<br>        classLoader.setRoot(<span class="hljs-string">&quot;E:\\temp&quot;</span>);<br>        <br>        Class&lt;?&gt; testClass = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            testClass = classLoader.loadClass(<span class="hljs-string">&quot;com.neo.classloader.Test2&quot;</span>);<br>            <br>            <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> testClass.newInstance();<br>            System.out.printLn(object.getClass().getClassLoader());<br>        &#125; <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/3.png"></p><p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意：</p><p>​    1、这里传递的文件名需要是类的全限定性名称，即 Test 格式的，因为 defineClass 方法是按这种格式进行处理的。如果没有全限定名，那么需要做的事情就是将类的全路径加载进去，而setRoot就是前缀地址 setRoot + loadClass的路径就是文件的绝对路径。</p><p>​    2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</p><p>​    3、这类Test 类本身可以被 AppClassLoader 类加载，因此不能把 Test.class 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader 加载，而不会通过自定义类加载器来加载。</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载机制</title>
    <link href="/2023/03/08/java%E5%9F%BA%E7%A1%80/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/03/08/java%E5%9F%BA%E7%A1%80/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>类加载机制是指将类的字节码文件所包含的数据读入内存，同时会生成数据的访问入口的一种特殊机制。那么可以得知，类加载的最终产品是数据访问入口。</p><p><img src="/image/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/1.png"></p><p>加载.class文件的方式：</p><p>​    1.从本地系统中直接加载：最常使用</p><p>​    2.通过网络下载class文件：Web Applet，也就是小程序应用</p><p>​    3.从zip，jar等归档文件中加载class文件：后续演变成jar，war格式</p><p>​    4.从专有数据库中提取class文件：JSP应用从专有数据库中提取class文件，极为少见</p><p>​    5.将java源文件动态编译为class文件，也就是运行时计算而成：动态代理技术</p><p>​    6.从加密文件中获取：典型的防class文件被反编译的保护措施。</p><p><img src="/image/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/2.png"></p><h2 id="1-加载-Load"><a href="#1-加载-Load" class="headerlink" title="1  加载(Load)"></a>1  加载(Load)</h2><p>查找和导入class文件</p><p>（1）   通过一个类的全限定名获取定义此类的二进制字节流（由上可知，不一定从字节码文件中获得，还有很多方法）。那么这个时候需要一个工具来寻找获取类二进制字节流。而java中正好有这么一段代码模块，可以实现通过类全名来获取此类的二进制字节流这个动作，并且将这个动作放到java虚拟机外部去实现，以便让应用程序决定如何获取所需要的类，实现这个动作的代码就是“类加载器“</p><p>（2）   将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p><p>（3）   在java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口</p><p> 注：获取类的二进制字节流的阶段是java程序员最关注的阶段，也是操控性最强的一个阶段。因为这个阶段可以对于类加载器进行操作，比如想自定义类加载器进行操作用以完成加载，又或者想通过java agent来完成字节码增强操作。</p><p>​    在装载完成之后，这时在内存中，运行时数据区的方法区以及堆就已经有数据了。即时编译之后的热点代码并不在这个阶段进入方法区。</p><p>​    方法区：类信息、静态常量、常量</p><p>​    堆：代表被加载类的java.lang.Class对象</p><h2 id="2-链接-Link"><a href="#2-链接-Link" class="headerlink" title="2 链接(Link)"></a>2 链接(Link)</h2><h3 id="2-1-验证-Verify"><a href="#2-1-验证-Verify" class="headerlink" title="2.1 验证(Verify)"></a>2.1 验证(Verify)</h3><p>验证只是为了确保Class文件中的字节流包含的信息完全符合当前虚拟机的要求，并且还要求文件中的信息不会危害虚拟机自身的安全，导致虚拟机的奔溃。</p><p>1） 文件格式验证：验证字节流是否符合class文件格式的规范，并且能够被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确的解析并存储于方法区之内。这阶段的验证是基于二进制字节流进行的，只有经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面验证都是基于方法区的存储结构进行的。</p><p>举例：是否以16进制cafebabe开头；版本号是否正确。</p><p>2） 元数据验证：对类的元数据信息进行语义校验(其实就是对java语法校验)，保证不存在不符合java语法规范的元数据信息。</p><p>举例：是否有父类；是否继承了final类；一个非抽象类是否实现了所有的抽象方法。</p><p>3） 字节码验证：进行数据流和控制流分析，确定程序语义是合法的,符合逻辑的。对类的方法体进行校验分析，保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。字节码的验证相对来说较为复杂。</p><p>举例：运行检查；栈数据类型和操作码参数吻合(比如栈空间只有4个字节，但是实际需要的远远大于4个字节，那么这时字节码就是有问题的)；跳转指令指向合理的位置。</p><p>4） 符号引用验证：这时最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候(解析阶段)，可以看作是对类自身以外的信息(常量池中的各种符号引用)进行匹配性的校验。符号引用验证的目的是确保解析动作能正常执行。</p><p>举例：常量池中描述类是否存在；访问的方法或者字段是否存在且具有足够的权限。</p><p>但是，很多情况下可能认为代码肯定是没有问题的，验证过程完全没必要，那么其实可以添加参数取消验证：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">-Xverify: <span class="hljs-built_in">none</span><br></code></pre></td></tr></table></figure><h3 id="2-2-准备-Prepare"><a href="#2-2-准备-Prepare" class="headerlink" title="2.2 准备(Prepare)"></a>2.2 准备(Prepare)</h3><p>为类的静态变量分配内存，并将其初始化为默认值。</p><table><thead><tr><th>数据类型</th><th>零值</th></tr></thead><tbody><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>short</td><td>(short)0</td></tr><tr><td>char</td><td>‘\u0000’</td></tr><tr><td>byte</td><td>(byte)0</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0d</td></tr><tr><td>reference</td><td>null</td></tr></tbody></table><p>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化。这个不会为实例变量(也就是没加static)分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//正常打印0，因为静态变量i在准备阶段会有默认值0</span><br>        System.out.printLn(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//编译不通过，因为局部变量没有赋值不能被使用</span><br>        <span class="hljs-type">int</span> <span class="hljs-number">1</span>;<br>        System.out.printLn(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进行分配内存的只是包括类变量(静态变量)，而不包括实例变量，实例变量是在对象实例化时随着对象一起分配在java堆中的。通常情况下，初始值为零值，假设public static int a = 1；那么a在准备阶段过后的初始值为0，不为1，这时只是开辟了内存空间，并没有运行java代码，a赋值为1的指令是程序被编译后，存放于类构造器(方法)中，所以a被赋值为1是在初始化阶段才会执行。</p><p>​    对于一些特殊情况,如果类字段属性表中存在ConstantValue属性，那在准备阶段变量a就会被初始化为ConstantValue属性所指的值。</p><p>​    <em>1.ConstantValue属性到底是干什么的?</em></p><p>​    Constant Value属性的作用是通知虚拟机自动为静态变量赋值，只有被static修饰的变量才可以使用这项属性，非static类型的变量的赋值是在实例构造器方法中进行的；static类型变量赋值分两种，在类构造器中赋值，或使用ConstantValue属性赋值。</p><p>​    <em>2.在实际的程序中，什么时候才会用到ConstantValue属性?</em></p><p>​    在实际的程序中，只有同时被final和static修饰的字段才有ConstantValue属性，且限于基本类型和String。编译时javac将会为该变量生成ConstantValue属性，在类加载的准备阶段虚拟机便根据ConstantValue为常量设置相应的值，如果该变量没有被final修饰，或者并非基本类型即字符串，则选择在类构造器中进行初始化。</p><p>​    <em>3.为什么ConstantValue的属性值只限于基本类型和String?</em></p><p>因为常量池中只能引用到基本类型和String类型的字面量。</p><h3 id="2-3-解析-Resolve"><a href="#2-3-解析-Resolve" class="headerlink" title="2.3 解析(Resolve)"></a>2.3 解析(Resolve)</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p><p>​    符号引用就是一组符号来描述目标。可以是任何字面量。引用的目标并不一定已经加载到内存中。</p><p>​    直接引用就是直接指向目标的指针，相对偏移量或一个间接定位到目标的句柄。</p><p>​    直接引用是与虚拟机内存布局实现相关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定存在内存中。</p><p>​    <strong>对解析结果进行缓存:</strong></p><p>​    同一符号引用进行多次解析请求是很常见的，除invokedynamic指令以外，虚拟机实现可以对第一次解析结果进行缓存，来避免解析动作重复进行。无论是否真正执行了多次解析动作，虚拟机需要保证的是在同一个实体中，如果一个引用符号之前已经被成功解析过，那么后续的引用解析请求就应当一直成功；同样的，如果第一次解析失败，那么其他指令对这个符号的解析请求也应该收到相同的异常。</p><p>inDy（invokedynamic）是 java 7 引入的一条新的虚拟机指令，这是自 1.0 以来第一次引入新的虚拟机指令。到了 java 8 这条指令才第一次在 java 应用，用在 lambda 表达式中。 indy 与其他 invoke 指令不同的是它允许由应用级的代码来决定方法解析。</p><h2 id="3-初始化-Initialize"><a href="#3-初始化-Initialize" class="headerlink" title="3 初始化(Initialize)"></a>3 初始化(Initialize)</h2><p>初始化阶段是执行类执行器方法的过程。或者讲的通俗易懂些，在准备阶段，类变量已赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，比如赋值。</p><p>​    在java中对类变量进行初始值设定由两种方式：1.声明类变量时指定初始值。2.使用静态代码块为类变量指定初始值。</p><p>​    按照程序员的逻辑，必须把静态变量定义在静态代码块的前面。因为两个的执行是会根据代码编写的顺序来决定的，顺序搞错了可能会影响业务代码。</p><p>​    JVM初始化步骤：1.假如这个类还没有被加载和连接，则程序先加载并连接该类。2.假如该类的直接父类还没有被初始化，则先初始化其直接父类。3.假如类中有初始化语句，则系统一次执行这些初始化语句。  </p><h2 id="4-使用"><a href="#4-使用" class="headerlink" title="4 使用"></a>4 使用</h2><ol><li>主动引用：只有当对类的主动引用的时候才会导致类的初始化，类的主动使用有6种：</li></ol><p>​    （1）创建类的实例，也就是new的方式。</p><p>​    （2）访问某个类或接口的静态变量，或者对该静态变量赋值</p><p>​    （3）调用类的静态方法</p><p>​    （4）反射，如Class.fonName(“com.carl.Test”)</p><p>​    （5）初始化某个类的子类，则其父类也会被初始化</p><p>​    （6）java虚拟机启动时被标明为启动类的类(JvmCaseApplication)，直接使用java.exe命令来运行某个主类。</p><p>​    2. 被动引用：</p><p>​    （1）引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。</p><p>​    （2）定义类数组，不会引起类的初始化。</p><p>​    （3）引用类的static final常量，不会引起类的初始化，如果只有static修饰，还是会引起类的初始化。</p><h2 id="5-卸载"><a href="#5-卸载" class="headerlink" title="5 卸载"></a>5 卸载</h2><p>在类使用完之后，如果满足下面的情况，类就会被卸载：</p><p>​    （1）该类的所有实例都已经被回收，也就是java堆中不存在该类的任何实例</p><p>​    （2）加载该类的ClassLoader已经被回收。</p><p>​    （3）该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</p><p>​    java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用他们所加载的类的Class对象，因此这些Class对象始终是可触及的。如果以上三个条件全部满足，JVM就会在方法区垃圾回收时堆类进行卸载，类的卸载过程其实就是在方法区种清空类信息，java类的整个声明周期就结束了。但是一般情况下启动类加载器加载的类不会被卸载，而其他两种基础类型的类加载器只有在极少数情况下才会被卸载。</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jvm初识</title>
    <link href="/2023/03/08/java%E5%9F%BA%E7%A1%80/jvm/jvm%E5%88%9D%E8%AF%86/"/>
    <url>/2023/03/08/java%E5%9F%BA%E7%A1%80/jvm/jvm%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1-官网"><a href="#1-官网" class="headerlink" title="1  官网"></a>1  官网</h2><h3 id="1-1-JDK-8"><a href="#1-1-JDK-8" class="headerlink" title="1.1 JDK 8"></a>1.1 JDK 8</h3><p><a href="https://docs.oracle.com/javase/8/">https://docs.oracle.com/javase/8/</a></p><h3 id="1-2-The-relation-of-JDK-JRE-JVM"><a href="#1-2-The-relation-of-JDK-JRE-JVM" class="headerlink" title="1.2  The relation of JDK/JRE/JVM"></a>1.2  The relation of JDK/JRE/JVM</h3><p>Reference -&gt; Developer Guides -&gt; 定位到：<a href="https://docs.oracle.com/javase/8/docs/index.html">https://docs.oracle.com/javase/8/docs/index.html</a></p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/1.png"></p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/2.png"></p><h3 id="1-3-源码到类文件"><a href="#1-3-源码到类文件" class="headerlink" title="1.3 源码到类文件"></a>1.3 源码到类文件</h3><h4 id="1-3-1-源码"><a href="#1-3-1-源码" class="headerlink" title="1.3.1 源码"></a>1.3.1 源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String address;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">hobby</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Programming&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span>&#123;<br>        System.out.printLn(<span class="hljs-string">&quot;person say .....&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> op1, <span class="hljs-type">int</span> op2)</span>&#123;<br>        <span class="hljs-keyword">return</span> op1 + op2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译：javac Person.java -&gt; Person.class</p><h4 id="1-3-2-编译过程"><a href="#1-3-2-编译过程" class="headerlink" title="1.3.2 编译过程"></a>1.3.2 编译过程</h4><p>Person.java -&gt; 词法分析器 -&gt; tokens流 -&gt; 语法分析器 -&gt; 语法树/抽象语法树 -&gt; 语义分析器 -&gt; 注解抽象语法树 -&gt; 字节码生成器 -&gt; Person.class文件</p><p>​    由上可知：编译器其实做的事情就是“对等信息转换”。java文件中的信息其实跟class文件中的信息是一样的。</p><h4 id="1-3-3-类文件-class文件"><a href="#1-3-3-类文件-class文件" class="headerlink" title="1.3.3 类文件(class文件)"></a>1.3.3 类文件(class文件)</h4><p>官网: <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/3.png"></p><ol><li><p>magic（魔数）：The magic item supplies the magic number identifying the file format; it has the value 0xCAFEBABE：café babe.</p></li><li><p>minor_version, major_version：0000 0034 对应十进制的52，代表JDK8中的一个版本</p></li><li><p>constant_pool_count：003f 对应十进制63代表常量池中62个常量</p></li></ol><p><strong>常量池中主要存储两方面的内容：字面量和符号引用。</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">字面量：文本字符串，<span class="hljs-keyword">final</span>修饰等<br>符号引用：类和接口的全限定名、字段名称和描述符、方法名称和描述符<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassFile&#123;<br>u4magic;<br>    u2minor_version;<br>    u2major_version;<br>    u2constant_pool_count;<br>    cp_info constant_pool[constant_pool_count-<span class="hljs-number">1</span>];<br>    u2access_flags;<br>    u2this_class;<br>    u2super_class;<br>    u2interfaces_count;<br>    u2interfaces[interfaces_count];<br>    u2fields_count;<br>    field_infofields[fields_count];<br>    u2methods_count;<br>    method_info methods[methods_count];<br>    u2attributes_count;<br>    attribute_infoattributes[attributes_count];<br>&#125;<br></code></pre></td></tr></table></figure><p>.class字节码文件</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">魔术和<span class="hljs-keyword">class</span>文件版本<br>常量池<br>访问标志<br>类索引、父类索引、接口索引<br>字段表集合<br>方法表集合<br>属性表集合<br></code></pre></td></tr></table></figure><h4 id="1-3-4-反编译验证"><a href="#1-3-4-反编译验证" class="headerlink" title="1.3.4  反编译验证"></a>1.3.4  反编译验证</h4><p>用javap指令验证上述猜想正确性。编译指令：javap -v -p Person.class</p><p>进行反编译之后，查看字节码信息和指令等信息。JVM相对class文件来说可以理解为是操作系统；class文件相对JVM来说可以理解是汇编语言或者机器语言。</p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/4.png"></p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/5.png"></p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/6.png"></p><p>上面分析到常量池中常量的数量是62，接下来来具体分析一下这62个常量，也就是这块包含的信息：cp_info constant_pool[constant_pool_count-1]，cp其实就是一个表格的形式。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">cp_info</span> &#123;<br><span class="hljs-attribute">u1</span> tag;<br><span class="hljs-attribute">u1</span> <span class="hljs-literal">info</span>[];<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4</a></p><p><img src="/image/jvm/jvm%E5%88%9D%E8%AF%86/7.png"></p><p>（1）往下数一个u1，即0a-&gt;10：代表的是CONSTANT_Methodref，表示这是一个方法引用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">CONSTANT_Fieldref_info&#123;<br>u1 tag<span class="hljs-comment">;</span><br>u2 class_index<span class="hljs-comment">;</span><br>u2 name_and_type_index<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>往下数两个u2：</p><p>​    第一个u2，即00 0a-&gt;10：代表的是class_index，表示该方法所属的类在常量池中的索引</p><p>​    第二个u2，即00 2b-&gt;43：代表的是name_and_type_index，表示该方法的名称和类型的索引。</p><p>（2）往下数u1，即08-&gt;8：表示的是CONSTANT_String，表示字符串类型</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">CONSTANT_String_info &#123;<br>u1 tag<span class="hljs-comment">;</span><br>u2 string_index<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>往下数u2，即00 2c-&gt;44：代表的是string_index</p><p>（3）往下数u1，即09 -&gt;9：表示CONSTANT_Fieldref，表示字段类型</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">CONSTANT_Fieldref_info&#123;<br>u1 tag<span class="hljs-comment">;</span><br>u2 class_index<span class="hljs-comment">;</span><br>u2 name_and_type_index<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>往下数两个u2：</p><p>​    第一个u2：即00 0d -&gt;13：代表的是class_index</p><p>​    第二个u2：即00 2d -&gt;45：代表的是name_and_type_index</p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nacos配置中心</title>
    <link href="/2023/03/07/spring%E6%A1%86%E6%9E%B6/springcloud/nacos/nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <url>/2023/03/07/spring%E6%A1%86%E6%9E%B6/springcloud/nacos/nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p><em>Nacos版本：2.0.4  nacos2.x已不支持ribbon，使用nacos2.x需要手动引入LoadBalancer</em></p><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1 基本使用"></a>1 基本使用</h2><p>使用外部数据源</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.platform</span>=<span class="hljs-string">mysql</span><br><span class="hljs-attr">db.num</span>=<span class="hljs-string">1</span><br><span class="hljs-attr">db.url.0</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/mynacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span><br><span class="hljs-attr">db.user</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">db.password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure><h3 id="1-1-本地配置"><a href="#1-1-本地配置" class="headerlink" title="1.1 本地配置"></a>1.1 本地配置</h3><h4 id="1-1-1-实现"><a href="#1-1-1-实现" class="headerlink" title="1.1.1 实现"></a>1.1.1 实现</h4><p>（1）application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">lecturer:</span> <span class="hljs-string">Test</span><br></code></pre></td></tr></table></figure><p>（2）UserController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @Value</span><br><span class="hljs-meta">@Value(&quot;$&#123;lecturer&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String lecturer;<br><br><span class="hljs-meta">@RequestMapping(&quot;/local-config-value&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">localConfigValue</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;lecturer: &quot;</span>+<span class="hljs-built_in">this</span>.lecturer;<br>&#125;<br><br><span class="hljs-comment">// env</span><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> Environment environment;<br><br><span class="hljs-meta">@RequestMapping(&quot;/local-config-env&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">localConfigEnv</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;environment lecturer: &quot;</span>+<span class="hljs-built_in">this</span>.environment.getProperty(<span class="hljs-string">&quot;lecturer&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-1-2-实现原理"><a href="#1-1-2-实现原理" class="headerlink" title="1.1.2 实现原理"></a>1.1.2 实现原理</h4><p><a href="https://docs.spring.io/spring-boot/docs/2.7.6/reference/htmlsingle/#features.external-config">https://docs.spring.io/spring-boot/docs/2.7.6/reference/htmlsingle/#features.external-config</a></p><p>（1）加载application.yml文件中的配置</p><p>PropertySourceLoader#load() -&gt; YamlPropertySourceLoader#load() -&gt; OriginTrackedMapPropertySource</p><p>（2）查看Environment的属性配置源</p><p>SpringApplication#run()  –&gt;debug: configureIgnoreBeanInfo(environment)</p><p>（3）比如在Program arguments中配置timeout=1000，</p><p>观察environment中的 SimpleCommandLinePropertySource</p><p>（4）@Value实现原理</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">（<span class="hljs-number">1</span>）使用BeanPostProcessor解析类上的<span class="hljs-meta">@Value</span>字段<br>（<span class="hljs-number">2</span>）获取到字段上的<span class="hljs-meta">@Value</span>字段<br>（<span class="hljs-number">3</span>）解析<span class="hljs-meta">@Value</span>字段的value属性值，比如age<br>（<span class="hljs-number">4</span>）从environment中的属性配置源OriginTrackedMapPropertySource中寻找age的key<br>（<span class="hljs-number">5</span>）根据key获取到对应的value值<br>（<span class="hljs-number">6</span>）通过field反射的方式设置value值<br></code></pre></td></tr></table></figure><h3 id="1-2-在nacos上创建配置文件"><a href="#1-2-在nacos上创建配置文件" class="headerlink" title="1.2 在nacos上创建配置文件"></a>1.2 在nacos上创建配置文件</h3><p>（1）创建user-dev.yaml文件</p><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/1.png"></p><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/2.png"></p><p>（2）文件存储位置</p><p>mysql     nacos库     config_info表</p><p>nacos home</p><h3 id="1-3-基于HTTP的配置管理"><a href="#1-3-基于HTTP的配置管理" class="headerlink" title="1.3 基于HTTP的配置管理"></a>1.3 基于HTTP的配置管理</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 发布配置</span><br>curl -X POST <span class="hljs-string">&quot;http://127.0.0.1:8848/nacos/v1/cs/configs?</span><br><span class="hljs-string">dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld&quot;</span><br><br><span class="hljs-comment">#获取配置</span><br>curl -X POST <span class="hljs-string">&quot;http://127.0.0.1:8848/nacos/v1/cs/configs?</span><br><span class="hljs-string">dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld&quot;</span><br></code></pre></td></tr></table></figure><h3 id="1-4-基于Java-SDK的配置管理"><a href="#1-4-基于Java-SDK的配置管理" class="headerlink" title="1.4 基于Java SDK的配置管理"></a>1.4 基于Java SDK的配置管理</h3><p><a href="https://nacos.io/zh-cn/docs/sdk.html">https://nacos.io/zh-cn/docs/sdk.html</a></p><p>（1）引入nacos-client包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.nacos<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>nacos-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）编写Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">COnfigExample</span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">serverAddr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;localhost&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">dataId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;redis.yaml&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;DEFAULT_GROUP&quot;</span>;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        properties.put(PropertyKeyConst.SERVER_ADDR, serverAddr);<br>        <span class="hljs-type">ConfigService</span> <span class="hljs-variable">configService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NacosFactory</span>.createConfigService(properties);<br>        <br>        <span class="hljs-comment">//添加监听</span><br>        configService.addListencer(dataId, group, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Listence</span>()&#123;<br>           <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveConfigInfo</span><span class="hljs-params">(String configInfo)</span>&#123;<br>                System.out.printLn(<span class="hljs-string">&quot;receive: &quot;</span> + configInfo);<br>            &#125;<br>            <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">getExecutor</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;);<br>        <br>        <span class="hljs-comment">//发布配置</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isPublishOK</span> <span class="hljs-operator">=</span> configService.publishConfig(dataId, group, <span class="hljs-string">&quot;redis.host: 120.0.0.1:6379&quot;</span>);<br>        System.out.printLn(isPublishOK);<br>        <br>        Threan.sleep(<span class="hljs-number">3000</span>);<br>        <span class="hljs-comment">//获取配置</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> configService.getConfig(dataId, group, <span class="hljs-number">5000</span>);<br>        System.out.printLn(content);<br>        <br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）通过dashboard修改redis.yaml文件中的配置内容，观察监听器的回调打印信息</p><h3 id="1-5-user服务基于SC的配置管理"><a href="#1-5-user服务基于SC的配置管理" class="headerlink" title="1.5 user服务基于SC的配置管理"></a>1.5 user服务基于SC的配置管理</h3><p>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）在resources目录下创建bootstrap.yaml文件，并写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">user</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/3.png"></p><p>（3）启动user服务，如若报错如下信息，则在pom文件中添加bootstrap starter，并重新启动user服 务</p><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/4.png"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（4）创建访问接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Value的方式获取</span><br><span class="hljs-meta">@Value(&quot;$&#123;age&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String age;<br><br><span class="hljs-meta">@RequestMapping(&quot;/nacos-config-value&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">nacosConfigValue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> age;<br>&#125;<br><br><span class="hljs-comment">//Env的方式获取</span><br><span class="hljs-meta">@RequestMapping(&quot;/nacos-config-env&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">nacosConfigEnv</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.environment.getProperty(<span class="hljs-string">&quot;age&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）访问/user/nacos-config-value和/user/nacos-config-env </p><p>（6）通过dashboard修改age的值，不重启项目的情况下 访问/user/nacos-config-env，发现已经更新 访问/user/nacos-config-value，发现没有更新，在UserController上添加@RefreshScope注解后再尝试</p><h3 id="1-6-当前服务的通用配置"><a href="#1-6-当前服务的通用配置" class="headerlink" title="1.6 当前服务的通用配置"></a>1.6 当前服务的通用配置</h3><p>创建user.yaml文件，nacos会自动加载user、user-dev.yaml、user.yaml三个配置文件</p><h3 id="1-7-不同服务的公共配置"><a href="#1-7-不同服务的公共配置" class="headerlink" title="1.7 不同服务的公共配置"></a>1.7 不同服务的公共配置</h3><p>（1）创建公共配置文件mysql.yaml和es.yaml</p><p>（2）在bootstrap.yaml文件中添加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span><br>        <span class="hljs-string">shared-configs[0]:</span><br>          <span class="hljs-attr">data-id:</span> <span class="hljs-string">mysql.yaml</span><br>          <span class="hljs-attr">refresh:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-string">extension-configs[0]:</span><br>          <span class="hljs-attr">data-id:</span> <span class="hljs-string">es.yaml</span><br>          <span class="hljs-attr">refresh:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">user</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><p>（3）启动user服务观察日志并访问</p><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/5.png"></p><h2 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2 源码解析"></a>2 源码解析</h2><h3 id="2-1-nacos发布配置"><a href="#2-1-nacos发布配置" class="headerlink" title="2.1 nacos发布配置"></a>2.1 nacos发布配置</h3><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/%E5%8F%91%E5%B8%83%E9%85%8D%E7%BD%AE.jpg"></p><h3 id="2-2-Spring-Boot启动调用Nacos-API"><a href="#2-2-Spring-Boot启动调用Nacos-API" class="headerlink" title="2.2 Spring Boot启动调用Nacos API"></a>2.2 Spring Boot启动调用Nacos API</h3><p>启动服务时，会从nacos server上获取配置信息[bootstrap.yaml中配置的]，然后保存到environment中的属性配置源PropertySource中。具体使用的是Spring生态中的扩展点：ApplicationContextInitializer。在Spring Cloud提供的初始化器就是PropertySourceBootstrapConfiguration#initialize方法。</p><h3 id="2-3-获取配置"><a href="#2-3-获取配置" class="headerlink" title="2.3 获取配置"></a>2.3 获取配置</h3><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE.jpg"></p><h3 id="2-4-添加监听与配置变更图"><a href="#2-4-添加监听与配置变更图" class="headerlink" title="2.4 添加监听与配置变更图"></a>2.4 添加监听与配置变更图</h3><p><img src="/image/springcloud/nacos/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/nacos%E6%B7%BB%E5%8A%A0%E7%9B%91%E5%90%AC%E4%B8%8E%E9%85%8D%E7%BD%AE%E5%8F%98%E6%9B%B4.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>nacos</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
      <tag>nacos</tag>
      
      <tag>配置中心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenFeign</title>
    <link href="/2023/03/07/spring%E6%A1%86%E6%9E%B6/springcloud/openfegin/openfegin/"/>
    <url>/2023/03/07/spring%E6%A1%86%E6%9E%B6/springcloud/openfegin/openfegin/</url>
    
    <content type="html"><![CDATA[<p><em>新版本的OpenFeign把ribbon移除了，正常使用应该引入LoadBalancer依赖</em></p><h2 id="1-OpenFeign使用"><a href="#1-OpenFeign使用" class="headerlink" title="1 OpenFeign使用"></a>1 OpenFeign使用</h2><p>(1) 整合openfeign依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）写注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserApplication</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）编写FeignClient接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderFeignClient</span> &#123;<br><span class="hljs-meta">@RequestMapping(&quot;/order/query&quot;)</span><br>String <span class="hljs-title function_">query</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）在Controller中使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> OrderFeignClient orderFeignClient;<br><br><span class="hljs-meta">@RequestMapping(&quot;/openfeign&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">openfeign</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.orderFeignClient.query();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Feign单独请求url"><a href="#2-Feign单独请求url" class="headerlink" title="2 Feign单独请求url"></a>2 Feign单独请求url</h2><p>（1）定义FeignClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;jack&quot;,url = &quot;https://ke.gupaoedu.cn/&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">JackFeignClient</span> &#123;<br><span class="hljs-meta">@RequestMapping(&quot;/gupao&quot;)</span><br>String <span class="hljs-title function_">gupao</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> JackFeignClient jackFeignClient;<br><br><span class="hljs-meta">@RequestMapping(&quot;/openfeign-url&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">openfeignUrl</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.jackFeignClient.gupao();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-配置OpenFeign的日志级别"><a href="#3-配置OpenFeign的日志级别" class="headerlink" title="3 配置OpenFeign的日志级别"></a>3 配置OpenFeign的日志级别</h2><p><a href="https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/#feign-logging">https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/#feign-logging</a></p><h3 id="3-1-OrderFeignClient-Java代码方式"><a href="#3-1-OrderFeignClient-Java代码方式" class="headerlink" title="3.1 OrderFeignClient-Java代码方式"></a>3.1 OrderFeignClient-Java代码方式</h3><p>（1）为注解@FeignClient配置configuration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;order&quot;, configuration = OrderFeignClientConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderFeignClient</span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/order/query&quot;)</span><br>    String <span class="hljs-title function_">query</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）新建配置类，并配置日志级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里不需要添加@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderFeignClientConfiguration</span> &#123;<br><span class="hljs-meta">@Bean</span><br>Logger.Level <span class="hljs-title function_">feignLoggerLevel</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">// 将feign的日志级别设置为FULL</span><br><span class="hljs-keyword">return</span> Logger.Level.FULL;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）在application.yml文件中将OrderFeignClient的日志级别设置为debug</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.test.openfeign.OrderFeignClient:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h3 id="3-2-OrderFeignClient-yml文件方式"><a href="#3-2-OrderFeignClient-yml文件方式" class="headerlink" title="3.2 OrderFeignClient-yml文件方式"></a>3.2 OrderFeignClient-yml文件方式</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.test.openfeign.OrderFeignClient:</span> <span class="hljs-string">debug</span><br><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-comment">#目标服务名称</span><br>      <span class="hljs-attr">order:</span><br>       <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">full</span><br></code></pre></td></tr></table></figure><h3 id="3-3-全局配置-Java代码方式"><a href="#3-3-全局配置-Java代码方式" class="headerlink" title="3.3 全局配置-Java代码方式"></a>3.3 全局配置-Java代码方式</h3><p>（1）找到Spring Boot的启动入口类，在@EnableFeignClients注解中配置defaultConfiguration属性， 为其指定全局配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableFeignClients(defaultConfiguration = GlobalFeignConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserApplication</span> immplements ApplicationRunner&#123;&#125;<br></code></pre></td></tr></table></figure><p>（2）新建配置类，并配置日志级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalFeignConfiguration</span> &#123;<br><span class="hljs-meta">@Bean</span><br>Logger.Level <span class="hljs-title function_">feignLoggerLevel</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">// 将feign的日志级别设置为FULL</span><br><span class="hljs-keyword">return</span> Logger.Level.FULL;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）在application.yml文件中将UserFeignClient的日志级别设置为debug</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>   <span class="hljs-attr">com.test.opennfeign.OrderFeignClient:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h3 id="3-4-全局配置-yml文件方式"><a href="#3-4-全局配置-yml文件方式" class="headerlink" title="3.4 全局配置-yml文件方式"></a>3.4 全局配置-yml文件方式</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.jack.user.openfeign.OrderFeignClient:</span> <span class="hljs-string">debug</span><br><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-comment"># 全局配置</span><br>      <span class="hljs-attr">default:</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">full</span><br></code></pre></td></tr></table></figure><h2 id="4-更改OpenFeign调用方式"><a href="#4-更改OpenFeign调用方式" class="headerlink" title="4 更改OpenFeign调用方式"></a>4 更改OpenFeign调用方式</h2><p>将OpenFeign默认使用的HttpURLConnection更改为httpclient</p><p>（1）查看当前http调用方式</p><p>SynchronousMethodHandler#invoke-&gt;executeAndDecode-&gt;client#execute-&gt;Default#execute- &gt;HttpURLConnection</p><p>（2）引入httpclient依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（3）写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-comment"># 全局配置</span><br>      <span class="hljs-attr">default:</span> <br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">full</span><br>  <span class="hljs-attr">httpclient:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">max-connections:</span> <span class="hljs-number">200</span><br>    <span class="hljs-attr">max-connections-per-route:</span> <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><h2 id="5-OpenFeign架构"><a href="#5-OpenFeign架构" class="headerlink" title="5 OpenFeign架构"></a>5 OpenFeign架构</h2><p><img src="/image/springcloud/openFegin/openfeign%E6%9E%B6%E6%9E%84.jpg"></p><h2 id="6-核心源码分析"><a href="#6-核心源码分析" class="headerlink" title="6 核心源码分析"></a>6 核心源码分析</h2><p>Spring Boot启动的时候，会扫描指定的包路径，然后判断接口上有没有添加@FeignClient，通过Spring提供的扩展FactoryBean接口，实现getObject方法实现自定义动态代理类，OrderFeignClient=Proxy#newInstance，将动态代理实现类放到ioc容器中。</p><p>调用接口时orderFeignClient#query() –&gt; Proxy#XXXHandler#invoke() ：通过loadbalancer根据order进行服务发现和负载均衡，然后得到一个localhost:9091/order/query ，调用uri进行结果返回。</p><p><img src="/image/springcloud/openFegin/openfeign%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>OpenFeign</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>OpenFeign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>负载均衡LoadBalancer</title>
    <link href="/2023/03/06/spring%E6%A1%86%E6%9E%B6/springcloud/LoadBalancer/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1LoadBalancer/"/>
    <url>/2023/03/06/spring%E6%A1%86%E6%9E%B6/springcloud/LoadBalancer/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1LoadBalancer/</url>
    
    <content type="html"><![CDATA[<p>nacos2.x已不支持ribbon，使用nacos2.x需要手动引入LoadBalancer</p><h2 id="1-手写随机负载均衡算法"><a href="#1-手写随机负载均衡算法" class="headerlink" title="1 手写随机负载均衡算法"></a>1 手写随机负载均衡算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br><span class="hljs-comment">//通过restTemplate访问随机一个url地址</span><br><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">loadbalance</span><span class="hljs-params">()</span>&#123;<br>    List&lt;ServiceInstance&gt; instances = discoveryClient.getInstance(<span class="hljs-string">&quot;order&quot;</span>);<br>    List&lt;String&gt; uris = instances.stream().map(instance -&gt; instance.getUri().toString() + <span class="hljs-string">&quot;/order/query&quot;</span>).collect(Collections.toList());<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> ThreadLocalRandom.current().nextInt(uris.size());<br>    <span class="hljs-type">String</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> uris.get(i);<br>    System.out.printLn(<span class="hljs-string">&quot;访问地址为&quot;</span> + uri);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.restTemplate.getForObject(uri, String.calss);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-LoadBalancerClient-API"><a href="#2-LoadBalancerClient-API" class="headerlink" title="2 LoadBalancerClient API"></a>2 LoadBalancerClient API</h2><p><a href="https://spring.io/guides/gs/spring-cloud-loadbalancer/">https://spring.io/guides/gs/spring-cloud-loadbalancer/</a></p><p>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> LoadBalancerClient loadBalancerClient;<br><br><span class="hljs-meta">@RequestMapping(&quot;/loadbalancerclient-api&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">loadbalancerclientApi</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">ServiceInstance</span> <span class="hljs-variable">serviceInstance</span> <span class="hljs-operator">=</span> loadBalancerClient.choose(<span class="hljs-string">&quot;order&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> serviceInstance.getUri().toString()+<span class="hljs-string">&quot;/order/query&quot;</span>;<br><span class="hljs-keyword">return</span> restTemplate.getForObject(url,String.class);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-LoadBalanced注解方式"><a href="#3-LoadBalanced注解方式" class="headerlink" title="3 @LoadBalanced注解方式"></a>3 @LoadBalanced注解方式</h2><p>（1）引入loadbalancer starter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）自定义一个@LoadBalanced注解的RestTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span> <span class="hljs-comment">// 相当于为restTemplate整合了lb的能力</span><br><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplateLoadBalancer</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RestTemplate restTemplateLoadBalancer;<br><br><span class="hljs-meta">@RequestMapping(&quot;/loadbalancerclient-annotation&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">loadbalancerclientAnnotation</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.restTemplateLoadBalancer.getForObject(<span class="hljs-string">&quot;http://order/order/query&quot;</span>, String.class);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-更改默认负载均衡方式"><a href="#4-更改默认负载均衡方式" class="headerlink" title="4 更改默认负载均衡方式"></a>4 更改默认负载均衡方式</h2><p><a href="https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#switching-between-the-load-balancing-algorithms">https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#switching-between-the-load-balancing-algorithms</a></p><p>默认的负载均衡为轮询</p><p>（1）定义配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomLoadBalancerConfiguration</span> &#123;<br><span class="hljs-meta">@Bean</span><br>ReactorLoadBalancer&lt;ServiceInstance&gt; <span class="hljs-title function_">randomLoadBalancer</span><span class="hljs-params">(Environment environment, LoadBalancerClientFactory loadBalancerClientFactory)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomLoadBalancer</span>(loadBalancerClientFactory.getLazyProvider(name,ServiceInstanceListSupplier.class), name);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）在启动类上通过@LoadBalancerClients注解使用自定义的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@LoadBalancerClients(defaultConfiguration = CustomLoadBalancerConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserApplication</span> &#123;<br></code></pre></td></tr></table></figure><h2 id="5-核心源码分析"><a href="#5-核心源码分析" class="headerlink" title="5 核心源码分析"></a>5 核心源码分析</h2><p>实际上，loadbalancer注解就是给RestTemplate添加了一个拦截器，调用过程简单来说，就是RestTemplate加上loadbalancer注解后，在创建请求之前添加了一个拦截器，在拦截器中通过服务名称调用LoadBalancer的choose方法，获取到真实的ip:port然后再拼接上具体的接口，替换原有uri，再通过RestTemplate进行远程调用。</p><h3 id="5-1-LoadBalancerClient-choose"><a href="#5-1-LoadBalancerClient-choose" class="headerlink" title="5.1 LoadBalancerClient#choose"></a>5.1 LoadBalancerClient#choose</h3><p>（1）LoadBalancerClient的自动装配</p><p><em>BlockingLoadBalancerClientAutoConfiguration</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnBean(LoadBalancerClientFactory.class)</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> LoadBalancerClient <span class="hljs-title function_">blockingLoadBalancerClient</span><span class="hljs-params">(LoadBalancerClientFactory loadBalancerClientFactory)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingLoadBalancerClient</span>(loadBalancerClientFactory);<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）LoadBalancerClient-choose源码分析</p><p><img src="/image/springcloud/loadbalancer/LoadBalancer-choose%E6%BA%90%E7%A0%81.jpg"></p><h3 id="5-2-LoadBalanced和RestTemplate"><a href="#5-2-LoadBalanced和RestTemplate" class="headerlink" title="5.2 @LoadBalanced和RestTemplate"></a>5.2 @LoadBalanced和RestTemplate</h3><h4 id="5-2-1-RestTamplate调用过程"><a href="#5-2-1-RestTamplate调用过程" class="headerlink" title="5.2.1 RestTamplate调用过程"></a>5.2.1 RestTamplate调用过程</h4><p><img src="/image/springcloud/loadbalancer/1.png"></p><h4 id="5-2-2-RestTemplate使用-LoadBalanced"><a href="#5-2-2-RestTemplate使用-LoadBalanced" class="headerlink" title="5.2.2 RestTemplate使用@LoadBalanced"></a>5.2.2 RestTemplate使用@LoadBalanced</h4><p>（1）向Spring IoC容器中注入RestTemplate的Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span> <span class="hljs-comment">// 相当于为RestTemplate整合了LoadBalancer的功能</span><br><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplateLoadBalancer</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）依赖注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(RestTemplate.class)</span><br><span class="hljs-meta">@ConditionalOnBean(LoadBalancerClient.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(LoadBalancerRetryProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoadBalancerAutoConfiguration</span> &#123;<br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-meta">@Autowired(required = false)</span> <span class="hljs-comment">// 获取到restTemplateLoadBalancer，然后给其添加拦截器</span><br><span class="hljs-keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();<br></code></pre></td></tr></table></figure><p>（3）创建拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> LoadBalancerInterceptor <span class="hljs-title function_">loadBalancerInterceptor</span><span class="hljs-params">(LoadBalancerClient loadBalancerClient,</span><br><span class="hljs-params">                                                       LoadBalancerRequestFactory requestFactory)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoadBalancerInterceptor</span>(loadBalancerClient, requestFactory);<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）给指定的restTemplate添加拦截器属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> RestTemplateCustomizer <span class="hljs-title function_">restTemplateCustomizer</span><span class="hljs-params">(<span class="hljs-keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> &#123;<br><span class="hljs-keyword">return</span> restTemplate -&gt; &#123;<br>        List&lt;ClientHttpRequestInterceptor&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(restTemplate.getInterceptors());<br>list.add(loadBalancerInterceptor);<br>restTemplate.setInterceptors(list);<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）拥有了拦截器能力的RestTemplate</p><p><img src="/image/springcloud/loadbalancer/2.png"></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>LoadBalancer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>LoadBalancer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis常见问题</title>
    <link href="/2023/03/03/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/03/03/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1-数据一致性问题"><a href="#1-数据一致性问题" class="headerlink" title="1   数据一致性问题"></a>1   数据一致性问题</h2><h3 id="1-1-缓存使用场景"><a href="#1-1-缓存使用场景" class="headerlink" title="1.1  缓存使用场景"></a>1.1  缓存使用场景</h3><p>针对读多写少的高并发场景，可以使用缓存来提升查询速度。使用redis作为缓存的时候，一般流程是这样的：</p><ol><li>如果数据在redis存在，应用就可以直接从redis拿到数据，不用访问数据库。</li></ol><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/1.png"></p><ol start="2"><li>应用新增了数据，只保存在数据库中，这个时候redis没有这条数据。如果redis里面没有，先到数据库查询，然后写入到redis，再返回给应用。</li></ol><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/2.png"></p><h3 id="1-2-一致性问题的定义"><a href="#1-2-一致性问题的定义" class="headerlink" title="1.2  一致性问题的定义"></a>1.2  一致性问题的定义</h3><p>因为数据最终是以数据库为准的（这是原则），如果redis没有数据，就不存在这个问题。当redis和数据库都有同一条记录，而这条记录发生变化的时候，就可能出现一致性问题。一旦被缓存的数据发生变化（比如修改，删除）的时候，既要操作数据库的数据，也要操作redis的数据，才能让redis和数据库保持一致。所以问题来了。现在有两种选择：</p><p>​    1.先操作redis的数据再操作数据库的数据</p><p>​    2.先操作数据库的数据再操作redis的数据</p><p>​    首先需要明确的是，不管选择哪一种方案，肯定是希望两个操作要么都成功，要么都不成功。但是，redis的数据和数据库是不可能通过事务达到统一的，只能根据相应的场景和所需要付出的代价来采取一些措施降低数据不一致的问题出现的概率，在数据一致性和性能之间取得一个权衡。</p><p>​    比如，对于数据库的实时性一致性要求不是特别高的场合，比如T+1的报表，可以采用定时任务查询数据库数据同步到redis的方案。由于是以数据库的数据为准的，所以给缓存设置一个过期时间，删除redis的数据，也能保证最终一致性。既然提到了Redis和数据库一致性的问题，一般是希望尽可能靠近实时一致性，操作延迟带来的不一致的时间越少越好。</p><h3 id="1-3-方案选择"><a href="#1-3-方案选择" class="headerlink" title="1.3  方案选择"></a>1.3  方案选择</h3><h4 id="1-3-1-redis：删除还是更新？"><a href="#1-3-1-redis：删除还是更新？" class="headerlink" title="1.3.1 redis：删除还是更新？"></a>1.3.1 redis：删除还是更新？</h4><p>这里补充一点：当存储的数据发生变化，redis的数据也要更新的时候，有两种方案，一种就是直接更新redis数据，调用set；还有一种是直接删除redis数据，让应用在下次查询的时候重新写入。</p><p>​    更新缓存之前，是不是要经过其他表的查询，接口调用，计算才能得到最新的数据，而不是直接从数据库拿到的值。如果是的话，建议直接删除，这种方案更加简单，而且避免了数据库的数据和缓存不一致的情况。在一般情况下，也推荐使用删除的方案。所以，更新操作和删除操作，只要数据变化，都用删除。</p><h4 id="1-3-2-先更新数据库，再删除缓存"><a href="#1-3-2-先更新数据库，再删除缓存" class="headerlink" title="1.3.2 先更新数据库，再删除缓存"></a>1.3.2 先更新数据库，再删除缓存</h4><p>正常情况：更新数据库成功，删除缓存成功。</p><p>异常情况：</p><p>​    1. 更新数据库失败，程序捕获异常，不会走到下一步，数据不会出现不一致。</p><p>​    2. 更新数据成功，删除缓存失败。数据库是新数据，缓存是旧数据，发生了不一致的情况。</p><p>​    对于这个问题，可以提供一个重试机制。比如：如果删除缓存失败，捕获这个异常，把需要删除的key发送到消息队列。然后自己创建一个消费者消费，尝试再次删除这个key。这种方式有个缺点，会对业务代码造成入侵。</p><p>​    所以有了第二种方案(异步更新缓存)：因为更新数据库时会往binlog写入日志，所以可以通过一个服务来监听binlog的变化(比如阿里的canal)，然后在客户端完成删除key的操作。如果删除失败的话，在发送到消息队列。<a href="https://gper.club/articles/7e7e7f7ff3g59gc6g6d">https://gper.club/articles/7e7e7f7ff3g59gc6g6d</a> (canal)。总之，对于后删除缓存失败的情况，我们的做法是不断地重试删除，直到成功。无论是重试还是异步删除，都是最终一致性地思想。</p><h4 id="1-3-3-先删除缓存，再更新数据库"><a href="#1-3-3-先删除缓存，再更新数据库" class="headerlink" title="1.3.3 先删除缓存，再更新数据库"></a>1.3.3 先删除缓存，再更新数据库</h4><p>正常情况：删除缓存成功，更新数据库成功。</p><p>异常情况：</p><p>​    1.删除缓存，程序捕获异常，不会走到下一步，数据不会出现不一致。</p><p>​    2.删除缓存成功，更新数据库失败。因为以数据库的数据为准，所以不存在数据不一致的情况。</p><p>​    看起来好像没有问题，但是如果有程序并发操作的情况下：</p><p>​    1）线程A需要更新数据，首先删除了redis缓存</p><p>​    2）线程B查询数据，发现缓存不存在，到数据库查询旧值，写入redis，返回</p><p>​    3）线程A更新了数据库</p><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/3.png"></p><p>这个时候，redis 是旧值，数据库是新的值，发生了数据不一致的情况。</p><p>​    这个是由线程并发造成的问题，能不能让对同一条数据的访问串行化呢？代码肯定保证不了，因为有多个线程，即使做了任务队列也可能有多个应用实例（应用做了集群部署）。数据库也保证不了，因为会有多个数据库的连接。只有一个数据库只提供一个连接的情况下，才能保证读写的操作的串行的，或者我们把所有的读写请求放到同一个内存队列当中，但是强制串行操作，吞吐量太低了。</p><p>​    所以有一种延时双删的策略，在写入数据之后，再删除一次缓存。</p><p>​    A线程：1）删除缓存。 2）更新数据库。 3）休眠500ms（这个时间，依据读取数据的耗时而定）。 4）再次删除缓存。 伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String key, Object data)</span>&#123;<br>    redis.delKey(key);<br>    db.updateData(data);<br>    Thread.sleep(<span class="hljs-number">500</span>);<br>    redis.delKey(key);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-高并发问题"><a href="#2-高并发问题" class="headerlink" title="2  高并发问题"></a>2  高并发问题</h2><p>在redis存储的所有数据中，有一部分是被频繁访问的。有两种情况可能会导致热点问题的产生，一个是用户集中访问的数据，比如抢购商品，明星结婚和明星出轨的微博。还有一种就是在数据进行分片的情况下，负载不均衡，超过了单个服务器的承受能力。热点问题可能引起缓存服务的不可用，最终造成压力堆积到数据库。出于存储和流量优化的角度，必须要找到这些热点数据。</p><h3 id="2-1-热点数据发现"><a href="#2-1-热点数据发现" class="headerlink" title="2.1  热点数据发现"></a>2.1  热点数据发现</h3><h4 id="2-1-1-客户端"><a href="#2-1-1-客户端" class="headerlink" title="2.1.1 客户端"></a>2.1.1 客户端</h4><p>比如可不可以在所有调用了get，set方法的地方，加上key的计数。但是这样的话，每一个地方都要修改，重复代码也多。如果用的是Jedis的客户端，可以修改Jedis的源码，在jedis的connection类的sendCommand()里面，用一个HashMap进行key的计数。但是这种方式有几个问题：</p><p>​    1.会对客户端的代码造成入侵</p><p>​    2.不知道要存多少个key，可能发生内存泄漏的问题。</p><p>​    3.只能统计当前客户端的热点key。</p><h4 id="2-1-2-代理层"><a href="#2-1-2-代理层" class="headerlink" title="2.1.2 代理层"></a>2.1.2 代理层</h4><p>第二种方式就是在代理层实现，比如TwemProxy或者Codis，但是不是所有的项目都使用了代理的架构。</p><h4 id="2-1-3-服务端"><a href="#2-1-3-服务端" class="headerlink" title="2.1.3 服务端"></a>2.1.3 服务端</h4><p>第三种就是在服务端统计，redis有一个monitor的命令，可以监控到所有redis执行的命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">jedis.monitor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisMonitor</span>()&#123;<br>   <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCommand</span><span class="hljs-params">(String command)</span>&#123;<br>        System.out.printLn(<span class="hljs-string">&quot;#monitor&quot;</span> + command);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>Facebook的开源项目redis-faina就是基于这个原理实现的。它是一个python脚本，可以分析monitor的数据。</p><p><a href="https://github.com/facebookarchive/redis-faina.git">https://github.com/facebookarchive/redis-faina.git</a></p><p>这种方法也会有两个问题：1）monitor命令在高并发的场景下，会影响性能，所以不适合长时间使用。2）只能统计一个redis节点的热点key。</p><h4 id="2-1-4-机器层面"><a href="#2-1-4-机器层面" class="headerlink" title="2.1.4 机器层面"></a>2.1.4 机器层面</h4><p>还有一种方法就是机器层面的，通过对TCP协议进行抓包，也有一些开源的方案，比如ELK的packetbeat插件。发现了热点key之后，来看下热点数据在高并发的场景下可能会出现的问题，以及怎么去解决。</p><h3 id="2-2-缓存雪崩"><a href="#2-2-缓存雪崩" class="headerlink" title="2.2  缓存雪崩"></a>2.2  缓存雪崩</h3><h4 id="2-2-1-什么是缓存雪崩"><a href="#2-2-1-什么是缓存雪崩" class="headerlink" title="2.2.1 什么是缓存雪崩"></a>2.2.1 什么是缓存雪崩</h4><p>缓存雪崩就是Redis的大量热点数据同时过期（失效），因为设置了相同的过期时间，刚好这个时候redis请求的并发量又很大，就会导致所有的请求落到数据库。</p><h4 id="2-2-2-缓存雪崩的解决方案"><a href="#2-2-2-缓存雪崩的解决方案" class="headerlink" title="2.2.2 缓存雪崩的解决方案"></a>2.2.2 缓存雪崩的解决方案</h4><p>​    1）加互斥锁或者使用队列，针对同一个key只允许一个线程到数据库查询</p><p>​    2）缓存定时预先更新，避免同时失效</p><p>​    3）通过加随机数，使得key在不同的时间过期</p><p>​    4）缓存永不过期</p><h3 id="2-3-缓存穿透"><a href="#2-3-缓存穿透" class="headerlink" title="2.3  缓存穿透"></a>2.3  缓存穿透</h3><h4 id="2-3-1-缓存穿透何时发生"><a href="#2-3-1-缓存穿透何时发生" class="headerlink" title="2.3.1 缓存穿透何时发生"></a>2.3.1 缓存穿透何时发生</h4><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/4.png"></p><p>在这里redis起到了提升查询速度和保护数据库的作用。还有一种情况，数据在数据库和redis里面都不存在，可能是一次条件错误的查询。在这种情况下，因为数据库值不存在，所以肯定不会写入redis，那么下一次查询相同的key的时候，肯定还是会再到数据库查一次。那么这种循环查询数据库中不存在的值，并且每次使用的是相同的key的情况，该怎么避免应用到数据库查询？</p><p>​    （1）缓存空数据 （2）缓存特殊字符串，比如&amp;&amp;</p><p>​    可以在数据库缓存一个空字符串，或者缓存一个特殊的字符串。那么在应用里面拿到这个特殊字符串的时候，就知道数据库没有值了，也没有必要再到数据库查询了。但是这里需要设置一个过期时间，不然的话数据库已经新增了这一条记录，应用也还是拿不到值。</p><p>​    这个是应用重复查询同一个不存在的值的情况，如果应用每一次查询的不存在的值是不一样的？即使每次都缓存特殊字符串也没用，因为它的值不一样，比如我们的用户系统登陆的场景，如果是恶意的请求，它每次都生成了一个符合ID规则的账号，但是这个账号在数据库是不存在的，那redis就完全失去了作用。这种因为每次查询的值都不存在导致的redis失效的情况，应该怎么去解决？</p><h4 id="2-3-2-经典面试题"><a href="#2-3-2-经典面试题" class="headerlink" title="2.3.2 经典面试题"></a>2.3.2 经典面试题</h4><p>其实它也是一个通用的问题，关键就在于怎么知道请求的key在数据库中是否存在，如果数据量特别大的话，怎么去快速判断。</p><p>​    这也是一个非常经典的面试题：如何在海量元素中（例如10亿无序，不定长，不重复）快速判断一个元素是否存在？</p><p>​    如果是缓存穿透的这个问题，要避免到数据库查询不存在的数据，肯定要把这10亿放在别的地方。为了加快检索速度，要把数据放到内存里面来判断，问题来了：如果直接把这些元素的值放到基本的数据结构（List，Map，Tree）里面，比如一个元素一字节的字段，10亿的数据大概需要900G的内存空间，这个对于普通的服务器来说是承受不了的。所以，存储着几十亿个元素，不能直接存值，应该找到一种最简单的最节省空间的数据结构，用来标记这个元素有没有出现。（比如签到表顺序打勾）</p><p>​    这个东西叫做位图，它是一个有序的数组，只有两个值，0和1：0代表不存在，1代表存在。</p><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/5.png"></p><p>对于这个映射方法，有几个基本的要求：</p><p>​    1）因为值长度是不固定的，希望不同长度的输入，可以得到固定长度的输出。</p><p>​    2）转换成下标的时候，希望他在我的这个有序数组里面是分布均匀的，不然的话全部挤到一对去了，也没办法判断哪个元素存了，哪个元素没存。</p><p>​    这个就是哈希函数，比如MD5，SHA-1等等这些都是常见的哈希算法。</p><p>比如这6个元素，经过哈希函数和位运算，得到了相应的下标。</p><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/6.png"></p><h4 id="2-3-3-哈希碰撞"><a href="#2-3-3-哈希碰撞" class="headerlink" title="2.3.3 哈希碰撞"></a>2.3.3 哈希碰撞</h4><p>这个时候，Tom和Mic经过计算得到的哈希值是一样的，那么再经过位运算得到的下标肯定是一样的，把这种情况叫做哈希冲突或者哈希碰撞。如果发生过了哈希碰撞，这个时候对于容器存值肯定是由影响的，从数据结构和映射方法这两个角度来分析，可以通过哪些方式去降低哈希碰撞的概率呢？</p><p>第一种是扩大数组的长度或者说位图容量。因为函数是分布均匀的，所以，位图容量越大，再同一位置发生哈希碰撞的概率越小。是不是位图的容量越大越好？不管存多少个元素，都创建一个几万亿大小的位图，可以吗？当然不行，因为越大的位图容量，意味着越多的内存消耗，所以要建立一个合适大小的位图容量。</p><p>除了扩大位图容量，还有第二种方法，只用一个哈希函数，现在对于每一个要存储的元素都用多个哈希函数计算，这样每次计算出来的下标都相同的概率就小很多了。</p><p>同样的，可以引入很多个哈希函数，也会有问题，第一个就是它会填满位图的更多空间，第二个是计算是需要消耗时间的。</p><p>所以总的来说，既要节省空间，又要很高的计算效率，就必须在位图容量和函数个数之间找到一个最佳的平衡。</p><h4 id="2-3-4-布隆过滤器-BF-原理"><a href="#2-3-4-布隆过滤器-BF-原理" class="headerlink" title="2.3.4 布隆过滤器(BF)原理"></a>2.3.4 布隆过滤器(BF)原理</h4><p>当然，这个事情早就有人研究过了，在1970年的时候，有一个叫做布隆的前辈对于判断海量元素中元素是否存在的问题进行了研究，也就是到底需要多大的位图容量和多少个哈希函数，提出的这个容器就叫做布隆过滤器。</p><p>布隆过滤器的工作原理：首先，布隆过滤器的本质就是刚才分析的，一个位数组码和若干个哈希函数。</p><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/7.png"></p><p>集合中有三个元素，要把它存到布隆过滤器中去，怎么做？首先是a元素，这里用3次计算。b，c元素也一样。元素已经存进去之后，现在要来判断一个元素在这个容器里面是否存在，就要使用同样的三个函数进行计算。比如d元素，用第一个函数f1计算，发现这个位置上是1，没问题。第二个位置也是1，第三个位置也是1.如果经过三次计算得到的下标位置都是1，这种情况下，能不能确定d元素一定在这个容器中呢？实际上是不能的。比如这张图里面，这三个位置分别是把abc存进去的时候置成1的，所以即使d元素之前没有存进去，也会得到1，判断返回true。</p><p>​    所以，这个是布隆过滤器的一个很重要的特性，因为哈希碰撞不可避免，所以它会存在一定的误判率。这种把本来不存在布隆过滤器中的元素误判为存在的情况，把它叫做假阳性(False Positive Probability，FPP)。</p><p>​    再来看另一个元素，e元素。要判断它在容器中是否存在，一样的要用这三个函数去计算。第一个位置是1，第二个位置是1，第三个位置是0。E元素是不是一定不在这个容器中呢？可以确定一定不存在，如果说但是已经把e元素存到布隆过滤器中去了，那么这三个位置肯定是1，不会出现0.</p><p>​    总结，布隆过滤器的特点；</p><p>​    从容器的角度来说：</p><ol><li><p>如果布隆过滤器判断元素在集合中存在，不一定存在</p></li><li><p>如果布隆过滤器判断不存在，一定不存在</p></li></ol><p>从元素的角度来说：</p><ol start="3"><li><p>如果元素实际存在，布隆过滤器一定判断存在</p></li><li><p>如果元素实际不存在，布隆过滤器可能判断存在</p></li></ol><h4 id="2-3-5-Guava-BF实现"><a href="#2-3-5-Guava-BF实现" class="headerlink" title="2.3.5 Guava BF实现"></a>2.3.5 Guava BF实现</h4><p>谷歌的Guava中就提供了一个现成的布隆过滤器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>21.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>创建布隆过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">BloomFilter&lt;String&gt; bf = BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), insertions);<br></code></pre></td></tr></table></figure><p>布隆过滤器提供的存放元素的方法是put()。布隆过滤器提供的判断元素是否存在的方法是mightContain().</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(bf.mightContain(data))&#123;<br>    <span class="hljs-keyword">if</span>(sets.contains(data))&#123;<br>        <span class="hljs-comment">//判断存在实际存在的时候，命中</span><br>        right++;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-comment">//判断存在但实际不存在的时候，错误</span><br>    wrong++;<br>&#125;<br></code></pre></td></tr></table></figure><p>布隆过滤器把误判率默认设置位0.03，也可以在创建的时候指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; BloomFilter&lt;T&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(Funnel&lt;? <span class="hljs-built_in">super</span> T&gt;funnel, <span class="hljs-type">long</span> expectedInsertions)</span>&#123;<br>    <span class="hljs-keyword">return</span> create(funnel, expectedInsertions, <span class="hljs-number">0.03D</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>位图的容量是基于元素个数和误判率计算出来的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">long numBits = optimal<span class="hljs-constructor">NumOfBits(<span class="hljs-params">expectedInsertions</span>, <span class="hljs-params">fpp</span>)</span>;<br></code></pre></td></tr></table></figure><p>根据位图数组的大小，进一步计算出了哈希函数的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">numHashFunctions</span> <span class="hljs-operator">=</span> optimalNumOfHashFunctions(expectedInsertions, numBits);<br></code></pre></td></tr></table></figure><p>存储100万个元素只占用了0.87M的内存，生成了5个哈希函数。</p><h4 id="2-3-6-bf在项目中的使用"><a href="#2-3-6-bf在项目中的使用" class="headerlink" title="2.3.6 bf在项目中的使用"></a>2.3.6 bf在项目中的使用</h4><p>布隆过滤器的工作位置</p><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/8.png"></p><p>因为要判断数据库的值是否存在，所以第一步是加载数据库所有的数据。在去redis查询之前，现在布隆过滤器查询，如果bf说没有，那数据库肯定没有，也不用去查了。如果bf说有，才走之前的流程。</p><h4 id="2-3-7-布隆过滤器的不足与变种"><a href="#2-3-7-布隆过滤器的不足与变种" class="headerlink" title="2.3.7 布隆过滤器的不足与变种"></a>2.3.7 布隆过滤器的不足与变种</h4><p>如果数据库删除了，布隆过滤器的数据也要删除。但是布隆过滤器里面没有提供删除的方法。为什么布隆过滤器不提供删除的方法呢？或者说，如果删除了布隆过滤器的元素，会发生什么问题？</p><p><img src="/image/redis/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/9.png"></p><p>比如把a删除了，那么三个位置都要改成0，但是再来判断b元素是否存在的时候，因为有一个位置变成了0，所以b元素也判断不存在。就是因为存在哈希碰撞，所以元素只能存入，不能删除。</p><p>那如果要实现删除的功能，怎么做？类似于HashMap的链地址法，可以在每个下标位置上增加一个计数器。比如这个位置命中了两次，计数器就是2。当删除a元素的时候，先把计数器改成1，删除b元素的时候，计数器变成0，这个时候下标对应的位才置成0。</p><p>实际上在布隆过滤器提出来的几十年中，出现了很多布隆过滤器的变种，这种通过计数器提供删除功能的bf叫做Counting Bloom Filter</p><h4 id="2-3-8-布隆过滤器的其他应用场景"><a href="#2-3-8-布隆过滤器的其他应用场景" class="headerlink" title="2.3.8 布隆过滤器的其他应用场景"></a>2.3.8 布隆过滤器的其他应用场景</h4><p>布隆过滤器解决的问题是如何在海量元素中快速判断一个元素是否存在。所以除了解决缓存穿透的问题之外，还有很多其他的用途。</p><p>比如爬虫，爬过的url不需要重复爬，那么在几十亿的url中，怎么判断一个url是不是已经爬过了？还有邮箱服务器，发送垃圾邮件的账号把它们叫做spamer，在这么多的邮箱账号中，怎么判断一个账号是不是spamer？等等一些场景，都可以使用到布隆过滤器。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis客户端</title>
    <link href="/2023/03/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <url>/2023/03/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="1-通信协议"><a href="#1-通信协议" class="headerlink" title="1  通信协议"></a>1  通信协议</h2><p>Redis监听默认6379的端口号，可以通过TCP方式建立连接。服务端约定了一种特殊的消息格式，每个命令都是以\r\n（CRLF回车+换行）结尾。这种编码格式之前在AOF文件中见到了，叫做Redis Serialization Protocol（RESP，redis序列化协议），发消息或者相应消息需要按这种格式编码，接受消息需要按这种格式解码，redis设计这种格式的原因：容易实现，解析快，可读性强。Redis6.0新特性里面说得RESP协议升级到了3.0版本，其实就是对于服务端和客户端可以接受的消息进行了升级扩展，比如客户端缓存的功能就是在这个版本中实现的。自己实现一个Redis的java客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClient</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">private</span> OutputStream write;<br>    <span class="hljs-keyword">private</span> InputStream read;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClient</span><span class="hljs-params">(String host, <span class="hljs-type">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(host, port);<br>        write = socket.getOutputStream();<br>        read = socket.getInputStream();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(String key, String val)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-comment">// 代表3个参数</span><br>        sb.append(<span class="hljs-string">&quot;*3&quot;</span>).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第一个参数(set)的长度</span><br>        sb.append(<span class="hljs-string">&quot;#3&quot;</span>).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第一个参数的内容</span><br>        sb.append(<span class="hljs-string">&quot;SET&quot;</span>).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第二个参数key的长度，(不定，动态获取)</span><br>        sb.append(<span class="hljs-string">&quot;$&quot;</span>).append(key.getBytes().length).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第二个参数key的内容</span><br>        sb.append(key).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第三个参数value的长度，(不定，动态获取)</span><br>        sb.append(<span class="hljs-string">&quot;$&quot;</span>).append(val.getBytes().length).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第三个参数val的内容</span><br>        sb.append(val).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <br>        <span class="hljs-comment">//发送命令</span><br>        write.write(sb.toString().getBytes());<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">//接受响应</span><br>        read.read(bytes);<br>        System.out.printLn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-comment">// 代表2个参数</span><br>        sb.append(<span class="hljs-string">&quot;*2&quot;</span>).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第一个参数(get)的长度</span><br>        sb.append(<span class="hljs-string">&quot;#3&quot;</span>).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第一个参数的内容</span><br>        sb.append(<span class="hljs-string">&quot;GET&quot;</span>).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第二个参数key的长度，(不定，动态获取)</span><br>        sb.append(<span class="hljs-string">&quot;$&quot;</span>).append(key.getBytes().length).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <span class="hljs-comment">// 第二个参数key的内容</span><br>        sb.append(key).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        <br>        <span class="hljs-comment">//发送命令</span><br>        write.write(sb.toString().getBytes());<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">//接受响应</span><br>        read.read(bytes);<br>        System.out.printLn(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>        <span class="hljs-type">MyClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClient</span>(<span class="hljs-string">&quot;192.168.44.181&quot;</span>, <span class="hljs-number">6379</span>);<br>        client.set(<span class="hljs-string">&quot;qs&quot;</span>, <span class="hljs-string">&quot;2673&quot;</span>);<br>        client.get(<span class="hljs-string">&quot;qs&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用这种协议，可以用java实现所有的redis操作命令。</p><h2 id="2-常用客户端"><a href="#2-常用客户端" class="headerlink" title="2  常用客户端"></a>2  常用客户端</h2><p><a href="https://redis.io/resources/clients/#java%EF%BC%8C%E5%AE%98%E7%BD%91%E6%8E%A8%E8%8D%90%E7%9A%84java%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%89%E4%B8%89%E4%B8%AA%EF%BC%9AJedis%EF%BC%8CRedisson%E5%92%8CLuttce">https://redis.io/resources/clients/#java，官网推荐的java客户端有三个：Jedis，Redisson和Luttce</a></p><table><thead><tr><th>客户端</th><th>作用</th></tr></thead><tbody><tr><td>Jedis</td><td>体系非常小，但是功能很完善</td></tr><tr><td>Lettuce</td><td>高级客户端，支持线程安全，异步，反应式编程，支持集群，哨兵，pipeline，编解码</td></tr><tr><td>Redisson</td><td>基于Redis服务实现的java分布式可扩展的数据结构</td></tr></tbody></table><p>Spring操作redis提供了一个模板方法，RedisTemplate。实际上这个并不是spring官方开发的一个客户端呢。Spring定义了一个连接工厂接口：redisConnectionFactory。这个接口有很多实现，例如：JedisConnectionFactory，JredisConnectionFactory，LettuceConnectionFactory，SrpConnectionFactory。也就是说，RedisTemplate对其他现成的客户端再进行了一层封装而已。在springboot 2.x版本之前，RedisTemplate默认使用Jedis。2.x版本之后，默认使用Lettuce。</p><h2 id="3-Jedis"><a href="#3-Jedis" class="headerlink" title="3  Jedis"></a>3  Jedis</h2><p><a href="https://github.com/redis/jedis/">https://github.com/redis/jedis/</a></p><h3 id="3-1-Jedis功能特性"><a href="#3-1-Jedis功能特性" class="headerlink" title="3.1 Jedis功能特性"></a>3.1 Jedis功能特性</h3><p>Jedis是最熟悉和最常用的客户端。如果不用RedisTemplate，就可以直接创建Jedis的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>    jedis.set(<span class="hljs-string">&quot;qs&quot;</span>, <span class="hljs-number">6379</span>);<br>    System.out.printLn(jedis.get(<span class="hljs-string">&quot;qs&quot;</span>));<br>    jedis.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>Jedis有一个问题：多个线程使用一个连接的时候线程不安全。</p><p>下面也提供了解决思路：使用连接池，为每个请求创建不同的连接，基于Apache common pool实现。Jedis的连接池有三个实现：JedisPool，ShardedJedisPool。JedisSentinePool。都是用getResource从连接池获取一个连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//普通连接池</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ordinaryPool</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">JedisPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(<span class="hljs-string">&quot;192.168.44.181&quot;</span>, <span class="hljs-number">6379</span>);<br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> pool.getResource();<br>    System.out.printLn(jedis.get(<span class="hljs-string">&quot;qs&quot;</span>));<br>&#125;<br><br><span class="hljs-comment">//分片连接池</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shardedPool</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>    <span class="hljs-type">JedisSjardInfo</span> <span class="hljs-variable">shardInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisShardInfo</span>(<span class="hljs-string">&quot;192.168.44.181&quot;</span>, <span class="hljs-number">6379</span>);<br>    List&lt;JedisShardInfo&gt; infoList = Arrays.asList(shardInfo);<br>    <span class="hljs-type">ShardedJedisPool</span> <span class="hljs-variable">jedisPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShardedJedisPool</span>(poolConfig, infoList);<br>    <br>    <span class="hljs-type">ShardedJedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> jedisPool.getResource();<br>    System.out.printLn(jedis.get(<span class="hljs-string">&quot;qs&quot;</span>));<br>&#125;<br><br><span class="hljs-comment">//哨兵连接池</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sentinelPool</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">masterName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;redis-master&quot;</span>;<br>    Set&lt;String&gt; sentinels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    sentinels.add(<span class="hljs-string">&quot;192.168.44.186:26379&quot;</span>);<br>    sentinels.add(<span class="hljs-string">&quot;192.168.44.187:26379&quot;</span>);<br>    sentinels.add(<span class="hljs-string">&quot;192.168.44.188:26379&quot;</span>);<br>    <br>    <span class="hljs-type">JedisSentinelPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisSentinelPool</span>(masterName, sentinels);<br>    System.out.printLn(pool.getResource().get(<span class="hljs-string">&quot;qs&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>Jedis的功能比较完善，redis官方的特性全部支持，比如发布订阅，事务，Lua脚本，客户端分片，哨兵，集群，pipeline等等。</p><h3 id="3-2-Sentinel获取连接原理"><a href="#3-2-Sentinel获取连接原理" class="headerlink" title="3.2 Sentinel获取连接原理"></a>3.2 Sentinel获取连接原理</h3><p>在构造方法中（JedisSentinelPool）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisSentinelPool</span>(masterName, sentinels);<br></code></pre></td></tr></table></figure><p>调用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HostAndPort</span> <span class="hljs-variable">master</span> <span class="hljs-operator">=</span> initSentinels(sentinels, masterName);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">private</span> HostAndPort <span class="hljs-title function_">initSentinels</span><span class="hljs-params">(Set&lt;String&gt; sentinels, String masterName)</span> &#123;<br>      <span class="hljs-type">HostAndPort</span> <span class="hljs-variable">master</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">sentinelAvailable</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-built_in">this</span>.log.info(<span class="hljs-string">&quot;Trying to find master from available Sentinels...&quot;</span>);<br>      <span class="hljs-type">Iterator</span> <span class="hljs-variable">var5</span> <span class="hljs-operator">=</span> sentinels.iterator();<br><br>      String sentinel;<br>      HostAndPort hap;<br>      <span class="hljs-comment">//有多个sentinels，遍历这些sentinel</span><br>      <span class="hljs-keyword">while</span>(var5.hasNext()) &#123;<br>          sentinel = (String)var5.next();<br>          <span class="hljs-comment">//host:port表示的sentinel地址转化成一个HostAndPort对象</span><br>          hap = HostAndPort.parseString(sentinel);<br>          <span class="hljs-built_in">this</span>.log.debug(<span class="hljs-string">&quot;Connecting to Sentinel &#123;&#125;&quot;</span>, hap);<br>          <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>          <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">//连接到sentinel</span><br>              jedis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(hap.getHost(), hap.getPort(), <span class="hljs-built_in">this</span>.sentinelConnectionTimeout,<br>                                <span class="hljs-built_in">this</span>.sentinelSoTimeout);<br>              <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.sentinelUser != <span class="hljs-literal">null</span>) &#123;<br>                  jedis.auth(<span class="hljs-built_in">this</span>.sentinelUser, <span class="hljs-built_in">this</span>.sentinelPassword);<br>              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.sentinelPassword != <span class="hljs-literal">null</span>) &#123;<br>                  jedis.auth(<span class="hljs-built_in">this</span>.sentinelPassword);<br>              &#125;<br><br>              <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.sentinelClientName != <span class="hljs-literal">null</span>) &#123;<br>                  jedis.clientSetname(<span class="hljs-built_in">this</span>.sentinelClientName);<br>              &#125;<br><span class="hljs-comment">//根据masterName得到master的地址，返回一个list，host=list[0],port=list[1]</span><br>              List&lt;String&gt; masterAddr = jedis.sentinelGetMasterAddrByName(masterName);<br>              sentinelAvailable = <span class="hljs-literal">true</span>;<br>              <span class="hljs-keyword">if</span> (masterAddr != <span class="hljs-literal">null</span> &amp;&amp; masterAddr.size() == <span class="hljs-number">2</span>) &#123;<br>                  <span class="hljs-comment">//如果在任何一个sentinel中找到了master，不再遍历sentinels</span><br>                  master = <span class="hljs-built_in">this</span>.toHostAndPort(masterAddr);<br>                  <span class="hljs-built_in">this</span>.log.debug(<span class="hljs-string">&quot;Found Redis master at &#123;&#125;&quot;</span>, master);<br>                  <span class="hljs-keyword">break</span>;<br>              &#125;<br>              <span class="hljs-built_in">this</span>.log.warn(<span class="hljs-string">&quot;Can not get master addr, master name: &#123;&#125;. Sentinel: &#123;&#125;&quot;</span>, masterName, hap);<br>          &#125; <span class="hljs-keyword">catch</span> (JedisException var13) &#123;<br>              <span class="hljs-built_in">this</span>.log.warn(<span class="hljs-string">&quot;Cannot get master address from sentinel running @ &#123;&#125;.&quot;</span>+<br>                            <span class="hljs-string">&quot; Reason: &#123;&#125;. Trying next one.&quot;</span>, hap, var13);<br>          &#125; <span class="hljs-keyword">finally</span> &#123;<br>              <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) &#123;<br>                  jedis.close();<br>              &#125;<br><br>          &#125;<br>      &#125;<br><span class="hljs-comment">//到这里，如果master为null，则说明两种情况，一种是所有的sentinel节点都down了，一种是master节点没有被存活的sentinel监控到</span><br>      <span class="hljs-keyword">if</span> (master == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">if</span> (sentinelAvailable) &#123;<br>              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisException</span>(<span class="hljs-string">&quot;Can connect to sentinel, but &quot;</span> + masterName <br>                                       + <span class="hljs-string">&quot; seems to be not monitored...&quot;</span>);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisConnectionException</span>(<span class="hljs-string">&quot;All sentinels down, cannot determine where is &quot;</span> <br>                                                 + masterName + <span class="hljs-string">&quot; master is running...&quot;</span>);<br>          &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">//如果走到这里，说明找到了master地址</span><br>          <span class="hljs-built_in">this</span>.log.info(<span class="hljs-string">&quot;Redis master running at &#123;&#125;, starting Sentinel listeners...&quot;</span>, master);<br>          var5 = sentinels.iterator();<br><span class="hljs-comment">//启动对每个sentinels的监听为每个sentinel都启动了一个监听者MasterListener。MasterListener本身是一个线程，它会去订阅sentinel上关于master节点地址改变的信息</span><br>          <span class="hljs-keyword">while</span>(var5.hasNext()) &#123;<br>              sentinel = (String)var5.next();<br>              hap = HostAndPort.parseString(sentinel);<br>              <span class="hljs-type">MasterListener</span> <span class="hljs-variable">masterListener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MasterListener</span>(masterName, hap.getHost(),<br>                                                                 hap.getPort());<br>              masterListener.setDaemon(<span class="hljs-literal">true</span>);<br>              <span class="hljs-built_in">this</span>.masterListeners.add(masterListener);<br>              masterListener.start();<br>          &#125;<br>          <span class="hljs-keyword">return</span> master;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-Cluster获取连接原理"><a href="#3-3-Cluster获取连接原理" class="headerlink" title="3.3 Cluster获取连接原理"></a>3.3 Cluster获取连接原理</h3><p>使用Jedis连接Cluster的时候，我们只需要连接到任意一个或者多个redis group中的实例地址，为了避免get，set的时候发生重定向错误，需要把slot和redis节点的关系保存起来，在本地计算slot，就可以获得redis节点信息。</p><p><img src="/image/redis/redis%E5%AE%A2%E6%88%B7%E7%AB%AF/1.png"></p><p>注意slots的数量是写死的，不能修改。</p><p>第一，在服务端表示16384个位，只需要2kb的大小（每个group维护一个位数组，在16384bit里面把对应下表的值改成1，就代表slot由当前节点负责）。再大的话，获取slots信息有点浪费通信资源。</p><p>第二，一般来说集群的节点数不会特别大，16384个slots够他们分了。</p><p><em>关键问题：在于如何存储slot和redis连接池的关系。</em></p><ol><li>程序启动初始化集群环境，读取配置文件中的节点配置，无论是主从，无论多少个，只拿第一个，获取redis连接实例。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeSlotsCache</span><span class="hljs-params">(Set&lt;HostAndPort&gt; startNodes, GenericObjectPoolConfig poolCOnfig, String password)</span>&#123;<br>    <span class="hljs-keyword">for</span>(HostAndPort hostAndPort : startNodes)&#123;<br>        <span class="hljs-comment">//获取一个Jedis实例</span><br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(hostAndPort.getHost(),hostAndPort.getPort());<br>        <span class="hljs-keyword">if</span>(password != <span class="hljs-literal">null</span>)&#123;<br>            jedis.auth(password);<br>        &#125;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//获取redis节点和Slot虚拟槽</span><br>            cache.discoverClusterNodesAndSlots(jedis);<br>            <span class="hljs-comment">//直接跳出循环</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">catch</span>(JedisConnectionException e)&#123;<br>            <br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span>(jedis != <span class="hljs-literal">null</span>)&#123;<br>                jedis.close();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>discoverClusterNodesAndSlots方法，用获取的redis 连接实例执行clusterSlots()方法，实际执行redis服务端cluster slots命令，获取虚拟槽信息。该集合的基本信息为[long.long,List,List]，第一，第二个元素是该节点负责槽点的其实位置，第三个元素是主节点信息，第四个元素为主节点对应的从节点信息。该list的基本信息为[string,int,string]，第一个为host信息，第二个为port信息，第三个为唯一id。</p></li><li><p>获取有关节点的槽点信息后，调用getAssignedSlotArray(slotinfo)来获取所有的槽点值。</p></li><li><p>再获取主节点的地址信息，调用generateHostAndPort(hostInfo)方法，生成一个hostAndPort对象。</p></li><li><p>再assignSlotsToNode方法中，再根据节点地址信息来设置节点对应的JedisPool，即设置Map&lt;Srting, JedisPool&gt; nodes的值。</p></li></ol><p>接下来判断若此时节点信息为主节点信息时，则调用assignSlotsToNodes方法，设置每个槽点对应的连接池（slave不需要连接），即设置Map&lt;Integer, JedisPool&gt; slots的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">discoverClusterNodesSlots</span><span class="hljs-params">(Jedis jedis)</span>&#123;<br>    w.lock();<br>    <span class="hljs-keyword">try</span>&#123;<br>        reset();<br>        <span class="hljs-comment">//获取节点集合</span><br>        List&lt;Object&gt; slots = jedis.clusterSlots();<br>        <span class="hljs-comment">//遍历3个master节点</span><br>        <span class="hljs-keyword">for</span>(Object slotInfoObj : slots)&#123;<br>            List&lt;object&gt; slotInfo = (List&lt;Object&gt;) slotInfoObj;<br>            <span class="hljs-comment">//如果&lt;=2，代表没有分配slot</span><br>            <span class="hljs-keyword">if</span>(slotInfo.size() &lt;= MASTER_NODE_INDEX)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//获取分配到当前master节点的数据槽</span><br>            List&lt;Integer&gt; slotNums = getAssignedSlotArray(slotInfo);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> slotInfo.size();<br>            <span class="hljs-comment">//第3位和第4位是主从端口的信息</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> MASTER_NODE_INDEX ; i &lt; size ; i++)&#123;<br>                List&lt;Object&gt; hostInfos = (List&lt;Object&gt;) slotInfo.get(i);<br>                <span class="hljs-keyword">if</span>(hostInfos.size() &lt;= <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">//根据IP端口生成HostAndPort实例</span><br>                <span class="hljs-type">HostAndPort</span> <span class="hljs-variable">targetNode</span> <span class="hljs-operator">=</span> generateHostAndPort(hostInfos);<br>                <span class="hljs-comment">//根据HostAndPort解析出ip:port的key值，再根据key从缓存中查询对应的jedisPool实例。如果没有jedisPool实例，就创建JedisPool实例，最后放入缓存中，nodeKey和nodePool的关系</span><br>                setupNodeIfNotExist(targetNode);<br>                <span class="hljs-keyword">if</span>(i == MASTER_NODE_INDEX)&#123;<br>                    assignSlotsToNode(slotNums, targetNode);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        w.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显，这个Map有16384个key，key对应的value是一个连接池信息。有几个Redis Group（或者说有几个master），就有几个不同的连接池。获取slot和redis实例的对应关系之后，接下来就是从集群环境获取值。Jedis集群模式下所有的命令都要调用这个方法：核心代码JedisClusterCommand#runWithRetries</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">connection = connectionHandler.getConnectionFromSlot(JedisClusterCRC16.getSlot(key));<br></code></pre></td></tr></table></figure><ol><li><p>把key作为参数，执行CRC16算法，获取key对应的slot值。</p></li><li><p>通过该slot值，去slots的map集合中获取jedisPool实例。</p></li><li><p>通过jedisPool实例获取jedis实例，最终完成redis数据存取工作。</p></li></ol><h3 id="3-4-Jedis实现分布式锁"><a href="#3-4-Jedis实现分布式锁" class="headerlink" title="3.4 Jedis实现分布式锁"></a>3.4 Jedis实现分布式锁</h3><p>分布式锁的基本需求：</p><p>​    1. 互斥性：只有一个客户端能够持有锁</p><p>​    2. 不会产生死锁：即使持有锁的客户端奔溃，也能保证后续其他客户端可以获取锁。</p><p>​    3. 只有持有这把锁的客户端才能解锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryGetDistributedLock</span><span class="hljs-params">(Jedis jedis, String lockKey, String requestId, <span class="hljs-type">int</span> expireTime)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);<br>    <span class="hljs-keyword">if</span>(LOCK_SUCCESS.equals(result))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    1. lockKey是redis key的名称，谁添加成功这个key，就代表谁获取锁成功。比如有一把修改1001账户余额的锁。</p><p>​    2. requestId是客户端的ID（设置成value），如果我们要保证只有加锁的客户端才能释放锁，就必须获取客户端的ID（保证第三点，自己才能解锁）。</p><p>​    3. SET_IF_NOT_EXIST是我们的命令中加上NX（保证第一点，互斥）。</p><p>​    4. SET_WITH_EXPIRE_TIME，PX代表以毫秒为单位设置key的过期时间（保证第二点，不会死锁）。expireTime是自动释放锁的时间，比如5000代表5秒。</p><p>如果在释放锁的时候，这把锁已经不属于这个客户端（例如已经过期，并且被别的客户端获取锁成功了），那就会出现释放了其他客户端的锁的情况。所以，要先判断是不是自己加的锁，才能释放，为了保证原子性，我们把判断客户端是否相等和删除key的操作放在Lua脚本中执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseDistributedLock</span><span class="hljs-params">(Jedis jedis, String lockKey, String requestId)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1])==ARGV[1] then return redis.call(&#x27;del&#x27;,KEY[1]) else return 0 end&quot;</span>;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.eval(script, Collections.singletonList(lockKey), CollectionssingletonList(requestId));<br>    <span class="hljs-keyword">if</span>(RELEASE_SUCCESS.equals(result))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-Pipline"><a href="#3-5-Pipline" class="headerlink" title="3.5 Pipline"></a>3.5 Pipline</h3><p>平时说redis是单线程的，说的是redis的请求是单线程处理的，只有上一个命令的结果响应以后，下一个命令才会处理。如果要一次操作10万个key，客户端跟服务端就要交互10万次，排队的时间加上网络通信的时间，就会很慢。举个例子，假设一次交互的网络延迟的1毫秒，客户端1秒钟最多只能发送1000个命令。这个就太浪费服务端的性能了。</p><p>​    能不能像把一组命令组装在一起发送给redis服务端执行，然后一次性获得返回结果呢？这个就是Pipeline的作用。Pipeline通过一个队列把所有的命令缓存起来，然后把多个命令在一次连接中发送给服务器。</p><p>​    要是按Pipeline，既要服务端的支持，也要客户端的支持。对于服务端来说，需要能够处理客户端通过一个TCP连接发来的多个命令，并且逐个地执行命令一起返回。对于客户端来说，要把多个命令缓存起来，达到一定地条件就发送出去，最后才处理redis地应答（这里要注意对客户端内存地消耗）。jedis-pipeline的client0buffer限制：8192bytes，客户端堆积的命令超过8M时，会发送给服务端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisOutputStream</span><span class="hljs-params">(<span class="hljs-keyword">final</span> OutputStream out)</span>&#123;<br>    <span class="hljs-built_in">this</span>(out, <span class="hljs-number">8192</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>pipeline对于命令条数没有限制，但是命令可能会受限于TCP包大小。需要注意的是，并不是所有业务场景都要用pipeline。如果某些操作需要马上得到redis操作是否成功的结果，这种场景就不合适。有些场景，例如批量写入数据，对于结果的实时性和成功性要求不高，就可以用Pipeline。</p><h2 id="4-Lettuce"><a href="#4-Lettuce" class="headerlink" title="4  Lettuce"></a>4  Lettuce</h2><p>与Jedis相比，Lettuce则完全克服了其线程不安全的缺点：Lettuce是一个可伸缩的线程安全的redis客户端，支持同步，异步和响应式模式（Reactive）。多个线程可以共享一个连接实例，而不必担心多线程并发问题。</p><p>Lettuce基于Netty框架构建，支持Redis的全部高级功能，如发布订阅，事务，Lua脚本，Sentinel，集群，pipeline支持连接池。Lettuce是springboot 2.x默认的客户端，替换了jedis。集成之后我们不需要单独使用它，直接调用spring的redisTemplate操作，连接和创建和关闭也不需要我们操心。</p><h2 id="5-Redisson"><a href="#5-Redisson" class="headerlink" title="5  Redisson"></a>5  Redisson</h2><p>Redisson是一个在redis的基础上实现的java内存数据网格（In-Memory Data Grid），提供了分布式和可扩展的java数据结构，比如分布式的Map，List，Queue，Set，不需要自己去运行一个服务实现。</p><h3 id="5-1-特点"><a href="#5-1-特点" class="headerlink" title="5.1 特点"></a>5.1 特点</h3><p>基于Netty实现，采用非阻塞IO，性能高；支持异步请求。支持连接池，pipeline，Lua脚本，redis Sentinel， redis cluster。不支持事务，官方建议以lua脚本代替事务。主从，哨兵，集群都支持。Spring也可以配置和注入RedissonClient。</p><h3 id="5-2-实现分布式锁"><a href="#5-2-实现分布式锁" class="headerlink" title="5.2 实现分布式锁"></a>5.2 实现分布式锁</h3><p>在Redisson里面提供了更见简单的分布式锁的实现。</p><p><img src="/image/redis/redis%E5%AE%A2%E6%88%B7%E7%AB%AF/2.png"></p><p>加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">rLock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;updateAccount&quot;</span>);<br>    <span class="hljs-comment">//最多等待100秒，上锁10后自动解锁</span><br>    <span class="hljs-keyword">if</span>(rLock.tryLock(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS))&#123;<br>        System.out.printLn(<span class="hljs-string">&quot;获取锁成功&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">//do something</span><br>    rLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>在获得锁之后，只需要一个tryLock方法，里面有三个参数：</p><p>​    1.waitTime：获取锁的最大等待时间，超过这个时间不再尝试获取锁。</p><p>​    2.leaseTime：如果没有调用unlock，超过了这个时间会自动释放锁。</p><p>​    3.TimeUnit：释放时间的单位</p><p>Redisson的分布式锁的实现原理，在加锁的时候，在redis写入了一个HASH，key是锁名称，field是线程名称，value是1（表示锁的重入次数）。</p><p><img src="/image/redis/redis%E5%AE%A2%E6%88%B7%E7%AB%AF/3.png"></p><p>trylock() -&gt;tryAcquire() -&gt; tryAcquireAsync()-&gt; trylockInnerAsync()，最终也是调用了一段lua脚本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//KEYS[1]锁名称 updateAccount</span><br><span class="hljs-comment">//ARGV[1]key过期时间10000ms</span><br><span class="hljs-comment">//ARGV[2]线程名称</span><br><span class="hljs-comment">//锁名称不存在</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;exists&#x27;</span>,KEYS[<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>)) then<br>    <span class="hljs-comment">//创建一个hash，key=锁名称，field=线程名，value=1</span><br>    redis.call(<span class="hljs-string">&#x27;hset&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">2</span>],<span class="hljs-number">1</span>);<br><span class="hljs-comment">//设置hash的过期时间</span><br>redis.call(<span class="hljs-string">&#x27;prxpire&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> nil;<br>end;<br><span class="hljs-comment">//锁名称存在，判断是否当前线程持有的锁</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">2</span>])==<span class="hljs-number">1</span>) then<br>    <span class="hljs-comment">//如果是，value+1，代表重入次数+1</span><br>    redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">2</span>],<span class="hljs-number">1</span>);<br><span class="hljs-comment">//重新获得锁，需要重新设置key的过期时间</span><br>redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> nil;<br>end;<br><span class="hljs-comment">//锁存在，但是不是当前线程持有，返回过期时间(毫秒)</span><br><span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;pttl&#x27;</span>,KEYS[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><p>释放锁:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//KEYS[1]锁名称 updateAccount</span><br><span class="hljs-comment">//KEYS[2]频道名称rredisson_lock_channel:&#123;updateAccount&#125;</span><br><span class="hljs-comment">//ARGV[1]释放锁的消息 0</span><br><span class="hljs-comment">//ARGV[2]释放时间 10000</span><br><span class="hljs-comment">//ARGV[3]线程名称</span><br><span class="hljs-comment">//锁不存在，过期或者已经释放</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;exists&#x27;</span>,KEYS[<span class="hljs-number">1</span>])==<span class="hljs-number">0</span>) then<br>    <span class="hljs-comment">//发布锁已经释放的消息</span><br>    redis.call(<span class="hljs-string">&#x27;publish&#x27;</span>,KEYS[<span class="hljs-number">2</span>],ARGV[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>end;<br><span class="hljs-comment">//锁存在，但是不是当前线程加的锁</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">3</span>])==<span class="hljs-number">0</span>) then<br>    <span class="hljs-keyword">return</span> nil;<br>end;<br><span class="hljs-comment">//锁存在，是当前线程加的锁，重入次数-1</span><br>local counter=redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">3</span>],<span class="hljs-number">-1</span>);<br><span class="hljs-comment">//减1后大于0，说明这个线程持有这把锁还有其他的任务需要执行</span><br><span class="hljs-keyword">if</span>(counter&gt;<span class="hljs-number">0</span>) then<br>    <span class="hljs-comment">//重新设置锁的过期时间</span><br>    redis.call(<span class="hljs-string">&#x27;pexpire&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">2</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">//减1后等于0，释放锁</span><br>    redis.call(<span class="hljs-string">&#x27;del&#x27;</span>,KEYS[<span class="hljs-number">1</span>]);<br><span class="hljs-comment">//释放后发布消息</span><br>redis.call(<span class="hljs-string">&#x27;publish&#x27;</span>,KEYS[<span class="hljs-number">2</span>],ARGV[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>end;<br><span class="hljs-comment">//其他情况返回nil</span><br><span class="hljs-keyword">return</span> nil;<br></code></pre></td></tr></table></figure><p>这个是Redisson里面分布式锁的实现，在调用的时候非常简单。</p><p>​    1.业务没执行完，锁到期了怎么办？ watchdog（Redisson github wiki）</p><p>​    2.集群模式下，如果对多个master加锁，导致重复加锁怎么办？  Redisson会自动选择同一个master</p><p>​    3.业务没执行完，redis master挂了怎么办？ redis slave还有这个数据</p><p>​    Redisson跟jedis定位不同，它不是一个单纯的redis客户端，而是基于redis实现的分布式的服务，如果有需要用到一些分布式的数据结构，比如还可以基于Redisson的分布式队列实现分布式事务，就可以引入redisson的依赖实现。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis分布式</title>
    <link href="/2023/03/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <url>/2023/03/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>如果要实现redis数据的分片，有三种方案。</p><p>第一种是在客户端实现相关的逻辑，例如用取模或者一致性哈希对key进行分片，查询和修改都先判断key的路由。</p><p>第二种是把做分片处理的逻辑抽取出来，运行一个独立的代理服务，客户端连接到这个代理服务，代理服务做请求的转发。</p><p>第三种就是基于服务端实现。</p><h2 id="1-客户端Sharding-ShardedJedis"><a href="#1-客户端Sharding-ShardedJedis" class="headerlink" title="1  客户端Sharding-ShardedJedis"></a>1  客户端Sharding-ShardedJedis</h2><p>RedisTemplate就是对jedis的封装。</p><p>Jedis有几种连接池。比如这里一个连接到186，一个连接到windows的redis服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShardingTest</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>        <span class="hljs-comment">//Redis服务器</span><br>        <span class="hljs-type">JedisShardInfo</span> <span class="hljs-variable">shardInfo1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisShardInfo</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>        <span class="hljs-type">JedisShardInfo</span> <span class="hljs-variable">shardInfo2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisShardInfo</span>(<span class="hljs-string">&quot;192.168.44.186&quot;</span>, <span class="hljs-number">6379</span>);<br>        <span class="hljs-comment">//连接池</span><br>        List&lt;JedisShardInfo&gt; infoList = Arrays.asList(shardInfo1, shardInfo2);<br>        <span class="hljs-type">ShardedJedisPool</span> <span class="hljs-variable">jedisPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShardedJedisPool</span>(poolConfig, infoList);<br>        <br>        <span class="hljs-type">ShardedJedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            jedis = jedisPool.getResource();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">100</span> i++)&#123;<br>                jedis.set(<span class="hljs-string">&quot;k&quot;</span>+i, <span class="hljs-string">&quot;&quot;</span>+i);<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">100</span> ; i++)&#123;<br>                System.out.printLn(jedis.get(<span class="hljs-string">&quot;k&quot;</span>+i));<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span>(jedis != <span class="hljs-literal">null</span>)&#123;<br>                jedis.close();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过dbsize命令发现，一台服务器有44个key，一台服务器有56个key。如果是希望数据分布相对均匀的话，首先可以考虑哈希后取模(因为key不一定是整数，所以先计算哈希)。</p><p><strong>哈希后取模</strong></p><p>例如，hash(key)%N，根据余数，决定映射到哪个节点。这种方式比较简单，属于静态的分片规则，但是一旦节点数量变化，由于取模的N发生变化，数据需要重新分布。为了解决这个问题，又有了一致性哈希算法。ShardedJedis实际上用的就是一致性哈希算法。</p><p><strong>一致性哈希</strong></p><p>原理：把所有的哈希值空间组织成一个虚拟的圆环(哈希环)，整个空间按顺时针方向组织。因为是环形空间，0和2^32-1是重叠的。假如有四台机器要哈希环来实现映射(分布数据)，先根据机器的名称或者ip计算哈希值，然乎分布到哈希环中(红色圆圈)。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/1.png"></p><p>现在有4条数据或者4个访问请求，对key计算后，得到哈希环中的位置（绿色圆圈）。沿哈希环顺时针找到的第一个node，就是数据存储的节点。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/2.png"></p><p>在这种情况下，新增了一个node5节点，只影响一部分数据的分布。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/3.png"></p><p>删除了一个节点node4，只影响相邻的一个节点。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/4.png"></p><p>一致性哈希解决了动态增减节点时，所有数据都需要重新分布的问题，它只会影响到下一个相邻的系欸但，对其他节点没有影响。但是这样的一致性算法有一个缺点，因为节点不一定是均匀分布的，特别是在节点数比较少的情况下，所以数据不能得到均匀分布。解决这个问题的办法是引入虚拟节点(Virtual node)。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/5.png"></p><p>Node1设置了两个虚拟节点，node2也设置了两个虚拟节点（虚线圆圈）。这时候有3条数据分布到了node1，1条数据分布到了node2。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/6.png"></p><p>一致性哈希在分布式系统中，负载均衡，分库分表等场景中都有应用，跟LRU一样，是一个基础的算法。</p><p><strong>java源码</strong></p><p>Redis.client.util.Sharded.initialze()，jedis实例被放到了一棵红黑树TreeMap中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(List&lt;S&gt; shards)</span> &#123;<br>      <span class="hljs-comment">//创建一个红黑树</span><br>      <span class="hljs-built_in">this</span>.nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>();<br><span class="hljs-comment">//把所有节点放入红黑树中</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i != shards.size(); ++i) &#123;<br>          <span class="hljs-type">S</span> <span class="hljs-variable">shardInfo</span> <span class="hljs-operator">=</span> (ShardInfo)shards.get(i);<br>          <span class="hljs-comment">//为每个Redis节点创建160个虚拟节点，放到红黑树中</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">160</span> * shardInfo.getWeight();<br>          <span class="hljs-type">int</span> n;<br>          <span class="hljs-keyword">if</span> (shardInfo.getName() == <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span>; n &lt; N; ++n) &#123;<br>                  <span class="hljs-built_in">this</span>.nodes.put(<span class="hljs-built_in">this</span>.algo.hash(<span class="hljs-string">&quot;SHARD-&quot;</span> + i + <span class="hljs-string">&quot;-NODE-&quot;</span> + n), shardInfo);<br>              &#125;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span>; n &lt; N; ++n) &#123;<br>                  <span class="hljs-comment">//对名字计算哈希(MurmurHash)</span><br>                  <span class="hljs-built_in">this</span>.nodes.put(<span class="hljs-built_in">this</span>.algo.hash(shardInfo.getName() + <span class="hljs-string">&quot;*&quot;</span> + n), shardInfo);<br>              &#125;<br>          &#125;<br><span class="hljs-comment">//添加到map中，键为ShardInfo，值为redis实例</span><br>          <span class="hljs-built_in">this</span>.resources.put(shardInfo, shardInfo.createResource());<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>当存取键值对时，计算键的哈希值，然后从红黑树上摘下比该值大的第一个节点上的JedisShardInfo，随后从resources去除jedis。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> R <span class="hljs-title function_">getShard</span><span class="hljs-params">(String key)</span>&#123;<br>    <span class="hljs-keyword">return</span> resources.get(getShardInfo(key));<br>&#125;<br></code></pre></td></tr></table></figure><p>获取红黑树子集，找出比它大的第一个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> S <span class="hljs-title function_">getShardInfo</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] key)</span> &#123;<br>    <span class="hljs-comment">//获取比当前key的哈希值要大的红黑树的子集</span><br>    SortedMap&lt;Long, S&gt; tail = <span class="hljs-built_in">this</span>.nodes.tailMap(<span class="hljs-built_in">this</span>.algo.hash(key));<br>    <span class="hljs-keyword">return</span> tail.isEmpty() ? <br>        <span class="hljs-comment">//没有比它大的了，直接从nodes中取出</span><br>        (ShardInfo)<span class="hljs-built_in">this</span>.nodes.get(<span class="hljs-built_in">this</span>.nodes.firstKey()) : <br>    <span class="hljs-comment">//返回第一个比它大的JedisShardInfo</span><br>    (ShardInfo)tail.get(tail.firstKey());<br>&#125;<br></code></pre></td></tr></table></figure><p>使用ShardedJedis之类的客户端分片代码的优势是配置简单，不依赖于其他中间件，分区的逻辑可以自定义，比较灵活。但是基于客户端的方案，不能实现动态的服务增减，每个客户端需要自行维护分片则略，存在重复代码。</p><h2 id="2-代理Proxy"><a href="#2-代理Proxy" class="headerlink" title="2  代理Proxy"></a>2  代理Proxy</h2><p>典型的代理分区方案有Twitter开源的Twemproxy和国内的豌豆荚开源的Codis。</p><h3 id="2-1-Twemproxy"><a href="#2-1-Twemproxy" class="headerlink" title="2.1 Twemproxy"></a>2.1 Twemproxy</h3><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/7.png"></p><p>Twemproxy的优点：比较稳定，可用性高。</p><p>不足：</p><ol><li><p>出现故障不能自动转移，架构复杂，需要借助其他组件（LVS/HAProxy+Keepalived）实现HA</p></li><li><p>扩缩容需要修改配置，不能实现平滑地扩缩容（需要重新分布数据）。</p></li></ol><h3 id="2-2-Codis"><a href="#2-2-Codis" class="headerlink" title="2.2 Codis"></a>2.2 Codis</h3><p>Codis是一个代理中间件，豌豆荚公司用Go语言开发的（快三年时间没有更新了）。跟数据库分库分表中间件的Mycat的工作层次是一样的。功能：客户端连接Codis跟连接redis没有区别。</p><table><thead><tr><th>功能特性</th><th>Codis</th><th>Tewmproxy</th><th>Redis Cluster</th></tr></thead><tbody><tr><td>重新分片不需要重启</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>pipeline</td><td>yes</td><td>yes</td><td>–</td></tr><tr><td>多key操作的hash tags {}</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>重新分片时的多key操作</td><td>yes</td><td>–</td><td>no</td></tr><tr><td>客户端支持</td><td>所有</td><td>所有</td><td>支持cluster协议的客户端</td></tr></tbody></table><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/8.png"></p><p>分片原理：Codis把所有的key分成了N个槽（例如1024），每个槽对应一个分组，一个分组对应于一个或者一组Redis实例。Codis对key进行CRC32运算，得到一个32位的数字，然后模拟N（槽的个数），得到余数，这个就是key对应的槽，槽后面就是redis实例（跟Mycat的先哈希后范围的算法思想类似）。比如4个槽：</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/9.png"></p><p>Codis的槽位映射关系是保存在proxy中的，如果要解决单点的问题，Codis也要做集群部署，多个Codis节点同步槽和实例的关系需要运行一个Zookeeper（或者etcd/本地文件）。</p><p>在新增节点的时候，可以为节点指定特定的槽位。Coids也提供了自动均衡策略。Codis不支持事务，其他的一些命令也不支持。获取数据原理（mget）在redis中的各个实例里获取到符合的key，然后再汇总到Codis中。Codis是第三方提供的分布式解决方案，再官网的集群功能稳定之前，Coids也得到了大量的应用。</p><h2 id="3-Redis-Cluster"><a href="#3-Redis-Cluster" class="headerlink" title="3  Redis Cluster"></a>3  Redis Cluster</h2><p>Redis Cluster是在Redis3.0版本正式推出的，用来解决分布式的需求，同时也可以实现高可用。跟Codis不一样，它是去中心化的，客户端可以连接到任意一个可用节点。数据分片有几个关键的问题需要解决：</p><ol><li><p>数据怎么相对均匀的分片</p></li><li><p>客户端怎么访问到相应的节点和数据</p></li><li><p>重新分片的过程，怎么保证正常服务</p></li></ol><h3 id="3-1-架构"><a href="#3-1-架构" class="headerlink" title="3.1 架构"></a>3.1 架构</h3><p>Redis Cluster可以看成是由多个Redis实例组成的数据集合。客户端不需要关注数据到底存储在哪个节点，只需要关注这个集合整体。以3主3从为例，节点之间两两交互，共享数据分片，节点状态等信息。</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/10.png"></p><h3 id="3-2-搭建"><a href="#3-2-搭建" class="headerlink" title="3.2 搭建"></a>3.2 搭建</h3><table><thead><tr><th>类型</th><th>命令</th></tr></thead><tbody><tr><td>集群</td><td>cluster info：打印集群的信息<br />cluster nodes：列出集群当前已知的所有节点，以及这些节点的相关信息</td></tr><tr><td>节点</td><td>cluster meet &lt;ip<ip>&gt;&lt;port<port>&gt; : 将ip与port所指定的节点添加到集群当中，让它成为集群的一份子<br />cluster forget&lt;node_id<node_id>&gt; : 从集群中移除node_id指定的节点(保证空槽道)<br />cluster replicate&lt;node_id<node_id>&gt; : 将当前节点设置为node_id指定节点的从节点 <br />cluster saveconfig：将节点的配置文件保存到硬盘中</td></tr><tr><td>槽(slot)</td><td>cluster addslots&lt;slot<slot>&gt;[slot …]：将一个或多个槽指派给当前节点<br />cluster delslots&lt;slot<slot>&gt;[slot …]：移除一个或多个槽对当前节点的指派 <br />cluster flushslots：移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点<br />cluster setslot&lt;slot<slot>&gt; node&lt;node_id<node_id>&gt;：将槽slot指派给node_id指定的节点，如果槽已经指派给另一个节点，那么先让另一个节点删除该槽，然后再进行指派<br />cluster setslot&lt;slot<slot>&gt; migrating<node_id>&gt;：将本节点的槽迁移到node_id指定的节点中<br />cluster setslot&lt;slot<slot>&gt; importing<node_id>&gt;：从node_id指定的节点中导入槽到本节点<br />cluster setslot&lt;slot<slot>&gt; stable：取消对槽的导入或者迁移</td></tr><tr><td>键</td><td>cluster keyslot &lt;key<key>&gt;：计算键key应该被放置在哪个槽上<br />cluster countkeysinslot &lt;slot<slot>&gt;：返回槽目前包含的键值对数量<br />cluster getkeysinslot&lt;slot<slot>&gt; &lt;count<count>&gt;：返回count个槽中的键</td></tr></tbody></table><h3 id="3-3-数据分布"><a href="#3-3-数据分布" class="headerlink" title="3.3 数据分布"></a>3.3 数据分布</h3><p>Redis既没有用哈希取模，也没有用一致性哈希，而是用虚拟槽来实现的。Redis创建了16384个槽（slot），每个节点负责一定区间的slot。比如Node1负责0-5460，Node2负责5461-10922，Node3负责10923-163838.</p><p><img src="/image/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F/11.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli -p 7291<br>redis-cli -p 7292<br>redis-cli -p 7293<br></code></pre></td></tr></table></figure><p>对象分布到Redis节点上时，对key用CRC16算法计算再%16384，得到一个slot的值，数据落到负责这个slot的redis节点上。Redis的每个master节点都会维护自己负责的slot。用一个bit序列实现，比如：序列的第0位是1，就代表第一个slot是它负责；序列的第1位是0，就代表第二个slot不归它负责。查看key属于哪个slot：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">redis&gt; <span class="hljs-keyword">cluster</span> keyslot qs<br></code></pre></td></tr></table></figure><p>注意：key与slot的关系是永远不会变的，汇编的只有slot和redis节点的关系。</p><p><em>问题：怎么让相关的数据落到同一个节点上？</em></p><p>比如有些multi key操作是不能跨节点的，例如用户2673的基本信息和金融信息？</p><p>在key里面加入{hash tag}即可。Redis在计算槽编号的时候只会获取{}之间的字符串进行槽便哈计算，这样由于上面两个不同的键。{}里面的字符串是相同的，因此他们可以被计算出相同的槽。</p><h3 id="3-4-客户端重定向"><a href="#3-4-客户端重定向" class="headerlink" title="3.4 客户端重定向"></a>3.4 客户端重定向</h3><p>比如在7291端口的redis的redis-cli客户端操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">127.0.0.1:7291&gt; <span class="hljs-built_in">set</span> qs 1<br>(error)MOVED 13724 127.0.0.1:7293<br></code></pre></td></tr></table></figure><p>服务器返回MOVED，也就是根据key计算出来的slot不归7291端口管理，而是归7293端口管理，服务器返回MOVED告诉客户端去7293端口操作。这个时候更换端口，用redis-cli-p 7293操作，才会返回OK。或者用./redis-cli-c -o port的命令。Jedis等客户端会在本地维护一份slot——node的映射关系，大部分时候不需要重定向，所以叫做smart jedis（需要客户端支持）。</p><h3 id="3-5-数据迁移"><a href="#3-5-数据迁移" class="headerlink" title="3.5 数据迁移"></a>3.5 数据迁移</h3><p>因为key和slot的关系是永远不会变的，当新增了节点的时候，需要把原有的slot分配给新的节点负责，并且把相关的数据迁移过来。</p><p>添加新节点（新增一个7297）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli --cluster add-node 127.0.0.1:7291 127.0.0.1:7297<br></code></pre></td></tr></table></figure><p>新增的节点没有哈希槽，不能分布数据，在原来的任意一个节点上执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli --cluster reshard 127.0.0.1:7291<br></code></pre></td></tr></table></figure><p>输入需要分配的哈希槽的数量（比如500），和哈希槽的来源节点（可以输入all或者id）。</p><h3 id="3-6-高可用和主从切换原理"><a href="#3-6-高可用和主从切换原理" class="headerlink" title="3.6 高可用和主从切换原理"></a>3.6 高可用和主从切换原理</h3><p>当slave发现自己的master变成FAIL状态时，便尝试进行Failover，成为新的master。由于挂掉的master可能会有多个slave，从而存在多个slave竞争成为master节点的过程，其过程如下：</p><ol><li><p>slave发现自己的master变成Fail</p></li><li><p>将自己记录的集群currentEpoch加1，并广播FAILOVER_AUTH_REQUEST信息</p></li><li><p>其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack。</p></li><li><p>尝试failover的slave收集FAILOVER_AUTH_ACK</p></li><li><p>超过半数后变成新master</p></li><li><p>广播pong通知其他集群节点</p></li></ol><p>总结：Redis Cluster既能够实现主从的角色分配，又能够实现主从切换，相当于集成了Replication和Sentinel的功能。</p><h3 id="3-7-总结"><a href="#3-7-总结" class="headerlink" title="3.7 总结"></a>3.7 总结</h3><p>Redis Cluster特点：</p><ol><li><p>无中心架构</p></li><li><p>数据按照slot存储分布在多个节点，节点间数据共享，可动态调整数据分布。</p></li><li><p>可扩展性，可线性扩展到1000个节点（官方推荐不超过1000个），节点可动态添加或删除。</p></li><li><p>高可用性，部分节点不可用时，集群仍可用。通过增加Slave做standby数据副本，能够实现故障自动failover，节点之间通过gossip协议交换状态信息，用投票机制完成slave到master的角色提升。</p></li><li><p>降低运维成本，提高系统的扩展性和可用性。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis主从复制</title>
    <link href="/2023/03/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <url>/2023/03/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>redis支持集群的架构。集群的节点有主节点和从节点之分，主节点叫master，从节点叫slave。slave会通过复制的技术，自动同步master的数据。</p><h2 id="1-主从复制配置"><a href="#1-主从复制配置" class="headerlink" title="1  主从复制配置"></a>1  主从复制配置</h2><p>Redis的主从配置非常的简单，只需要在配置文件里面添加一行配置就可以了。例如一主多从，186是主节点，在每个slave节点的redis.conf配置文件增加一行:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">replicaof</span> <span class="hljs-string">192.168.44.186 6379</span><br></code></pre></td></tr></table></figure><p>从节点启动之后，就会自动连接到master节点，开始同步数据。如果master节点变了，比如原来的master宕机，选举出了新的master，这个配置会被重写。还有一种方式，就是在启动服务器时通过参数直接指定master节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">./redis-server --slaveof <span class="hljs-number">192.168</span><span class="hljs-number">.44</span><span class="hljs-number">.186</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><p>一个正在运行的节点，可以改变其他节点的从节点，这就是第三种方式，在客户端直接执行slaveof IP port，使该redis实例成为从节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">slaveof <span class="hljs-number">192.168</span><span class="hljs-number">.44</span><span class="hljs-number">.186</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><p>一个从节点也可以是其他节点的主节点，形成级联复制的关系。查看集群状态:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">redis&gt; info replication<br></code></pre></td></tr></table></figure><p>从节点是只读的，不能执行写操作。执行命令会报错。在主节点写入后，slave会自动从master同步数据。把配置文件里面的replica of去掉重启，或者直接断开复制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">redis&gt; slaveof no one<br></code></pre></td></tr></table></figure><p>此时从节点会变成自己的主节点，不再复制数据。MySQL的主从复制原理是依赖binlog，然后还有几个线程。</p><h2 id="2-主从复制原理"><a href="#2-主从复制原理" class="headerlink" title="2 主从复制原理"></a>2 主从复制原理</h2><p>Redis的主从复制分为两类，一种叫全量复制，就是一个节点第一次连接到master节点，需要全部的数据。第二种叫做增量复制，比如之前已经连接到master节点，但是中间网络断开，或者slave节点宕机了，缺失了一部分的数据。</p><h3 id="2-1-连接阶段"><a href="#2-1-连接阶段" class="headerlink" title="2.1 连接阶段"></a>2.1 连接阶段</h3><ol><li><p>  slave节点启动时（或者执行slaveof命令时），会在自己本地保存master节点的消息，包括master node的host和ip。</p></li><li><p>slave节点内部有个定时任务replicationCron，每个一秒检查是否有新的master node要连接和复制。</p></li></ol><p>如果发现有master节点，就跟master节点建立连接。如果连接成功，从节点就会连接建立一个专门处理复制工作的文件事件处理器负责后续的复制工作。为了让主节点感知到slave节点的存在，slave节点定时会给主节点发送ping请求。</p><h3 id="2-2-数据同步阶段"><a href="#2-2-数据同步阶段" class="headerlink" title="2.2 数据同步阶段"></a>2.2 数据同步阶段</h3><p>如果是新加入的slave节点，那就需要全量复制。Master通过bgsave命令再本地生成一份RDB快照，将RDB快文件发给slave节点（如果超时会重连，可以调大repl-timeout的值）。</p><p>如果slave自己本来有数据，Slave节点首先需要清除自己的旧数据，然后用RDB文件加载数据。</p><p>master节点生成RDB期间，如果接收到写命令，开始生成RDB文件时，master会把所有新的写命令缓存在内存中，在slave节点保存了RDB之后，再将新的写命令复制给slave节点。（跟AOF重写rewrite期间接收到的命令的处理思路是一样的）。</p><p>第一次全量同步完了，主从已经保持一致了，后面就是持续把接收到的命令发送给slave节点。</p><h3 id="2-3-命令传播阶段"><a href="#2-3-命令传播阶段" class="headerlink" title="2.3 命令传播阶段"></a>2.3 命令传播阶段</h3><p>master节点持续把写命令，异步复制给slave节点。总结起来非常的简单，前面同RDB文件，后面把命令发给slave节点，就实现了主从复制。注意，一般情况下不会用redis做读写分离，因为redis的吞吐量已经够高了，做集群分片之后并发的问题更少，所以不需要考虑主从延迟的问题。跟MySQL一样主从之间复制延迟是不可避免的，只能通过优化网络来改善。</p><p>第二种情况就是增量复制了。slave通过master_repl_offset记录偏移量。Redis的一个新特性，就是主从复制的无盘复制（从2.8.18版本开始支持无盘复制）。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">repl-diskless-sync</span>=<span class="hljs-string">no</span><br></code></pre></td></tr></table></figure><p>为了降低主节点的磁盘开销，redis支持无盘复制，master生成的RDB文件并不保存到磁盘而是直接通过网络发送给从节点。无盘复制适用于主节点所在机器磁盘性能较差但网络带宽较充裕的场景。</p><h2 id="3-主从复制不足"><a href="#3-主从复制不足" class="headerlink" title="3  主从复制不足"></a>3  主从复制不足</h2><p>Redis的主从复制解决了数据备份和一部分性能的问题，但是没有解决高可用的问题。在一主一从或者多主多从的情况下，如果主服务器挂了，对外提供的服务就不可用了，单点问题没有得到解决。跟mysql一样。如果每次都是手动把之前的从服务器切换到主服务器，然后再把剩余节点设置为它的从节点，这个比较费时费力，还会造成一定时间的服务不可用。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis哨兵(Sentinel)</title>
    <link href="/2023/03/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%93%A8%E5%85%B5(Sentinel)/"/>
    <url>/2023/03/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%93%A8%E5%85%B5(Sentinel)/</url>
    
    <content type="html"><![CDATA[<h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1  原理"></a>1  原理</h2><p>怎么实现高可用？第一个对于服务器来说，能够实现主从自动切换；第二个，对于客户端来说，如果发生了主从切换，它需要获取最新的master节点。这个怎么实现呢？这里面应该要有一个管理redis节点状态的角色，而且具备路由功能。比如RocketMQ是通过nameserver来实现的。思路：创建一台监控服务器来监控所有redis服务节点的状态，比如，master节点超过一定时间没有给监控服务器发送心跳报文，就把master标记为下线，之后把某一个slave变成master，应用每一次都是从这个监控服务器拿到master的地址。</p><p>Redis的高可用是通过哨兵Sentinel来保证的。它的思路就是通过运行监控服务器来保证服务的可用性。从redis2.8版本起，提供了一个稳定版本的哨兵，用来解决高可用的问题。我们会启动奇数个的哨兵服务（通过src/redis-sentinel）。可以同sentinel的脚本启动，也可以用redis-server的脚本加sentinel参数启动。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">./redis-sentinel ../sentinel.conf<br># 或者<br>./redis-server ../sentinel.conf --sentinel<br></code></pre></td></tr></table></figure><p>它的本质上只是一个运行在特殊模式之下的redis。Sentinel通过info命令得到被监听redis机器的master，slave信息。</p><p><img src="/image/redis/redis%E5%93%A8%E5%85%B5/1.png"></p><p>为保证监控服务器的可用性，会对Sentinel做集群的部署。Sentinel既监控所有的redis服务，Sentinel相互之间也监控。注意：Sentinel本身没有主从之分，地位是平等的，只有redis服务节点有主从之分。sentinel唯一的联系，就是监控相同的master，sentinel节点是怎么知道其他的Sentinel节点的存在的？因为Sentinel是一个特殊状态的redis节点，它也有发布订阅的功能。哨兵上线时，给所有的redis节点的名字为_sentinel_:hello的channle发送消息。每个哨兵都订阅了所有redis节点为_sentinel_:helo的channle，所以能相互感知对方的存在，而进行监控。</p><h3 id="1-1-服务下线"><a href="#1-1-服务下线" class="headerlink" title="1.1 服务下线"></a>1.1 服务下线</h3><p>sentinel默认以每秒钟1次的频率向redis服务节点发送ping命令。如果在指定时间内没有收到有效回复，sentinel会将该服务器标记为下线（主观下线）。由这个参数控制：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># sentiel.conf</span><br><span class="hljs-attr">sentiel</span> <span class="hljs-string">down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br></code></pre></td></tr></table></figure><p>默认是30秒。但是，只有发现master下线，并不代表master真的下线了。也有可能是网络出问题了。所以，这个时候第一个发现master下线的sentinel节点会继续询问其他的sentinel节点，确认这个节点是否下线，如果多数sentinel节点都认为master下线，master才真正被确认下线（客观下线）。确定master下线后，就需要重新选举master。Kafka有会在Broke里面选一个Controller出来。RocketMQ用Dledger技术选举（基于Raft协议）。</p><h3 id="1-2-故障转移"><a href="#1-2-故障转移" class="headerlink" title="1.2 故障转移"></a>1.2 故障转移</h3><p>Redis的选举和故障转移都是由sentinel完成的，故障转移流程的第一步就是在sentinel集群选择一个leader，由leader完成故障转移流程。Sentinel通过Raft算法，实现sentinel选举。</p><p><strong>Raft算法</strong></p><p>只要有了多个副本，就必然要面对副本一致性的问题。如果要所有的节点达成一致，必然要通过复制的方式实现。所以数据保持一致需要两个步骤：领导选举，数据复制。数据复制在redis主从复制中说过了，这里关注一下选举的实现。</p><p>Raft算法是一个共识算法(consensus algorith)。Spring cloud的注册中心解决方案Consul也用到了Raft协议。Raft的核心思想：先到先得，少数服从多数。sentinel的raft实现跟原生的算法有所区别，但是大体思想一致。</p><ol><li><p>分布式环境中的节点有三个状态: Follower,Candidate,Leader.</p></li><li><p>一开始所有的节点都是Follower状态.如果follower连接不到leader(leader挂了),它就会成为candidate。candidate请求其他节点的投票，其他的节点会投给它，如果它得到了大多数节点的投票，它就成为了主节点.这个过程就叫做leader election。</p></li><li><p>现在所有的写操作需要在leader节点上发生。leader会记录操作日志，没有同步到其他follower节点的日志，状态是uncommitted。等到超过半数的follower同步了这条记录，日志状态就会变成committed。leader会通知所有的follower日志已经committed，这个时候所有的节点就达成了一致，这个过程叫log replication。</p></li><li><p>在raft协议中，选举的时候有两个超时时间。第一个叫election timeout，也就是说，为了防止同一时间大量节点参与选举，每个节点在变成candidate之前需要随机等待一段时间，时间范围是150ms and 300ms之间。第一个变成candidate的节点会先发起投票，它会先投给自己，然后请求其他节点投票(request vote)。</p></li><li><p>如果还没有收到投票结果，又到了超时时间，需要重置超时时间，只要有大部分节点投给了一个节点，他就会变成leader。</p></li><li><p>成为leader之后，它会发消息来同步数据(append entries)，发消息的间隔是由heartbeat timeout的计时。</p></li><li><p>只要follower收到了同步数据的信息，代表leader没挂，他们就会清除heartbeat timeout的计时。</p></li><li><p>但是一旦followers在heartbeat timeout时间之内没有收到append entries消息，它就会认为leader挂了，开始让其他节点投票，成为新的leader。</p></li><li><p>必须超过半数以上节点投票，保证只有一个leader被选出来。</p></li><li><p>如果两个follower同时变成了candidate，就会出现分割投票，比如有两个节点同时变成candidate，而且各自有一个投票请求先达到了其他的节点。加上他们给自己的投票，每个candidate手上有两票。但是，因为他们的election timeout不同，在发起新的一轮选举的时候，有一个节点收到了更多的投票，所以它变成了leader。</p></li></ol><p>总结:sentinel的raft算法和raft论文略有不同.</p><ol><li><p>master客观下线触发选举，而不是过了election timeout时间开始选举。</p></li><li><p>leader并不会把自己成为leader的消息发送给其他sentinel。其他sentinel等待leader从slave选出master后，检测到新的master正常工作后，就会去掉客观下线的标识，从而不需要进入故障转移流程。</p></li></ol><p>到达这里，从所有的sentinel节点里面选出来一个leader，也就是所谓选举委员会主席，下面才是真正的选举。</p><p><strong>故障转移</strong></p><p>对于所有的slave节点，一共有四个因素影响选举的结果，分别是断开连接时长、优先级排序、复制数量、进程id。</p><ol><li><p>如果与哨兵连接断开的比较久，超过了某个阈值，就直接失去了选举权。</p></li><li><p>如果拥有选举权，那就看谁的优先级高，这个在配置文件里可以设置(replica-priority 100)，数值越小优先级越高。</p></li><li><p>如果优先级相同，那就看谁从master中复制的数据最多(复制偏移量最大)，选最多的那个。</p></li><li><p>如果复制量也相同，就选进程id最小的那个。</p></li></ol><p>Master节点确定之后，让其他的节点变成它的从节点：</p><ol><li><p>选出sentinel leader之后，由sentinel leader向某个节点发送slaveof no one命令，让他成为独立节点。</p></li><li><p>然后向其他节点发送slaveof x.x.x.x xxxx(本机ip端口)，让它们成为这个节点的从节点，故障转移完成。</p></li></ol><h2 id="2-功能总结"><a href="#2-功能总结" class="headerlink" title="2  功能总结"></a>2  功能总结</h2><p>监控：sentinel会不断检查主服务器和从服务器是否正常运行。</p><p>通知：如果某一个被监控的实例出现问题，sentinel可以通过命令发出通知。</p><p>自动故障转移(failover)：如果主服务器发生故障，sentinel可以启动故障转移过程，把某台服务器升级为主服务器，并发出通知。</p><p>配置管理：客户端连接到sentinel，获取当前的redis主服务器的地址。</p><h2 id="3-实战"><a href="#3-实战" class="headerlink" title="3  实战"></a>3  实战</h2><h3 id="3-1-Sentinel配置"><a href="#3-1-Sentinel配置" class="headerlink" title="3.1 Sentinel配置"></a>3.1 Sentinel配置</h3><p>为了保证sentinel的高可用,sentinel也需要做集群部署,集群中至少需要三个sentinel实例(推荐奇数个,防止脑裂).</p><table><thead><tr><th>hostname</th><th>ip地址</th><th>节点角色&amp;端口</th></tr></thead><tbody><tr><td>master</td><td>192.168.44.186</td><td>Master: 6379 / Sentinel: 26379</td></tr><tr><td>slave1</td><td>192.168.44.187</td><td>Slave: 6379 / Sentinel: 26379</td></tr><tr><td>slave2</td><td>192.168.44.188</td><td>Slave: 6379 / Sentinel: 26379</td></tr></tbody></table><p>以redis的安装路径/user/local/soft/redis-6.0.9/为例，在187和188的src/redis.conf配置文件中添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">replicaof <span class="hljs-number">192.168</span><span class="hljs-number">.44</span><span class="hljs-number">.186</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><p>在186,187,188创建sentinel配置文件(安装后根目录下默认有sentinel.conf)，三台服务器内容相同：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">daemonize</span> <span class="hljs-string">yes</span><br><span class="hljs-attr">port</span> <span class="hljs-string">26739</span><br><span class="hljs-attr">protected-mode</span> <span class="hljs-string">no</span><br><span class="hljs-attr">dir</span> <span class="hljs-string">&quot;/usr/local/soft/redis-6.0.9/sentinel-tmp&quot;</span><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">monitor redis-master 192.168.44.186 6379 2</span><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">down-after-milliseconds redis-master 30000</span><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">failover-timeout redis-master 180000</span><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">parallel-syncs redis-master 1</span><br></code></pre></td></tr></table></figure><p>上面出现了4个’redis-master’,这个名称要统一,并且使用客户端(比如jedis)连接的时候要使用这个名字。</p><table><thead><tr><th>配置</th><th>作用</th></tr></thead><tbody><tr><td>protected-mode</td><td>是否允许外部网络访问，yes不允许</td></tr><tr><td>dir</td><td>sentinel的工作目录</td></tr><tr><td>sentinel monitor</td><td>sentinel监控的redis主节点</td></tr><tr><td>sentinel down-after-milliseconds（毫秒）</td><td>master宕机多久，才会被sentinel主观认为下线</td></tr><tr><td>sentinel failover-timeout（毫秒）</td><td>1.同一个sentinel对同一个master两次failover之间的间隔时间<br />2.当一个slave从一个错误的master那里同步数据开始计算时间，知道slave被纠正为向正确的master那里同步的数据时间。<br />3.当想要取消一个正进行的failover所需要的时间。<br />4.当进行failover时，配置所有slaves指向新的master所需的最大时间</td></tr><tr><td>sentinel parallel-syncs</td><td>这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成failover所需的时间就越长，但是这个数字越大，就意味着越多的slave因为replication而不可用，可以通过将这个值设为1来保证每次只有一个slave处于不能处理命令请求的状态</td></tr></tbody></table><h3 id="3-2-Sentinel验证"><a href="#3-2-Sentinel验证" class="headerlink" title="3.2 Sentinel验证"></a>3.2 Sentinel验证</h3><p>启动redis服务和sentinel，查看集群状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">redis&gt; info replication<br></code></pre></td></tr></table></figure><p>模拟宕机,在主节点执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">redis&gt; shutdown<br></code></pre></td></tr></table></figure><p>某个节点会被选为新的master，只有一个slave节点。注意看sentinel.conf里面的redis-master被修改了！模拟原master恢复，启动redis-server。master又有两个slave了。</p><h3 id="3-3-Sentinel连接使用"><a href="#3-3-Sentinel连接使用" class="headerlink" title="3.3 Sentinel连接使用"></a>3.3 Sentinel连接使用</h3><p>Jedis连接sentinel，master name来自于sentinel.conf的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisSentinelPool <span class="hljs-title function_">createJedisPool</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">masterName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;redis-master&quot;</span>;<br>    Set&lt;String&gt; sentinels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    sentinels.add(<span class="hljs-string">&quot;192.168.44.186:26379&quot;</span>);<br>    sentinels.add(<span class="hljs-string">&quot;192.168.44.187:26379&quot;</span>);<br>    sentinels.add(<span class="hljs-string">&quot;192.168.44.188:26379&quot;</span>);<br>    pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisSentinelPool</span>(masterName, sentinels);<br>    <span class="hljs-keyword">return</span> pool;<br>&#125;<br></code></pre></td></tr></table></figure><p>Springboot连接sentinel:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.redis.sentinel.master</span>=<span class="hljs-string">redis-master</span><br><span class="hljs-attr">spring.redis.sentinel.nodes</span>=<span class="hljs-string">192.168.44.186:26379,192.168.44.187:26379,192.168.44.188:26379</span><br></code></pre></td></tr></table></figure><p>无论是jedis还是springbot(2.x版本默认是Lettuce)，都只需要配置全部哨兵的地址，由哨兵返回当前的master节点地址。</p><h2 id="4-不足"><a href="#4-不足" class="headerlink" title="4 不足"></a>4 不足</h2><p>主从切换的过程中会丢失数据，因为只有一个master。只能单点写，没有解决水平扩容的问题。如果数据量非常大，这个时候就要对redis的数据进行分片了。这个时候需要多个master-slave的group，把数据分布到不同的group中。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis持久化机制</title>
    <link href="/2023/02/28/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/02/28/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>Redis速度快，很大一部分原因是因为它所有的数据都存储在内存中。如果断电或者宕机，都会导致内存的数据丢失。为了实现重启后数据不丢失，redis提供了两种持久化的方案，一种是RDB快照（Redis Database），一种是AOF（Append Only File）。持久化是redis跟memcache的主要区别之一。</p><h2 id="1-RDB"><a href="#1-RDB" class="headerlink" title="1. RDB"></a>1. RDB</h2><p>RDB是redis默认的持久化方案（注意如果开启了AOF，优先用AOF）。当满足一定条件的时候，会把当前内存中的数据写入磁盘，生成一个快照文件dump.rdb。redis重启会通过加载dump.rdb文件恢复数据。</p><h3 id="1-1-Rdb触发"><a href="#1-1-Rdb触发" class="headerlink" title="1.1 Rdb触发"></a>1.1 Rdb触发</h3><p><strong>1 自动触发</strong></p><p>a） 配置规则触发。</p><p>redis.conf，SNAPSHOTTING，其中定义了触发把数据保存到磁盘的触发频率。如果不需要rdb方案，注释save或者配置成空字符串“”。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span>     #<span class="hljs-number">900</span>秒内至少有一个key被修改（包括添加）<br><span class="hljs-attribute">save</span> <span class="hljs-number">400</span> <span class="hljs-number">10</span>    #<span class="hljs-number">400</span>秒内至少有<span class="hljs-number">10</span>个key被修改<br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span>  #<span class="hljs-number">60</span>秒内至少有<span class="hljs-number">10000</span>个key被修改<br></code></pre></td></tr></table></figure><p>注意上面的配置是不冲突的，只要满足任意一个都会触发。用lastsave命令可以查看最近一次成功生成快照的时间。Rdb文件位置和目录（默认在安装根目录下）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">dir</span> ./  <span class="hljs-comment">#文件路径</span><br>dbfilename dump.rdb  <span class="hljs-comment">#文件名称</span><br>rdbcompression <span class="hljs-built_in">yes</span>  <span class="hljs-comment">#是否以LZF压缩rdb文件</span><br>rdbchechsum <span class="hljs-built_in">yes</span>  <span class="hljs-comment">#开启数据校验</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>dir</td><td>rdb文件默认在启动目录下（相对路径） config get dir获取</td></tr><tr><td>dbfilename</td><td>文件名称</td></tr><tr><td>rdbcompression</td><td>开启压缩可以节省存储空间，但是会消耗一些CPU的计算时间，默认开启</td></tr><tr><td>rdbchecksum</td><td>使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</td></tr></tbody></table><p>b） shutdown触发，保证服务器正常关闭。</p><p>c） flushall，rdb文件是空的，没什么意义。</p><p><strong>2 手动触发</strong></p><p>如果我们需要重启服务或者迁移数据，这个时候就需要手动触发快照保存。Redis提供了两条命令：</p><p>a） save，在生成快照的时候会阻塞当前redis服务器，redis不能处理其他命令。如果内存中的数据比较多，会造成redis长时间的阻塞。生产环境下不建议使用这个命令。</p><p>b） 执行bgsave，执行bgsave时，redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体操作是redis进程执行fork操作创建子线程（copy-on-write），rdb持久化过程由子进程负责，完成后自动结束。它不会记录fork之后产生的数据。阻塞只发生在fork阶段，一般时间很短。</p><h3 id="1-2-RDB数据恢复"><a href="#1-2-RDB数据恢复" class="headerlink" title="1.2 RDB数据恢复"></a>1.2 RDB数据恢复</h3><ol><li> shutdown持久化</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#添加键值</span><br>redis&gt; <span class="hljs-built_in">set</span> k1 1<br>redis&gt; <span class="hljs-built_in">set</span> k2 2<br>redis&gt; <span class="hljs-built_in">set</span> k3 3<br>redis&gt; <span class="hljs-built_in">set</span> k4 4<br>redis&gt; <span class="hljs-built_in">set</span> k5 5<br><span class="hljs-comment">#停止服务器，触发save</span><br>redis&gt; shutdown<br><span class="hljs-comment">#备份dump.rdb文件</span><br><span class="hljs-built_in">cp</span> dump.rdb dump.rdb.bak<br><span class="hljs-comment">#启动服务器，数据都在</span><br>redis&gt; redis-server redis.conf<br></code></pre></td></tr></table></figure><ol start="2"><li>模拟数据丢失</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#模拟数据丢失，触发save</span><br>redis&gt; shutdown<br><span class="hljs-comment">#停止服务器</span><br>redis&gt; shutdown<br><span class="hljs-comment">#启动服务器</span><br>redis&gt; redis-server redis.conf<br><span class="hljs-comment">#数据丢失</span><br></code></pre></td></tr></table></figure><ol start="3"><li> 通过该备份文件恢复数据</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#停止服务器</span><br>redis&gt; shutdown<br><span class="hljs-comment">#重命名备份文件</span><br><span class="hljs-built_in">mv</span> dump.rdb.bak dump.rdb<br><span class="hljs-comment">#启动服务器</span><br>redis&gt; redis-server redis.conf<br><span class="hljs-comment">#数据找回</span><br></code></pre></td></tr></table></figure><h3 id="1-3-RDB文件的优劣"><a href="#1-3-RDB文件的优劣" class="headerlink" title="1.3 RDB文件的优劣"></a>1.3 RDB文件的优劣</h3><p>一、 优势</p><p>1． Rdb是一个非常紧凑（compact）的文件，它保存了redis在某个时间点上的数据集。这种文件非常适合用于进行备份和灾难恢复。</p><p>2． 生成rdb文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘io操作。</p><p>3． Rdb在恢复大数据集时的速度比aof的恢复速度快。</p><p>二．劣势</p><p>1.rdb方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，频繁执行成本过高。</p><p>2.在一定间隔时间做一次备份，所以如果redis意外当掉的话，就会丢失最后一次快照之后的所有修改（数据又丢失）。</p><p>​    如果数据相对来说比较重要，希望将损失降到最小，则可以使用aof方式进行持久化。</p><h2 id="2-AOF"><a href="#2-AOF" class="headerlink" title="2. AOF"></a>2. AOF</h2><p>Redis默认不开启。aof采用日志的形式来记录每个写操作，并追加文件中。开启后，执行更改redis数据的命令时，就会把命令写入到aof文件中。Redis重启时会根据日志文件的内容把写指令从前到后执行一次以完成数据的恢复工作。</p><h3 id="2-1-aof配置"><a href="#2-1-aof配置" class="headerlink" title="2.1 aof配置"></a>2.1 aof配置</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 开关</span><br><span class="hljs-attr">appendonly</span> <span class="hljs-string">no</span><br><span class="hljs-comment"># 文件名</span><br><span class="hljs-attr">appendfilename</span> <span class="hljs-string">&quot;appendonly.aof&quot;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>appendonly</td><td>Redis默认只开启RDB持久化，开启AOF需要修改为yes</td></tr><tr><td>appendfilename</td><td>路径也是通过dir参数配置，config get dir</td></tr></tbody></table><p>由于操作系统的缓存机制，aof数据并没有真正地写入磁盘，而是进入了系统的硬盘缓存。什么时候把缓冲区的内容写入到aof文件？</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>appendfsync everysec</td><td>AOF持久化策略(硬盘缓存到磁盘)，默认everysec <br />no—-表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快，但是不安全<br />always—-表示每次写入都执行fsync，以保证数据同步到磁盘，效率很低<br />everysec—-表示每秒执行一次fsync，可能会导致丢失这1s的数据，通常选择everysec，兼顾安全和效率</td></tr></tbody></table><p>由于aof持久化是redis不断将写命令记录到aof文件中，随着redis不断的进行，aof文件会越来越大，文件越大，占用服务器内存越大以及aof恢复要求时间越长。例如计数器增加100万次，100万个命令都记录进去了，但是结果只有一个。为了解决这个问题，redis新增了重写机制，当aof文件的大小超过锁设定的阈值时，redis就会启动aof文件的内容压缩，值保留可以恢复数据的最小指令集。可以使用命令bgrewriteaof来重写。Aof文件重写并不是对原文件进行重新整理，而是读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令，生成一个新的文件后去替换原来的aof文件。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 重写触发机制</span><br><span class="hljs-attr">auto-aof-rewrite-percentage</span> <span class="hljs-string">100</span><br><span class="hljs-attr">auto-aof-rewrite-min-size</span> <span class="hljs-string">64mb</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>auto-aof-rewrite-percentage</td><td>默认值是100，aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写，当前AOF文件大小是上次日志重写得到aof文件大小的二倍(设置为100)时，自动启动新的日志重写过程。</td></tr><tr><td>auto-aof-rewrite-min-size</td><td>默认64M。设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写</td></tr></tbody></table><p><em>问题：重写过程中，AOF文件被更改了怎么办？</em></p><p>当子进程执行aof重写时，主进程需要执行以下三个工作：</p><p>（1）处理命令请求；（2）将写命令追加到现有的aof文件中；（3）将写命令追加到aof重写缓存中</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>no-appendfsync-on-rewrite</td><td>在aof重写或者写入rdb文件时，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成过长时间的阻塞，no-appendfsync-on-rewrite字段设置为默认no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。设置为yes表示rewrite期间对新写操作不fsync，暂时存在内存中，等rewrite完成后再写入，默认为no，建议修改为yes。Linux默认fsync策略是30秒。可能丢失30秒数据。</td></tr><tr><td>aof-load-truncated</td><td>aof文件可能在尾部是不完整的，当redis启动时，aof文件的数据被载入内存中。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项，出现这种现象。redis宕机或者异常终止不会造成尾部不完整现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复aof文件才可以。默认为yes。</td></tr></tbody></table><h3 id="2-2-AOF数据恢复"><a href="#2-2-AOF数据恢复" class="headerlink" title="2.2 AOF数据恢复"></a>2.2 AOF数据恢复</h3><p>重启redis后就会进行aof文件的恢复</p><h3 id="2-3-AOF的优劣势"><a href="#2-3-AOF的优劣势" class="headerlink" title="2.3 AOF的优劣势"></a>2.3 AOF的优劣势</h3><p>一、 优点：</p><p>​    1． Aof持久化的方法提供了多种的同步频率，即使用默认的同步频率每秒同步一次，redis最多也就丢失1秒的数据而已。</p><p>二、缺点</p><p>​    1.对于具有相同数据的redis，aof文件通常会比RDB文件体积更大（rdb存的是数据快照）</p><p>​    2.虽然aof提供了多种同步的频率，默认情况下，每秒同步一次的频率也具有较高的性能，在高并发的情况下，rdb比aof具有更好的性能保证。</p><h2 id="3-两种方案比较"><a href="#3-两种方案比较" class="headerlink" title="3.  两种方案比较"></a>3.  两种方案比较</h2><p>如果可以忍受一小段时间内数据的丢失，毫无疑问使用rdb是最好的，定时生成rdb快照（snapshot）非常便于进行数据库备份，并且rdb恢复数据集的速度也要比aof恢复的速度要快。否则就是用AOF重写。但是一般情况下建议不要单独使用某一种持久化机制，而是应该两种一起用，在这种情况下，当redis重启的时候会优先加载aof文件来恢复原始的数据，因为在通常情况下aof文件保存的数据集要比RDB文件保存的数据集要完整。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis内存回收</title>
    <link href="/2023/02/27/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    <url>/2023/02/27/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="1-过期策略"><a href="#1-过期策略" class="headerlink" title="1. 过期策略"></a>1. 过期策略</h2><h3 id="1-1-立即过期-主动淘汰"><a href="#1-1-立即过期-主动淘汰" class="headerlink" title="1.1 立即过期(主动淘汰)"></a>1.1 立即过期(主动淘汰)</h3><p>每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好，但是会占用大量CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p><h3 id="1-2-惰性过期-被动淘汰"><a href="#1-2-惰性过期-被动淘汰" class="headerlink" title="1.2 惰性过期(被动淘汰)"></a>1.2 惰性过期(被动淘汰)</h3><p>只有当访问一个key时，才会判断该key是否已经过期，过期则清除。该策略可以最大化的节省CPU资源，却对内存非常不友好。极端情况下可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p><p>第一种情况，所有的查询都会调用expireIfNeeded判断是否过期：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">expireIfNeeded(redisDb *db, robj *key)<br></code></pre></td></tr></table></figure><p>第二种情况，每次写入key时，发现内存不够，吊桶activeExpireCycle释放一部分内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">activeExpireCycle(<span class="hljs-type">int</span> type)<br></code></pre></td></tr></table></figure><h3 id="1-3-定期过期"><a href="#1-3-定期过期" class="headerlink" title="1.3 定期过期"></a>1.3 定期过期</h3><p>每隔一定的时间，会扫描一定数量的数据库的expire字典中一定数量的key，并清除其中已经过期的key。该策略是前两者的一个折中方案，通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以再不同情况下使得Cpu和内存资源达到最优的平衡效果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span>&#123;</span><br>    dict *dict;<br>    dict *expires;<br>    dict *blocking_keys;<br>    dict *ready_keys;<br>    dict *watched_keys;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> avg_ttl;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> expires_cursor;<br>    <span class="hljs-built_in">list</span> *defrag_later;<br>&#125; redisDb;<br></code></pre></td></tr></table></figure><p>总结: Redis中同时使用了惰性过期和定期过期两种过期策略，并不是实时的清除过期的key。</p><h2 id="2-淘汰策略"><a href="#2-淘汰策略" class="headerlink" title="2. 淘汰策略"></a>2. 淘汰策略</h2><p>Redis的内存淘汰策略，是指当内存使用达到最大内存极限时，需要使用淘汰算法来决定清理掉哪些数据，以保证新数据的存入。</p><h3 id="2-1-最大内存设置"><a href="#2-1-最大内存设置" class="headerlink" title="2.1 最大内存设置"></a>2.1 最大内存设置</h3><p>Redis.conf参数配置  #maxmemory <bytes></p><p>如果不设置maxmemory或者设置为0，32位系统最多使用3GB内存，64位系统不限制内存。</p><p>动态修改（先get一下）：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">redis&gt;<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> maxmemory 2GB<br></code></pre></td></tr></table></figure><h3 id="2-2-淘汰策略"><a href="#2-2-淘汰策略" class="headerlink" title="2.2 淘汰策略"></a>2.2 淘汰策略</h3><p><a href="https://redis.io/docs/reference/eviction/">https://redis.io/docs/reference/eviction/</a></p><p>redis.conf   #maxmemory-policy noeviction</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coq"># volatile-lru -&gt; Evict <span class="hljs-built_in">using</span> approximated LRU, only keys <span class="hljs-built_in">with</span> an expire <span class="hljs-built_in">set</span><br># allkeys-lru  -&gt; Evict any key <span class="hljs-built_in">using</span> approximated LRU<br># vloatile-lfu -&gt; Evict <span class="hljs-built_in">using</span> approximated LFU, only keys <span class="hljs-built_in">with</span> an expire <span class="hljs-built_in">set</span><br># allkeys-lfu  -&gt; Evict any key <span class="hljs-built_in">using</span> approximated LFU<br># volatile-random -&gt; <span class="hljs-keyword">Remove</span> a random key having an expire <span class="hljs-built_in">set</span><br># allkeys-random  -&gt; <span class="hljs-keyword">Remove</span> a random key, any key<br># volatile-ttl -&gt; <span class="hljs-keyword">Remove</span> the key <span class="hljs-built_in">with</span> the nearest expire <span class="hljs-built_in">time</span>(minor TTL)<br></code></pre></td></tr></table></figure><p>（1）先从后缀的算法名来看：</p><p>LRU，Least Recently Used：最近最少使用。判断最近被使用的时间，目前最远的数据有限被淘汰。</p><p>LFU，Least Frequently Used：最不常用，按照使用频率删除，4.0版本新增。</p><p>Random 随机删除。</p><p>（2）从前缀针对的对象来分：volatile是针对设置了ttl的key，allkeys是针对所有key</p><table><thead><tr><th>策略</th><th>含义</th></tr></thead><tbody><tr><td>volatile-lru</td><td>根据LRU算法删除设置了超时属性(expire)的键，直到腾出足够内存为止。如果没有可删除的对象，回退到noeviction策略</td></tr><tr><td>allkeys-lru</td><td>根据LRU算法删除键，不管数据有没有设置超时属性，知道腾出足够的内存为止</td></tr><tr><td>volatile-lfu</td><td>在带有过期时间的键中选择最不常用的</td></tr><tr><td>allkeys-lfu</td><td>在所有键中选择最不常用的，不管数据有没有设置超时属性</td></tr><tr><td>volatile-random</td><td>在带有过期时间的键中随机选择</td></tr><tr><td>allkeys-random</td><td>随机删除所有键，知道腾出足够内存为止</td></tr><tr><td>volatile-ttl</td><td>根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noevitcion策略</td></tr><tr><td>noeviction</td><td>默认策略，不会删除任何数据，拒绝所有写入操作并返回客户端错误信息(error)OOM command not allowed when used memory, 此时Redis只响应读操作</td></tr></tbody></table><p>如果没有设置ttl或者没有符合前提条件的key被淘汰，那么volatile-lru，volatile-random，volatile-ttl相当于noeviction（不做内存回收）。动态修改淘汰策略（先get一下）</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">redis&gt; config set maxmemory-policy <span class="hljs-keyword">volatile</span>-lru<br></code></pre></td></tr></table></figure><p>建议使用volatile-lru，在保证正常服务的情况下，有限删除最近最少使用的key。</p><h3 id="2-3-LRU淘汰原理"><a href="#2-3-LRU淘汰原理" class="headerlink" title="2.3 LRU淘汰原理"></a>2.3 LRU淘汰原理</h3><p>LRU是一个很常见的算法，比如InnoDB的Buffer Pool也用到了LRU。传统LRU：通过链表+HashMap实现，设置链表长度，如果新增或者被访问，就移动到头节点，超过链表长度，末尾的节点被删除。</p><p><img src="/image/redis/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/1.png"></p><p>如果基于传统LRU算法实现redis LRU的话，需要额外的数据结构存储，消耗内存。所以Redis LRU对传统的LRU算法进行了改良，通过随机采样来调整算法的精度。如果淘汰策略是LRU，则根据篇日志的采样值maxmemory_samples（默认是5个），随机从数据库中选择m个key，淘汰其中热度最低的key对应的缓存数据。所以采样参数m配置的数值越大，就越能精确的查找到待淘汰的缓存数据，但是也消耗更多的CPU计算，执行效率降低。</p><p>Redis中所有对象结构都有一个lru字段，且使用了unsigned的低24位，这个字段用来记录对象的热度。对象被创建时会记录lru值。在被访问的时候也会更新lru的值。但并不是获取系统当前的时间戳，而是设置位全局变量server.lruclock的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span>&#123;</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS;<br>    <span class="hljs-type">int</span> refcount;<br>    <span class="hljs-type">void</span> *ptr;<br>&#125; robj;<br></code></pre></td></tr></table></figure><p>Redis中有个定时处理的函数serverCron，默认每100毫秒调用函数updateCachedTime更新一次全局变量的server.lruclock的值，它记录的是当前unix时间戳。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">updateCachedTime</span><span class="hljs-params">(<span class="hljs-type">int</span> update_daylight_info)</span>&#123;<br>    server.ustime = ustime();<br>    server.mstime = server.ustime / <span class="hljs-number">1000</span>;<br>    server.unixtime = server.mstime / <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">if</span>(update_daylight_info)&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> <span class="hljs-title">tm</span>;</span><br>        <span class="hljs-type">time_t</span> ut = server.unixtime;<br>        localtime_r(&amp;ut,&amp;tm);<br>        server.daylight_active = tm.tm_isdst;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>问题：为什么不获取精确的时间而是放在全局变量中？不会有延迟的问题吗？</em></p><p>这样函数查询key调用lookupKey中更新数据的lru热度值时，就不用换每次调用系统函数time，可以提高执行效率。</p><p>当对象里面已经有了LRU字段的值，就可以评估对象的热度了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">estimeteObjectIdleTime</span><span class="hljs-params">(robj *o)</span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> lrulock = LRU_CLOCK();<br>    <span class="hljs-keyword">if</span>(lruclock &gt;= o-&gt;lru)&#123;<br>        <span class="hljs-keyword">return</span> (lruclock - o-&gt;lru) * LRU_CLOCK_RESOLUTION;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> (lruclock + (LRU_CLOCK_MAX - o-&gt;lru)) * LRU_CLOCK_RESOLUTION;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数estimateObjectIdleTime评估指定对象的lru热度，方法就是对象的lru值和全局的server.lruclock的差值越大（越久没有得到更新）,该对象热度越低。server.lruclock 只有24位，按秒位单位来标识才能存储194天。但超过24bit能表示的最大时间的时候，他会从头开始计算。在这种情况下，可能会出现对象的lru大于server.lruclocl的情况，如果这种情况出现那么就两个相加而不是相减来求最久的key。</p><p>Redis LRU算法在sample为10的情况下，已经能接近传统LRU算法了。</p><h3 id="2-4-LFU"><a href="#2-4-LFU" class="headerlink" title="2.4 LFU"></a>2.4 LFU</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span>&#123;</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-type">unsigned</span> enncoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS;<br>    <span class="hljs-type">int</span> refcount;<br>    <span class="hljs-type">void</span> *ptr;<br>&#125; robj;<br></code></pre></td></tr></table></figure><p>当这24bits 用作LFU时，其被分为两部分：高16位用来记录访问时间（单位为分钟，Idt-last decrement time）低8位用来记录访问频率，简称counter（logc-logistic counter）</p><p>counter是用基于概率的对数计数器来实现的，8位可以标识百万次的访问频率。对象被读写的时候，lfu的值会被更新。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">updateLFU</span><span class="hljs-params">(robj *val)</span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counter = LFUDecrAndReturn(val);<br>    counter = LFULogIncr(counter);<br>    val-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="hljs-number">8</span>) | counter;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然这里并不是访问一次，技术就加1。增长的速率由一个参数决定，lfu-log-factor越大，counter增长的越慢，redis.conf配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># lfu-log-factor 10</span><br></code></pre></td></tr></table></figure><p>如果一段时间热点高，就一直保持这个热度，肯定也是不行的，体现不了整体频率。所以，没有被访问的时候，计数器还要递减。减少的值由衰减因子lfu-decay-time(分钟)来控制，如果值是1的话，N分钟没有访问，计数器就要减少N。lfu-decay-time越大，衰减越慢。Redis.conf配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># lfu-decay-time 1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nacos注册中心</title>
    <link href="/2023/02/27/spring%E6%A1%86%E6%9E%B6/springcloud/nacos/nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <url>/2023/02/27/spring%E6%A1%86%E6%9E%B6/springcloud/nacos/nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p><em>Nacos版本：2.0.4   nacos2.x已不支持ribbon，使用nacos2.x需要手动引入LoadBalancer</em></p><p><a href="https://nacos.io/zh-cn/docs/sdk.html">https://nacos.io/zh-cn/docs/sdk.html</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#服务注册</span><br>curl -X POST <span class="hljs-string">&#x27;http://localhost:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=8080&#x27;</span><br><br><span class="hljs-comment">#服务发现</span><br>curl -X GET <span class="hljs-string">&#x27;http://localhost:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h2><h3 id="1-1-基于Java-SDK的服务注册与发现"><a href="#1-1-基于Java-SDK的服务注册与发现" class="headerlink" title="1.1 基于Java SDK的服务注册与发现"></a>1.1 基于Java SDK的服务注册与发现</h3><p><a href="https://nacos.io/zh-cn/docs/sdk.html">https://nacos.io/zh-cn/docs/sdk.html</a></p><p>（1）引入nacos-client包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.nacos<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>nacos-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）编写Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceRegisterAndDiscovery</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NacosException, IOException&#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        properties.setProperty(<span class="hljs-string">&quot;serverAddr&quot;</span>, <span class="hljs-string">&quot;192.168.0.108:8848&quot;</span>); <span class="hljs-comment">//集群地址用逗号隔开</span><br>        <span class="hljs-type">NamingService</span> <span class="hljs-variable">naming</span> <span class="hljs-operator">=</span> NamingFactory.createNamingService(properties);<br>        <span class="hljs-comment">// 服务注册</span><br>System.out.println(<span class="hljs-string">&quot;-----服务注册-----&quot;</span>);<br>naming.registerInstance(<span class="hljs-string">&quot;nacos.test.3&quot;</span>, <span class="hljs-string">&quot;11.11.11.11&quot;</span>, <span class="hljs-number">8888</span>, <span class="hljs-string">&quot;TEST1&quot;</span>);<br><span class="hljs-comment">// 服务发现</span><br>System.out.println(<span class="hljs-string">&quot;-----服务发现-----&quot;</span>);<br>System.out.println(naming.getAllInstances(<span class="hljs-string">&quot;nacos.test.3&quot;</span>));<br>System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-基于SC的服务注册"><a href="#1-2-基于SC的服务注册" class="headerlink" title="1.2 基于SC的服务注册"></a>1.2 基于SC的服务注册</h3><p>（1）引入版本管理依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入spring cloud 版本管理 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入spring cloud alibaba 版本管理 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--引入spring cloud netflix 版本管理--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-netflix-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（2）引入nacos discovery依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（3）在application.yml文件中编写配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-comment"># nacos server地址</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-comment"># 服务名称</span><br>        <span class="hljs-attr">service:</span> <span class="hljs-string">order</span><br></code></pre></td></tr></table></figure><p>（4）启动order-9091、9092、9093，观察nacos dashboard的服务情况</p><h3 id="1-3-SC的服务发现"><a href="#1-3-SC的服务发现" class="headerlink" title="1.3 SC的服务发现"></a>1.3 SC的服务发现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义服务发现接口，使用DiscoveryClient测试</span><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;<br><span class="hljs-meta">@RequestMapping(&quot;/instances&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;ServiceInstance&gt; <span class="hljs-title function_">instances</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;serviceId&quot;)</span>String serviceId)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.discoveryClient.getInstances(serviceId);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-Nacos领域模型"><a href="#1-4-Nacos领域模型" class="headerlink" title="1.4 Nacos领域模型"></a>1.4 Nacos领域模型</h3><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/1.png"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 创建一个命名空间，名称为dev，并获取到其id：9c52616a-48c0-4f78-a256-573b6fb5a152</span><br><span class="hljs-comment"># 查看dev命名空间下的服务，发现没有任何服务</span><br><span class="hljs-comment"># 修改user服务的application.yml文件，主要配置体验一下namespace、group和cluster</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-comment"># nacos server地址</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-comment"># 服务名称</span><br>        <span class="hljs-attr">service:</span> <span class="hljs-string">user</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">9c52616a-48c0-4f78-a256-573b6fb5a152</span><br>        <span class="hljs-attr">group:</span> <span class="hljs-string">shop-group</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">BJ</span><br><span class="hljs-comment"># 启动user服务，观察nacos dashboard dev命名空间下的数据</span><br><span class="hljs-comment"># 调用user服务中UserController提供的服务发现代码，发现调用失败，说明不同名命名空间下的服务是隔离的</span><br><span class="hljs-comment"># http://localhost:8081/user/instances?serviceId=order</span><br></code></pre></td></tr></table></figure><h3 id="1-5-Nacos元信息-Metadata"><a href="#1-5-Nacos元信息-Metadata" class="headerlink" title="1.5 Nacos元信息(Metadata)"></a>1.5 Nacos元信息(Metadata)</h3><p>Nacos数据（如配置和服务）描述信息，如服务版本、权重、容灾策略、负载均衡策略、鉴权配置、 各种自定义标签 (label)，从作用范围来看，分为服务级别的元信息、集群的元信息及实例的元信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 配置元信息</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">Jack</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/2.png"></p><h3 id="2-1-Nacos-Server启动"><a href="#2-1-Nacos-Server启动" class="headerlink" title="2.1 Nacos Server启动"></a>2.1 Nacos Server启动</h3><ol><li>Nacos 2.x</li></ol><p>（1）http方式，以Spring Boot的方式启动内置的Tomcat容器，并且实例化很多Controller提供Http请求的访问形式，比如InstanceController。启动方式和正常springboot启动相同。用于持久节点注册</p><p>（2）在Nacos2.X中新增了gRPC的通信方式，所以会在Server端提供gRPC的监听，用于处理客户端的连接。用于临时节点注册。</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos-grpc-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.jpg"></p><ol start="2"><li><p>Nacos 1.x</p><p> 只有http方式</p></li></ol><h3 id="2-2-Spring-Boot启动调用Nacos-API"><a href="#2-2-Spring-Boot启动调用Nacos-API" class="headerlink" title="2.2 Spring Boot启动调用Nacos API"></a>2.2 Spring Boot启动调用Nacos API</h3><p>（1）Spring Boot项目启动 </p><p>（2）Spring Boot发布ServletWebServerInitializedEvent事件 </p><p>（3）Spring Cloud监听器AbstractAutoServiceRegistration 监听感兴趣事件 WebServerInitializedEvent </p><p>（4）回调AbstractAutoServiceRegistration#onApplicationEvent</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/3.png"></p><h3 id="2-3-Nacos客户端向服务端发起服务注册"><a href="#2-3-Nacos客户端向服务端发起服务注册" class="headerlink" title="2.3 Nacos客户端向服务端发起服务注册"></a>2.3 Nacos客户端向服务端发起服务注册</h3><p>（1）Nacos 2.x</p><ul><li>入口：NacosNamingService#registerInstance(serviceName,groupName,Instance instance)</li></ul><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos2.x-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.jpg"></p><p>（2）Nacos 1.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos1.x-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.jpg"></p><h3 id="2-4-Nacos服务端处理服务注册"><a href="#2-4-Nacos服务端处理服务注册" class="headerlink" title="2.4 Nacos服务端处理服务注册"></a>2.4 Nacos服务端处理服务注册</h3><p>（1）Nacos 2.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos2.x-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C.jpg"></p><p>（2）Nacos 1.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos1.x-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C.jpg"></p><h3 id="2-5-心跳机制与健康检查"><a href="#2-5-心跳机制与健康检查" class="headerlink" title="2.5 心跳机制与健康检查"></a>2.5 心跳机制与健康检查</h3><p>（1）Nacos 2.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos2.x-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5.jpg"></p><p>（2）Nacos 1.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos1.x-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5.jpg"></p><h3 id="2-6-服务发现与订阅及通知客户端"><a href="#2-6-服务发现与订阅及通知客户端" class="headerlink" title="2.6 服务发现与订阅及通知客户端"></a>2.6 服务发现与订阅及通知客户端</h3><p>（1）Nacos 2.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos2.x-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0.jpg"></p><p>（2）Nacos 1.x</p><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos1.x-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0.jpg"></p><h3 id="2-7-分布式架构"><a href="#2-7-分布式架构" class="headerlink" title="2.7 分布式架构"></a>2.7 分布式架构</h3><p>如果注册Nacos的client节点注册时ephemeral=true，那么Nacos集群对这个client节点的效果就是AP，采用distro协议实现；而注册Nacos的client节点注册时ephemeral=false，那么Nacos集群对这个节点的效果就是CP的，采用raft协议实现。根据client注册时的属性，AP，CP同时混合存在，只是对不同的client节点效果不同。Nacos可以很好的解决不同场景的业务需求。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#false为永久实例，true表示临时实例开启，注册为临时实例，默认是true</span><br><span class="hljs-attr">spring.cloud.nacos.discovery.ephemeral</span> = <span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><h4 id="2-7-1-AP架构-distro"><a href="#2-7-1-AP架构-distro" class="headerlink" title="2.7.1 AP架构-distro"></a>2.7.1 AP架构-distro</h4><p><img src="/image/springcloud/nacos/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/nacos2.x-%E5%88%86%E5%B8%83%E5%BC%8FAP%E6%9E%B6%E6%9E%84.jpg"></p><h4 id="2-7-2-CP架构-raft"><a href="#2-7-2-CP架构-raft" class="headerlink" title="2.7.2 CP架构-raft"></a>2.7.2 CP架构-raft</h4><p><a href="https://raft.github.io/">https://raft.github.io/</a></p><p><a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p><p><a href="https://raft.github.io/#implementations/">https://raft.github.io/#implementations/</a></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>nacos</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
      <tag>nacos</tag>
      
      <tag>服务注册中心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nacos安装与配置</title>
    <link href="/2023/02/27/spring%E6%A1%86%E6%9E%B6/springcloud/nacos/nacos%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/02/27/spring%E6%A1%86%E6%9E%B6/springcloud/nacos/nacos%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p><em>Nacos版本：2.0.4   nacos2.x已不支持ribbon，使用nacos2.x需要手动引入LoadBalancer</em></p><h2 id="1-单机版"><a href="#1-单机版" class="headerlink" title="1. 单机版"></a>1. 单机版</h2><h3 id="1-1-package-基于CentOS"><a href="#1-1-package-基于CentOS" class="headerlink" title="1.1 package(基于CentOS)"></a>1.1 package(基于CentOS)</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#（1）下载nacos-server的二进制包，比如：nacos-server-2.0.4.tar.gz</span><br><span class="hljs-comment">#（2）解压并进入bin目录</span><br>unzip nacos-server-<span class="hljs-variable">$version</span>.zip OR tar -xvf nacos-server-<span class="hljs-variable">$version</span>.tar.gz<br><span class="hljs-built_in">cd</span> nacos/bin<br><span class="hljs-comment">#（3）打开startup.sh文件，寻找MODE的默认方式，发现是&quot;cluster&quot;</span><br>vim startup.sh<br><span class="hljs-comment">#（4）查看nacos的启动配置文件，可以发现默认端口是8848，默认访问路径是/nacos</span><br>vim ../conf/application.properties<br><span class="hljs-comment">#（5）以单机模式启动nacos server</span><br>sh startup.sh -m standalone<br><span class="hljs-comment">#（6）查看启动日志</span><br><span class="hljs-built_in">tail</span> -f /root/nacos/logs/start.out<br><span class="hljs-built_in">tail</span> -f ../logs/start.out<br><span class="hljs-comment">#（7）关闭nacos server</span><br>sh shutdown.sh<br><span class="hljs-comment">#（8）打开浏览器访问，输入默认用户名:nacos和密码:nacos</span><br>centosip:8848/nacos<br></code></pre></td></tr></table></figure><h3 id="1-2-source"><a href="#1-2-source" class="headerlink" title="1.2 source"></a>1.2 source</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">（<span class="hljs-number">1</span>）下载nacos-<span class="hljs-keyword">server</span>的源码，比如：nacos<span class="hljs-number">-2.0</span><span class="hljs-number">.4</span>.zip<br>（<span class="hljs-number">2</span>）解压并进入nacos目录<br>（<span class="hljs-number">3</span>）maven构建<br>mvn -Prelease-nacos -Dmaven.test.skip=<span class="hljs-keyword">true</span> clean install -U<br>（<span class="hljs-number">4</span>）使用idea打开nacos工程<br>（<span class="hljs-number">5</span>）配置启动信息<br>Spring Boot<br><span class="hljs-type">Name</span>: nacos-<span class="hljs-keyword">server</span>-standalone<br>Main <span class="hljs-keyword">Class</span>: com.alibaba.nacos.Nacos<br>VM <span class="hljs-keyword">options</span>: -Dnacos.standalone=<span class="hljs-keyword">true</span> -Dnacos.home=nacos-home-standalone<br>classpath <span class="hljs-keyword">of</span> module: nacos-console<br></code></pre></td></tr></table></figure><h2 id="2-集群版"><a href="#2-集群版" class="headerlink" title="2. 集群版"></a>2. 集群版</h2><p><a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html</a></p><h3 id="2-1-package"><a href="#2-1-package" class="headerlink" title="2.1 package"></a>2.1 package</h3><p>（1）准备3台centos机器，把对应的nacos二进制包上传到3台机器中并解压</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.1.81</span><br><span class="hljs-number">192.168.1.82</span><br><span class="hljs-number">192.168.1.83</span><br></code></pre></td></tr></table></figure><p>（2）复制并编辑nacos/conf目录下的cluster.conf文件：cp cluster.conf.example cluster.conf</p><p>（3）选择其中一台机器作为MySQL的安装机器，比如81，生产使用建议至少主备模式，或者采用高可用数据库，并执行提供好的sql文件，用于创建数据库表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p<br><span class="hljs-keyword">create</span> database nacos;<br>use nacos;<br>source <span class="hljs-operator">/</span>root<span class="hljs-operator">/</span>nacos<span class="hljs-operator">/</span>conf<span class="hljs-operator">/</span>nacos<span class="hljs-operator">-</span>mysql.sql;<br><span class="hljs-keyword">show</span> tables;<br></code></pre></td></tr></table></figure><p>（4）将derby的配置切换成MySQL</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#（1）打开conf/application.properties文件</span><br><span class="hljs-comment"># vim application.properties</span><br><span class="hljs-comment">#（2）根据自己MySQL的安装情况修改如下配置信息</span><br><span class="hljs-comment">#*************** Config Module Related Configurations ***************#</span><br><span class="hljs-comment">### If use MySQL as datasource:</span><br><span class="hljs-attr">spring.datasource.platform</span>=<span class="hljs-string">mysql</span><br><span class="hljs-comment">### Count of DB:</span><br><span class="hljs-attr">db.num</span>=<span class="hljs-string">1</span><br><span class="hljs-comment">### Connect URL of DB:</span><br><span class="hljs-attr">db.url.0</span>=<span class="hljs-string">jdbc:mysql://192.168.1.81:3306/nacos?</span><br><span class="hljs-attr">characterEncoding</span>=<span class="hljs-string">utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span><br><span class="hljs-attr">&amp;useUnicode</span>=<span class="hljs-string">true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="hljs-attr">db.user.0</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">db.password.0</span>=<span class="hljs-string">root123</span><br></code></pre></td></tr></table></figure><p>（5）来到nacos/bin目录，直接启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sh startup.sh<br></code></pre></td></tr></table></figure><p>（6）访问任意一台机器的8848端口，看看dashboard中的内容</p><h3 id="2-2-source"><a href="#2-2-source" class="headerlink" title="2.2 source"></a>2.2 source</h3><p>​    nacos2.x的版本使用到了grpc进行通信，而grpc的端口会相对于server.port端口做的偏移 比如nacos server的http端口为8848，则grpc的会使用8848+1000，即9848作为和客户端的通信端口，同时grpc会使用8848+1001，即9849作为nacos集群间的数据同步端口，所以在源码搭建的时候，要避免端口冲突</p><p>（1）前置准备</p><p>​    下载nacos-server的源码，比如：nacos-2.0.4.zip ；解压并进入nacos目录 ；maven构建 mvn -Prelease-nacos -Dmaven.test.skip=true clean install -U ；使用idea打开nacos工程</p><p>（2）准备好MySQL数据库</p><p>（3）在nacos源码根目录创建3个文件夹，作为集群的nacos home。同时在3个nacos home下新建 conf目录，并创建cluster.conf文件，配置内容如下</p><p><img src="/image/springcloud/nacos/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/1.png"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:8841</span><br><span class="hljs-number">127.0.0.1:8843</span><br><span class="hljs-number">127.0.0.1:8845</span><br></code></pre></td></tr></table></figure><p>4）将derby修改成mysql，配置文件：nacos2.0.4\console\src\main\resources\application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#*************** Config Module Related Configurations ***************#</span><br><span class="hljs-comment">### If use MySQL as datasource:</span><br><span class="hljs-attr">spring.datasource.platform</span>=<span class="hljs-string">mysql</span><br><span class="hljs-comment">### Count of DB:</span><br><span class="hljs-attr">db.num</span>=<span class="hljs-string">1</span><br><span class="hljs-comment">### Connect URL of DB:</span><br><span class="hljs-attr">db.url.0</span>=<span class="hljs-string">jdbc:mysql://192.168.0.81:3306/nacos?</span><br><span class="hljs-attr">characterEncoding</span>=<span class="hljs-string">utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span><br><span class="hljs-attr">&amp;useUnicode</span>=<span class="hljs-string">true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="hljs-attr">db.user.0</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">db.password.0</span>=<span class="hljs-string">root123</span><br></code></pre></td></tr></table></figure><p>（5）配置集群的启动参数</p><ul><li><p>8841</p><p>  <img src="/image/springcloud/nacos/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/2.png"></p></li><li><p>8843</p><p>  <img src="/image/springcloud/nacos/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/3.png"></p></li><li><p>8845</p><p>  <img src="/image/springcloud/nacos/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/4.png"></p></li></ul><p>（6）分别启动集群的3个server</p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
      <category>nacos</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>架构演进以及版本更迭</title>
    <link href="/2023/02/27/spring%E6%A1%86%E6%9E%B6/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/"/>
    <url>/2023/02/27/spring%E6%A1%86%E6%9E%B6/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="1-架构演进"><a href="#1-架构演进" class="headerlink" title="1. 架构演进"></a>1. 架构演进</h2><h3 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1 单体架构"></a>1.1 单体架构</h3><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/1.png"></p><h3 id="1-2-垂直化拆分"><a href="#1-2-垂直化拆分" class="headerlink" title="1.2 垂直化拆分"></a>1.2 垂直化拆分</h3><p>按功能模块进行垂直化拆分</p><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/2.png"></p><h3 id="1-3-集群-负载均衡"><a href="#1-3-集群-负载均衡" class="headerlink" title="1.3 集群+负载均衡"></a>1.3 集群+负载均衡</h3><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/3.png"></p><h3 id="1-4-SOA"><a href="#1-4-SOA" class="headerlink" title="1.4 SOA"></a>1.4 SOA</h3><p>SOA：Service Oriented Architecture </p><p>ESB：Enterprise Service Bus 企业服务总线。ESB就相当于是一根管道，主要是为了集成不同协议的服务，使得不同服务之间能够彼此调用</p><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/4.png"></p><h3 id="1-5-微服务"><a href="#1-5-微服务" class="headerlink" title="1.5 微服务"></a>1.5 微服务</h3><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/5.png"></p><h2 id="2-微服务架构下问题的解决方案"><a href="#2-微服务架构下问题的解决方案" class="headerlink" title="2. 微服务架构下问题的解决方案"></a>2. 微服务架构下问题的解决方案</h2><p><a href="https://landscape.cncf.io/">Cloud Native Landscape (cncf.io)</a></p><p>（1）服务注册与发现：eureka、zookeeper、nacos、consul、etcd等 </p><p>（2）负载均衡：ribbon、nginx等 </p><p>（3）服务调用：dubbo、thrift、feign等 </p><p>（4）熔断：hystrix、sentinel等 </p><p>（5）网关：zuul、gateway、kong等 </p><p>（6）配置中心：config、nacos、apoll等 </p><p>（7）分布式消息：rocketmq、kafka、pulsar、rabbitmq等 </p><p>（8）分布式锁：redis、zookeeper等 </p><p>（9）分布式事务：seata、tx-lcn等</p><h2 id="3-Spring-Cloud生态"><a href="#3-Spring-Cloud生态" class="headerlink" title="3. Spring Cloud生态"></a>3. Spring Cloud生态</h2><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/6.png"></p><h2 id="4-版本对比"><a href="#4-版本对比" class="headerlink" title="4. 版本对比"></a>4. 版本对比</h2><h3 id="4-1-Spring-Cloud和Spring-Boot"><a href="#4-1-Spring-Cloud和Spring-Boot" class="headerlink" title="4.1 Spring Cloud和Spring Boot"></a>4.1 Spring Cloud和Spring Boot</h3><p><a href="https://spring.io/projects/spring-cloud#overview">https://spring.io/projects/spring-cloud#overview</a></p><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/7.png"></p><h3 id="4-2-Spring-Cloud和SCA"><a href="#4-2-Spring-Cloud和SCA" class="headerlink" title="4.2 Spring Cloud和SCA"></a>4.2 Spring Cloud和SCA</h3><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E</a></p><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/8.png"></p><h3 id="4-3-Spring-Cloud和SCN"><a href="#4-3-Spring-Cloud和SCN" class="headerlink" title="4.3 Spring Cloud和SCN"></a>4.3 Spring Cloud和SCN</h3><p><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2021.0-Release-Notes#202104">https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2021.0-Release-Notes#202104</a></p><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/9.png"></p><h3 id="4-4-SCA与具体组件版本"><a href="#4-4-SCA与具体组件版本" class="headerlink" title="4.4 SCA与具体组件版本"></a>4.4 SCA与具体组件版本</h3><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E#%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E#%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB</a></p><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/10.png"></p><h3 id="4-5-最终版本"><a href="#4-5-最终版本" class="headerlink" title="4.5 最终版本"></a>4.5 最终版本</h3><p><img src="/image/springcloud/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E6%9B%B4%E8%BF%AD/11.png"></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>springcloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lua脚本-redis</title>
    <link href="/2023/02/22/lua/Lua-redis/"/>
    <url>/2023/02/22/lua/Lua-redis/</url>
    
    <content type="html"><![CDATA[<h2 id="1-在redis中调用lua脚本"><a href="#1-在redis中调用lua脚本" class="headerlink" title="1  在redis中调用lua脚本"></a>1  在redis中调用lua脚本</h2><p>使用eval方法，语法格式：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">eval</span> lua-script <span class="hljs-built_in">key</span>-<span class="hljs-built_in">num</span> [key1 key2 key3 ...] [value1 value2 value3 ...]<br><br>//<span class="hljs-built_in">eval</span> 代表执行Lua语言的命令<br>//lua-script 代表Lua语言脚本内容<br>//<span class="hljs-built_in">key</span>-<span class="hljs-built_in">num</span> 表示参数中有多少个<span class="hljs-built_in">key</span>，需要注意的是Redis中的<span class="hljs-built_in">key</span>是从<span class="hljs-number">1</span>开始的，如果没有<span class="hljs-built_in">key</span>的参数，那么写<span class="hljs-number">0</span><br>//[key1 key2 key3 ...]是<span class="hljs-built_in">key</span>作为参数传递给Lua语言，也可以不写，但是需要和<span class="hljs-built_in">key</span>-<span class="hljs-built_in">num</span>的个数对应起来<br>//[value1 value2 value3 ...]参数的value值，一一对应，可填可不填<br></code></pre></td></tr></table></figure><p>示例：返回一个字符串，0个参数：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">eval</span> <span class="hljs-string">&quot;return &#x27;Hello World&#x27;&quot;</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>实际上，Lua脚本在Redis里面真正的用途是用来执行redis命令。</p><h2 id="2-在Lua脚本中调用redis命令"><a href="#2-在Lua脚本中调用redis命令" class="headerlink" title="2  在Lua脚本中调用redis命令"></a>2  在Lua脚本中调用redis命令</h2><h3 id="2-1-命令格式"><a href="#2-1-命令格式" class="headerlink" title="2.1 命令格式"></a>2.1 命令格式</h3><p>使用redis.call(command, key, [param1, param2 ……])进行操作。语法格式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">redis.call(command, key [param1, param2, ...])<br><span class="hljs-comment">-- command是命令，包括set、get、del等</span><br><span class="hljs-comment">-- key是被操作的键</span><br><span class="hljs-comment">-- param1， param2 ...代表给key的参数</span><br></code></pre></td></tr></table></figure><p>一个简单的案例，让Lua脚本执行set qingshan 2673</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">eval <span class="hljs-string">&quot;return redis.call(&#x27;set&#x27;,&#x27;qingshan&#x27;,&#x27;2673&#x27;)&quot;</span>  <span class="hljs-regexp">//</span>写死值<br>eval <span class="hljs-string">&quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[1])&quot;</span> <span class="hljs-number">1</span> qingshan <span class="hljs-number">2673</span> <span class="hljs-regexp">//</span>参数传递<br></code></pre></td></tr></table></figure><p>在redis-cli中直接写Lua脚本不够方便，也不能实现编辑和复用，通常我们会把lua脚本凡在文件中，然后执行这个文件。</p><h3 id="2-2-Lua脚本文件"><a href="#2-2-Lua脚本文件" class="headerlink" title="2.2 Lua脚本文件"></a>2.2 Lua脚本文件</h3><p>创建脚本文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft/redis-6.0.9/src<br>vim test.lua<br></code></pre></td></tr></table></figure><p>Lua脚本内容，先赋值，再取值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">redis.call(<span class="hljs-string">&#x27;set&#x27;</span>,<span class="hljs-string">&#x27;qingshan&#x27;</span>,<span class="hljs-string">&#x27;lua666&#x27;</span>)<br><span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;get&#x27;</span>,<span class="hljs-string">&#x27;qingshan&#x27;</span>)<br></code></pre></td></tr></table></figure><p>调用脚本文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /usr/local/soft/redis-6.0.9/src<br>redis-cli --<span class="hljs-built_in">eval</span> test.lua 0<br></code></pre></td></tr></table></figure><h3 id="2-3-案例：对IP进行限流"><a href="#2-3-案例：对IP进行限流" class="headerlink" title="2.3 案例：对IP进行限流"></a>2.3 案例：对IP进行限流</h3><p>需求：每个用户再X秒内只能访问Y次。设计思路：</p><p>首先是数据类型。用String的key记录IP，用value记录访问的次数。几秒钟和几次哟啊用参数动态传进去。拿到IP以后，对IP+1。如果是第一次访问，对key设置国企时间（参数1）.否则判断次数，超过限定次数（参数2），返回0。如果没有超过次数返回1。超过时间，key国企之后，可以再次访问。</p><p>KEY[1]是IP，ARGV[1]是过期时间X，ARGV[2]是限制访问的次数Y。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- ip_limit.lua</span><br><span class="hljs-comment">-- IP限流，对某个IP频率进行校址，6秒钟访问10次</span><br><span class="hljs-keyword">local</span> num=redis.call(<span class="hljs-string">&#x27;incr&#x27;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">tonumber</span>(num)==<span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>   <span class="hljs-keyword">elseif</span> <span class="hljs-built_in">tonumber</span>(num)&gt;<span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">2</span>]) <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>   <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>6秒钟内限制访问10次，调用测试（连续调用10次）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli --<span class="hljs-built_in">eval</span> ip_limit.lua app:ip:<span class="hljs-built_in">limit</span>:192.168.8.111 , 6 10<br></code></pre></td></tr></table></figure><p>Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LuaTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> getJedisUtil();<br>        jedis.eval(<span class="hljs-string">&quot;return redis.call(&#x27;set&#x27;,KEYS[1],ARGV[1])&quot;</span>, <span class="hljs-number">1</span>,<span class="hljs-string">&quot;test:lua:key&quot;</span>,<span class="hljs-string">&quot;qingshan2673lua&quot;</span>);<br>        System.out.println(jedis.get(<span class="hljs-string">&quot;test:lua:key&quot;</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>            limit();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 10秒内限制访问5次</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">limit</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> getJedisUtil();<br>        <span class="hljs-comment">// 只在第一次对key设置过期时间</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">lua</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;local num = redis.call(&#x27;incr&#x27;, KEYS[1]) \n&quot;</span> +<br>                <span class="hljs-string">&quot;if tonumber(num) == 1 then\n&quot;</span> +<br>                <span class="hljs-string">&quot;\t redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[1]) \n&quot;</span> +<br>                <span class="hljs-string">&quot;\t return 1 \n&quot;</span> +<br>                <span class="hljs-string">&quot;elseif tonumber(num) &gt; tonumber(ARGV[2]) then \n&quot;</span> +<br>                <span class="hljs-string">&quot;\t return 0 \n&quot;</span> +<br>                <span class="hljs-string">&quot;else \n&quot;</span> +<br>                <span class="hljs-string">&quot;\t return 1 \n&quot;</span> +<br>                <span class="hljs-string">&quot;end \n&quot;</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.evalsha(jedis.scriptLoad(lua), Arrays.asList(<span class="hljs-string">&quot;localhost&quot;</span>), Arrays.asList(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>));<br>        System.out.println(result);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedisUtil</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> ResourceUtil.getKey(<span class="hljs-string">&quot;redis.host&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> Integer.valueOf(ResourceUtil.getKey(<span class="hljs-string">&quot;redis.port&quot;</span>));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> ResourceUtil.getKey(<span class="hljs-string">&quot;redis.password&quot;</span>);<br>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">jedisPoolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>        <span class="hljs-type">JedisPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(jedisPoolConfig, ip, port, <span class="hljs-number">10000</span>, password);<br>        <span class="hljs-keyword">return</span> pool.getResource();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-缓存Lua脚本"><a href="#2-4-缓存Lua脚本" class="headerlink" title="2.4 缓存Lua脚本"></a>2.4 缓存Lua脚本</h3><p><strong>为什么要缓存</strong></p><p>​    在Lua脚本比较长的情况下，如果多次调用脚本都需要把整个脚本传给Redis服务端，会产生比较大的网络开销。为了解决这个问题，Redis可以缓存Lua脚本并生成SHA1摘要码，后面可以直接通过摘要码来执行Lua脚本。</p><p><strong>如何缓存</strong></p><p>这里面涉及到两个命令，首先是在服务端缓存lua脚本生成一个摘要码，用script load命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">script load <span class="hljs-string">&quot;return Hello World&quot;</span><br></code></pre></td></tr></table></figure><p>第二个命令是通过摘要码执行缓存的脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">evalsha <span class="hljs-string">&quot;摘要码&quot;</span> 0<br></code></pre></td></tr></table></figure><p><strong>自乘案例</strong></p><p>Redis有incrby这样的自增命令，但是没有自乘。比如乘以3，乘以5</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">set</span> num 2<br></code></pre></td></tr></table></figure><p>写一个自乘的运算，让它乘以后面的参数:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> curVal=redis.call(<span class="hljs-string">&quot;get&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">if</span> curVal==<span class="hljs-literal">false</span> <span class="hljs-keyword">then</span><br>    curVal=<span class="hljs-number">0</span><br>   <span class="hljs-keyword">else</span><br>    curVal=<span class="hljs-built_in">tonumber</span>(curVal)<br><span class="hljs-keyword">end</span><br>curVal=curVal*<span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>])<br>redis.call(<span class="hljs-string">&quot;set&quot;</span>,KEYS[<span class="hljs-number">1</span>],curVal)<br><span class="hljs-keyword">return</span> curVal<br></code></pre></td></tr></table></figure><p>这个命令变成串行，语句之间使用分号隔开，Script load命令（redis客户端执行）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">script locad <span class="hljs-string">&#x27;local curVal=redis.call(&quot;get&quot;,KEYS[1]);if curVal==false then curVal=0 else curVal=tonumber(curVal) end;curVal=curVal*tonumber(ARGV[1]);redis.call(&quot;set&quot;,KEYS[1],curVal);return curVal&#x27;</span><br></code></pre></td></tr></table></figure><p>调用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">evalsha <span class="hljs-string">&quot;摘要码&quot;</span> 1 num 6<br></code></pre></td></tr></table></figure><h3 id="2-5-脚本超时"><a href="#2-5-脚本超时" class="headerlink" title="2.5 脚本超时"></a>2.5 脚本超时</h3><p>Redis的指令执行本身是单线程的，这个线程还要执行客户端的Lua脚本，如果Lua脚本执行超时或者陷入了死循环，是不是没有办法为客户端提供服务了？它会导致其他的命令都会进入等待状态。为了防止这种情况，首先，脚本执行有一个超时时间，默认为5秒钟。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">lua-time-limit</span> <span class="hljs-string">5000</span><br></code></pre></td></tr></table></figure><p>超过5秒钟，其他客户端的命令不会等待，而是直接返回BUSY错误。这样也不行，不能一直拒绝其他客户端的命令执行。在提示中看到有两个命令可以使用，第一个是script kill，终止脚本的执行。但是需要注意:并不是所有的lua脚本执行都可以kill。如果当前执行的lua脚本对Redis的数据进行了修改（set，DEL、等），那么通过script kill命令是不能终止脚本运行的。为什么包含修改的脚本不能中断？因为要保证脚本运行的原子性。如果脚本执行了一部分被终止，那就违背了脚本原子性的目标。遇到这种情况，只能通过shutdown nosave命令，直接把redis服务停掉。正常关机是shutdown。Shutdown nosave和shutdown的区别在于shutdown nosave不会进行持久化操作，意味着发生在上一个快照后的数据库修改都会丢失。</p>]]></content>
    
    
    <categories>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis为什么这么快</title>
    <link href="/2023/02/22/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/"/>
    <url>/2023/02/22/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/</url>
    
    <content type="html"><![CDATA[<p>总结起来主要有三点：1.纯内存结构。2.请求处理单线程。3.多路复用机制</p><h2 id="1-原因"><a href="#1-原因" class="headerlink" title="1  原因"></a>1  原因</h2><h3 id="1-1-内存"><a href="#1-1-内存" class="headerlink" title="1.1 内存"></a>1.1 内存</h3><p>KV结构的内存数据库，时间复杂度是O(1)。</p><h3 id="1-2-单线程"><a href="#1-2-单线程" class="headerlink" title="1.2 单线程"></a>1.2 单线程</h3><p>这里说的单线程其实指的是处理客户端的请求是单线程的，可以把它叫做主线程。从4.0版本之后，还引入了一些线程处理其他的事情，比如清理脏数据，无用连接的释放，大key的删除。</p><p>​    把处理请求的主线程设置成单线程有什么好处呢？</p><p>​    1.没有创建线程，销毁线程带来的消耗</p><p>​    2.避免了上下文切换导致的CPU消耗</p><p>​    3.避免了线程之间带来的竞争关系，例如加锁释放锁死锁等等。</p><p>​    这里有个问题，就算单线程确实有这些好处，但是会不会白白浪费了CPU的资源？也就是说只能用到单核。官方的解释是这样的：在Redis中单线程已经够用了，CPU不是redis的瓶颈。redis的瓶颈最有可能是机器内存或者网络带宽，既然单线程容易实现，又不需要处理线程并发的问题，那就顺理成章的采用单线程的方案了。注意，因为请求处理是单线程的，不要在生产环境运行长命令，比如keys，flushall，flushdb。否则会导致请求被阻塞。</p><h3 id="1-3-同步非阻塞IO"><a href="#1-3-同步非阻塞IO" class="headerlink" title="1.3 同步非阻塞IO"></a>1.3 同步非阻塞IO</h3><p>同步非阻塞IO，多路复用并发连接</p><h2 id="2-单线程为什么这么快？"><a href="#2-单线程为什么这么快？" class="headerlink" title="2  单线程为什么这么快？"></a>2  单线程为什么这么快？</h2><p>因为redis是基于内存的操作，先从内存开始说起</p><h3 id="2-1-虚拟存储器-虚拟内存Virtual-Memory"><a href="#2-1-虚拟存储器-虚拟内存Virtual-Memory" class="headerlink" title="2.1 虚拟存储器(虚拟内存Virtual Memory)"></a>2.1 虚拟存储器(虚拟内存Virtual Memory)</h3><p>计算机里面的内存叫做主存，硬盘叫做辅存。主存可看作一个很长的数组，一个字节一个单元，每个字节有一个唯一的地址，这个地址叫做物理地址（Physical Address）。早期的计算机中，如果CPU需要内存，使用物理寻址，直接访问主存储器。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/1.png"></p><p>这种方式有几个弊端：</p><p>​    1.一般的操作系统都是多用户多任务的，所有的进程共享主存。如果每个进程都独占一块物理地址空间，主存很快就会被用完。我们希望在不同的时刻，不同的进程共用同一块物理地址空间。</p><p>​    2.如果所有进程都是直接访问物理内存，那么一个进程就可以修改其他进程的内存数据，导致物理地址空间被破坏，程序运行就会出现异常。</p><p>​    所以想了一个办法，在CPU和主存之间增加一个中间层。CPU不再使用物理地址访问主存，而是访问一个虚拟地址，由这个中间层把地址转换成物理地址，最终获得数据。这个中间层叫做MMU（Memory Management Unit），内存管理单元。</p><p>​    具体的操作如下所示：</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/2.png"></p><p>访问MMU就跟访问物理内存一样，所以把虚拟出来的地址叫做虚拟内存（Virtual Memory）。</p><p>在每一个进程开始创建的时候，都会分配一段虚拟地址，然后通过虚拟地址和物理地址的映射来获取真实数据，这样进程就不会直接接触到物理地址，甚至不知道自己调用的哪块物理地址的数据。目前，大多数操作系统都使用了虚拟内存，如Windows系统的虚拟内存，Linux系统的交换空间等。Windows的虚拟内存（pagefile.sys）是磁盘空间的一部分。在32位系统上，虚拟地址空间大小是2^32=4G。在64位系统上，最大虚拟地址空间大小是多少？是不是2^64-1024*1024TB?实际上没有用到64位，因为用不到这么大的空间，而且会造成很大的系统开销。linux一般用低48位来表示虚拟地址空间，也就是2^48=256T.</p><p>实际的物理内存可能远远小于虚拟内存的大小。总结：引入虚拟内存的作用：</p><p>​    1.通过把同一块物理内存映射到不同的虚拟地址空间实现内存共享。</p><p>​    2.对物理内存进行隔离，不同的进程操作互不影响</p><p>​    3.虚拟内存可以提供更大的地址空间，并且地址空间是连续的，使得程序编写，连接更加简单。</p><p>​    Linux/GNU的虚拟内存又进一步划分成了两块</p><h3 id="2-2-用户空间和内核空间"><a href="#2-2-用户空间和内核空间" class="headerlink" title="2.2 用户空间和内核空间"></a>2.2 用户空间和内核空间</h3><p>一部分是内核空间（Kernel-space）,一部分是用户空间（User-space）。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/3.png"></p><p>Linux系统中，虚拟地址布局如下：</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/4.png"></p><p>进程的用户空间中存放的是用户程序的代码和数据，内核空间中存放的是内核代码和数据。不管内核空间还是用户空间，它们都处于虚拟内存空间中，都是对物理地址的映射。当进程运行在内核空间时就处于内核态，而进程运行在用户空间时则处于用户态。进程在内核空间可以访问受保护的内存空间，也可以访问底层硬件设备。也就是可以执行任意命令，调用系统的一切资源。在用户空间只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称system call），才能向内核发出指令。所以，这样划分的目的是为了避免用户进程直接操作内核，保证内核安全。</p><h3 id="2-3-进程切换（上下文切换）"><a href="#2-3-进程切换（上下文切换）" class="headerlink" title="2.3 进程切换（上下文切换）"></a>2.3 进程切换（上下文切换）</h3><p>多任务操作系统是怎么实现运行远大于CPU数量的任务个数的?当然，这些任务实际上并不是真的在同时运行，而是因为系统通过时间片算法，在很短的时间内，将CPU轮流分配给它们，造成多任务同时运行的错觉。在这个交替运行的过程中，为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，以及恢复以前挂起的某个进程的执行。这个行为被称为进程切换。</p><p>​    什么叫上下文（Context）？在每个任务运行前，CPU都需要知道任务从哪里加载，又从哪里开始运行，也就是说，需要系统事先帮它设置好CPU寄存器和程序计数器，这个叫做CPU的上下文。</p><p>​    而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p><p>​    在切换上下文的时候，需要完成一系列的工作，这是一个很消耗资源的操作。</p><h3 id="2-4-进程的阻塞"><a href="#2-4-进程的阻塞" class="headerlink" title="2.4 进程的阻塞"></a>2.4 进程的阻塞</h3><p>正在运行的进程由于提出系统服务请求（如IO操作），但因为某种原因未得到操作系统的立即响应，该进程只能把自己变成阻塞状态，等待响应的时间出现后才被唤醒。进程在阻塞状态不占用CPU资源。</p><h3 id="2-5-文件描述符FD"><a href="#2-5-文件描述符FD" class="headerlink" title="2.5 文件描述符FD"></a>2.5 文件描述符FD</h3><p>Linus系统将所有设备都当作文件来处理，而Linux用文件描述符来标识每个文件对象。文件描述符（File Descriptior）是内核为了高效管理已被打开的文件锁创建的索引，用于指向被打开的文件，所有执行IO操作的系统调用都通过文件描述符。</p><p>​    文件描述符是一个简单的非负整数，用以标名每个被进程打开的文件。linux系统里面有三个标准文件描述符：</p><p>​    0：标准输入（键盘）；1：标准输出（显示器）；2：标准错误输出（显示器）。</p><h3 id="2-6-传统IO数据拷贝"><a href="#2-6-传统IO数据拷贝" class="headerlink" title="2.6 传统IO数据拷贝"></a>2.6 传统IO数据拷贝</h3><p>以读操作为例：但应用程序执行read系统调用读取文件描述符（FD）的时候，如果这块数据已经存在于用户进程的页内存中，就直接从内存中读取数据。如果数据不存在，则先将数据从磁盘加载数据到内核缓冲区中，再从内核缓冲器拷贝到用户进程的页内存中。（两个拷贝，两次user和kernel的上下文切换）。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/5.png"></p><h3 id="2-7-Bocking-I-O"><a href="#2-7-Bocking-I-O" class="headerlink" title="2.7 Bocking I/O"></a>2.7 Bocking I/O</h3><p>当使用read或write对某个文件描述符进行过读写时，如果当前FD不可读，系统就不会对其他的操作做出响应，从硬件设备复制数据到内核缓冲区是阻塞的，从内核缓冲区拷贝到用户空间，也是阻塞的，知道copy complete，内核返回结果，用户进程才解除block的状态。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/6.png"></p><p>为了解决阻塞的问题，有几个思路</p><p>​    1.在服务端创建多个线程或者使用线程池，但是在高并发的情况下需要的线程会很多，系统无法承受，而且创建和释放线程都需要消耗资源。</p><p>​    2.由请求方定期轮询，在数据准备完毕后再从内核缓存区复制数据到用户空间（非阻塞IO），这种方式存在一定的延迟。</p><p>​    能不能用一个线程处理多个客户端请求？</p><h3 id="2-8-I-O多路复用-IO-Multiplexing"><a href="#2-8-I-O多路复用-IO-Multiplexing" class="headerlink" title="2.8 I/O多路复用(IO Multiplexing)"></a>2.8 I/O多路复用(IO Multiplexing)</h3><p>​    IO指的是网络IO</p><p>​    多路指的是多个TCP连接（Socket或Channel）。</p><p>​    复用指的是复用一个或多个线程。</p><p>​    它的基本原理就是不再由应用程序自己监视连接，而是由内核替应用程序监视文件描述符。客户端再操作的时候，会产生具有不同事件类型的socket。在服务端，IO多路复用程序（IO Multiplexing Module）会把消息放入队列中，然后通过文件事件分派其（File event Dispatcher），转发到不同的事件处理器中。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/7.png"></p><p>多路复用有很多实现，以select为例，当用户进程调用了多路复用器，进程会被阻塞。内核会监视多路复用器负责的所有socket，当任何一个socket的数据准备好了，多路复用器就会返回。这时候用户进程再调用read操作，把数据从内核缓冲器拷贝到用户空间。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/8.png"></p><p>所以，IO多路复用的特点是通过一种机制让一个进程能同时等待多个文件描述符，而这些文件描述符其中的任意一个进入读就绪(readable)状态，select()函数就可以返回。多路复用需要操作系统的支持。redis的多路复用，提供了select，epoll，evport，kqueue几种选择，在编译的时候来选择一种。</p><p>​    evport是Solaris系统内核提供支持的；</p><p>​    epoll是Linux系统内核提供支持的；</p><p>​    kqueue是Mac系统提供支持的；</p><p>​    select是POSIX提供的，一般操作系统都有支撑(保底方案)</p><p>总结：redis抽象了一套AE事件模型，将IO事件和时间事件融入一起，同时借助多路复用机制的回调特性（Linux上用epoll），使得IO读写都是非阻塞的，实现高性能的网络处理能力。</p><p>​    一直在说的redis新版本多线程的特性，意思并不是服务端接收客户端请求变成多线程了，它还是单线程的。严格意义上来说，redis从4.0之后就引入了多线程用来处理一些耗时长的工作和后台工作，那不然的话，如果真的只有一个线程，那些耗时的操作肯定会导致金额护短请求被阻塞。我们这里说的多线程，确切的说叫做多线程IO</p><h3 id="2-9-多线程IO"><a href="#2-9-多线程IO" class="headerlink" title="2.9 多线程IO"></a>2.9 多线程IO</h3><p>服务端的数据返回给客户端，需要从内核空间copy数据到用户空间，然后会写道socket(write调用)，这个过程是非常耗时的。所以多线程IO指的就是把结果写道socket的这个环节是多线程的。处理请求依然是单线程的，所以不存在线程并发安全问题。</p><p><img src="/image/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/9.png"></p><p>Redis本质上是一个存储系统。所有的存储系统在数据量过大的情况下都会面临存储瓶颈，包括MySQL，RabbitMQ等等。这里要解决两个问题：首先作为一个内存的KV系统，redis服务肯定不是无限制的使用内存，应该设置一个上限（max_memory）。第二个，数据应该有过期属性，这样就能清除不再使用的key。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis事务</title>
    <link href="/2023/02/22/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E4%BA%8B%E5%8A%A1/"/>
    <url>/2023/02/22/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="1-为什么要用事务"><a href="#1-为什么要用事务" class="headerlink" title="1 为什么要用事务"></a>1 为什么要用事务</h2><p>Redis的单个命令是原子性的（比如get set mget mset），要么成功要么失败，不存在并发干扰的问题。如果涉及到多个命令的时候，需要把多个命令作为一个不可分割的处理序列，就必须要依赖redis的功能特性来实现了。</p><p>Redis提供了事务的功能，可以把一组命令一起执行。Redis的事务有3个特点：</p><ol><li><p>按进入队列的顺序执行。</p></li><li><p>不会受到其他客户端的请求的影响</p></li><li><p>事务不能嵌套，多个multi命令效果一样</p></li></ol><h2 id="2-事务的用法"><a href="#2-事务的用法" class="headerlink" title="2  事务的用法"></a>2  事务的用法</h2><p>Redis的事务涉及到四个命令：multi（开启事务），exec（执行事务），discard（取消事务），watch（监视）</p><p>案例场景：tom和mic各有1000元，tom向mic转账100元。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> tom <span class="hljs-comment">1000</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">mic 1000</span><br>multi<br>decrby <span class="hljs-comment">tom 100</span><br>incrby <span class="hljs-comment">mic 100</span><br>exec<br>get <span class="hljs-comment">tom</span><br>get <span class="hljs-comment">mic</span><br></code></pre></td></tr></table></figure><p>通过multi命令开启事务。Multi执行后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即执行，而是被放到一个队列中。当exec命令被调用时，所有队列中的命令才会被执行。如果没有执行exec，所有的命令都不会被执行。如果中途不想执行事务了，可以调用discard可以清空事务队列，放弃执行。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">multi </span><br>decrby tom <span class="hljs-number">100</span><br><span class="hljs-keyword">discard</span><br><span class="hljs-keyword"></span>get tom<br></code></pre></td></tr></table></figure><h2 id="3-Watch命令"><a href="#3-Watch命令" class="headerlink" title="3  Watch命令"></a>3  Watch命令</h2><p>为了防止事务过程中某个key‘的值被其他客户端请求修改，在Redis中还提供那个了一个watch命令。也就是多个客户端更新变量的时候，会跟原值做比较，只有它没有被其他线程修改的情况下，才更新成新的值。它可以为Redis事务提供CAS乐观锁行为。</p><p>可以一个用watch监视一个或者多个key，如果开启事务之后，至少一个被监视key键在exec执行之前被修改了，那么整个事务都会被取消（key提前过期除外）。可以用unwatch取消。</p><table><thead><tr><th>client 1</th><th>client 2</th></tr></thead><tbody><tr><td>set balance 1000 <br />watch balance <br />multi <br />incrby balance 100</td><td></td></tr><tr><td></td><td>decrby balance 100</td></tr><tr><td>exec [返回null] <br />get balance</td><td></td></tr></tbody></table><h2 id="4-事务可能遇到的问题"><a href="#4-事务可能遇到的问题" class="headerlink" title="4 事务可能遇到的问题"></a>4 事务可能遇到的问题</h2><h3 id="4-1-在执行exec之前发生错误"><a href="#4-1-在执行exec之前发生错误" class="headerlink" title="4.1 在执行exec之前发生错误"></a>4.1 在执行exec之前发生错误</h3><p>比如：入队的命令存在语法错误，包括参数数量，参数名称等等（编译器错误）。事务会被拒绝执行，也就是队列中所有的明林都不会得到执行。</p><h3 id="4-2-在执行exec之后发生错误"><a href="#4-2-在执行exec之后发生错误" class="headerlink" title="4.2 在执行exec之后发生错误"></a>4.2 在执行exec之后发生错误</h3><p>比如String使用了hash的命令，参数个数正确，但是数据类型错误，这是一种运行时错误。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gams">flushall<br>multi<br><span class="hljs-keyword">set</span> k1 <span class="hljs-comment">1</span><br>hset <span class="hljs-comment">k1 a b</span><br>exec<br>1) OK<br>2) (error) WRONGTYPE <span class="hljs-comment">Operation againest a key holding the wrong kind of value</span> <br>get <span class="hljs-comment">k1</span><br></code></pre></td></tr></table></figure><p>最后发现set k1 1的命令是成功的，也就是在这种发生了运行时异常的情况下，只有错误的命令没有被执行，但是其他命令没有收到影响。这个显然不符合对原子性的定义，也就是没办法用redis的这种事务机制来实现原子性，保证数据的一致。</p><h3 id="4-3-为什么不回滚？"><a href="#4-3-为什么不回滚？" class="headerlink" title="4.3 为什么不回滚？"></a>4.3 为什么不回滚？</h3><p>官方的解释是这样的：</p><ol><li><p>redis命令只会因为错误的语法而失败，也就是说，从实用性的角度来说，失败的命令是由代码错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</p></li><li><p>因为不需要对回滚进行支持，所以redis的内部可以保持简单且快速。需要知道的是：回滚不能够解决代码问题。</p></li></ol><p>Redis从2.6版本开始引入了Lua脚本，也就是说redis可以用lua来执行redis命令。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot启动流程</title>
    <link href="/2023/02/21/spring%E6%A1%86%E6%9E%B6/springboot/springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/02/21/spring%E6%A1%86%E6%9E%B6/springboot/springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-启动方式"><a href="#1-启动方式" class="headerlink" title="1. 启动方式"></a>1. 启动方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-comment">//方式一</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Application.class, args);<br>    &#125;<br>    <span class="hljs-comment">//方式二</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SpringApplication</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplication</span>(MySpringConfiguration.class);<br>        app.run(args);<br>    &#125;<br>    <span class="hljs-comment">//方式三</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplicationBuilder</span>()<br>            .sources(Parent.class)<br>            .child(Application.class)<br>            .run(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-启动流程概览"><a href="#2-启动流程概览" class="headerlink" title="2. 启动流程概览"></a>2. 启动流程概览</h2><p><img src="/image/springboot/springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.jpg"></p><h2 id="3-启动流程详解"><a href="#3-启动流程详解" class="headerlink" title="3. 启动流程详解"></a>3. 启动流程详解</h2><h3 id="3-1-new-Application初始化"><a href="#3-1-new-Application初始化" class="headerlink" title="3.1 new Application初始化"></a>3.1 new Application初始化</h3><h4 id="3-1-1-initializers初始化器"><a href="#3-1-1-initializers初始化器" class="headerlink" title="3.1.1 initializers初始化器"></a>3.1.1 initializers初始化器</h4><p>​    SPI方式设置初始化器initializers：this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));</p><p>​    扩展：自定义初始化器，在spring容器启动前执行，实现ApplicationContextInitializer接口，实现方法，在spring.factories中加入org.springframework.context.ApplicationContextInitializer=初始化器类全路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//springboot源码</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApplicationContextInitializer</span>&lt;C <span class="hljs-keyword">extends</span><br><span class="hljs-title class_">ConfigurableApplicationContext</span>&gt; &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Initialize the given application context.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> applicationContext the application to configure</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(C applicationContext)</span>;<br>&#125;<br><br><span class="hljs-comment">//自定义初始化器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextInitializer</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;自定义初始化器执行...&quot;</span>);<br><span class="hljs-type">ConfigurableEnvironment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> applicationContext.getEnvironment();<br><span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;jack&quot;</span>);<br>environment.getPropertySources().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MapPropertySource</span>(<span class="hljs-string">&quot;myInitializer&quot;</span>,map));<br>System.out.println(<span class="hljs-string">&quot;myInitializer execute, and add some property&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//通过SPI机制将自定义初始化器交给list集合initializers</span><br>org.springframework.context.ApplicationContextInitializer=com.intializer.MyInitializer<br></code></pre></td></tr></table></figure><p>初始化器的回调 SpringApplication#run()-&gt;prepareContext(..)–&gt;applyInitializers(context)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">applyInitializers</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> &#123;<br><span class="hljs-keyword">for</span> (ApplicationContextInitializer initializer : getInitializers()) &#123;<br>Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),ApplicationContextInitializer.class);<br>Assert.isInstanceOf(requiredType, context, <span class="hljs-string">&quot;Unable to call initializer.&quot;</span>);<br>initializer.initialize(context);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/springboot/1.png"></p><h4 id="3-1-2-listeners监听器"><a href="#3-1-2-listeners监听器" class="headerlink" title="3.1.2 listeners监听器"></a>3.1.2 listeners监听器</h4><p><img src="/image/springboot/2.png"></p><p>SPI方式设置监听器listeners：this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));</p><p>​    扩展：自定义监听器(starting-servlet启动前执行 or started-servlet启动后执行)，在spring容器启动前(后)执行，实现ApplicationListener接口，实现方法，在spring.factories中加入org.springframework.context.ApplicationListener=初始化器类全路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义监听器</span><br><span class="hljs-comment">//容器启动前调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStartingListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;ApplicationStartingEvent&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ApplicationStartingEvent event)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;myStartingListener 容器正在启动...&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">//容器启动完成调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStartedListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;ApplicationStartedEvent&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ApplicationStartedEvent event)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;myStartedListener 容器启动完成...&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//通过SPI机制将自定义初始化器交给list集合listeners</span><br>org.springframework.context.ApplicationListener=\<br>com.jack.springbootmybatis.listener.MyStartingListener,\<br>com.jack.springbootmybatis.listener.MyStartedListener<br></code></pre></td></tr></table></figure><p><img src="/image/springboot/3.png"></p><h3 id="3-2-run方法"><a href="#3-2-run方法" class="headerlink" title="3.2 run方法"></a>3.2 run方法</h3><ol><li><p>获取监听器，并启动starting类型的监听器</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SpringApplicationRunListeners</span> <span class="hljs-variable">listeners</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getRunListeners(args);<br>listeners.starting(bootstrapContext, <span class="hljs-built_in">this</span>.mainApplicationClass);<br></code></pre></td></tr></table></figure></li><li><p>准备Environment，和配置中心扩展有关</p></li><li><p>打印Banner；自定义Banner，有txt和image两种方式，在resources目录下创建一个banner.txt的文件就可以自定义banner效果</p></li><li><p>确定context类型：context = createApplicationContext()</p></li><li><p>prepareContext，执行初始化器initializers</p></li><li><p><strong>refreshContext(context) -&gt;AbstractApplicationContext#refresh()：创建tomcat容器；创建bean工厂；实例化bean</strong></p></li></ol><p>（1）this.prepareRefresh();上下文刷新前的准备工作：启动日期，设置context的当前状态，初始化属性和环境</p><p>（2）获取beanFantory工厂：obtainFreshFactory</p><p>（3）准备beanFactory工厂，配置一些标准的特性，比如上下文类加载器和后置处理器等</p><p>（4）postProcessBeanFactory(beanFactory)：处理一些web相关的bean以及作用域，比如：request和session等</p><p>（5）invokeBeanFactoryPostProcessors(beanFactory)：执行BeanFactory的后置处理器，解析@Configuration，生成BeanDefinition</p><p>​    扩展：自定义BeanFactoryPostProcessor：实现BeanFactoryPostProcessor，添加@Component注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义BeanFactoryPostProcessor</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JackBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactorybeanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>Arrays.asList(beanFactory.getBeanDefinitionNames()).forEach(beanDefinitionName -&gt;<br>System.out.println(beanDefinitionName));<br>System.out.println(<span class="hljs-string">&quot;JackBeanFactoryPostProcessor...&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>（6）registerBeanPostProcessors(beanFactory)：向BeanFactory中注册bean的postprocessor，用于后续bean创建的拦截操作，应用场景AOP</p><p>​    扩展：自定义BeanPostProcessor：实现BeanPostProcessor，添加@Component</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义BeanPostProcessor</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JackBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><span class="hljs-keyword">if</span>(beanName.equals(<span class="hljs-string">&quot;userController&quot;</span>))&#123;<br>System.out.println(<span class="hljs-string">&quot;找到了userController: &quot;</span>+bean);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（7）initMessageSource国际化</p><p>（8）initApplicationEventMulticaster：初始化一些广播器，用于发布事件</p><p>（9）<strong>onRefresh：初始化context子类上下文中的其他特别bean，创建tomcat容器等</strong></p><p>（10）finishBeanFactoryInitialization(beanFactory)：bean的初始化并加入beanFactory中</p><p>​    1-beanFactory.preInstantiateSingletons() </p><p>​    2-获取到所有BeanDefinition的名称 List beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames) </p><p>​    3-判断当前的bean是否为factorybean if (isFactoryBean(beanName)) </p><p>​    4-来到else部分的getBean(beanName)方法</p><p>​    5-判断是否可以从缓存中获取到bean或者父容器中获取：getSingleton(beanName)以及 getParentBeanFactory()</p><p>​    6-getSingleton(String beanName,Object Factory singleFactory)，调用singleFactory#getObject 方法时，会来到其实现类createBean(beanName,mbd,args)</p><p>​    7-AbstractAutowireCapableBeanFactory#doCreateBean()</p><p>​    8-选择无参构造函数创建Bean：</p><ol start="7"><li><p>执行runners</p><p> 扩展：自定义runner，在spring容器启动前执行，实现ApplicationRunner接口，实现方法，添加通过@Component注解</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义Runner</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplicationRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationRunner</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>System.out.println(<span class="hljs-string">&quot;MyApplicationRunner...&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/springboot/4.png"></p>]]></content>
    
    
    <categories>
      
      <category>spring框架</category>
      
      <category>Springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis入门</title>
    <link href="/2023/02/17/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%85%A5%E9%97%A8/"/>
    <url>/2023/02/17/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-redis定位与特性"><a href="#1-redis定位与特性" class="headerlink" title="1 redis定位与特性"></a>1 redis定位与特性</h2><h3 id="1-1-SQL与NoSQL"><a href="#1-1-SQL与NoSQL" class="headerlink" title="1.1 SQL与NoSQL"></a>1.1 SQL与NoSQL</h3><p>​    大部分时候，我们都会首先考虑用关系型数据库来存储我们的数据，比如SQLServer，Oracle，MySQL 等等。关系型数据库的特点：</p><p>​    1.它以表格的形式，基于行存储数据，是一个二维的模式。</p><p>​    2.它存储的是结构化的数据，数据存储有固定的模式（scheme），数据需要适应表结构。</p><p>​    3.表与表之间存在关联（Reletionship）。</p><p>​    4.大部分关系型数据库都支持SQL（结构化查询语句）的操作，支持复杂的关联查询。</p><p>​    5.通过支持事务（ACID）来提供严格或者实时的数据一致性。</p><p>​    但是使用关系型数据库也存在一些限制，比如：</p><p>​    1.要实现扩容的话，只能向上（垂直）扩展，比如磁盘限制了数据的存储，就要扩大磁盘容量，通过堆硬件的方式，不支持动态的扩缩容。水平扩容需要复杂的技术来实现，比如分库分表。</p><p>​    2.表结构修改困难，因此存储的数据格式也收到限制。</p><p>​    3.在高并发和高数据量的情况下，关系型数据库通常会把数据持久化到磁盘，基于磁盘的读写压力比较大。</p><p>​    为了规避关系型数据库的一系列问题，就有了非关系型的数据库，一般把它叫做“non-relational”或者“Not Only SQL”。NoSQL 最开始是不提供SQL 的数据库的意思，但是后来意思慢慢地发生了变化。</p><p>​    非关系型数据库的特点：</p><p>​    1、存储非结构化的数据，比如文本、图片、音频、视频。</p><p>​    2、表与表之间没有关联，可扩展性强。</p><p>​    3、保证数据的最终一致性。遵循BASE（碱）理论。Basically Available（基本可用）； Soft-state（软状态）； Eventually Consistent（最终一致性）。</p><p>​    4、支持海量数据的存储和高并发的高效读写。</p><p>​    5、支持分布式，能够对数据进行分片存储，扩缩容简单。</p><p>​    对于不同的存储类型，又有各种各样的非关系型数据库，比如有几种常见的类型：</p><p>​    1 、KV 存储， 用Key Value 的形式来存储数据。比较常见的有Redis 和MemcacheDB。</p><p>​    2、文档存储，MongoDB。</p><p>​    3、列存储，HBase。</p><p>​    4、图存储，这个图（Graph）是数据结构，不是文件格式。Neo4j。</p><p>​    5、对象存储。</p><p>​    6、XML 存储等等等等。</p><p>​    这个列举了各种各样的NoSQL 数据库<a href="http://nosql-database.org/">http://nosql-database.org/</a> 。NewSQL 结合了SQL 和NoSQL 的特性（例如PingCAP 的TiDB）。</p><h3 id="1-2Redis特性"><a href="#1-2Redis特性" class="headerlink" title="1.2Redis特性"></a>1.2Redis特性</h3><p>​    官网介绍：<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a></p><p>​    中文网站：<a href="http://www.redis.cn/">http://www.redis.cn</a> </p><p>​    硬件层面有CPU 的缓存；浏览器也有缓存；手机的应用也有缓存。把数据缓存起来的原因就是从原始位置取数据的代价太大了，放在一个临时位置存储起来，取回就可以快一些。</p><p>​    1.为什么要把数据放在内存中？</p><p>​    1）内存的速度快，10w QPS</p><p>​    2）减少计算的时间，减轻数据库的压力</p><p>​    2.如果是用内存的数据结构作为缓存，为什么不用HashMap或者Memcached？</p><p>​    1）更丰富的数据类型</p><p>​    2）进程内与跨进程；单机与分布式</p><p>​    3）功能丰富：持久化机制、内存淘汰策略，事务，发布订阅，pipeline，lua</p><p>​    4）支持多种编程语言</p><p>​    5）高可用，集群</p><p>注：Memcached只能存储KV，没有持久化机制，不支持主从复制，是多线程的。</p><h2 id="2-redis安装启动"><a href="#2-redis安装启动" class="headerlink" title="2 redis安装启动"></a>2 redis安装启动</h2><h3 id="2-1-服务端安装"><a href="#2-1-服务端安装" class="headerlink" title="2.1 服务端安装"></a>2.1 服务端安装</h3><p>1、Linux 安装</p><p>​    CentOS7 安装Redis 单实例<a href="https://gper.club/articles/7e7e7f7ff7g5egc4g6b">https://gper.club/articles/7e7e7f7ff7g5egc4g6b</a></p><p>​    Docker 安装Redis<a href="https://gper.club/articles/7e7e7f7ff7g5egc5g6c">https://gper.club/articles/7e7e7f7ff7g5egc5g6c</a></p><p>  主要是注意配置文件几处关键内容（后台启动、绑定IP、密码）的修改，配置别名</p><p>2、Windows 服务端安装</p><p>​    自行百度</p><h3 id="2-2-服务启动"><a href="#2-2-服务启动" class="headerlink" title="2.2 服务启动"></a>2.2 服务启动</h3><p>​    src 目录下，直接启动   ./redis-server</p><p>​    后台启动（指定配置文件）1、redis.conf -&gt;修改两行配置daemonize yes ；bind 0.0.0.0</p><p>​                         2、启动Redis -&gt; redis-server /usr/local/soft/redis-5.0.5/redis.conf</p><p>​    总结：redis 的参数可以通过三种方式配置，一种是redis.conf，一种是启动时–携带的参数，一种是config set。</p><h3 id="2-3-基本操作"><a href="#2-3-基本操作" class="headerlink" title="2.3 基本操作"></a>2.3 基本操作</h3><p>​    Redist默认有16个库（0-15）.可以在配置文件redis.conf中修改   database 16</p><p>​    因为没有完全隔离，不像数据库的database，不适合把不同的库分配给不同的业务使用。默认使用第一个库db0。在集群中只能使用第一个db。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">select 0;   <span class="hljs-comment">#切换数据库</span><br>flushdb;    <span class="hljs-comment">#清空当前数据库</span><br>flushall;   <span class="hljs-comment">#清空所有数据库</span><br></code></pre></td></tr></table></figure><p>​    Redis的存储叫做key-value存储，或者叫做字典结构。key的最大长度限制是512M，值得限制不同，有的是用长度限制，有的是用个数限制。先从key的基本操作入手。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">set</span> qs 2673   <span class="hljs-comment">#存值</span><br>get qs        <span class="hljs-comment">#取值</span><br>keys *        <span class="hljs-comment">#查看所有键</span><br>dbsize        <span class="hljs-comment">#获取键总数(生产环境数据量大，慎用)</span><br>exists qs     <span class="hljs-comment">#查看键是否存在</span><br>del qs hh     <span class="hljs-comment">#删除键</span><br>rename qs pyy <span class="hljs-comment">#重命名键</span><br><span class="hljs-built_in">type</span> qs       <span class="hljs-comment">#获取数据类型</span><br></code></pre></td></tr></table></figure><h2 id="3-redis基本数据类型"><a href="#3-redis基本数据类型" class="headerlink" title="3 redis基本数据类型"></a>3 redis基本数据类型</h2><h3 id="3-1-String字符串"><a href="#3-1-String字符串" class="headerlink" title="3.1 String字符串"></a>3.1 String字符串</h3><p><strong>存储类型</strong>  </p><p>​    可以用来存储INT（整数），float（单精度浮点数），String（字符串）</p><p><strong>操作命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh">getrange qs 0 1                        <span class="hljs-comment">#获取指定范围的字符</span><br>strlen                                 <span class="hljs-comment">#获取值长度</span><br>append qs good                         <span class="hljs-comment">#字符串追加内容</span><br>mset qs 888 hh 666                     <span class="hljs-comment">#设置多个值(批量操作，原子性)</span><br>mget qs hh                             <span class="hljs-comment">#获取多个值</span><br>setnx qs pyy                           <span class="hljs-comment">#设置值，如果key存在，则不成功</span><br><span class="hljs-comment">#基于此可实现分布式锁，用del key释放锁</span><br><span class="hljs-comment">#但如果释放锁的操作失败了，导致其他节点永远获取不到锁，怎么办？</span><br><span class="hljs-comment">#加过期时间，单独用expire加过期，也失败了。无法保证原子性，怎么办？多参数</span><br><span class="hljs-built_in">set</span> key value [expriation EX seconds|PX milliseconds][NX|XX]<br><span class="hljs-built_in">set</span> k1 v1 EX 10 NX                     <span class="hljs-comment">#使用参数的方式</span><br>incr qs                                <br>incrby qs 100                          <span class="hljs-comment">#(整数)值递增(值不存在会得到1)</span><br>decr qs<br>decrby qs 100                          <span class="hljs-comment">#(整数)值递减</span><br><span class="hljs-built_in">set</span> mf 2.6<br>incrbyfloat mf 7.3                     <span class="hljs-comment">#浮点数增量</span><br></code></pre></td></tr></table></figure><p><strong>存储实现原理</strong></p><p><em>1.数据模型</em></p><p>​    Redis是KV的数据库，Key-value一般会用哈希表来存储它。Redis的最外层是通过hashtable实现的（把这个叫做外层的哈希）。在redis里面。这个哈希表怎样实现呢？看一下C语言的源码（dict.h 47行），每一个键值对都是一个dictEntry（怪不得叫远程字典服务）,通过指针指向key的存储结构和value的存储结构，而且next 存储了指向下一个键值对的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span>&#123;</span><br>    <span class="hljs-type">void</span> *key; <span class="hljs-comment">//key关键字定义</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">void</span> *val; <span class="hljs-comment">//value定义</span><br>        <span class="hljs-type">uint64_t</span> u64;<br>        <span class="hljs-type">int64_t</span> s64;<br>        <span class="hljs-type">double</span> d;<br>    &#125; v;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dicEntry</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">//只向下一个键值对节点</span><br>&#125; dictEntry;<br></code></pre></td></tr></table></figure><p>实际上最外层是redisDb，redisDb里面放的是dict。源码server.h 661行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span>&#123;</span><br>    dict *dict; <span class="hljs-comment">//所有的键值对</span><br>    dict *expires; <span class="hljs-comment">//设置了过期时间的键值对</span><br>    dict *blocking_keys; <span class="hljs-comment">//Keys with clients waiting for data(BLOPOP)</span><br>    dict *ready_keys; <span class="hljs-comment">//Blocked keys that received a PUSH</span><br>    dict *watched_keys; <span class="hljs-comment">//WATCHED keys for MULTI/EXEC CAS</span><br>    <span class="hljs-type">int</span> id; <span class="hljs-comment">//Database ID</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> avg_ttl; <span class="hljs-comment">//Average TTL, just for stats</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> expires_cursor; <span class="hljs-comment">//Cursor of the active expore cycle</span><br>    <span class="hljs-built_in">list</span> *defrag_later; <span class="hljs-comment">// List of key names to attempt to defrag one by one, gradully</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以set hello world为例，因为key是字符串，Redis自己实现了一个字符串类型，叫做SDS，所以hello指向一个SDS的结构。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/1.png"></p><p>​    value是world，同样是一个字符串，当value存储一个字符串时，Redis并没有直接使用SDS存储，而是存储在redisObject中，实际上五种常用的数据类型的任何一种value，都是通过redisObject来存储的。最终redisObject再通过一个指针指向实际的数据结构，比如字符串或者其他。来看一下redisObject怎么定义的：redisObject：源码src/server.h 622行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C">typdef <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span>&#123;</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>; <span class="hljs-comment">//对象的类型，包括：OBJ_STRING,OBJ_LIST,OBJ_HASH,OBJ_SET,OBJ_ZSET</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>; <span class="hljs-comment">//具体的数据结构</span><br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS; <span class="hljs-comment">//24位，对象最后一次被命令程序访问的时间，与内存回收有关</span><br>    <span class="hljs-type">int</span> refcount; <span class="hljs-comment">//引用计数，当refcount为0的时候，表示该对象已经不被任何对象引用，则可以进行回收</span><br>    <span class="hljs-type">void</span> *ptr; <span class="hljs-comment">//只向对象实际的数据结构</span><br>&#125;<br></code></pre></td></tr></table></figure><p>用type命令看到的类型就是type的内容。</p><p>为什么一个value会有一种对外的类型，还有一种实际的编码呢？我们刚才说字符串会用SDS存储，那这个redisObject的value就会指向一个SDS：</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/2.png"></p><p>2.内部编码</p><p>用的String的命令，但是出现了三种不同的编码。这三种编码有什么区别？</p><p>​    （1）int，存储8个字节的长整型（long， 2^63-1）</p><p>​    （2）embstr，代表embstr格式的SDS，存储小于44个字节的字符串</p><p>​    （3）raw，存储大于44个字节的字符串</p><p><em>问题1，SDS是什么？</em></p><p>Redis中字符串的实现，Simple Dynamic String简单动态字符串。源码：sds.h 47行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">attribute_</span> ((_<span class="hljs-title">packed_</span>)) <span class="hljs-title">sdshdr8</span>&#123;</span><br>    <span class="hljs-type">uint8_t</span> len; <span class="hljs-comment">//当前字符数组的长度</span><br>    <span class="hljs-type">uint8_t</span> alloc; <span class="hljs-comment">//当前字符数组总共分配的内存大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">//当前字符数组的属性，用来标识到底是sdshdr8还是sdshdr16等</span><br>    <span class="hljs-type">char</span> buf[]; <span class="hljs-comment">//字符串真正的值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    本质上其实还是字符数组。SDS又有多种结构（sds.h）：sdshdr5，sdshdr8，sdshdr32，sdshdr32，sdshdr64，用于存储不同长度的字符串，分贝代表2^5=32byte，2^8=256byte, 2^16=65536byte=64KB, 2^32byte=4GB。</p><p><em>问题2：为什么Redis要用SDS是实现字符串？</em></p><p>​    因为C语言本身没有字符串类型，只能用字符串数组char[]实现。</p><p>​    （1）使用字符串数组必须先给目标变量分配足够的空间，否则可能会溢出</p><p>​    （2）如果要获取字符长度，必须遍历字符数组，时间复杂度是O(n)</p><p>​    （3）C字符长度的变更会对字符数组做内存重分配</p><p>​    （4）通过从字符串开始到结尾碰到的第一个‘\0’来标记字符串的结束，因此不能保存图片，音频，视频，压缩文件等二进制（bytes）保存的内容，二进制不安全。</p><p>SDS的特点：</p><p>​    1.不用担心内存溢出问题，如果需要会对SDS进行扩容</p><p>​    2.获取字符串长度时间复杂度为O(1)，因为定义了len属性</p><p>​    3.通过“空间预分配”（sdsMakeRoonFor）和“惰性空间释放”，防止多次重分配内存</p><p>​    4.判断是否结束的标志是len属性，可以包含‘\0‘（它同样以’\0’结尾是因为这样就可以使用C语言中函数库操作字符串的函数了）</p><table><thead><tr><th>C字符数组</th><th>SDS</th></tr></thead><tbody><tr><td>获取字符串长度的复杂度为O(N)</td><td>获取字符串长度的复杂度为O(1)</td></tr><tr><td>API是不安全的，可能会造成缓冲区溢出</td><td>API是安全的，不会造成缓冲区溢出</td></tr><tr><td>修改字符串长度N次必然需要执行N次内存重分配</td><td>修改字符串长度N次最多需要执行N次内存重分配</td></tr><tr><td>只能保存文本数据</td><td>可以保存文本或者二进制数据</td></tr><tr><td>可以使用所有&lt;string.h&gt;库中的函数</td><td>可以使用一部分&lt;string.h&gt;库中的函数</td></tr></tbody></table><p><em>问题3：embstr和raw编码的区别？为什么要为不同大小设计不同编码？</em></p><p>​    embstr的使用值分配一次内存空间（因为RedisObject和SDS是连续的），而raw需要分配两次内存空间（分别为RedisObject和SDS分配空间）。embstr的好处在于创建时少分配一次空间，删除时少释放一次空间，以及对象的所有数据连在一起，寻找方便。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/3.png"></p><p>​    而embstr的坏处也很明显，如果字符串的长度增加需要重新分配内存时，整个RedisObject和SDS都需要重新分配空间，因此Redis中的embstr实现为只读（这种编码的内容是不能修改的）。</p><p><em>问题4：int和embstr什么时候转化为raw？</em></p><ol><li><p>int数据不再是整数——raw</p></li><li><p>int大小超过了long的范围(2^63-1)——embstr</p></li><li><p>embstr长度超过了44个字节——raw</p></li></ol><p><em>明明没有超过44个字节，为什么变成raw了？</em></p><p>​    对于embstr，由于它的实现是只读的，因此在对embstr对象进行修改时，都会先转化为raw再进行修改。因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了44个字节。</p><p><em>问题5：当长度小于阈值时，会还原吗？</em></p><p>​    关于Redis内部编码的转换，都符合一下规律：编码转换在Redis写入数据时完成，且转换过程不可逆转，只能从小内存编码向大内存编码转换。</p><p><em>问题6：为什么要对底层的数据结构使用redisObject进行一层包装呢？</em></p><p>​    其实无论是设计redisObject，还是对存储字符设计这么多的SDS，都是为了根据存储的不同内容选择不同的存储方式，这样可以实现尽量地节省内存空间和提升查询速度的目的。</p><p><strong>应用场景</strong></p><p><em>1.缓存</em></p><p>​    String类型，缓存热点数据。例如明星出轨，网站首页，报表数据等等。可以显著提升热点数据的访问速度。</p><p><em>2.分布式数据共享</em></p><p>​    String类型，因为Redis是分布式的独立服务，可以在多个应用之间共享</p><p><em>3.分布式锁</em></p><p>​    String类型的setnx方法，只有不存在时才能添加成功，返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">getLock</span><span class="hljs-params">(Object lockObject)</span>&#123;<br>    jedisUtil = getJedisConnection();<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> jedisUtil.setNx(lockObject, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(flag)&#123;<br>        expire(lockObject, <span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> falg;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseLock</span><span class="hljs-params">(Object lockObject)</span>&#123;<br>    del(lockObject);<br>&#125;<br></code></pre></td></tr></table></figure><p><em>4.全局ID</em></p><p>​    INT类型，INCRBY，利用原子性（分库分表的场景，一次性拿一段）</p><p><em>5.计数器</em></p><p>INT类型，INCR方法。例如：文章的阅读量，微博点赞数，允许一定的延迟，先写入Redis再定时同步到数据库</p><p><em>6. 限流</em></p><p>INT类型，INCR方法。以访问者的IP和其他信息作为key，访问一次再增加一次计数，超过次数则返回false。</p><h3 id="3-2-Hash哈希"><a href="#3-2-Hash哈希" class="headerlink" title="3.2 Hash哈希"></a>3.2 Hash哈希</h3><p><strong>存储类型</strong></p><p>​    Hash用来存储多个无序的键值对。最大存储数量2^32-1（40亿左右）。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/4.png"></p><p>注意：前面说Redis所有的KV本身就是键值对，用dictEntry实现的，叫做外层的哈希，现在我们讲的是内层的哈希。</p><p>注意：Hash的value只能是字符串，不能是嵌套其他类型，比如hash或者list。</p><p>同样是存储字符串，Hash和String的主要区别?</p><ol><li><p>把所有相关的值聚集到一个key中，节省内存空间</p></li><li><p>只使用一个key，减少key中途</p></li><li><p>当需要批量获取值的时候，只需要使用一个命令，减少内存IO/CPU的消耗</p></li></ol><p>Hash不适合的场景：</p><ol><li><p>Field不能单独设置过期时间</p></li><li><p>需要考虑数据量分布的问题（field非常多的时候，无法分布到多个节点）</p></li></ol><p><strong>操作命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">hset h1 f 6;<br>hset h1 e 5;<br>hmset h1 a 1 b 2 c 3 d 4;<br>hget h1 a;<br>hmget h1 a b c;<br>hkeys h1;<br>hvals h1;<br>hgetall h1;<br>hdel h1 a;<br>hlen h1;<br></code></pre></td></tr></table></figure><p><strong>存储（实现）原理</strong></p><p>​    Redis的Hash本身也是一个KV结构，内层哈希底层可以使用两种数据结构实现：</p><p>​       （1）Ziplist: OBJ_ENCODING_ZIPLIST(压缩列表)</p><p>​       （2）Hashtable：OBJ_ENCODING_HT(哈希表)</p><p><em>1.ziplist压缩列表</em></p><p>​    ziplist是一个经过特殊编码的，由连续内存块组成的双向链表。它不存储指向上一个链表节点和指向下一个链表节点的指针，而是存储上一个节点长度和当前节点长度，这样读写可能会慢一些，因为你要去算长度，但是可以节省内存，是一种时间换空间的思想。</p><p>Ziplist的内部结构-源码ziplist.c第16行的注释：</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/5.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zlentry</span>&#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> privrawlensize; <span class="hljs-comment">//存储上一个链表节点的长度数值所需要的字节数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> prevrawlen; <span class="hljs-comment">//上一个链表节点占用的长度</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> lensize; <span class="hljs-comment">//存储当前链表节点长度数值所需要的字节数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len; <span class="hljs-comment">//当前链表节点占用的长度</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> headersize; <span class="hljs-comment">//当前链表节点的头部大小(privrawlensize + lensize)，即非数据域的大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> encoding; <span class="hljs-comment">//编码方式</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p; <span class="hljs-comment">//压缩链表以字符串的形式保存，该指针指向当前节点起始位置</span><br>&#125; zlentry;<br></code></pre></td></tr></table></figure><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/6.png"></p><p>编码类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIP_STR_06B(0&lt;&lt;6) <span class="hljs-comment">//长度小于等于63字节</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIP_STR_14B(1&lt;&lt;6) <span class="hljs-comment">//长度小于等于16383字节</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZIP_STR_32B(2&lt;&lt;6) <span class="hljs-comment">//长度小于等于4294967295字节</span></span><br></code></pre></td></tr></table></figure><p><em>问题：什么时候使用ziplist存储？</em></p><p>当哈希对象同时满足一下两个条件的时候，使用ziplist编码：</p><p>1） 哈希对象保存的键值对数量&lt;512个</p><p>2） 所有的键值对的键和值的字符串长度都&lt;64byte（一个英文字母一个字节）</p><p>src/redis.conf配置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">hash-max-ziplist-value <span class="hljs-number">64</span> <span class="hljs-comment">//ziplist中最大能存放的值长度</span><br>hash-max-ziplist-entries <span class="hljs-number">512</span> <span class="hljs-comment">//ziplist中最多能存放的entry节点数量</span><br></code></pre></td></tr></table></figure><p>如果超过这两个阈值的任何一个，存储接后就会转换为hashtable。总结：字段个数少，字段值小，用ziplist。</p><p><em>2.hashtable（dict）</em></p><p>​    在redis中，hashtable被称为字典（dictionary）。前面我们知道了，Redis的KV结构是通过一个dictEntry来实现的。在hashtable中，又对dictEntry进行了多层的封装。源码位置Ldict.h 47行。首先有一个dictEntry：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span>&#123;</span><br>    <span class="hljs-type">void</span> *key; <span class="hljs-comment">//关键字定义</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">void</span> *val; <span class="hljs-comment">//value定义</span><br>        <span class="hljs-type">uint64_t</span> u64;<br>        <span class="hljs-type">int64_t</span> s64;<br>        <span class="hljs-type">double</span> d;<br>    &#125; v;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">//只向下一个键值对节点</span><br>&#125; dictEntry；<br></code></pre></td></tr></table></figure><p>dictEntry放到了dictht（hashtable里面）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span>&#123;</span><br>    dictEntry **table; <span class="hljs-comment">//哈希表数组</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size; <span class="hljs-comment">//哈希表大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask; <span class="hljs-comment">//掩码大小，用于计算索引值，总是等于size-1</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used; <span class="hljs-comment">//已有节点数</span><br>&#125; dictht;<br></code></pre></td></tr></table></figure><p>Ht放到了dict里面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>  &#123;</span><br>    dictType *type; <span class="hljs-comment">//字典类型</span><br>    <span class="hljs-type">void</span> *privdata; <span class="hljs-comment">//私有数据</span><br>    dictht ht[<span class="hljs-number">2</span>]; <span class="hljs-comment">//一个字典有两个哈希表</span><br>    <span class="hljs-type">long</span> rehashidx; <span class="hljs-comment">//rehash索引</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> iterators; <span class="hljs-comment">//当前正在使用的迭代器数量</span><br>&#125; dict;<br></code></pre></td></tr></table></figure><p>从最底层到最高层dictEntry——dictht——dict。它是一个数组+链表的结构，展开一下，哈希的整体存储结构：</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/7.png"></p><p>​    注意：dictht后面是null说明第二个ht还没有用到。DictEntry*后面是Null说明没有hash到这个地址。DictEntry后面是NULL说明没有发生哈希冲突。</p><p><em>问题：为什么要定义两个哈希表，其中一个不同呢？</em></p><p>Redis的哈希默认使用的是ht[0]，ht[1]不会初始化和分配空间。哈希表dictht是用链地址法来解决碰撞问题的。在这种情况下，哈希表的性能取决于它的大小（size属性）和它锁保存的节点的数量（used属性）之间的比率：</p><p>*比率在1：1时（一个哈希表ht只储一个节点entry）哈希表的性能最好。</p><p>*如果节点数量比哈希表的大小要大很多的话（这个比率用ratio表示，5标识平均一个ht存储5个entry），那么哈希表就会退化成多个链表，哈希表本身的性能优势就不再存在。</p><p>如果单个哈希表的节点数量过多，哈希表的大小需要扩容。Redis里面的这种操作叫做rehash。步骤：</p><ol><li><p>为字符ht[1]哈希表分配空间，ht[1]的大小为第一个大于等于ht[0].used*2的2的N次方幂。比如已经使用了10000，那就是16384.</p></li><li><p>将所有的ht[0]上的节点rehash到ht[1]上，重新计算hash值和索引，然后放入指定的位置。</p></li><li><p>当ht[0]全部迁移到了ht[1]之后，释放ht[0]的空间，将ht[1]设置为ht[0]表，并创建新的ht[1]，为下次rehash做准备。</p></li></ol><p><em>问题：什么时候触发扩容？</em></p><p>负载因子（源码dict.c）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> dict_can_resize = <span class="hljs-number">1</span>; <span class="hljs-comment">//是否需要扩容</span><br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> dict_force_resize_ratio = <span class="hljs-number">5</span>; <span class="hljs-comment">//扩容因子</span><br></code></pre></td></tr></table></figure><p>总结一下，Redis的Hash类型，可以用ziplist和hashtables来实现。</p><p><strong>应用场景</strong></p><p><em>1. 跟String一样</em></p><p>String可以做的事情。Hash都可以做</p><p><em>2.存储对象类型的数据</em></p><p>比如对象或者一张表的数据，比String节省了更多key的空间，也更加便于集中管理。</p><h3 id="3-3-List列表"><a href="#3-3-List列表" class="headerlink" title="3.3 List列表"></a>3.3 List列表</h3><p><strong>存储类型</strong></p><p>存储有序的字符串（从左到右），元素可以重复。最大存储数量2^32-1（40亿左右）。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/8.png"></p><p><strong>操作命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#元素增减</span><br>lpush queue a;<br>lpush queue b c;<br>rpush queue d e;<br>lpop queue;<br>rpop queue;<br><span class="hljs-comment">#取值</span><br>lindex queue 0;<br>lrange queue 0 -1;<br></code></pre></td></tr></table></figure><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/9.png"></p><p><strong>存储（实现）原理</strong></p><p>​    在早期的版本中，数据量较小时用ziplist存储（特殊编码的双向链表），达到临界值时转换为linkedlist进行存储，分别对应OBJ_ENCODING_ZIPLIST和OBJ_ENCODING_LINKEDLIST。3.2版本之后，统一用quicklist来存储。quicklist存储了一个双向链表，每个节点都是一个ziplist，所以是ziplist和linkedlist的结合体。</p><p><strong>quicklist：</strong>总体结构：</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/10.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklist</span>&#123;</span><br>    quicklistNode *head; <span class="hljs-comment">//指向双向列表的表头</span><br>    quicklistNode *tail; <span class="hljs-comment">//指向双向列表的表尾</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> count; <span class="hljs-comment">//所有的ziplist中一共存了多少个元素</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len; <span class="hljs-comment">//双向列表的长度，node的数量</span><br>    <span class="hljs-type">int</span> fill : QL_FILL_BITS; <span class="hljs-comment">//ziplist最大大小，对应list-max-ziplist-size</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> compress: QL_COMP_BITS; <span class="hljs-comment">//压缩深度，对应list-compress-depth</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bookmark_count: QL_BM_BITS; <span class="hljs-comment">//4位，bookmarks数组的大小</span><br>    quicklistBookmark bookmarks[]; <span class="hljs-comment">//bookmarks是一个可选字段，quicklist重新分配内存空间时使用，不使用时不占用空间</span><br>&#125; quicklist；<br></code></pre></td></tr></table></figure><p>redis.conf相关参数：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>list-max-ziplist-size (fill)</td><td>正数表示单个ziplist最多所包含的entry个数<br />负数表示单个ziplist的大小，默认8K</td></tr><tr><td>list-compress-depth (compress)</td><td>压缩深度，默认为0。<br />1：首尾的ziplist不压缩；2：首尾第一第二个ziplist不压缩，以此类推</td></tr></tbody></table><p>quicklist.h 46行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">pre</span>;</span> <span class="hljs-comment">//指向前一个节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">//指向后一个节点</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zl; <span class="hljs-comment">//指向实际的ziplist</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz; <span class="hljs-comment">//当前ziplist占用多少字节</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count : <span class="hljs-number">16</span>; <span class="hljs-comment">//当前ziplist中存储了多少个元素，占16bit（下同），最大65536个</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> encoding : <span class="hljs-number">2</span>; <span class="hljs-comment">//是否采用了LZF压缩算法压缩节点，RAW == 1 or LZF == 2</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> container : <span class="hljs-number">2</span>; <span class="hljs-comment">//未来可能支持其他结构存储 NONE==1 or ziplist == 2</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> recompress : <span class="hljs-number">1</span>; <span class="hljs-comment">//当前ziplist是不是已经被解压出来作临时使用</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> attempted_compress: <span class="hljs-number">1</span>; <span class="hljs-comment">//测试用</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> extra : <span class="hljs-number">10</span>; <span class="hljs-comment">//预留给未来用</span><br>&#125; quicklistNode;<br></code></pre></td></tr></table></figure><p><strong>应用场景</strong></p><p>list主要用在存储有序内容的场景。</p><p>​    <em>1.列表</em></p><p>​    例如用户的消息列表，网站的公告列表，活动列表，博客的文章列表，评论列表等等。思路：存储所有字段，LRANGE取出一页，按顺序显示。</p><p><em>2.队列/栈</em></p><p>​    list还可以当作分布式环境的队列/栈使用。list提供了两个阻塞的弹出操作：BLPOP/BRPOP，可以设置超时时间（单位：秒）.</p><p>​    BLPOP：BLPOP key 1 timeout移出并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p><p>​    BRPOP：BRPOP key 1 timeout移出并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/11.png"></p><p>​    队列：先进先出：rpush blpop，左头右尾，有便进入队列，左边出队列。</p><p>​    栈：先进后出：rpush brpop</p><p>​    总结一下：List存储有序的内容，用quicklist实现，本质上是数组——链表。Hashtable也是数组+链表，只是内部编码结构不一样。</p><h3 id="3-4-Set集合"><a href="#3-4-Set集合" class="headerlink" title="3.4 Set集合"></a>3.4 Set集合</h3><p><strong>存储类型</strong></p><p>Set存储String类型的无序集合，最大存储数量2^32-1（40亿左右）。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/12.png"></p><p><strong>操作命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">sadd myset a b c d e f g  <span class="hljs-comment">#添加一个或者多个元素</span><br>smembers myset            <span class="hljs-comment">#获取多个元素</span><br>scard myset               <span class="hljs-comment">#统计元素个数</span><br>srandmember myset         <span class="hljs-comment">#随机获取一个元素</span><br>spop myset                <span class="hljs-comment">#随机弹出一个元素</span><br>srem myset d e f          <span class="hljs-comment">#移除一个或多个元素</span><br>sismember myset a         <span class="hljs-comment">#查看元素是否存在</span><br></code></pre></td></tr></table></figure><p><strong>存储（实现）原理</strong></p><p>Redis用inset或hashtable存储set。如果元素都是整数类型，就用inset存储。inset.h 35行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intset</span>&#123;</span><br>    <span class="hljs-type">uint32_t</span> encoding; <span class="hljs-comment">//编码类型</span><br>    <span class="hljs-type">uint32_t</span> length; <span class="hljs-comment">//长度</span><br>    <span class="hljs-type">int8_t</span> contents[]; <span class="hljs-comment">//用来存储成员的动态数组</span><br>&#125; intset；<br></code></pre></td></tr></table></figure><p>如果不是整数类型，就用hashtable（数组+链表的存储结构），如果元素超过512个，也会用hashtable存储，跟一个配置有关</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">set-max-intset-entries</span> <span class="hljs-string">512</span><br></code></pre></td></tr></table></figure><p>问题：set的key没有value，怎么用hashtable存储？value存null就好了。</p><p><strong>应用场景</strong></p><p>抽奖：随机获取元素：spop myset。点赞，签到，打卡。商品标签。商品筛选。用户关注，推荐模型</p><h3 id="3-5-ZSet有序集合"><a href="#3-5-ZSet有序集合" class="headerlink" title="3.5 ZSet有序集合"></a>3.5 ZSet有序集合</h3><p><strong>存储类型</strong></p><p>sorted set存储有序的元素。每个元素有个score，按照score从小到大排名。score相同时，按照key的ASCII码排序。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/13.png"></p><table><thead><tr><th>数据结构</th><th>是否允许存在重复元素</th><th>是否有序</th><th>与有序实现方式</th></tr></thead><tbody><tr><td>列表list</td><td>是</td><td>是</td><td>索引下标</td></tr><tr><td>集合set</td><td>否</td><td>否</td><td>无</td></tr><tr><td>有序集合zset</td><td>否</td><td>否</td><td>分值score</td></tr></tbody></table><p><strong>操作命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">zadd myzset 10 java 20 php 30 ruby 40 cpp 50 python <span class="hljs-comment">#添加元素</span><br>zrange myzset 0 -1 withscores                       <br>zrevrange myzset 0 -1 withscores                     <span class="hljs-comment">#获取全部元素</span><br>zrangebyscore myzset 20 30                           <span class="hljs-comment">#根据分值区间获取元素</span><br>zrem myzset php cpp                                  <span class="hljs-comment">#移除元素，亦可以根据score rank删除</span><br>zcard myzset                                         <span class="hljs-comment">#统计元素个数</span><br>zincrby myzset 5 python                              <span class="hljs-comment">#分值递增</span><br>zcount myzset 20 60                                  <span class="hljs-comment">#根据分值统计个数</span><br>zrank myzset python                                  <span class="hljs-comment">#获取元素rank</span><br>zscore myzset python                                 <span class="hljs-comment">#获取元素score</span><br></code></pre></td></tr></table></figure><p><strong>存储（实现）原理</strong></p><p>​    默认使用ziplist编码（第三次见到了，hash的小编码，quicklist的Node，都是ziplist）。在ziplist内部，按照score排序递增来存储，插入的时候要移动之后的数据。如果元素数量大于等于128个，或者任一member长度大于等于64字节使用skiplist+dict存储。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">zset-max-ziplist-entries</span> <span class="hljs-string">128</span><br><span class="hljs-attr">zset-max-ziplist-value</span> <span class="hljs-string">64</span><br></code></pre></td></tr></table></figure><p>​    <em>什么是skiplist（跳表）？</em></p><p>​    我们先来看一下有序链表：</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/14.png"></p><p>​    在这样一个链表中，如果我们要查找某个数据，那么需要从头开始逐个进行比较，直到找到包含数据的那个节点，或者找到第一个比给定数据大的节点为止。时间复杂度为O(n)。同样，当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置。二分查找只适用于有序数组，不适用于链表。</p><p>​    假如我们每相邻两个节点增加一个指针，让指针指向下个节点（或者理解为有三个元素进入了第二层）。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/15.png"></p><p>​    这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一般（上图中是7，19，26）</p><p>​    问题：是哪些元素运气这么好，进入到第二层？在插入一个数据的时候，决定要放到哪一层，取决于一个算法，源码：t_zset.c 122行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">zslRandomLevel</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">int</span> level = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>((random()&amp;<span class="hljs-number">0xFFFF</span>) &lt; (ZSKIPLIST_P*<span class="hljs-number">0xFFFF</span>))<br>        level += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL)?level:ZSKIPLIST_MAXLEVEL;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在当我们想查找数据的时候，可以先沿着这个新链表进行查找。当碰到比待查数据大的节点时，再到下一层进行查找。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/16.png"></p><p>​    比如，我们想查找23，查找的路径是沿着标红的指针所指向的方向进行的：</p><p>​    1.23首先和7比较，再和19比较，比它们都大，继续向后比较。</p><p>​    2.但23和26比较的时候，比26要小，因此回到下面的链表（原链表），与19在第一层的下一个节点22比较。</p><p>​    3.23比22要大，沿下面的指针继续向后和26比较。23比26小，说明待查数据23在原链表中不存在。</p><p>​    在这个查找过程中，由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了。需要比较节点数大概只有原来的一般。这就是跳表。为什么不用AVL树或者红黑树？因为skiplist更加简洁。因为level是随机的，得到的skiplist可能是这样的，有些在第四层，有些在第三层，有些在第二层，有些在第一层。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/17.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span>&#123;</span><br>    sds ele;<br>    <span class="hljs-type">double</span> score;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span>&#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> span;<br>    &#125; level[];<br>&#125; zskiplistNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>, *<span class="hljs-title">tail</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br>    <span class="hljs-type">int</span> level;<br>&#125; zskiplist;<br><br>typdef <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zset</span>&#123;</span><br>    dict *dict;<br>    zskiplist *zsl;<br>&#125; zset;<br></code></pre></td></tr></table></figure><p><strong>应用场景</strong></p><p>顺序会动态变化的列表, 比如：排行榜</p><h3 id="3-6-其他数据结构简介"><a href="#3-6-其他数据结构简介" class="headerlink" title="3.6 其他数据结构简介"></a>3.6 其他数据结构简介</h3><h4 id="3-6-1-BitMaps"><a href="#3-6-1-BitMaps" class="headerlink" title="3.6.1 BitMaps"></a>3.6.1 BitMaps</h4><p>bitMaps是在字符串类型上面定义的位操作。一个字节由8个二进制位组成。</p><p><img src="/image/redis/redis%E5%85%A5%E9%97%A8/18.png"></p><p>set k1 a</p><p>​    获取value在offset处的值（a对应的ASCII码是97，转换为二进制数据是01100001）</p><p>​    getbit k1 0</p><p>​    修改二进制数据</p><p>​    setbit k1 6 1</p><p>​    setbit k1 7 0</p><p>​    get k1</p><p>​    <em>问题：怎么变成b了？（b对应的ASCII码是98，二进制数是01100010）</em></p><p>​    统计二进制位中1的个数</p><p>​    bitcount k1</p><p>​    获取第一个1或者0的位置</p><p>​    bitpos k1 1</p><p>​    bitpos k1 0</p><p>​    因为bit非常节省空间（1MB=8388608bit），可以用来做大数据量的统计。</p><p>​    应用场景：用户访问统计， 在线用户统计</p><h4 id="3-6-2-Hyperloglogs"><a href="#3-6-2-Hyperloglogs" class="headerlink" title="3.6.2 Hyperloglogs"></a>3.6.2 Hyperloglogs</h4><p>​    Hyperloglogs：提供了一种不太精确的基数统计方法，用来统计以集合中不重复的元素个数，比如统计网站的UV，或者应用的日活，月活，存在一定的误差。在redis中实现HyperLogLog，只需要12K内存就能统计2^54个数据。</p><h4 id="3-6-3-Geo"><a href="#3-6-3-Geo" class="headerlink" title="3.6.3 Geo"></a>3.6.3 Geo</h4><p>​    消费金融，给客户使用的客户端有这么一个需求，要获取半径1公里以内的门店，那么我们就要把门店的经纬度保存起来。那个时候我们是直接把经纬度保存到数据库的，一个字段存经度一个字段存维度。计算距离比较复杂。Redis的GEO直接提供了这个方法。</p><p>操作：增加地址位置信息，获取地址位置信息，计算两个位置的距离，获取指定范围内的地理位置集合等等。</p><h4 id="3-6-4-Streams"><a href="#3-6-4-Streams" class="headerlink" title="3.6.4 Streams"></a>3.6.4 Streams</h4><p>5.0推出的数据类型。支持多播的可持久化的消息队列，用于实现发布订阅功能，借鉴了kafka的设计。</p><h3 id="3-7-总结"><a href="#3-7-总结" class="headerlink" title="3.7 总结"></a>3.7 总结</h3><table><thead><tr><th>对象</th><th>对象type属性值</th><th>type命令输出</th><th>object_encoding</th></tr></thead><tbody><tr><td>字符串对象</td><td>OBJ_STRING</td><td>string</td><td>int  embstr  raw</td></tr><tr><td>列表对象</td><td>OBJ_LIST</td><td>list</td><td>quicklist</td></tr><tr><td>哈希对象</td><td>OBJ_HASH</td><td>hash</td><td>ziplist   hashtable</td></tr><tr><td>集合对象</td><td>OBJ_SET</td><td>set</td><td>intset   hashtable</td></tr><tr><td>有序集合对象</td><td>OBJ_ZSET</td><td>zset</td><td>ziplist  skiplist+hashtable</td></tr></tbody></table><p><strong>应用场景总结</strong></p><p>​    缓存——提升热点数据库的访问速度</p><p>​    共享数据——数据的存储和共享的问题</p><p>​    全局ID——分布式全局ID的生成方案（分库分表）</p><p>​    分布式锁——进程间共享数据的原子操作保证</p><p>​    在线用户统计和计数</p><p>​    队列，栈——跨进程的队列/栈</p><p>​    消息队列——异步解耦的消息队列</p><p>   服务注册与发现——RPC通信机制的服务协调中心（Dubbo支持Redis）</p><p>​    购物车</p><p>​    新浪/Twitter 用户消息时间线</p><p>​    抽奖逻辑（礼物，转发）</p><p>​    点赞，打卡，签到</p><p>​    商品标签</p><p>​    用户（商品）关注（推荐）模型</p><p>​    电商产品筛选</p><p>​    排行榜</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis发布订阅模式</title>
    <link href="/2023/02/17/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/17/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-列表的局限"><a href="#1-列表的局限" class="headerlink" title="1 列表的局限"></a>1 列表的局限</h2><p>通过队列的rpush和blpop可以实现消息队列（队尾进队头出），没有任何元素可以弹出的时候，连接会被阻塞。但是基于list实现的消息队列，不支持一对多的消息分发，相当于只有一个消费者。</p><h2 id="2-发布订阅模式"><a href="#2-发布订阅模式" class="headerlink" title="2 发布订阅模式"></a>2 发布订阅模式</h2><p>除了通过list实现消息队列之外，Redis还提供了发布订阅的功能</p><h3 id="2-1-订阅频道"><a href="#2-1-订阅频道" class="headerlink" title="2.1 订阅频道"></a>2.1 订阅频道</h3><p>消息的生产者和消费者是不同的客户端，连接到同一个redis的服务。通过什么对象把生产者和消费者关联起来？</p><p>在RabbitMQ中叫Queue，在kafka中叫Topic。Redis的模型中这个叫channel（频道）。订阅者可以订阅一个或多个channel。消息的发布者可以给指定的channel发布于消息，只要有消息到达了channel，所有订阅了这个channel的订阅者都会收到这条消息。</p><p><img src="/image/redis/redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/1.png"></p><p>订阅者订阅频道：可以一次订阅多个，比如这个客户端订阅了3个频道，频道不用实现创建。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">subscribe</span> channel-<span class="hljs-number">1</span> channel-<span class="hljs-number">2</span> channel-<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>发布者可以向指定的频道发布消息（并不支持一次向多个频道发送消息）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">publish</span> channel-<span class="hljs-number">1</span> test<br></code></pre></td></tr></table></figure><p>取消订阅（不能在订阅状态下使用）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">unsubscribe</span> channel-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="2-2-按规则-Pattern-订阅频道"><a href="#2-2-按规则-Pattern-订阅频道" class="headerlink" title="2.2 按规则(Pattern)订阅频道"></a>2.2 按规则(Pattern)订阅频道</h3><p>?代表一个字符，*代表0个或多个字符。</p><p>例如，现在有三个新闻频道，运动新闻（news-sport），音乐新闻（news-music），天气新闻（news-weather）。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">psubscribe *sport  <span class="hljs-comment">//消费端1关注运动消息</span><br>psubscribe <span class="hljs-keyword">new</span><span class="hljs-type">s</span>*  <span class="hljs-comment">//消费端2关注所有消息</span><br>psubscribe <span class="hljs-keyword">new</span><span class="hljs-type">s</span>-weather  <span class="hljs-comment">//消费端3关注天气新闻</span><br></code></pre></td></tr></table></figure><p><img src="/image/redis/redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/2.png"></p><p>一般来说，考虑到性能和持久化的因素，不建议使用Redis的发布订阅功能来实现MQ。Redis的一些内部机制用到了发布订阅功能。</p><h3 id="2-3-java伪代码"><a href="#2-3-java伪代码" class="headerlink" title="2.3 java伪代码"></a>2.3 java伪代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PublishTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>        jedis.publish(<span class="hljs-string">&quot;test-123&quot;</span>, <span class="hljs-string">&quot;666&quot;</span>);<br>        jedis.publish(<span class="hljs-string">&quot;test-abc&quot;</span>, <span class="hljs-string">&quot;pengyuyan&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JedisPubSub</span> &#123;<br>    <span class="hljs-comment">// 取得订阅的消息后的处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String channel, String message)</span> &#123;<br>        System.out.println(channel + <span class="hljs-string">&quot;=&quot;</span> + message);<br>    &#125;<br>    <span class="hljs-comment">// 初始化订阅时候的处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSubscribe</span><span class="hljs-params">(String channel, <span class="hljs-type">int</span> subscribedChannels)</span> &#123;<br>        <span class="hljs-comment">// System.out.println(channel + &quot;=&quot; + subscribedChannels);</span><br>    &#125;<br>    <span class="hljs-comment">// 取消订阅时候的处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUnsubscribe</span><span class="hljs-params">(String channel, <span class="hljs-type">int</span> subscribedChannels)</span> &#123;<br>        <span class="hljs-comment">// System.out.println(channel + &quot;=&quot; + subscribedChannels);</span><br>    &#125;<br>    <span class="hljs-comment">// 初始化按表达式的方式订阅时候的处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPSubscribe</span><span class="hljs-params">(String pattern, <span class="hljs-type">int</span> subscribedChannels)</span> &#123;<br>        <span class="hljs-comment">// System.out.println(pattern + &quot;=&quot; + subscribedChannels);</span><br>    &#125;<br>    <span class="hljs-comment">// 取消按表达式的方式订阅时候的处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPUnsubscribe</span><span class="hljs-params">(String pattern, <span class="hljs-type">int</span> subscribedChannels)</span> &#123;<br>        <span class="hljs-comment">// System.out.println(pattern + &quot;=&quot; + subscribedChannels);</span><br>    &#125;<br>    <span class="hljs-comment">// 取得按表达式的方式订阅的消息后的处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPMessage</span><span class="hljs-params">(String pattern, String channel, String message)</span> &#123;<br>        System.out.println(pattern + <span class="hljs-string">&quot;=&quot;</span> + channel + <span class="hljs-string">&quot;=&quot;</span> + message);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListenTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">MyListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyListener</span>();<br>        <span class="hljs-comment">// 使用模式匹配的方式设置频道</span><br>        <span class="hljs-comment">// 会阻塞</span><br>        jedis.psubscribe(listener, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;test-*&quot;</span>&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL性能优化</title>
    <link href="/2023/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2023/02/17/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="1-优化思路"><a href="#1-优化思路" class="headerlink" title="1 优化思路"></a>1 优化思路</h2><p>​    说到性能调优，大部分时候想要实现的目标是让查询更快。一个查询的流程又是由很多个环节组成的，每个环节都会消耗时间。要减少查询所消耗的时间，就要从每一个环节入手。</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/1.png"></p><p>确定环境：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> version();<br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%engine%&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="2-连接-配置优化"><a href="#2-连接-配置优化" class="headerlink" title="2 连接-配置优化"></a>2 连接-配置优化</h2><p>​    第一个环节是客户端连接到服务端，连接这一块有可能出现的问题是服务端连接数不够导致应用程序获取不到连接。比如Mysql：error 1040：Too many connections的错误。这个是超过了服务端设置的最大并发连接数。</p><p>​    可以从两个方面来解决连接数不够的问题：</p><p>​    1.从服务端来说，可以增加服务端的可连接数。如果有多个应用或者很多请求同时访问数据库，连接数不够的时候，可以:</p><p>​    （1）增加可用连接数，修改max_connections的大小：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> varibales <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;max_connections&#x27;</span>; <span class="hljs-comment">--修改最大连接数，当有多个应用连接的时候</span><br></code></pre></td></tr></table></figure><p>​    （2）及时释放不活动的连接。交互式和非交互式的客户端的默认超时时间都是28800秒，8小时，可以把这个值调小。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;wait_timeout&#x27;</span>; <span class="hljs-comment">--及时释放不活动的连接，注意不要释放连接池还在使用的连接</span><br></code></pre></td></tr></table></figure><p>​    2.从客户端来说，可以减少从服务端获取的连接数。如果想要不是每一次执行SQL都要创建一个新的连接，这时可以引入连接池，可以实现连接的重用。常见的连接池有老牌的DBCP和C3P0，阿里的Druid，Hikari（Spring Boot2.X版本默认的连接池）。连接池不是越大越好，只要维护一定数量大小的连接池，其他的客户端排队等待获取连接就可以了。有的时候连接池越大，效率反而越低。</p><p>​    Druid默认最大连接池大小是8。Hikari默认最大连接池大小是10。在Hikari的githuhb文档中，给出了一个PostgreSQL数据库建议的设置连接池小大的公式。它的建议是机器核数乘以2加1.也就是说，4核的机器，连接池维护9个连接就够了。这个公式从一定程度上来说对其他数据库也是适用的。每一个连接，服务端都需要创建一个线程去处理它。连接数越多，服务端创建的线程数就会越多。问题：CPU是怎么同时执行远远超过它的核数大小的任务的？分配时间片。上下文切换。而CPU的核数是有限的，频繁的上下文切换回造成比较大的性能开销。</p><p>​    这里说到了从数据库配置的层面去优化数据库。不管是数据库本身的配置，还是安装这个数据库服务的操作系统的配置，对于配置进行优化，最终的目标都是为了更好的发挥硬件本身的性能，包括CPU，内存，磁盘，网络。在不同的硬件环境下，操作系统和MySQL的参数的配置是不同的，没有标准的配置。 一般修改配置的工作是由专业的DBA完成，也有一些工具可以给出推荐值。</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/2.png"></p><h2 id="3-架构优化"><a href="#3-架构优化" class="headerlink" title="3 架构优化"></a>3 架构优化</h2><h3 id="3-1-缓存"><a href="#3-1-缓存" class="headerlink" title="3.1 缓存"></a>3.1 缓存</h3><p>​    在系统中有一些很慢的查询，要么数据量大，要么关联的表多，要么是计算逻辑非常复杂，这样的查询每次会占用连接很长时间。所以为了减轻数据库的压力，和提升查询效率，把数据放到内存中缓存起来，比如使用redis。</p><p>​    缓存适用于实时性不是很高的业务，比如报表数据，一次查询要2分钟，但是一天只需要更新一次。</p><p>​    独立的缓存服务，属于架构层面的优化。</p><h3 id="3-2-集群，主从复制"><a href="#3-2-集群，主从复制" class="headerlink" title="3.2 集群，主从复制"></a>3.2 集群，主从复制</h3><p>​    在分布式中，有一种提升可用性的手段叫做冗余，也就是创建集群。</p><p>​    集群的话必然会面临一个问题，就是不同的节点之间数据一致性的问题。如果同时读写多台数据库节点，怎么让所有的节点数据保持一致？这个时候需要用到复制技术（replication），被复制的节点称为master，复制的节点称为slave。Slave本身也可以作为其他节点的数据来源，这个叫做级联复制。之前说过，MySQL所有的更新语句都会记录到Server层binlog中。从服务器会不断获取主服务器的binlog文件，然后解析里面的SQL语句，在从服务器上面执行一遍，保持主从的数据一致。</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3.png"></p><p>​    这里面涉及到三个线程，连接到master获取binlog，并且解析binlog写入中继日志，这个线程叫做IO线程。Master节点上有一个log dump线程，是用来发送binlog给slave的。从库的SQl线程，是用来读取relay log，把数据写入到数据库的。</p><p>​    做了主从复制配置之后，我们只把数据写入master节点，而读的请求可以分担到slave节点。我们把这种方案叫做读写分离。</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/4.png"></p><p>​    对于读多写少的项目来说，读写分离对于减轻主服务器的访问压力很有用。</p><h3 id="3-3-分库分表"><a href="#3-3-分库分表" class="headerlink" title="3.3 分库分表"></a>3.3 分库分表</h3><p>​    在集群架构中，所有的节点存储的都是相同的数据。如果单张表存储的数据过大的时候，比如一张表有上亿的数据，每天以百万的量级增加，单表的查询性能还是会大幅下降。这时就要用到第二手段，叫做分片。把单个节点的数据分散到多个节点存储，减少存储和访问压力，这个就是分库分表。</p><p>​    分库分表总体上可以分为两类：垂直分库，减少并发压力；水平分表，解决存储瓶颈。</p><p><strong>1.垂直分库</strong>：把一个数据库按照业务拆分成不同的数据库</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/5.png"></p><p><strong>2.水平分库分表</strong>：把单张表的数据按照一定的规则分布到多个数据库</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/6.png"></p><h2 id="4-优化器-SQL优化"><a href="#4-优化器-SQL优化" class="headerlink" title="4  优化器-SQL优化"></a>4  优化器-SQL优化</h2><p>​    优化器的作用是对SQL语句进行优化分析，生成执行计划。首先，要用到服务端的慢查询日志。</p><h3 id="4-1-慢查询日志slow-query-log"><a href="#4-1-慢查询日志slow-query-log" class="headerlink" title="4.1 慢查询日志slow query log"></a>4.1 慢查询日志slow query log</h3><h4 id="4-1-1-打开慢查询开关"><a href="#4-1-1-打开慢查询开关" class="headerlink" title="4.1.1 打开慢查询开关"></a>4.1.1 打开慢查询开关</h4><p>因为开启慢查询日志是有代价的（跟binlog，optimizer-trace一样），所以它默认是关闭的.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;slow_query%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>除了这个开关，还有一个参数，控制执行超过多长时间的SQL才记录到慢日志，默认是10秒。如果改成0秒的话就是记录所有的SQL。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%long_query%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>参数的两种修改方式：</p><p>​    1.set动态修改参数（重启后失效）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> @<span class="hljs-variable">@global</span>.slow_query_log<span class="hljs-operator">=</span><span class="hljs-number">1</span>; <span class="hljs-comment">--1开启，0关闭，重启后失效</span><br><span class="hljs-keyword">set</span> @<span class="hljs-variable">@global</span>.long_query_time<span class="hljs-operator">=</span><span class="hljs-number">3</span>; <span class="hljs-comment">--默认10秒，另开一个窗口后才会查到最新值</span><br></code></pre></td></tr></table></figure><p>​    2.修改配置文件my.cnf，以下配置定义了慢查询日志的开关，慢查询的时间，日志文件的存放路径。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">show_query_log</span>=<span class="hljs-string">ON</span><br><span class="hljs-attr">long_query_time</span>=<span class="hljs-string">2</span><br><span class="hljs-attr">show_query_log_file</span>=<span class="hljs-string">/var/lib/mysql/localhost-slow.log</span><br></code></pre></td></tr></table></figure><h4 id="4-1-2-慢日志分析"><a href="#4-1-2-慢日志分析" class="headerlink" title="4.1.2 慢日志分析"></a>4.1.2 慢日志分析</h4><p>1.日志内容</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/7.png"></p><p>2.mysqldumpslow</p><p>MySQL提供了mysqldumpslow的工具，在Mysql的bin目录下。例如：查询用时最多的10条慢SQL：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mysqldumpslow -s t -t 10 -g <span class="hljs-string">&#x27;select&#x27;</span> /var/lib/mysql/localhost-slow.log<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/8.png"></p><p>​    Count代表这个SQL执行了多少次；Time代表执行的时间，括号中是累计时间；Lock表示锁定的时间，括号是累计；Rows表示返回的记录数，括号是累计。当然，有的时候查询慢，不一定是SQL语句的问题，也有可能是服务器状态的问题。所以也要掌握一些查看服务器和存储引擎状态的命令。</p><h4 id="4-1-3-其他系统命令"><a href="#4-1-3-其他系统命令" class="headerlink" title="4.1.3 其他系统命令"></a>4.1.3 其他系统命令</h4><p>1.Show processlist 运行线程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">full</span> processlist;<br></code></pre></td></tr></table></figure><p>这是一个很重要的命令，用于显示用户运行线程。可以根据id号kill线程。也可以查表，效果一样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> information.processlist<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/9.png"></p><table><thead><tr><th>列</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>线程的唯一标识，可以根据它kill线程</td></tr><tr><td>User</td><td>启动这个线程的用户，普通用户只能看到自己的线程</td></tr><tr><td>Jpst</td><td>哪个端口发起的连接</td></tr><tr><td>db</td><td>操作的数据库</td></tr><tr><td>Command</td><td>线程的命令 <a href="https://dev.mysql.com/doc/refman/5.7/en/thread-commands.html">https://dev.mysql.com/doc/refman/5.7/en/thread-commands.html</a></td></tr><tr><td>Time</td><td>操作持续时间，单位秒</td></tr><tr><td>State</td><td>线程状态，比如查询所有可能有copying to tmp table, Sorting result, Sending data <br /> <a href="https://dev.mysql.com/doc/refman/5.7/en/general-thread-states.html">https://dev.mysql.com/doc/refman/5.7/en/general-thread-states.html</a></td></tr><tr><td>Info</td><td>SQL语句的前100个字符。如果要查看完整的SQL语句，用show full processlist</td></tr></tbody></table><p>2.Show status 服务器运行状态</p><p>Show status用于查看mysql服务器运行状态（重启后会清空）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> status;<br></code></pre></td></tr></table></figure><p>有session和global两种作用域，格式：参数-值。可以通过like带通配符过滤：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">showo <span class="hljs-keyword">global</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;com_select&#x27;</span>; <span class="hljs-comment">--查看select次数</span><br></code></pre></td></tr></table></figure><p>3.show engine 存储引擎运行信息</p><p>​    Show engine用来显示存储引擎的当前运行信息，包括事务持有的表锁，行锁信息；事务锁等待情况；线程信号量等待；文件IO请求；buffer pool统计信息。 例如：show engine innodb status；开启InnoDB监控：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> innodb_status_output<span class="hljs-operator">=</span><span class="hljs-keyword">ON</span>;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> innodb_status_output_locks<span class="hljs-operator">=</span><span class="hljs-keyword">ON</span>;<br></code></pre></td></tr></table></figure><p>​    很多开源的MySQL监控工具，其实他们的原理也都是读取的服务器，操作系统，MYSQL服务的状态和变量。之后，MySQL提供了一个执行计划的工具。通过EXPLAIN可以模拟服务端执行SQL查询语句的过程。通过这种方式可以分析语句或者表的性能瓶颈。</p><p>​    MYSQL5.6.3以前只能分析select，之后可以分析update，delete，insert。</p><h3 id="4-2-EXPLAIN执行计划"><a href="#4-2-EXPLAIN执行计划" class="headerlink" title="4.2 EXPLAIN执行计划"></a>4.2 EXPLAIN执行计划</h3><p>先创建三张表。课程表，老师表，老师联系方式表（没有任何索引）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if_exists course;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;course&#x27;</span> (<br><span class="hljs-string">&#x27;cid&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-string">&#x27;cname&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-string">&#x27;tid&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span><br>) engine<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">default</span> charrest<span class="hljs-operator">=</span>utf8mb4;<br><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if_exists teacher;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;teacher&#x27;</span> (<br><span class="hljs-string">&#x27;tid&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-string">&#x27;tname&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-string">&#x27;tcid&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span><br>) engine<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">default</span> charrest<span class="hljs-operator">=</span>utf8mb4;<br><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if_exists teacher_contact;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;teacher_contact&#x27;</span> (<br><span class="hljs-string">&#x27;tcid&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-string">&#x27;phone&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>) engine<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">default</span> charrest<span class="hljs-operator">=</span>utf8mb4;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;course&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;mysql&#x27;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;course&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;jvm&#x27;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;course&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;juc&#x27;</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;course&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;spring&#x27;</span>, <span class="hljs-number">3</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;teacher&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;qs&#x27;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;teacher&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;hh&#x27;</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;teacher&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;mic&#x27;</span>, <span class="hljs-number">3</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;teacher_contact&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;13688888888&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;teacher_contact&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;13688888889&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;teacher_contact&#x27;</span> <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;13688888810&#x27;</span>);<br></code></pre></td></tr></table></figure><p>Explain的结果字段有很多，详细分析一下：</p><h4 id="4-2-1-Id"><a href="#4-2-1-Id" class="headerlink" title="4.2.1 Id"></a>4.2.1 Id</h4><p>Id是查询序列编号，每张表都是单独访问的，一个select就会有一个序号。</p><p>（1）Id值不同的时候，先查询id值大的（先大后小）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> tc.phone <br><span class="hljs-keyword">from</span> teacher_contact tc<br><span class="hljs-keyword">where</span> tcid <span class="hljs-operator">=</span> (<br>    <span class="hljs-keyword">select</span> tcid <span class="hljs-keyword">from</span> teacher t <span class="hljs-keyword">where</span> t.tid <span class="hljs-operator">=</span> (<br>        <span class="hljs-keyword">select</span> c.tid <span class="hljs-keyword">from</span> course c <span class="hljs-keyword">where</span> c.cname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;mysql&#x27;</span><br>        )<br>    )<br></code></pre></td></tr></table></figure><p>查询顺序：course c——teacher t——teacher_contact tc</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/10.png"></p><p>先查课程表，再查老师表，最后查老师联系表。子查询只能以这种方式进行，只有拿到内层的结果之后才能进行外层的查询。</p><p>（2）id值相同</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> t.tname, c.name, tc.phone<br><span class="hljs-keyword">from</span> teacher t, course c, teacher_contact tc<br><span class="hljs-keyword">where</span> t.tid <span class="hljs-operator">=</span> c.tid <span class="hljs-keyword">and</span> t.tcid <span class="hljs-operator">=</span> tc.tcid <span class="hljs-keyword">and</span> (c.cid <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> tc.cid <span class="hljs-operator">=</span> <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/11.png"></p><p>Id值相同时，表的查询顺序是从上往下顺序执行。例如这次查询的id都是1（说明子查询被优化器转换成了连接查询），查询的顺序是teacher t（3条）——course c（4条）——teacher_contact tc（3条）。</p><p>​    （3）如果id有相同也有不同，就是id不同的先大后小，相同的从上往下。</p><p>​    在连接查询中，先查询的叫做驱动表，后查询的叫做被驱动表。应该先查小表（得到的结果少），小表驱动大表。</p><h4 id="4-2-2-Select-type-查询类型"><a href="#4-2-2-Select-type-查询类型" class="headerlink" title="4.2.2 Select type 查询类型"></a>4.2.2 Select type 查询类型</h4><p>​    这里并没有列出全部（其他：dependent union，dependent subquery，materialized，uncacheable subquery，uncacheable union）。下面列举了一些常见的查询类型：</p><p>​    1.simple：简单查询，不包含子查询，不包含关联查询union。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/12.png"></p><p>再看一个包含子查询的案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--查询mysql课程老师的手机号</span><br>explain <span class="hljs-keyword">select</span> tc.phone <span class="hljs-keyword">from</span> tescher_contact tc<br><span class="hljs-keyword">where</span> tcid <span class="hljs-operator">=</span> (<br>    <span class="hljs-keyword">select</span> tcid <span class="hljs-keyword">from</span> teacher t <span class="hljs-keyword">where</span> t.tid <span class="hljs-operator">=</span> (<br>        <span class="hljs-keyword">select</span> c.tid <span class="hljs-keyword">from</span> course c <span class="hljs-keyword">where</span> c.cname<span class="hljs-operator">=</span><span class="hljs-string">&#x27;mysql&#x27;</span><br>        )<br>    )<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/13.png"></p><p>​    2.primary：子查询sql语句中的主查询，也就是最外层的查询</p><p>​    3.subquery：子查询中所有的内层查询都是该类型。</p><p>​    4.derived：衍生查询，表示在得到最终查询结果之前会用到的临时表，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> cr.cname <span class="hljs-keyword">from</span> (<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> course <span class="hljs-keyword">where</span> tid<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">union</span><br>    <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> course <span class="hljs-keyword">where</span> tid<span class="hljs-operator">=</span><span class="hljs-number">2</span><br>) cr;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/14.png"></p><p>​    对于关联查询，先执行有便的table（union），再执行左边的table，类型是derived</p><p>​    5.union：同上例</p><p>​    6.union result：主要是显示哪些表之间存在union查询。&lt;union2,3&gt;代表id=2和id=3的查询存在union，同上例。</p><h4 id="4-2-3-Type-连接类型"><a href="#4-2-3-Type-连接类型" class="headerlink" title="4.2.3 Type 连接类型"></a>4.2.3 Type 连接类型</h4><p>​    所有连接类型中，上面的最好，越往下越差。在常用的连接类型中：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;all。这里并没有列举全部（其他: fulltext, ref_or_null, index_merger, unique_subquery, index_subquery）。以上访问类型除了all，都能用到索引。</p><p>​    <strong>1.const</strong>：主键索引或者唯一索引，只能查到一条数据的SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> talbe if_exists single_data;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> single_data(<br>id <span class="hljs-type">int</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">primary</span> key,<br>    content <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)<br>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> single_data <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;a&#x27;</span>);<br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> single_data a <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">&#x27;;</span><br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/15.png"></p><p><strong>2.system</strong>：system是const的一种特例，只有一行满足条件，对于NyISAM，Memory的表，只查询到一条记录，也是system。比如系统库的这张表（8.0的版本中系统表全部变成InnoDB存储引擎了）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> mysql.proxies_priv;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/16.png"></p><p><strong>3.eq_ref</strong>：通常出现在多表的join查询，被驱动表通过唯一性索引（unique或primary key）进行访问，此时被驱动表的访问方式就是eq_ref。eq_ref是出const之外最好的访问类型。先删除teacher表中多余的数据，teacher_contact有3条数据，teacher表有三条数据。teacher_contact表的tcid（第一个字段）创建主键索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- alert table teacher_contact drop primary key</span><br>alert <span class="hljs-keyword">table</span> teacher_contact <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary</span> key(tcid);<br><br>explain <span class="hljs-keyword">select</span> t.tcid <span class="hljs-keyword">from</span> teacher t, teacher_contact tc <span class="hljs-keyword">where</span> t.tcid<span class="hljs-operator">=</span>tc.tcid<br></code></pre></td></tr></table></figure><p>此时的执行计划（先大后小，从上往下，tc是被驱动表。Tc表是eq_ref）：被驱动表用主键进行访问</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/17.png"></p><p><strong>小结</strong>：以上三种system，const，eq_ref，都是可遇不可求的，基本上很难优化到这个状态。</p><p>​    <strong>4.ref</strong>：查询用到了非唯一性索引，或者关联操作只使用了索引的最左前缀</p><p>​    为teacher表的tcid（第三个字段）创建普通索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- alert table teacher drop primary key</span><br>alert <span class="hljs-keyword">table</span> teacher <span class="hljs-keyword">add</span> <span class="hljs-keyword">primary</span> key(tcid);<br><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">where</span> tcid<span class="hljs-operator">=</span><span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/18.png"></p><p><strong>5.range</strong>：索引范围扫描。如果where后面是between and 或 &lt; 或 &gt; 或 &gt;= 或 &lt;= 或 in这些，type类型就为range。不走索引一定是全表扫描（ALL），所以先加上普通索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- alert table teacher drop index idx_tid</span><br>alert <span class="hljs-keyword">table</span> teacher <span class="hljs-keyword">add</span> index idx_tid(tid)<br><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">where</span> tid<span class="hljs-operator">&lt;</span><span class="hljs-number">3</span>;<br><span class="hljs-comment">-- 或</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">where</span> tid <span class="hljs-keyword">between</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/19.png"></p><p>IN查询也是range（字段上有主键索引）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> teacher_contact <span class="hljs-keyword">where</span> tcid <span class="hljs-keyword">in</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/20.png"></p><p><strong>6.index</strong>：Full Index Scan，查询全部索引中的数据（比不走索引要快）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> tid <span class="hljs-keyword">from</span> teacher;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/21.png"></p><p><strong>7.all：</strong>Full Table Scan，如果没有索引或者没有用到索引，type就是ALL。代表全表扫描。</p><p><strong>8.Null：</strong>不用访问表或者索引就能得到结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> dual <span class="hljs-keyword">where</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>总结：一般来说，需要保证查询的type至少达到range级别，最好能达到ref。all（全表扫描）和index（查询全部索引）都是需要优化的</p><h4 id="4-2-4-Possible-key-key"><a href="#4-2-4-Possible-key-key" class="headerlink" title="4.2.4 Possible_key, key"></a>4.2.4 Possible_key, key</h4><p>​    可能用到的索引和实际用到的索引。如果是null就代表没有用到索引。Possible_key可以有一个个或者多个，可能用到索引不代表一定用到索引。反过来，possible_key为空，key可能有值吗？表上创建联合索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">alert <span class="hljs-keyword">table</span> user_innodb <span class="hljs-keyword">add</span> index name_phone(name, phone);<br>explain <span class="hljs-keyword">select</span> phone <span class="hljs-keyword">from</span> user_innodb <span class="hljs-keyword">where</span> phone <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;126&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/22.png"></p><p>结论：是有可能的（这里是覆盖索引的情况）。如果通过分析发现没有用到索引，就要检查SQL或者创建索引。</p><h4 id="4-2-5-key-len"><a href="#4-2-5-key-len" class="headerlink" title="4.2.5 key_len"></a>4.2.5 key_len</h4><p>​    索引的长度（使用的字节数）。跟索引字段的类型，长度有关。</p><p>​    表上有联合索引：KEY ‘comidx_name_phone’(‘name’, ‘phone’)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_innodb <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;qs&#x27;</span>;<br></code></pre></td></tr></table></figure><p>Key_len = 1023，为什么不是255+11=266呢？这里的索引只用到了name字段，定义长度255.utf8mb4编码一个字符4个字节。所以是255*4=1020.使用变长字段varchar需要额外增加2个字节，允许null需要额外增加1个字节。所以一共1023.</p><h4 id="4-2-6-Rows"><a href="#4-2-6-Rows" class="headerlink" title="4.2.6 Rows"></a>4.2.6 Rows</h4><p>MySQL认为扫描多少行才能返回请求的数据，是一个预估值。一般来说行数越少越好。</p><h4 id="4-2-7-Filtered"><a href="#4-2-7-Filtered" class="headerlink" title="4.2.7 Filtered"></a>4.2.7 Filtered</h4><p>​    这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，它是一个百分比。如果比例很低，说明存储引擎层返回的数据经过大量过滤，这个是会消耗性能的，需要关注。</p><h4 id="4-2-8-Ref"><a href="#4-2-8-Ref" class="headerlink" title="4.2.8 Ref"></a>4.2.8 Ref</h4><p>使用哪个列或者常数和索引一起从表中筛选数据。</p><h4 id="4-2-9-Extra"><a href="#4-2-9-Extra" class="headerlink" title="4.2.9 Extra"></a>4.2.9 Extra</h4><p>执行计划给出额外的信息说明。</p><p>​    1.using index：用到了覆盖索引，不需要回表</p><p>​    2.using where：使用了where过滤，表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤（跟是否使用索引没有关系）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_innodb <span class="hljs-keyword">where</span> phone <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1345353545&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/23.png"></p><p>​    3.using index condition：索引条件下推</p><p>​    4.using filesort：不能使用索引来排序，用到了额外的排序（跟磁盘或文件没有关系）。需要优化。（复合索引的前提）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">alert <span class="hljs-keyword">table</span> user_innodb <span class="hljs-keyword">drop</span> index comidx_name_phone;<br>alert <span class="hljs-keyword">table</span> user_innodb <span class="hljs-keyword">add</span> index comidx_name_phone(name,phone);<br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_innodb <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;qs&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/24.png"></p><p>​    5.using temporary：用到了临时表，例如（以下不是全部情况）</p><p>​       （1）distinct非索引列（确定tid字段是否有索引）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span>(tid) <span class="hljs-keyword">from</span> teacher t;<br></code></pre></td></tr></table></figure><p>​       （2）group by非索引列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> tname <span class="hljs-keyword">from</span> teacher <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> tname;<br></code></pre></td></tr></table></figure><p>​       （3）使用join的时候，group任意列（t表的结果）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> t.tid <span class="hljs-keyword">from</span> teacher t <span class="hljs-keyword">join</span> course c <span class="hljs-keyword">on</span> t.tid <span class="hljs-operator">-</span> c.tid <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> t.tid;<br></code></pre></td></tr></table></figure><p>需要优化，比如创建复合索引。</p><p>如果需要具体的cost信息，可以用：EXPLAIN FORMAT = JSON。如果觉得explain还不够细，可以开启optimizer trace。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;optimizer_trace&#x27;</span>;<br><span class="hljs-keyword">set</span> optimizer_trace<span class="hljs-operator">=</span><span class="hljs-string">&#x27;enabled=on&#x27;</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> information_schema.optimizer_trace\G<br></code></pre></td></tr></table></figure><p>总结一下：模拟优化器执行SQL查询语句的过程，来知道MySQL是怎么处理一条SQL语句的，通过这种方式我们可以分析语句或者表的性能瓶颈。分析出问题之后，就是对SQL语句的具体优化。</p><h3 id="4-3-SQL与索引优化"><a href="#4-3-SQL与索引优化" class="headerlink" title="4.3 SQL与索引优化"></a>4.3 SQL与索引优化</h3><p>​    当我们的SQL语句比较复杂，有多个关联和子查询的时候，就要分析SQL语句有没有改写的方法。举个简单的例子，一摸一样的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 大偏移量的limit</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_innodb limit <span class="hljs-number">900000</span>,<span class="hljs-number">10</span>;<br><span class="hljs-comment">-- 改成先过滤ID，再limit</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_innodb <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">900000</span> limit <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>一个sum语句性能提升3倍的优化案例： <a href="https://gper.club/articles/7e7e7f7ff4g5egc2g63">https://gper.club/articles/7e7e7f7ff4g5egc2g63</a>   这一步是SQL语句的优化，目的是让SQL语句的cost更小。</p><h2 id="5-存储引擎与表结构优化"><a href="#5-存储引擎与表结构优化" class="headerlink" title="5  存储引擎与表结构优化"></a>5  存储引擎与表结构优化</h2><p>1.存储引擎的选择</p><p>​       为不同的业务表选择不同的存储引擎，例如：查询插入多的业务表，用MyISAM。临时数据用memory。 常规并发多更新的表用InnoDB。</p><p>​    2.分表或者分区</p><p>​       交易历史表：在年底为下一年度建立12个分区，每个月一个分区</p><p>​       渠道交易表：分成：当日表，当月表，历史表，历史表再做分区</p><p>​    3.字段定义：</p><p>​       原则：使用可以正确存储数据的最小数据类型。为每列选择合适的字段类型：</p><p>​       （1）整数类型：</p><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/25.png"></p><p>Int有6中类型，不同的类型的最大存储范围是不一样的，占用的存储空间也是不一样的。举       例：存储性别字段？用tinyint，因为enum也是整数存储。</p><p>​       （2）字符类型：变长情况下，varchar更节省空间，但是对于varchar字段，需要一个字节来记录长      度，比如：联系地址。固定长度的用char，不要用varchar，比如：行政区编码。</p><p>​       （3）非空：非空字段尽量定义成not null，提供默认值，或者使用特殊值，空串代替null。NULL类     型的存储，优化，使用都会存在问题。</p><p>​       （4）不要使用外键，触发器，视图：降低了可读性；影响数据库性能，应该把计算的事情交给程序，       数据库专心做存储；数据的完整性应该在程序中检查。</p><p>​       （5）大文件存储：图片和音频，视频怎么存储？不要用数据库村粗图片（比如base64编码）或者      大文件。把文件放在NAS上，数据库只存储URI（相对路径），在应用中配置NAS服务器地址。</p><p>​       （6）表拆分或者字段冗余：</p><p>​           表拆分：将不常用的字段拆分出去，避免列数过多和数据量过大。淘宝的商品表。商户信息表。      比如在业务系统中，要记录所有接收和发送的消息，这个消息是XML格式的，用blob或者text存      储，用来追踪和判断重复，可以建立一张表专门用来存储报文。</p><p>​           字段冗余：合同表的客户姓名。</p><h2 id="6-总结：优化体系"><a href="#6-总结：优化体系" class="headerlink" title="6  总结：优化体系"></a>6  总结：优化体系</h2><p><img src="/image/mysql/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/26.png"></p><p>除了对于代码，SQL语句，表定义，架构，配置优化之外，业务层面的优化也不能忽视，举几个例子：</p><p>​    （1）在某一年的双十一，为什么会做一个充值到余额宝和余额有奖金的活动？现在会推荐大家用花呗支付，而不是银行卡支付？因为使用余额或者余额宝付款是记录本地或者内部数据库中，而使用银行卡付款，需要调用接口，操作内部数据库肯定更快。</p><p>​    （2）在某一年的双十一，为什么在凌晨禁止查询今天之外的账单？为什么小鸡的饲料发放延迟了？这时一种降级措施，用来保证当前最核心的业务。</p><p>​    （3）某银行的叫记录，只能按月份查询。</p><p>​    （4）最近几年的双十一，为什么11月1日就开始了？变成了各种定金红包模式？预售分流。</p><p>​    在应用层面同样有很多其他的方案来优化，达到尽量减轻数据库的压力的目的，比如限流，或者引入MQ削锋，等等。用数据库慢，不代表数据库本身慢，有的时候还要往上层去优化。当然，如果关系型数据库解决不了的问题，我们可能需要用到搜索引擎或者大数据的方案了，并不是所有的数据都要放到关系型数据库存储。</p><h2 id="7-优化案例"><a href="#7-优化案例" class="headerlink" title="7  优化案例"></a>7  优化案例</h2><p>​    服务端状态分析：</p><p>​    如果出现连接变慢，查询被阻塞，无法获取连接的情况。</p><p>​       1.重启！</p><p>​       2.show processlist查看线程状态，连接数数量，连接时间，状态</p><p>​       3.查看锁的状态</p><p>​       4.kill有问题的线程</p><p>​    对于具体的慢SQL：</p><p>​    一，分析查询基本情况</p><p>​       涉及到的表的表结构，字段的索引情况，每张表的数据量，查询的业务含义。这个非常重要，因为    有时候你会发现SQL根本没必要这么写，或者表设计是有问题的。</p><p>​    二，找出慢的原因</p><p>​       1.查看执行计划，分析SQL的执行情况，了解表访问顺序，访问类型，索引，扫描行数等信息</p><p>​       2.如果总体的时间很长，不确定哪一个因素影响最大，通过条件的增减，顺序的调整，找出引起查    询慢的主要原因，不断的尝试验证。找到原因：比如是没有走索引引起的，还是关联查询引起的，还order     by引起的。找到原因后：</p><p>​       3.对症下药，</p><p>​       （1）创建索引或者联合索引</p><p>​       （2）改写SQL，这里需要平时积累经验，例如：a）使用小表驱动大表，b）用join代替子查询，c）         not exist转换为left join is null，d）or改成union，e）如果结果集允许重复的话，使用union         all代替union，f）大偏移的limit，先过滤再排序。</p><p>​       如果sql本身解决不了，就要上升到表结构和架构了。</p><p>​       （3）表结构（冗余，拆分，not all等），架构优化（缓存，读写分离，分表分库）</p><p>​       （4）业务层的优化，必须条件是否必要</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL事务和锁</title>
    <link href="/2023/02/16/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/"/>
    <url>/2023/02/16/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="1-数据库事务"><a href="#1-数据库事务" class="headerlink" title="1. 数据库事务"></a>1. 数据库事务</h2><h3 id="1-1-事务的典型场景"><a href="#1-1-事务的典型场景" class="headerlink" title="1.1 事务的典型场景"></a>1.1 事务的典型场景</h3><p>​    在项目中，什么地方使用事务？是根据业务类型来使用的还是根据数据操作类型来使用的？无论你是在方法上加@Transactional注解，还是在xml文件中配置切面，还是直接用JDBC的方法。很多时候我们需要事务是因为我们希望涉及数据库的多个操作都成功，比如客户下单，会操作订单表，资金表，物流表等等，就需要放在一个事务中执行。</p><p>​    一个非常典型的案例就是银行转账。如果我们把行内转账简化为一个账户余额减少，另一个账户余额增加的情况，那么这两个动作一定是同时成功或同时失败的，否则会造成会计科目不平衡。另一个例子：12306的连续换乘功能，两张票必须同时购买成功，只买到前半程或者只买到后半程是没有意义的。</p><h3 id="1-2事务的定义"><a href="#1-2事务的定义" class="headerlink" title="1.2事务的定义"></a>1.2事务的定义</h3><p>​    事务是数据库管理系统（DBMS）执行过程中的一个逻辑单位，有一个有限的数据库操作序列构成。这里有两个关键点，1.所谓的逻辑单位，意味着它是数据库最小的工作单位，是不可再分的。2.它可能包含了一个或者多个DML语句，包括insert delete update。（单条DDL（create drop）和DCL（grant revoke）也会有事务）。</p><h3 id="1-3-哪些存储引擎支持事务"><a href="#1-3-哪些存储引擎支持事务" class="headerlink" title="1.3 哪些存储引擎支持事务"></a>1.3 哪些存储引擎支持事务</h3><p>​    并不是所有的数据库或者所有的存储引擎都支持事务，它是作为一种特性出现的。在MySQL中除了做集群的NDB之外，只有InnoDB支持事务，这个也是它成为默认的存储引擎的一个重要原因。</p><h3 id="1-4-事务的四大特性-ACID"><a href="#1-4-事务的四大特性-ACID" class="headerlink" title="1.4 事务的四大特性(ACID)"></a>1.4 事务的四大特性(ACID)</h3><p>​    1.原子性，Atomicity，也就是不可再分，因为原子是化学上（参加化学反应）最小单位。也就意味着我们对数据库的一系列操作，要么都成功，要么都失败，不可能出现部分成功的情况。问题是如果前面一个成功了，后面的操作失败了，怎么让它全部失败？这个时候我们必须要回滚。原子性在InnoDB中是通过undo log来实现的，他记录了数据修改之前的值（逻辑日志），一旦发生异常，就可以用undo log来实现回滚操作。</p><p>​    2.隔离性，Isolation，我们有了事务的定义后，在数据库中会有很多的事务同时去操作我们的同一张表或者同一行数据，必然会产生一些并发或者干扰的操作。我们对隔离性的定义，就是这些很多个的事务，对表或者行的并发操作，应该是透明的，互相不干扰的。比如两个人给青山转账100，开启两个事务，都拿到了青山账户的余额1000，然后各自基于1000加100，最后结果是1100，就出现了数据混乱的问题。</p><p>​    3.持久性，Durability，事务的持久性是什么意思？我们对数据库的任意的操作，增删改，是要事务提交成功，那么结果就是永久性的，不可能因为数据库掉电，宕机，意外重启，又能变成原来的状态。这个就是事务的持久性。持久性是通过redo log和double write buffer（双写缓冲）来实现的，我们操作数据的时候，会先写到内存的buffer pool中，同时记录redo log，如果在刷盘之前出现异常，在重启后就可以读取到redo log的内容，写入到磁盘，保证数据的持久性。当然，恢复成功的前提是数据页本身没有损坏，是完整的，这个通过双写缓冲保证。需要注意的是，原子性，隔离性，持久性，最后都是为了实现一致性。</p><p>​    4.一致性，consistent，指的是数据库的完整性约束没有被破坏，事务执行前后都是合法的数据状态。数据库自身提供了一些约束：比如主键必须是唯一的，字段长度符合要求。另外还有用户自定义的完整性，用户自定义的完整性通常要在代码中控制，例如金额不能小于0等。</p><h3 id="1-5数据库什么时候出现事务"><a href="#1-5数据库什么时候出现事务" class="headerlink" title="1.5数据库什么时候出现事务"></a>1.5数据库什么时候出现事务</h3><p>​    当执行一条更新语句，实际上，它不仅自动开启了事务，而且还自动提交了，所以最终写入了磁盘。这个是开启事务的第一种方式，增删改的语句会自动开启事务，当然是一条SQL一个事务。注意每个事务都是有编号的，这个编号是一个整数，有递增的特性。如果把多条SQL放在一个事务中，就要手动开启事务。手动开启事务有两种方式：一种是用begin；一种是用start transaction。结束事务也有两种方式：一种是回滚事务rollback，事务结束；另一种是提交事务commit，事务结束。</p><p>​    InnoDB中有一个autocommit的参数（分为两个级别，session和global级别）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;autocommit&#x27;</span>;<br></code></pre></td></tr></table></figure><p>​    它的默认值是ON。这个参数的意义是是否自动提交。如果它的值是true/ON的话，会自动提交事务。如果设置为false/OFF的话，那么数据库的事务就需要我们手动结束，用rollback或commit。</p><p>​    还有一种情况，客户端的连接断开的时候，事务也会结束。</p><h3 id="1-6事务并发会带来哪些问题？"><a href="#1-6事务并发会带来哪些问题？" class="headerlink" title="1.6事务并发会带来哪些问题？"></a>1.6事务并发会带来哪些问题？</h3><p>​    有两个事务，一个编号2573，另一个是2674。在第一个事务中，它首先通过where id=1的条件查询一条数据，返回name=Ada，age=16的这条数据，然后第二个事务，它通过一个update的语句，把id=1的数据的age改成了18，但是没有提交。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/1.png"></p><p>​    这时，在第一个事务中，它再次执行相同的查询操作，发现数据发生了变化，获取到的数据age变成了18.那么，这种在一个事务中，由于其他的时候修改了数据并且没有提交，而导致了前后两次读取数据不一致的情况，这种事务并发的问题，我们把它定义为<strong>脏读。</strong>如果在转账的案例中，我们第一个事务基于读取到的第二个事务未提交的余额进行了操作，但是第二个事务进行了回滚，这个时候就会导致数据不一致。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/2.png"></p><p>​    同样是两个事务，第一个事务通过id=1查询到了一条数据。然后第二个事务中执行了一个update操作，执行了update以后它通过一个commit提交了修改。然后第一个事务读取到了其他事务已提交的数据导致前后两次读取数据不一致的情况，就像这里，age到底是16还是18，那么这种事务并发带来的问题，把它叫做<strong>不可重复读。</strong></p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/3.png"></p><p>​    在第一个事务中我们执行了一个范围查询，这时满足条件的数据只有一条。在第二个事务中，插入了一行数据，并且提交了。重点：插入了一条数据。在第一个事务再去查询时，它发现多了一行数据。一个事务前后两次读取数据不一致，是由于其他事务插入数据造成的，这种情况叫做<strong>幻读</strong>。</p><p>不可重复读和幻读的区别在哪里？修改或删除造成的读不一致叫做不可重复读，插入造成的读叫做幻读。</p><p>这里有两点需要说明：</p><ol><li><p>一个事务读取到其他事务最新提交的数据，这不是正常的吗？当然是正常的，所以这里讨论的是读一致性。读一致性的意义就是一个事务的select操作跟其他事务没有瓜葛，你不需要修改数据，所以不需要获取最新的数据，这样能够提高并发性能。</p></li><li><p>如果在第一个事务中，select以后，再执行一个update，就能获取到第二个事务的最新数据，这个怎么解释？同样的，这个页脱离了读一致性的讨论范畴。如果要修改数据。必然会读取到最新的数据，也会影响其他的事务。</p></li></ol><p>所以这里要不要修改，要不要读取到最新的数据，是一个区别点。目前我们讨论的都是一个事务中多次重复读取。</p><p>​    小结：无论是脏读，不可重复读，幻读，他们都是数据库的读一致性问题，都是在一个事务中前后两次读取出现了不一致的情况。读一致性的前提，必须要由数据库提供一定的事务隔离机制来解决。就像我们去饭店吃饭，基本的设施和卫生保证都是饭店提供的。那么我们使用的数据库，隔离性的问题页必须由数据库帮助我们解决。</p><h3 id="1-7SQL92标准事务隔离级别定义"><a href="#1-7SQL92标准事务隔离级别定义" class="headerlink" title="1.7SQL92标准事务隔离级别定义"></a>1.7SQL92标准事务隔离级别定义</h3><p>​    美国国家标准协会（ANSI）制定了一个SQL标准，也就是说建议数据库厂商都按照这个标准，提供一定的事务隔离级别，来解决事务并发的问题。这个SQL标准有很多版本，大家最熟悉的是SQL92标准。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/4.png"></p><p>​    这个表格里面定义了四个隔离级别，右边P1 P2 P3计师代表事务并发的3个问题，脏读，不可重复读，幻读。Possible代表在这个隔离级别下，这个问题有可能发生，换句话说就是没有解决这个问题。Not Possiable就是解决了这个问题。</p><p>我们详细的分析这4个隔离级别是怎么定义的。</p><ol><li><p>Read Uncommitted（未提交读），一个事务可以读取到其他事务为提交的数据，会出现脏读，所以叫做RU，没有解决任何问题。</p></li><li><p>Read Commited（已提交读），就是一个事务只能读取到其他事务已提交的数据，不能读取其他事务未提交的数据，解决了脏读的问题，但是会出现不可重复读的问题。</p></li><li><p>Repeatable Read（可重复读），它解决了不可重复读的问题，也就是在同一事务中多次读取的数据结果是一样的，但是没有解决幻读的问题</p></li><li><p>Serializable（串行化），这个隔离级别下，所有的事务都是串行执行的，也就是对数据的操作需要排队，已经不存在事务的并发操作了，所以它解决了所有问题。</p></li></ol><p>事务的隔离级别是可以修改的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level read uncommitted;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level read committed;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level repeatable read;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> transaction isolation level serializable;<br></code></pre></td></tr></table></figure><p>​    这个是SQL92的标准，但是不同的数据库厂商或者存储引擎的实现有一定的差异，比如Oracle中就只有两种RC（已提交读）和Serializable（串行化）。</p><h3 id="1-8-InnoDB事务隔离级别的实现"><a href="#1-8-InnoDB事务隔离级别的实现" class="headerlink" title="1.8 InnoDB事务隔离级别的实现"></a>1.8 InnoDB事务隔离级别的实现</h3><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读(Read Uncommitted)</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>已提交读(Read Committed)</td><td><em>不可能</em></td><td>可能</td><td>可能</td></tr><tr><td>可重复读(Repeatable Read)</td><td><em>不可能</em></td><td><em>不可能</em></td><td><em><strong>对InnoDB不可能</strong></em></td></tr><tr><td>串行化(Serializable)</td><td><em>不可能</em></td><td><em>不可能</em></td><td><em>不可能</em></td></tr></tbody></table><p>​    InnoDB支持的4个隔离级别和SQL92定义的完全一致，隔离级别越高，事务的并发度越低。唯一的区别是InnoDB在RR级别就解决了幻读的问题。也就是说不需要使用串行话去解决所有问你题，既保证了数据的一致性，又支持较高的并发度，这个就是InnoDB默认使用RR作为事务隔离级别的原因。</p><h3 id="1-9-读一致性解决方案"><a href="#1-9-读一致性解决方案" class="headerlink" title="1.9 读一致性解决方案"></a>1.9 读一致性解决方案</h3><p>​    如果要解决读一致性的问题，保证一个事务中前后两次读取数据结果一致，实现事务隔离，总体上有以下两大类方案。</p><h4 id="1-9-1-LBCC"><a href="#1-9-1-LBCC" class="headerlink" title="1.9.1 LBCC"></a>1.9.1 LBCC</h4><p>​    既要保证前后两次读取数据一致，那么我读取数据时锁定我要操作的数据，不允许其他的事务修改就行了。这种方案叫做基于锁的并发控制Lock Based Concurrency Control（LBCC）。</p><p>​    如果仅仅是基于锁来实现事务隔离，一个事务读取得时候不允许其他事务修改，那就意味着不支持并发得读写操作，而我们得大多数应用都是读多写少得，这样会极大得影响操作数据得效率。</p><h4 id="1-9-2-MVCC"><a href="#1-9-2-MVCC" class="headerlink" title="1.9.2 MVCC"></a>1.9.2 MVCC</h4><p>​    第二种，如果要让一个事务前后两次读取得数据保持一致，那么我们可以在修改数据之前给它建立一个备份或者快照，后面再来读取这个快照就行了。这种方案我们叫做多版本的并发控制Multi Version Concurrency Control（MVCC）。MVCC的原则：</p><p>一个事务能看到的数据版本：</p><ol><li><p>第一次查询之前已经提交的事务的修改</p></li><li><p>本事务的修改</p></li></ol><p>一个事务不能看见的数据版本：</p><ol><li><p>在本事务第一次查询之后创建的事务（事务ID比本事务ID大）</p></li><li><p>活跃的（未提交的）事务的修改</p></li></ol><p>​    MVCC的效果：我们可以查到在我这个事务之前已经存在数据，即使它在后面被修改删除了，而在我这个事务之后新增的数据，我是查不到的。所以我们才把这个叫做快照，不管别的事务做任何增删改查的操作，它只能看到第一次查询时看到的数据版本。</p><p>​    分析一下MVCC的原理。首先，InnoDB的事务都是由编号的，而且会不断递增。InnoDB为每行记录都实现了两个隐藏字段：</p><p>​    1.DB_TRX_ID，6字节：事务id，数据是在哪个事务插入或者修改为新数据的，就记录为当前事务ID。</p><p>​    2.DB_ROLL_PTR，7字节：回滚指针，我们把它理解为删除版本号，数据被删除或记录为旧数据时，记录当前事务ID，没有修改或者删除的时候是空。</p><table><thead><tr><th>id</th><th>name</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th></tr></thead><tbody><tr><td>1</td><td>aaa</td><td>01</td><td>NULL</td></tr></tbody></table><p>当第一个事务，初始化数据（检查初始数据）</p><table><thead><tr><th>Transaction 1</th></tr></thead><tbody><tr><td>begin; <br />insert into mvcctest values(null, ‘qs’);<br />insert into mvcctest values(null, ‘hh’);<br />commit;</td></tr></tbody></table><p>此时的数据，创建版本是当前事务ID（假设事务编号是1），删除版本为空：</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>qh</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>hh</td><td>1</td><td>undefined</td></tr></tbody></table><p>第二个事务，执行第一次查询，读取到两条原始数据，这时事务ID是2：</p><table><thead><tr><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;<br />select * from mvcctest; –(1)第一次查询</td></tr></tbody></table><p>第三个事务，插入数据：</p><table><thead><tr><th>Transaction 3</th></tr></thead><tbody><tr><td>begin;<br />insert into mvcctest values(NULL, ‘tom’);<br />commit</td></tr></tbody></table><p>此时的数据，多了一条tom，它的创建版本号是当前事务编号，3：</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>qs</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>hh</td><td>1</td><td>undefined</td></tr><tr><td>3</td><td>tom</td><td>3</td><td>undefined</td></tr></tbody></table><p>第二个事务，执行第二次查询：</p><table><thead><tr><th>Transaction 2</th></tr></thead><tbody><tr><td>select * from mvcctest;  –(2)第二次查询</td></tr></tbody></table><p>​    MVCC的查找原则：只能查找创建时间小于等于当前事务ID的数据，和删除时间大于当前事务ID的行（或未删除）。也就是不能查到在我的事务开始之后插入的数据，tom的创建ID大于2，所以还是只能查到两条数据。</p><p>第四个事务，删除数据，删除了id=2 hh这条记录：</p><table><thead><tr><th>Transaction 4</th></tr></thead><tbody><tr><td>begin;<br />delete from mvcctest where id=2;<br />commit;</td></tr></tbody></table><p>此时的数据，hh的删除版本被记录为当前事务ID，4，其他数据不变：</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>qs</td><td>1</td><td>undefined</td></tr><tr><td>2</td><td>hh</td><td>1</td><td>4</td></tr><tr><td>3</td><td>tom</td><td>3</td><td>undefined</td></tr></tbody></table><p>在第二个事务中，执行第三次查询：</p><table><thead><tr><th>Transaction 2</th></tr></thead><tbody><tr><td>select * from mvcctest; (3)第三次查询</td></tr></tbody></table><p>​    查找规则：只能查找创建时间小于等于当前事务ID的数据，和删除时间大于当前事务ID的行（或未删除）。也就是，在我事务开始之后删除的数据，所以huihui依然可以查出来。所以还是查出两条数据。</p><p>​    第五个事务，执行更新操作，这个事务ID是5：</p><table><thead><tr><th>Transaction 5</th></tr></thead><tbody><tr><td>begin;<br />update mvcctest ser name = ‘盆玉艳’ where id= 1;<br />commit;</td></tr></tbody></table><p>此时的数据，更新数据时，旧数据的删除版本被记录为当前事务ID5（undo），产生了一条新数据，创建ID为当前事务ID5：</p><table><thead><tr><th>id</th><th>name</th><th>创建版本</th><th>删除版本</th></tr></thead><tbody><tr><td>1</td><td>qs</td><td>1</td><td>5</td></tr><tr><td>2</td><td>hh</td><td>1</td><td>4</td></tr><tr><td>3</td><td>tom</td><td>3</td><td>undefined</td></tr><tr><td>1</td><td>盆玉艳</td><td>5</td><td>undefined</td></tr></tbody></table><p>第二个事务，执行第四次查询：</p><table><thead><tr><th>Transaction 2</th></tr></thead><tbody><tr><td>select * from mvcctest; (4)第四次查询</td></tr></tbody></table><p>​    查找规则：只能查找创建时间小于等于当前事务ID的数据，和删除时间大于当前事务ID的行（或未删除）。因为更新后的数据盆鱼宴创建版本大于2，代表是在事务之后增加的，查不出来。而旧数据qingshan的删除版本大于2，代表是在事务之后删除的，可以查出来。</p><p>​    通过以上演示可以看到，通过版本号的控制，无论其他事务是插入，修改，删除，第一个事务查询到的数据都没有变化。这个是MVCC的效果，当然，这里是一个简化的模型。假设一条数据修改了3次，两次提交了一次未提交，每次修改之后都有开启一个事务去查询，那么事务2，4，6查到的数据会有不一样。</p><table><thead><tr><th>trx_id</th><th>SQL</th></tr></thead><tbody><tr><td>trx1</td><td>update user_info set name = ‘penyuyan’ where id =1;<br />commit;</td></tr><tr><td>trx2</td><td>select name from user_info where id = 1;</td></tr><tr><td>trx3</td><td>update user_info set name=’wuyanzu’ where id = 1; <br />commit;</td></tr><tr><td>trx4</td><td>select name from user_info where id = 1;</td></tr><tr><td>trx5</td><td>update user_info set name=’liudehua’ where id = 1;  <br />未提交</td></tr><tr><td>trx6</td><td>select name from user_info where id = 1;</td></tr><tr><td></td><td>trx2、4、6再各查一次</td></tr></tbody></table><p>​    InnoDB中，一条数据的旧版本，是存放在undo log中。因为修改了多次，这些undo log回形成一个链条，叫做undo log链，现在undo log中有刘德华，吴彦祖，盆鱼宴。所以前面说的DB_ROLL_PTR，它其实指向undo log链的指针。</p><p>​    第二个问题，事务2，4，6最后再查一次，他们去undo log链找数据时。拿到的数据是不一样的。再这个undo log链里面，一个事务怎么判断哪个版本的数据是它应该读取的？</p><p>回想一下MVCC的规则：</p><p>一个事务能看到的数据版本：1，第一次查询之前已经提交的事务的修改；2，本事务的修改。</p><p>一个事务不能看到的数据版本：1，本事务第一次查询之后创建的事务（事务ID比我的事务ID大）；2，活跃的（未提交的）事务的修改。</p><p>​    所以，必须要有一个数据结构，把本事务ID，活跃事务ID，当前系统最大事务ID存起来，这样才能实现判断。这个数据结构叫Read View（可见性视图），每个事务都维护一个自己的Read View。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/6.png"></p><p><em>m_ids</em>：表示在生成ReadView时当前系统活跃的读写事务的事务id列表。</p><p><em>min_trx_id</em>：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务ID，也就是m_ids中的最小值。</p><p><em>mmax_trx_id</em>：表示生成ReadView时系统中应该分配给下一个事务的id值。</p><p><em>creator_trx_id</em>：表示生成该ReadView的事务的事务id。</p><p>有了这个数据结构后，事务判断可见性的规则是这样的：</p><p>0，从数据的最早版本开始判断（undo log）。</p><p>1，数据版本的trx_id = creator_trx_id，本事务修改，可以访问。</p><p>2，数据版本的trx_id &lt; min_trx_id（未提交事务的最小ID），说明这个版本是生成ReadView已经提交，可以访问。</p><p>3，数据版本的trx_id &gt; max_trx_id（下一个事务ID），这个版本是生成ReadView之后才开启的事务建立的，不能访问。</p><p>4，数据版本的trx_id在min_trx_id和max_trx_id之间，看看是否在m_ids中。如果在，不可以。如果不在，可以。</p><p>5，如果当前版本不可见，就找undo log链中的下一个版本。</p><p>​    注意：RR中ReadView是事务第一次查询时建立的。RC的ReadView是事务每次查询的时候建立的。Oracle，Postgres等等其他数据库都有MVCC实现。需要注意，在InnoDB中，MVCC和锁是协同使用的，这两种方式并不是互斥的。</p><h2 id="2-InnoDB锁的基本类型"><a href="#2-InnoDB锁的基本类型" class="headerlink" title="2 InnoDB锁的基本类型"></a>2 InnoDB锁的基本类型</h2><h3 id="2-1-锁的粒度"><a href="#2-1-锁的粒度" class="headerlink" title="2.1 锁的粒度"></a>2.1 锁的粒度</h3><p>​    InnoDB和MyISAM支持的锁的类型是不同的。InnoDB同时支持表锁和行锁，MySIAM只支持表锁，用lock table的语法加锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">lock talbes xxx read;<br>lock tables xxx write;<br>unlock tables;<br></code></pre></td></tr></table></figure><h3 id="2-2-锁的类型"><a href="#2-2-锁的类型" class="headerlink" title="2.2 锁的类型"></a>2.2 锁的类型</h3><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html</a></p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/7.png"></p><p>​    官网把锁分成了8类。把前面的两个行级别锁（Shared and Exclusive Locks），和两个表级别的锁（Intention Locks）称为锁的基本模式。后面三个Record Locks，Gap Locks，Next-Key Locks，我们把它们叫做锁的算法。</p><p>​    插入意向锁（Insert Intention Locks）：是一个特殊的间隙锁。间隙锁不允许插入数据，但是插入意向锁允许多个事务同时插入数据到同一个范围，比如（4，7），一个事务插入5，一个事务插入6，不会发生锁等待。</p><p>​    自增锁（AUTO-INC Locks）：是一种特殊的表锁，用来防止自增字段重复，数据插入以后就会释放，不需要等到事务提交才释放。如果需要选择更快的子增值生成速度或者更加连续的子增值，就要通过修改自增锁的模式改变。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_autoinc_lock_mode&#x27;</span><br></code></pre></td></tr></table></figure><p>​    0：traditional（每次都会产生表锁）</p><p>​    1：consecutive（会产生一个轻量锁，simple insert会获得批量的锁，保证连续插入，默认值）</p><p>​    2：interleaved（不会锁表，来一个处理一个，并发最高）</p><p>​    Predicate Locks for Spatial Indexes是5.7版本中新增的一种数据类型的索引的锁。</p><h3 id="2-3-共享锁"><a href="#2-3-共享锁" class="headerlink" title="2.3 共享锁"></a>2.3 共享锁</h3><p>​    第一个行级别的锁就是Shared Locks（共享锁），获取了一行数据的读锁以后，可以用来读取数据，所以也叫做读锁，注意不要在加上了读锁以后去写数据，不然的话可能会出现死锁的情况。而且多个事务可以共享一把读锁。共享锁的作用：因为共享锁会阻塞其他事务的修改，所以可以用在不允许其他事务修改数据的情况（共享锁和写锁互斥的例子后面再看）。我们可以用select …… lock in share mode；的方式手工加上一把读锁。释放锁有两种方式，只要事务结束就会自动释放锁，包括提交事务和结束事务</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from student where id =1 lock in share mode;</td><td></td></tr><tr><td></td><td>begin;</td></tr><tr><td></td><td>select * from student where id = 1 lock in share mode;  <br />//OK</td></tr></tbody></table><h3 id="2-4-排他锁"><a href="#2-4-排他锁" class="headerlink" title="2.4 排他锁"></a>2.4 排他锁</h3><p>​    第二个行级别的锁叫做Exclusive Locks（排他锁），它是用来操作数据的，所以又叫做写锁。只要一个事务获取了一行数据的排他锁，其他事务就不能再获取这一行数据的共享锁和排他锁。加锁的方式有两种，第一种是自动加排他锁，增删改都会默认加上一个排他锁。还有一种是手工加锁，我们用一个FOR UPDATE给一行数据加上一个排他锁，这个无论是在我们的代码中还是操作数据的工具中都比较常用。释放锁和前面是一样的。</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>update student set sname=’fdasfd’ where id = 1;</td><td></td></tr><tr><td></td><td>begin;</td></tr><tr><td></td><td>select * from student where id=1 lock in share mode;  //blocked <br />select * from student where id=1 for update; //blocked   <br />delete from student where id=1 //blocked</td></tr></tbody></table><h3 id="2-5-意向锁"><a href="#2-5-意向锁" class="headerlink" title="2.5 意向锁"></a>2.5 意向锁</h3><p>​    意向锁是由数据库自己维护的。也就是说，当我们给一行数据加上共享锁之前，数据库会自动在这张表上面加上意向共享锁。当我们给一行数据加上排他锁之前，数据库会自动在这张表上面加上一个意向排他锁。反过来，如果一张表上至少有一个意向共享锁，说明其他事务给其中的某些数据加上了共享锁；如果表上至少有一个意向排他锁，说明其他事务给其中的某些数据行加上了排他锁。</p><p>​    意向锁和意向锁是不冲突的，意向锁和行锁也不冲突。那么这两个表级别的锁有什么意义？如果没有意向锁的话，当我们准备给一张表加上表锁时，我们首先需要去判断有没有其他事务锁定了某些行，如果有的话，肯定不能加上表锁。那么这时我们就要去扫描整张表才能确定能不能成功加上一个表锁，如果数据量很大，那么加表锁的效率就非常低。但是我们引入意向锁后就不一样了，我们只要判断这张表上是否有意向锁，如果有直接返回失败。如果没有就可以加锁成功。所以InnoDB中的表锁，我们可以把它理解为一个标志（就像火车上卫生间有没有使用的灯），是用来提高加锁效率的。</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from student where id=1 for update;</td><td></td></tr><tr><td></td><td>beginl</td></tr><tr><td></td><td>lock tables student write; //blocked <br />unlock tables; //释放表锁的方式</td></tr></tbody></table><p>​    数据库锁跟java中的锁是一样的，是为了解决资源竞争的问题，java中的资源是对象，数据库的资源是数据表或者数据行。所以锁是用来解决事务对数据的并发访问问题的。</p><h2 id="3-行锁的原理"><a href="#3-行锁的原理" class="headerlink" title="3 行锁的原理"></a>3 行锁的原理</h2><p>​    有三张表，一张没有索引的t1，一张有主键索引的t2，一张有唯一索引的t3</p><p><strong>1.没有索引的表（假设锁住记录）</strong></p><p>​    假设InnoDB的行锁是锁住了一行数据或者一条记录。先看一下t1的表结构，它有两个字段，int类型的id和varchar类型的name。里面有4条数据1，2，3，4。</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from t1 where id = 1 for update;</td><td></td></tr><tr><td></td><td>select * from t1 where id=3 for update;  //blocked</td></tr><tr><td></td><td>insert into ‘t1’(‘id’,’name’) values(5, ‘5’);  //blocked</td></tr></tbody></table><p>​    在两个会话中手工开启两个事务。第一个事务中我们通过where id = 1锁住第一行数据。第二个事务中，我们尝试给id=3的这一行数据加锁，被阻塞。插入一条id=5的数据，被阻塞。结果第二个事务的加锁操作被阻塞了，说明<strong>InnoDB的行锁锁住的不是Record</strong>。那为啥在没有索引或者没有用到索引的情况下，会锁住整张表？这个问题后续解释。</p><p><strong>2.有主键索引的表</strong></p><p>​    t2的表结构。字段是一样的，不同的地方是id上创建了一个主键索引。里面的数据是1，4，7，10.</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from t2 where id = 1 for update;</td><td></td></tr><tr><td></td><td>select * from t2 where id=1 for update;  //blocked</td></tr><tr><td></td><td>select * from t2 where id=4 for update  //OK</td></tr></tbody></table><p>第一种情况，使用相同的id值去加锁，冲突；使用不同的id加锁，加锁成功。</p><p><strong>3.唯一索引（假设锁住字段）</strong></p><p>t3的表结构。字段还是一样的，id上创建了一个主键索引，name上创建了一个唯一索引。里面数据1，4，7，10.</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from t3 where name=’4’ for update;</td><td></td></tr><tr><td></td><td>select * from t3 where name=’4’ for update;  //blocked</td></tr><tr><td></td><td>select * from t3 where id=4 for update  //blocked</td></tr></tbody></table><p>​    第一个事务中我们通过name字段去锁定值是4的数据。第二个事务中尝试获取一样的排他锁，失败。然后用id=4去给这行数据加锁，被阻塞，说明行锁锁住字段的推测也是错的。</p><p>​    既然锁住的不是record，也不是column，InnoDB的行锁到底锁住了什么？在这三个案例中，他们的差异就在于表结构，其实答案就是索引，InnoDB的行锁是**通过锁住索引实现的。还有两个问题没有解决：</p><p>​    1.为什么表中没有索引的时候，锁住一行数据会导致锁表？因为查询没有使用索引，会进行全表扫描，然后把每一个隐藏的聚集索引都锁住了。</p><p>​    2.为什么通过唯一索引给数据行加锁，主键索引也会被锁住？因为我们通过辅助索引锁定一行数据时，它跟我们检索数据的步骤是一样的，会通过主键值找到主键索引，然后也锁定。本质上是因为锁定的是同一行数据，是相互冲突的。</p><h2 id="4-行锁的算法"><a href="#4-行锁的算法" class="headerlink" title="4  行锁的算法"></a>4  行锁的算法</h2><p>​    我们先看一下测试用表t2，其中有个主键，插入4行数据，主键id分别是1，4，7，10.</p><p>​    首先，先普及一下三种范围的概念。因为我们用主键索引加锁，我们这里划分标准就是主键索引的值。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/9.png"></p><p>​    这些数据库中存在的主键值，我们把它叫做Record，记录，那么我们这里就有4个Record。根据主键，这些存在的Record隔开的数据不存在的区间，我们叫做Gap，间隙，它是一个左开右开的区间。假如我们有N个Record，那么我们就有N+1个Gap。最后一个，间隙（Gap）连同它左边的记录（Record），我们把它叫做临键的区间，它是左开右臂=闭得区间。整型的主键索引，它是可以排序的，所以才有这种区间，如果我的主键索引不是整型，是字符怎么办？任何一个字符集，都有相应得排序规则：</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/10.png"></p><h3 id="4-1-记录锁-Record-Locks"><a href="#4-1-记录锁-Record-Locks" class="headerlink" title="4.1 记录锁(Record Locks)"></a>4.1 记录锁(Record Locks)</h3><p>​    当对于唯一性的索引（包括唯一索引和主键索引）使用等值查询，精准匹配到一条记录的时候，这时使用的就是记录锁。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/11.png"></p><p>​    使用不同的key去加锁，不会冲突，它只锁住这个record。图片上红的字就是使用这种锁的条件。</p><h3 id="4-2-间隙锁-Gap-Locks"><a href="#4-2-间隙锁-Gap-Locks" class="headerlink" title="4.2 间隙锁(Gap Locks)"></a>4.2 间隙锁(Gap Locks)</h3><p>​    当查询的记录不存在，没有命中任何一个record，无论是用等值查询还是范围查询时，它使用的都是间隙锁。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/12.png"></p><p>​    举个例子，where id &gt; 4 and id &lt; 7, where id = 6。</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select * from t2 where id=6 for update;</td><td></td></tr><tr><td></td><td>insert into ‘t2’(‘id’,’name’) values(5,’6’); //blocked<br />insert into ‘t2’(‘id’,’name’) values(6,’6’); //blocked <br />select * from t2 where id=6 for update; //OK</td></tr><tr><td>select * from t2 where id &gt; 20 for update;</td><td></td></tr><tr><td></td><td>insert into ‘t2’(‘id’,’name’) values(11,’6’); //blocked</td></tr></tbody></table><p>当查询不存在时使用间隙锁。注意，间隙锁主要是阻塞插入insert，相同的间隙锁之间不冲突。</p><h3 id="4-3-临键锁-Next-Key-Locks"><a href="#4-3-临键锁-Next-Key-Locks" class="headerlink" title="4.3 临键锁(Next-Key Locks)"></a>4.3 临键锁(Next-Key Locks)</h3><p>​    当我使用了范围查询，不仅仅命中了Record记录，还包含了Gap间隙，在这种情况下我们使用的就是临键锁，它是Mysql中默认的行锁算法，相当于记录锁加上间隙锁。唯一性索引，等值查询匹配到一条记录时退化为记录锁。没有匹配到记录时退化成间隙锁。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/13.png"></p><p>​    比如使用&gt;5，&lt;9，它包含了记录不存在的区间，也包含了一个Record 7.</p><table><thead><tr><th>Transaction 1</th><th>Transaction 2</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select from t2 where id&gt;5 and id&lt;9 for update</td><td></td></tr><tr><td></td><td>begin;</td></tr><tr><td></td><td>select * from t2 where id=4 for update;  //OK<br />insert into ‘t2’(‘id’,’name’) values(6, ‘6’); //blocked <br />insert into ‘t2’(‘id’,’name’) values(8, ‘6’); //blocked <br />select * from t2 where id=10 for update; //blocked</td></tr></tbody></table><p>​    临键锁，锁住最后一个key的下一个左开右闭区间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t2 <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">7</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>; <span class="hljs-comment">--锁住(4,7] 和(7,10]</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t2 <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">8</span> <span class="hljs-keyword">and</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>; <span class="hljs-comment">--锁住(7,10] 和(10,正无穷)</span><br></code></pre></td></tr></table></figure><p>为什么要锁住下一个左开右闭区间？就是为了解决幻读的问题。</p><h3 id="4-4-InnoDB事务隔离级别的实现"><a href="#4-4-InnoDB事务隔离级别的实现" class="headerlink" title="4.4 InnoDB事务隔离级别的实现"></a>4.4 InnoDB事务隔离级别的实现</h3><p>​    所以，InnoDB的RR级别能够解决幻读的问题，就是用临键锁实现的。</p><p>​    最后总结一下四个事务隔离级别的实现：</p><p>​    1.Read Uncommited：RU隔离级别，不加锁</p><p>​    2.Serializable：所有的select语句都会被隐式的转化为select ……in share mode，会和update，delete互斥。</p><p>​    3.Repeatable Read：RR隔离级别下，普通的select使用快照读（snapshot），底层使用MVCC来实现。加锁的select（select … in share mode/select …for update）以及更新操作update，delete等语句使用当前读（current read），底层使用记录锁，或者间隙锁或者临键锁。</p><p>​    4.Read Commited：RC隔离级别下，普通的select都是快照读（MVCC）。加锁的select都使用记录锁，因为没有Gap Lock。除了两种特殊情况——外键约束检查（foreign-key constraint checking）以及重复键检查（duplicate-key checking）时会使用间隙锁封锁区间，所以RC会出现幻读问题。</p><h2 id="5-事务隔离级别的选择"><a href="#5-事务隔离级别的选择" class="headerlink" title="5 事务隔离级别的选择"></a>5 事务隔离级别的选择</h2><p>​    RU和Serializable肯定不能使用。为什么有些公司要用RC？</p><p>​    RC和RR主要有几个区别：</p><p>​    1.RR的间隙锁会导致锁定范围的扩大。</p><p>​    2.条件列未使用到索引，RR锁表，RC锁行</p><p>​    3.RC的“半一致性”（semi-consistent）读可以增加update操作的并发性。</p><p>​    在RC中，一个update语句，如果督导一行已经加锁的记录，此时InnoDB返回记录最近提交的版本，由MySQL上层判断此版本是否满足update的where条件。若满足（需要更新），则MuSQLhi重新发起一次读操作，此时会读取行的最新版本（并加锁）。</p><p>​    实际上，如果能够正确的使用锁（避免不使用索引去加锁），只锁定需要的数据，用默认的RR级别就可以了。在我们使用锁的时候，有个问题时需要注意和避免的，我们知道，排他锁由互斥的特性。一个事务或者说一个线程持有锁时，会阻止其他的线程获取锁，这时会造成阻塞等待，如果训话等待，会有可能造成死锁。</p><h2 id="6-死锁"><a href="#6-死锁" class="headerlink" title="6 死锁"></a>6 死锁</h2><h3 id="6-1-锁的释放与阻塞"><a href="#6-1-锁的释放与阻塞" class="headerlink" title="6.1 锁的释放与阻塞"></a>6.1 锁的释放与阻塞</h3><p>​    锁是在事务结束（commit，rollback）或者客户端断开连接的时候释放。控制锁的等待时间，默认是50秒</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_lock_wait_timeout&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="6-2-死锁的发生与检测"><a href="#6-2-死锁的发生与检测" class="headerlink" title="6.2 死锁的发生与检测"></a>6.2 死锁的发生与检测</h3><p>​    在发生死锁时，InnoDB一般通过算法（wait-for graph）自动检测到。 死锁产生的条件：</p><p>​    （1）同一时刻只能有一个事务持有这把锁</p><p>​    （2）其他事务需要在这个事务释放锁之后才能获取锁，而不可以强行剥夺</p><p>​    （3）当多个事务形成等待环路的时候，即发生死锁。</p><p>​    实际上，发生死锁的原因很多，但是都满足以上3个条件这个也是表锁是不会发生死锁的原因，因为表锁的资源都是一次性获取的。</p><h3 id="6-3-查看锁信息（日志）"><a href="#6-3-查看锁信息（日志）" class="headerlink" title="6.3 查看锁信息（日志）"></a>6.3 查看锁信息（日志）</h3><p>首先，SHOW STATUS命令中，包括了一些行锁的信息。</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/15.png"></p><p>Show命令是一个概要信息。InnoDB还提供了三张表来分析事务与锁的情况：</p><p><img src="/image/mysql/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/16.png"></p><p>更加详细的锁信息，开启标准监控和锁监控：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> innodb_status_output<span class="hljs-operator">=</span><span class="hljs-keyword">ON</span>;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> innodb_status_output_locks<span class="hljs-operator">=</span><span class="hljs-keyword">ON</span>;<br></code></pre></td></tr></table></figure><p>​    如果一个事务长时间持有锁不释放，可以kill事务对应的线程ID，也就是INNODB_TRX表中的trx_mysql_thread_id。当然，死锁的问题不能每次都靠kill解决，我们应该尽量在编码的过程中避免。</p><h3 id="6-4-死锁的避免"><a href="#6-4-死锁的避免" class="headerlink" title="6.4 死锁的避免"></a>6.4 死锁的避免</h3><p>​    （1）在程序中，操作多张表时，尽量以相同的顺序来访问（避免形成等待环路）</p><p>​    （2）批量操作单张表数据时，先对数据进行排序（避免形成等待环路）</p><p>​    （3）申请足够级别的锁，如果要操作数据，就申请排他锁</p><p>​    （4）尽量使用索引访问数据，避免没有where条件的操作，避免锁表</p><p>​    （5）如果可以，大事务化成小事务</p><p>​    （6）使用等值查询而不是范围查询查询数据，命中记录，避免间隙锁对并发的影响。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引</title>
    <link href="/2023/02/16/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E7%B4%A2%E5%BC%95/"/>
    <url>/2023/02/16/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-索引含义"><a href="#1-索引含义" class="headerlink" title="1.索引含义"></a>1.索引含义</h2><h3 id="1-1-索引图解"><a href="#1-1-索引图解" class="headerlink" title="1.1 索引图解"></a>1.1 索引图解</h3><p>​    数据库索引是数据库管理系统（DBMS）中一个排序的数据结构，以协助快速查询，更新数据库表中数据。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/1.png"></p><p>​    数据是以文件的形式存放在磁盘上面的，每一行数据都有它的磁盘地址。如果没有索引的话，我们要从500万行数据里面检索一条数据，只能一次遍历这张表的全部数据，直到找到这条数据。但是有了索引后，只需要在索引中去检索这条数据就行了，因为它是一种特殊的专门用来快速检索的数据结构，我们找到数据存放的磁盘地址，就可以拿到数据了。</p><h3 id="1-2-索引类型"><a href="#1-2-索引类型" class="headerlink" title="1.2 索引类型"></a>1.2 索引类型</h3><p>​    打开navicat工具，右键设计表，在索引的这个选项卡里面，可以创建索引。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/2.png"></p><p>​    在InnoDB中，索引类型有三种：普通索引，唯一索引（主键索引是特殊的唯一索引），全文索引。</p><p>​    <em>普通（Normal）</em>：也叫非唯一索引，是最普通的索引，没有任何限制。</p><p>​    <em>唯一（Unique）</em>：唯一索引要求键值不能重复，另外注意的是，主键索引是一种特殊的唯一索引，它还多了一个限制条件是键值不能为空。主键索引引用primary key创建。</p><p>​    <em>全文（Fulltext）</em>：针对比较大的数据，比如我们存放的是消息内容，一篇文章，有几KB的数据的这种情况，如果要解决like查询在全文匹配时效率低的问题，可以创建全文索引。只有文本类型的字段才可以创建全文索引，比如char，varchar，text。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;fulltext_test&#x27;</span> (<br><span class="hljs-string">&#x27;content&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>    FULLTEXT KEY <span class="hljs-string">&#x27;content&#x27;</span>(<span class="hljs-string">&#x27;content&#x27;</span>)<br>)<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> fulltext_test <span class="hljs-keyword">where</span> <span class="hljs-keyword">match</span>(content) against(<span class="hljs-string">&#x27;咕泡学院&#x27;</span><span class="hljs-keyword">IN</span> <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">LANGUAGE</span> MODE)<br></code></pre></td></tr></table></figure><p>​    MyISAM和InnoDB支持全文索引。</p><h2 id="2-索引存储模型推演"><a href="#2-索引存储模型推演" class="headerlink" title="2. 索引存储模型推演"></a>2. 索引存储模型推演</h2><h3 id="2-1-二分查找（折半查找）"><a href="#2-1-二分查找（折半查找）" class="headerlink" title="2.1 二分查找（折半查找）"></a>2.1 二分查找（折半查找）</h3><p>​    每一次查找，都把候选数据缩小了一半，如果数据排过序的话，这种效率更高。所以第一个，我们可以考虑用有序数组作为索引的数据结构。有序数组的等值查询和比较查询效率非常高，但是更新数据时会出现一个问题，可能要挪动大量的数据（改变index），所以只适合存储静态的数据。为了支持频繁的修改，我们需要采用链表。链表的话，如果是单链表，它的查找效率还是不够高。所以为了解决这个问题出现二叉查找树BST（Binary Search Tree）出现了。</p><h3 id="2-2-二叉查找树"><a href="#2-2-二叉查找树" class="headerlink" title="2.2 二叉查找树"></a>2.2 二叉查找树</h3><p>​    二叉查找树的特点：左子树节点都小于父节点，右子树节点都大于父节点。投影到平面就是一个有序的线性表。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/3.png"></p><p>​    二叉查找树既能够实现快速查找，又能实现快速插入，但是它有个问题：它的查找耗时是和这棵树的深度相关的，在最坏的情况下时间复杂度会退化成O(n)。还是刚才这一批数字，如果插入的数据刚好是有序的，它就会变成链表（斜树），这种情况下不能达到加快检索速度的目的，和顺序查找效率是没有区别的。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/4.png"></p><h3 id="2-3-平衡二叉树-AVL-Tree-左旋右旋"><a href="#2-3-平衡二叉树-AVL-Tree-左旋右旋" class="headerlink" title="2.3 平衡二叉树(AVL Tree)(左旋右旋)"></a>2.3 平衡二叉树(AVL Tree)(左旋右旋)</h3><p>​    平衡二叉树解决了二叉树平衡的问题。索引必须要存你建立的字段的值，叫做键值，比如id的值。还要存完整记录在磁盘上的地址。由于AVL是二叉树，所以还要额外的存储左右子树的指针。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/5.png"></p><p>如图：</p><p>第一个是索引的键值，比如我们在id上面创建了一个索引，我在用where id = 1的条件查询时就会找到索引里面的id的这个键值。</p><p>第二个是数据的磁盘地址，因为索引的作用就是去查找数据存放的地址。</p><p>第三个，因为是二叉树，它必须还要有左右子节点的引用，这样我们能才能找到下个子节点。</p><p>​    当用树的结构了存储索引时，访问一个节点就要和磁盘间发生一次io操作。InnoDB操作磁盘的最小单位是一页（或者叫一个数据块，大小是16K）。那么，一个树的结点必须设计成16K的大小，不然就会出现读不完或者读不够的情况。如果一个节点只存一个键值+数据+引用，可能只用了十几个或者几十个字节，远远达不到16K的容量。我们基于索引查找数据时，肯定是希望一次从磁盘中加载很多的数据到内存中，如果一个节点只存1个这样的单元，就需要读更多的节点，发生更多的IO。</p><p>怎么解决这个问题？第一，  让每个节点存储更多的数据。第二，  节点上的关键字的数量越多，我们的指针数也越多，也就是有更多的分叉（路数），因为分叉越多，树的深度就会减少（根节点是0）。这样树的样子就从高瘦变成矮胖了。这时，时就变成多叉（多路）。</p><h3 id="2-4-多路平衡查找树-B-Tree-分裂合并"><a href="#2-4-多路平衡查找树-B-Tree-分裂合并" class="headerlink" title="2.4 多路平衡查找树(B Tree)(分裂合并)"></a>2.4 多路平衡查找树(B Tree)(分裂合并)</h3><p>​    Balance Tree，跟AVL树一样，B树在节点上存储键值，数据地址，节点引用。它有一个特点：分叉数（路数）永远比关键字数多1，比如下面这棵树，每个节点存储两个关键字，那么就会有三个指针指向三个子节点。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/6.png"></p><p>B Tree的查找规则是什么样的？</p><p>比如要找15：因为15&lt;17，走左边；15&gt;12，走右边，在磁盘7里找到了15，只用了3次IO。</p><p>B Tree是怎样保持平衡的，和AVL有什么区别？</p><p>当路数为3时，我们插入3的时候，本来应该在第一个磁盘块，但是如果一个节点有三个关键字，意味着有4个指针，子节点就会变成4格，所以这个时候就需要分裂。把中间数据2提上去，把1和3变成2的子节点。如果删除节点，会有相反的合并的操作（注意这里的合并和分裂跟AVL中的左右旋是不一样的）。从这里可以看到，在更新索引时会有大量的索引结构的调整，所以解释我们不要在频繁更新的列上加索引，或者不要更新主键。</p><p>节点的分裂和合并，其实就是InnoDB页的分裂和合并。如果索引键值有序，写满一页接着开辟一个新的页，如果索引值无序，存储过程中造成大量的磁盘碎片，带来频繁的page分裂和合并。</p><h3 id="2-5-B-树-加强版多平衡查找树"><a href="#2-5-B-树-加强版多平衡查找树" class="headerlink" title="2.5 B+树(加强版多平衡查找树)"></a>2.5 B+树(加强版多平衡查找树)</h3><p>B+树的存储结构。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/7.png"></p><p>B+树的特点：</p><p>1.它的关键字的数量和路数时相等的</p><p>2.B+树的根节点和枝节点都不会存储数据，只有叶子节点才存储数据，搜索到关键字不会直接返回，会到最后一层的叶子节点才会返回数据。</p><p>3.B+树的每个叶子节点增加了一个指向相邻叶子节点的指针，它的最后一个数据会指向下一个叶子节点的第一个数据，形成了一个有序链表，方便范围查询。</p><p>总结一下，InnoDB的B+tree特性带来的优势：</p><ol><li><p>它是B Tree的变种，B Tree能解决的问题，它都能解决（每个节点存储更多的关键字；路数更多），</p></li><li><p>扫库，扫表能力强（如果我们要对全表进行扫描，只需要遍历叶子节点就可以了，不需要便利整课B+树拿数据）。</p></li><li><p>B+树的磁盘读写能力比B树更强（根节点不保存数据，所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多）。</p></li><li><p>排序能力更强（因为叶子节点有下一个数据区的指针，数据形成了链表）</p></li><li><p>效率更加稳定（B+tree永远只在叶子节点拿数据，所以IO次数时稳定的）。</p></li></ol><h3 id="2-6-为什么不用红黑树？"><a href="#2-6-为什么不用红黑树？" class="headerlink" title="2.6 为什么不用红黑树？"></a>2.6 为什么不用红黑树？</h3><p>红黑树也是BST树，但是不是严格平衡的，通过变色和旋转来保持平衡，必须满足5个约束：</p><ol><li><p>节点为红色或者黑色</p></li><li><p>根节点必须是黑色的</p></li><li><p>叶子节点都是黑色的null节点</p></li><li><p>红色节点的两个子节点都是黑色（不允许两个相邻的红色节点）。</p></li><li><p>从任意节点出发，到每个叶子节点的路径中包含相同数量的黑色节点。</p></li></ol><p>基于以上节点，可以推导出：从根节点到叶子节点的最长路径（红黑相同的路径）不大于最短路径（全部是黑色节点）的2倍。</p><p>为什么不用红黑树？1，只有两路。2，不够平衡。红黑树一般在内存里运用。</p><h3 id="2-7-Hash索引"><a href="#2-7-Hash索引" class="headerlink" title="2.7 Hash索引"></a>2.7 Hash索引</h3><p>HASH：以KV的形式检索数据，也就是说，它会根据字段生成哈希码和指针，指针指向数据。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/8.png"></p><p>Hash索引的特点：</p><ol><li><p>它的时间复杂度是O(1)，查询速度比较快。因为哈希索引里面的数据不是按顺序存放的，所以不能用于排序。</p></li><li><p>我们在查询数据时要根据键值计算哈希码，所以它只能支持等值查询，不支持范围查询。</p></li><li><p>如果字段重复值很多的时候，会出现大量的哈希冲突（采用拉链法解决）效率会降低。</p></li></ol><p>​    在InnoDB中，不能显示的创建一个哈希索引（所谓的支持哈希索引指的是AHI,自适应哈希，它是InnoDB自动为buffer pool中的热点页创建的索引）。Memory存储引擎中可以使用Hash索引。</p><h2 id="3-B-Tree的落地形式"><a href="#3-B-Tree的落地形式" class="headerlink" title="3  B+Tree的落地形式"></a>3  B+Tree的落地形式</h2><p>​    MySQL的数据都是文件形式存放在磁盘的，可以找到这个目录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;datadir&#x27;</span>;<br></code></pre></td></tr></table></figure><p>​    每个数据库都有一个目录，主要关注一下最长用的两个存储引擎，MyISAM和InnoDB的索引的实现。InnoDB的表有两个文件（.frm和.ibd），MyISAM的表有三个文件（.frm，.MYD, .MYI）。其中.frm是Mysql数据库中定义表结构的文件，每一种存储引擎都有。</p><h3 id="3-1-MyISAM"><a href="#3-1-MyISAM" class="headerlink" title="3.1 MyISAM"></a>3.1 MyISAM</h3><p>在MyISAM中有另外两个文件，数据和索引是两个独立的文件：</p><p>​    1.MYD文件，D代表数据，是一个数据文件。</p><p>​    2.MYI文件，I代表index，是索引文件，存放索引</p><p>​    MyISAM的B+Tree中，叶子节点存储的是数据文件对应的磁盘地址。从索引文件中找到键值后，会到数据文件中获取相应的数据记录。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/9.png"></p><p>​    在MyISAM中，其他索引也在MYI文件中，非主键索引跟主键索引存储和检索数据的方式是没有任何区别的，一样是在索引文件中找到磁盘地址，然后到数据文件中获取数据。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/10.png"></p><h3 id="3-2-InnoDB"><a href="#3-2-InnoDB" class="headerlink" title="3.2 InnoDB"></a>3.2 InnoDB</h3><p>​    在InnoDB的某个索引的叶子节点上，直接存储了我们的数据。所以，为什么说在InnoDB中索引即数据，数据即索引，就是这个原因。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/11.png"></p><p>​    但是有一个问题，一张InnoDB表可能有很多索引，数据肯定只有一份，那数据是在哪个索引的叶子节点上呢？</p><p>​    这里要介绍一个叫做聚集索引（聚簇索引）的概念，就是索引键值的逻辑顺序和表数据行的物理存储顺序是一致的。</p><p>​    InnoDB组织数据的方式就是（聚集）索引组织表（clustered index organize table）。如果说一张表创建了主键索引，那么这个主键索引就是聚集索引，决定数据行的物理存储顺序。</p><p>​    问题来了，那聚集索引之外的索引，会不会也把完整记录在叶子节点放一份呢？并不会，因为这回带来额外的存储空间浪费和计算损耗。那他们的叶子节点上没有数据怎么检索完整的数据呢？比如我们在name字段上建立的普通索引。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/12.png"></p><p>​    InnoDB中，主键索引和辅助索引是由一个主次之分的，如果有主键索引，那么主键索引就是聚集索引，其他的索引统称为“二级索引”（secondary index）。二级索引存储的是二级索引的键值，而叶子节点存的是这条记录对应的主键的值，所以，二级索引检索数据的流程是这样的：</p><p>​    当我们用name索引查询一条记录，它会在二级索引的叶子节点找到name=qingshan，拿到主键值，也就是id=1，然后再到主键索引的叶子节点拿到数据。</p><p>​    为什么不存地址而是存键值？因为地址会变化。从这个角度来说，因为主键索引比二级索引少扫描了一棵B+Tree（避免了回表），所以它的速度相对快一些。</p><p>​    但是，如果一张表没有主键怎么办？那完整的记录放在哪个索引的叶子节点？或者这张表根本没有索引呢？数据放在哪里？</p><p>​    1.如果我们定义了主键（primary key），那么InnoDB会选择主键作为聚集索引。</p><p>​    2.如果没有显示定义主键，则InnoDB会选择第一个不包含有null值得唯一索引作为主键索引。</p><p>​    3.如果也没有这样得一个唯一索引，InnoDB会选择内置6字节长得ROWID作为隐藏得聚集索引，它会随着行记录得写入而主键递增。</p><h2 id="4-索引使用原则"><a href="#4-索引使用原则" class="headerlink" title="4 索引使用原则"></a>4 索引使用原则</h2><h3 id="4-1-列的离散度"><a href="#4-1-列的离散度" class="headerlink" title="4.1 列的离散度"></a>4.1 列的离散度</h3><p>​    列的离散度，定义公式：count(distinct(column_name)):count(*)，列的全部不同值和所有数据行的比例，数据行相同的情况下，分子越大，列的离散度越高。简单来说，如果列的重复值越多，离散度度劫越低，重复值越多，离散度就越高。我们不建议在离散度低的字段上，如果B+Tree中的重复值太多，MySQL的优化器发现走索引跟使用全表扫描差不多，就算建立了索引，也不一定会走索引。</p><h3 id="4-2-联合索引最左匹配原则"><a href="#4-2-联合索引最左匹配原则" class="headerlink" title="4.2 联合索引最左匹配原则"></a>4.2 联合索引最左匹配原则</h3><p>​    前面都是针对单列创建的索引，但有时我们的多条件查询的时候，也会建立联合索引。单列索引也可以看作是特殊的联合索引。如果我们创建三个字段的联合索引index(a, b, c)，相当于创建了三个索引：index(a), index(a, b), index(a, b, c)；</p><h3 id="4-3-覆盖索引"><a href="#4-3-覆盖索引" class="headerlink" title="4.3 覆盖索引"></a>4.3 覆盖索引</h3><p>​    回表：非主键索引，我们先通过索引找到主键索引的键值，再通过主键值查出索引中没有的数据，它比基于主键索引的查询多扫描了一棵索引树，这个过程就叫回表。在二级索引中，不管单列索引还是联合索引，如果select的数据列只用从索引中就能取得，不必从数据区中读取，这时使用的索引叫做覆盖索引，这样避免了回表。很明显，因为覆盖索引减少了IO次数，减少了数据的访问量，可以大大提高查询效率。</p><h3 id="4-4-索引条件下推（ICP）"><a href="#4-4-索引条件下推（ICP）" class="headerlink" title="4.4 索引条件下推（ICP）"></a>4.4 索引条件下推（ICP）</h3><p>​    索引条件下推（index condition pushdown），5.6后完善的功能。只适用于二级索引。ICP的目标是减少访问表的完整行的读数量从而减少IO操作。这里说的下推，其实意思是把过滤的动作在存储引擎做完，而不需要到Server层过滤。来看这么一张表。在last_name和first_name上面创建联合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> employees;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;employees&#x27;</span> (<br><span class="hljs-string">&#x27;emp_no&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-string">&#x27;birth_date&#x27;</span> <span class="hljs-type">date</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-string">&#x27;first_name&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">14</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-string">&#x27;last_name&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-string">&#x27;gender&#x27;</span> enum(<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-string">&#x27;hire_date&#x27;</span> <span class="hljs-type">date</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">primary</span> key (<span class="hljs-string">&#x27;emp_no&#x27;</span>)<br>) engine<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>latinl;<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> employees <span class="hljs-keyword">add</span> index idx_lastname_firstname(last_name,first_name);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;689&#x27;</span>,<span class="hljs-string">&#x27;liu&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;431&#x27;</span>,<span class="hljs-string">&#x27;afdu&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;3424&#x27;</span>,<span class="hljs-string">&#x27;fdasfng&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;41z&#x27;</span>,<span class="hljs-string">&#x27;fdasfg&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">5</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;41zz&#x27;</span>,<span class="hljs-string">&#x27;wfdasf&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">6</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;41zz&#x27;</span>,<span class="hljs-string">&#x27;wang&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">7</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;41zz&#x27;</span>,<span class="hljs-string">&#x27;wang&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">8</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;41zzi&#x27;</span>,<span class="hljs-string">&#x27;wang&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">9</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;41zi&#x27;</span>,<span class="hljs-string">&#x27;gda&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;employees&#x27;</span>(<span class="hljs-string">&#x27;emp_no&#x27;</span>,<span class="hljs-string">&#x27;birth_date&#x27;</span>,<span class="hljs-string">&#x27;first_name&#x27;</span>,<span class="hljs-string">&#x27;last_name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;hire_date&#x27;</span>) <span class="hljs-keyword">values</span>(<span class="hljs-number">10</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;4i&#x27;</span>,<span class="hljs-string">&#x27;qafd&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure><p>现在查询所有姓wang，并且最后一字是zi的员工。查询的sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> last_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;wang&#x27;</span> <span class="hljs-keyword">and</span> last_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;%zi&#x27;</span>;<br></code></pre></td></tr></table></figure><p>​    正常来说，因为字符是从左往右排序的，当你把%加在前面时，是不能基于索引去比较的，所以只有last_name这个字段能够用于索引比较和过滤。所以查询过程是这样的：</p><p>​    1）根据联合索引查出所有姓wang的二级索引数据（3个主键6，7，8）</p><p>​    2）回表，到主键索引上查询全部符合条件的数据（3条数据）</p><p>​    3）把这3台哦数据返回到Server层，在Server层过滤出名字以zi结尾的员工。</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/13.png"></p><p>​    注意，索引的比较是在存储引擎中进行的，数据记录的比较是在Server中进行的。而当first_name的条件不能用于索引过滤时，Server层不会把first_name的条件传递给存储引擎，所以读取了两条没用的记录。这时，如果满足last_name=‘wang’的记录有10万条，就会有99999条没有必要读取的记录。所以，根据first_name字段过过滤的动作，能不能再存储引擎层完成呢？这是第二种查询方法：</p><p>​    1）根据联合索引查出所有姓wang的二级索引数据（3个主键值6，7，8）</p><p>​    2）然后从二级索引中筛选出first_name以zi结尾的索引（1个索引）</p><p>​    3）然后再回表，到主键索引上查询全部符合条件的数据（1条数据），返回给server层</p><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/14.png"></p><p>​    很明显，第二种方法到主键索引上查询的数据更少。 ICP时默认开启的，也就是说针对二级索引，只要能够把条件下推给存储引擎，它就会下推，不需要我们干预：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> optimizer_switch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;index_condition_pushdown=on&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/15.png"></p><p>关闭ICP：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> optimizer_switch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;index_condition_pushdown=off&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/image/mysql/mysql%E7%B4%A2%E5%BC%95/16.png"></p><p>Using where代表从存储引擎返回的数据不全部满足条件，需要再server层过滤。</p><h2 id="5-索引的创建和使用"><a href="#5-索引的创建和使用" class="headerlink" title="5  索引的创建和使用"></a>5  索引的创建和使用</h2><h3 id="5-1-索引的创建"><a href="#5-1-索引的创建" class="headerlink" title="5.1 索引的创建"></a>5.1 索引的创建</h3><ol><li><p>在用于where判断order排序和join的（on），group by的字段上创建索引</p></li><li><p>索引的个数不要太多 —-浪费空间，更新变慢</p></li><li><p>过长的字段，建立前缀索引</p></li><li><p>区分度低的字段，例如性别，不要建立索引 —-离散度太低，导致扫描行数过多</p></li><li><p>频繁更新的值，不要作为主键或者索引  ——页分裂</p></li><li><p>随机无序的值，不建议建立索引，例如身份证，UUID</p></li><li><p>组合索引把离散度高的值放在前面</p></li><li><p>创建复合索引，而不是修改单列索引</p></li></ol><h3 id="5-2-索引失效的情况"><a href="#5-2-索引失效的情况" class="headerlink" title="5.2 索引失效的情况"></a>5.2 索引失效的情况</h3><ol><li><p>在索引列上使用函数，表达式</p></li><li><p>字符串不加引号，出现隐式转换</p></li><li><p>Like条件中前面带%</p></li><li><p>负向查询: NOT LIKE不能；！=  （&lt;&gt;）和not in某些情况下可以</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> emp_no <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span>(<span class="hljs-number">1</span>)<br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> emp_no <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ol><p>​    这个例子中，因为索引是有序的，只要从1之后开始顺序读取就行了。其实，用不用索引，最终都是优化器说了算。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL执行流程</title>
    <link href="/2023/02/15/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/02/15/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-查询SQL的执行流程"><a href="#1-查询SQL的执行流程" class="headerlink" title="1.查询SQL的执行流程"></a>1.查询SQL的执行流程</h2><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/1.png"></p><h3 id="1-1-连接"><a href="#1-1-连接" class="headerlink" title="1.1 连接"></a>1.1 连接</h3><p>​    MySQL的服务器监听端口默认时3306，客户端连接服务端的方式有很多。可以是同步的也可以是异步的，可以是长连接也可以是短连接，可以是TCP也可以是Unix Socket，MySQL有专门处理连接的模块，连接的时候需要验证权限。查看当前的连接数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;Thread%&#x27;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>Threads_cached</td><td>缓存中的线程连接数</td></tr><tr><td>Threads_connected</td><td>当前打开的连接数</td></tr><tr><td>Threads_created</td><td>未处理连接创建的线程数</td></tr><tr><td>Threads_running</td><td>非睡眠状态的连接数，通常指并发连接数</td></tr></tbody></table><p>​    客户端每产生一个连接或者一个会话，在服务端就会创建一个线程来处理。反过来，如果杀死会话，就是kill进程。既然分配进程的话，保持连接肯定会消耗服务端的资源。MySQL会把哪些长时间不活动的（sleep）连接自动断开。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;wait_timeour&#x27;</span>; <span class="hljs-comment">--非交互式超时时间，如JDBC程序</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;interactive_timeout&#x27;</span>; <span class="hljs-comment">--交互式超时时间，如数据库工具</span><br></code></pre></td></tr></table></figure><p>​    默认都是28800秒，8小时。查看mysql服务的最大连接数：5.7版本中默认是151，最大可设置成100000。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘max_connections’；<br></code></pre></td></tr></table></figure><p>​    <strong>参数级别说明：</strong></p><p>​    MySQL中的参数（变量）分为session和global级别，分别是在当前会话中生效和全局生效，但是并不是每个参数都有两个几倍，比如max_connections就只有全局级别。当没有带参数的时候，默认是session级别，包括查询和修改。比如修改了一个参数以后，在本窗口已经生效，但是其他窗口不生效：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;autocommit&#x27;</span>;<br><span class="hljs-keyword">set</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-keyword">on</span>;<br></code></pre></td></tr></table></figure><p>​    所以，如果只是临时修改，建议修改session级别。如果需要在其他会话中生效，必须显示的加上global参数。</p><h3 id="1-2-查询缓存"><a href="#1-2-查询缓存" class="headerlink" title="1.2 查询缓存"></a>1.2 查询缓存</h3><p>​    MySQL内部自带了一个缓存模块。但是MySQL的缓存默认是关闭的。在MySQL8.0中，查询缓存已经被移除了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;query_cache%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>​    默认关闭的意思是不推荐使用，因为MySQL自带的缓存的应用场景有限：第一个是它要求SQL语句必须一模一样，中间多一个空格，字母大小写都被认为是不同的SQL；第二个是表里面任何一条数据发生变化时，这张表所有缓存都会失效，所以对于大量数据更新的应用，也不适合。所以缓存这一块，我们还是交给orm框架（比如mybatis默认开启了一级缓存），或者独立的缓存服务，比如Redis来处理更合适。</p><h3 id="1-3-语法解析和预处理-Parser-amp-Preprocessor"><a href="#1-3-语法解析和预处理-Parser-amp-Preprocessor" class="headerlink" title="1.3 语法解析和预处理(Parser &amp; Preprocessor)"></a>1.3 语法解析和预处理(Parser &amp; Preprocessor)</h3><p>​    对语句基于SQL语法进行词法分析，语法分析和语义的解析。</p><h4 id="1-3-1-词法解析"><a href="#1-3-1-词法解析" class="headerlink" title="1.3.1 词法解析"></a>1.3.1 词法解析</h4><p>​    词法解析就是把一个完整的SQL语句打碎成一个个的单词</p><h4 id="1-3-2-语法解析"><a href="#1-3-2-语法解析" class="headerlink" title="1.3.2 语法解析"></a>1.3.2 语法解析</h4><p>​    语法解析会对SQL做一语法检查，比如单引号有没有闭合，然后根据MySQL定义的语法规则，根据SQL语句生成一个数据结构，这个数据结构我们把它叫做解析树（select_lex）。</p><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/2.png"></p><p>​    词法语法分析是一个非常基础的功能，java的编译器，百度搜索引擎如果要识别语句，必须也要有词法语法分析功能。任何数据库的中间件，要解析SQL完成路由功能，也必须要有词法语法功能，比如Mycat，Sharding-JDBC（用到了Druid Parser）。在市面上也有很多的开源的词法解析的工具（比如LEX，Yacc）。</p><h4 id="1-3-3-预处理器"><a href="#1-3-3-预处理器" class="headerlink" title="1.3.3 预处理器"></a>1.3.3 预处理器</h4><p>​    预处理器会检查生成的解析树，解决解析器无法解析的语义。比如它会检查表和列名是否存在，检查名字和别名，保证没有歧义。预处理后得到一个新的解析树。</p><h3 id="1-4-查询优化与查询执行计划"><a href="#1-4-查询优化与查询执行计划" class="headerlink" title="1.4 查询优化与查询执行计划"></a>1.4 查询优化与查询执行计划</h3><p>​    一条SQL语句是可以有很多执行方式的，最终返回相同的结果，他们是等价的。选择哪种执行方式就是由MySQL的查询优化器的模块（Optimizer）。查询优化器的目的是根据解析树生成不同的执行计划（Execution Plan），然后选择一种最优的执行计划，MySQL中使用的是基于开销（cost）的优化器，哪种执行计划开销最小，就用哪种。查看查询的开销：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> ‘Last_query_cost’;<br></code></pre></td></tr></table></figure><p>​    优化的细节可以查看《数据库查询优化器的艺术-原理解析与SQL性能优化》。优化器最终会把解析树变成一个查询执行计划，查询执行计划是一个数据结构。MySQL提供了一个执行计划的工具，我们在SQL语句前面加上explain，就可以看到执行计划的信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">select</span> name <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>​    如果要得到详细的信息，还可以用format=json，或者开启optimizer trace。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN FORMAT<span class="hljs-operator">=</span>JSON <span class="hljs-keyword">where</span> name <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="1-5-存储引擎"><a href="#1-5-存储引擎" class="headerlink" title="1.5 存储引擎"></a>1.5 存储引擎</h3><p>​    查看数据库存放数据的路径</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;datastr&#x27;</span>;<br></code></pre></td></tr></table></figure><p>​    默认情况下，每个数据库都有自己的一个文件夹。任何一个存储引擎都有一个frm文件，这是表结构定义文件。不同的存储引擎存放数据的方式不一样， 产生的问价也不一样，innodb是1个，memory没有，myisam是两个。</p><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/3.png"></p><h4 id="1-5-1-存储引擎的选择"><a href="#1-5-1-存储引擎的选择" class="headerlink" title="1.5.1 存储引擎的选择"></a>1.5.1 存储引擎的选择</h4><p>​    一张表的存储引擎，是在创建表的时候指定的，使用ENGINE关键字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;user_innodb&#x27;</span>(<br><span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    PRIMARY_KEY(<span class="hljs-string">&#x27;id&#x27;</span>),<br>    KEY <span class="hljs-string">&#x27;comidx_name&#x27;</span> (<span class="hljs-string">&#x27;name&#x27;</span>)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>urf8mb4;<br></code></pre></td></tr></table></figure><p>​    没有指定的话，数据库就会使用默认的存储引擎，5.5.5之前，默认的是myisam。5.5.5之后默认的是innodb。不同的业务需求对应相应的存储引擎。</p><h4 id="1-5-2-存储引擎的比较"><a href="#1-5-2-存储引擎的比较" class="headerlink" title="1.5.2 存储引擎的比较"></a>1.5.2 存储引擎的比较</h4><p>​    常见的存储引擎：<a href="https://dev.mysql.com/doc/refman/5.7/en/storage-engines.html">https://dev.mysql.com/doc/refman/5.7/en/storage-engines.html</a></p><p>​    <strong>MyISAM（3个文件）</strong></p><p>​    应用范围比较小。表级锁限制了读/写的性能，因此在web和数据仓库配置中，它通常用于只读或以读为主的工作。</p><p>​    特点：</p><p>​                1.支持表级别的锁（插入或更新会锁表）。不支持事务。</p><p>​                2.拥有较高的插入（insert）和查询（select）速度。</p><p>​                3.存储了表的行数（count速度更快）。</p><p>​    （怎么快速向数据库中插入100万条数据？我们有一种先用myisam插入数据，然后修改存储引擎为innodb的操作）</p><p>​    适合：只读之类的数据分析项目</p><p><strong>InnoDB（2个文件）</strong></p><p>​    MySQL5.7中默认的存储引擎。InnoDB是一个事务安全（与ACID兼容）的MySQL存储引擎，它具有提交，回滚和奔溃回复功能来保护用户数据。InnoDB行级锁（不升级为更粗粒度的锁）和Oracle风格的一致非锁读提高了多用户并发性和性能。InnoDB将用户数据存储在聚集索引中，以减少基于主键的常见查询的I/O。为了保持数据的完整性，InnoDB还支持外键引用完整性约束。</p><p>​    特点：</p><p>​        1.支持事务，支持外键，因此数据的玩成型，一致性更高。</p><p>​        2.支持行级锁和表级锁</p><p>​        3.支持读写并发，写不阻塞读（MVCC）</p><p>​        4.特殊的索引存放方式，可以减少IO，提升查询效率。</p><p>​    适合：经常更新的表，存在并发读写或者由事务处理的业务系统。</p><p>​    <strong>Memory（1个文件）</strong></p><p>​    将所有数据存储在RAM中，以便在需要快速查找非关键性数据的环境中快速访问。这个引擎以前被称为堆引擎。其使用案例正在减少；InnoDB及其缓存池内存区域提供了一种通用，持久的方法来将大部分或所有数据保存在内存中，而ndbcluster为大型分布式数据提供了快速的键值查找。</p><p>​    特点：把数据放在内存里面，读写速度很快。但是数据库重启或者奔溃，数据会全部消失，只适合做临时表。将表中的数据存储到内存中。</p><p>​    <strong>CSV（3个文件）</strong></p><p>​    它的表实际上是带有逗号分隔值的文本文件。Csv表允许以csv格式导入或转储数据，以便与读写相同格式的脚本和应用程序交换数据，因为csv表没有索引，所以通常在正常操作期间将数据保存在innodb中，并且只在导入或导出阶段使用csv表。</p><p>​    特点：不允许空行，不支持索引。格式通用，可以直接编辑。</p><p>​    适合：在不同数据库之间导入导出。</p><p><strong>Archive（2个文件）</strong></p><p>​    这些紧凑的未索引的表用于存储和检索大量很少引用的历史，存档或安全审计信息。</p><p>​    特点：不支持索引，不支持update delete。</p><p>​    这些是mysql中常见的一些存储引擎，不同的存储引擎提供的特性都不一样，它们由不同的存储机制。索引方式，锁定水平等功能。我们在不同的业务场景中对数据操作的要求不同，就可以选择不同的存储引擎来满足我们的需求。</p><h4 id="1-5-3-如何选择存储引擎"><a href="#1-5-3-如何选择存储引擎" class="headerlink" title="1.5.3 如何选择存储引擎"></a>1.5.3 如何选择存储引擎</h4><p>​    InnoDB：对数据一致性要求比较高，需要事务支持。</p><p>​    MyIsam：数据查询多更新少，对查询性能要求比较高。</p><p>​    Memory：需要一个用于查询的临时表。</p><p>​    还可以根据官网内部手册使用C语言开发一个存储引擎。所有的存储引擎都遵循了一定的规范，提供了相同的接口。</p><h3 id="1-6-执行引擎"><a href="#1-6-执行引擎" class="headerlink" title="1.6 执行引擎"></a>1.6 执行引擎</h3><p>​    它利用存储引擎提供相应的api来完成操作，不同功能的存储引擎实现的api是相同的。最后把数据返回给客户端。</p><h2 id="2-更新SQL执行流程"><a href="#2-更新SQL执行流程" class="headerlink" title="2. 更新SQL执行流程"></a>2. 更新SQL执行流程</h2><p>​    在数据库里，我们说的update操作其实包括了更新，插入和删除。MyBatis的源码中Executor里面只有doQuery()和doUpdate()方法，没有doDelete()和doInsert()。它和查询的基本流程是一致的，也就是说，它也要经过解析器，优化器得处理，最后交给执行器。区别在于拿到符合条件得数据之后的操作。</p><h3 id="2-1-Buffer-Pool-缓冲池"><a href="#2-1-Buffer-Pool-缓冲池" class="headerlink" title="2.1 Buffer Pool(缓冲池)"></a>2.1 Buffer Pool(缓冲池)</h3><p>​    首先，对于InnoDB存储引擎来说，数据都是放在磁盘上得，存储引擎要操作数据。必须先把磁盘里面的数据加载到内存中才能操作。这里有个问题，是不是我们需要的数据多大，我们就一次从磁盘加载多少数据到内存呢?比如我要读6个字节。</p><p>​    磁盘I/O的读写相对于内存的操作来说是很慢的。如果我们需要的数据分散在磁盘的不同的地方，那就意味着回产生很多次的I/O操作。所以，无论是操作系统也好，还是存储引擎也好，都有一个预读取的概念，也就是说，当磁盘上的一块区域被读取时，很有可能它附近的位置也回马上被读取到，这个就叫做局部性远离了，那么这样，我们干脆每次多读一些，而不是用多少都多少。</p><p>​    InnoDB设定了一个存储引擎从磁盘读取数据带内存的最小单位，叫做页。操作系统也有页的概念。操作系统的页一般是4k，而Innodb中最小的单位默认是16K。如果要修改这个值的大小，需要清空数据重新初始化服务。</p><p>​    还有一个问题，操作数据的时候，每次都要从磁盘读取到内存（再返回给Server），有没有什么办法可以提高效率？还是缓存的思想，把读取过来的数据页缓存起来。</p><p>​    InnoDB设计了一个内存的缓冲区，读取数据的时候，先判断是不是在这个内存区域里面，如果是，就直接读取，然后操作。不用再次从磁盘中加载。如果不是，读取后就写到这个内存的缓冲区。这个区域就叫Buffer Pool。</p><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/4.png"></p><p>​    修改数据的时候，也是先写入到buffer pool中，而不是直接写到磁盘。内存的数据页个磁盘数据不一致的时候，我们就叫它为脏页。InnoDB中有专门的后台线程把Buffer Pool的数据写入到磁盘，每个一段时间就一次性的把多个修改写入磁盘，这个动作叫做刷脏。</p><p>​    总结一下：Buffer Pool的作用是为了提高读写效率。</p><h3 id="2-2-Redo-Log"><a href="#2-2-Redo-Log" class="headerlink" title="2.2 Redo Log"></a>2.2 Redo Log</h3><p>​    因为刷脏不是实时的，如果Buffer Pool里面的脏页还没有刷入磁盘时，数据库宕机或者重启，这些数据就会丢失。所以内存必须要有一个持久化的措施。为了避免这个问题，InnoDB把对所有页面的修改操作专门写入一个日志文件。如果有未同步到磁盘的数据，数据库在启动的时候，回从这个日志文件进行恢复操作（实现Crash-safe）。我们说的事务的ACID中的D（持久性），就是用它来实现的。</p><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/5.png"></p><p>​    这个日志文件就是磁盘的redo log（重做日志）。 那么写日志文件和写到数据文件有什么区别？</p><p>​    我们说一下磁盘寻址的过程。这个是磁盘的构造。磁盘的盘片不停的旋转，磁头会在磁盘表面画出一个圆形轨迹，这个就叫做磁道。从内到外半径不同有很多磁道。然后又用半径线，把磁道分割成了扇区（两根射线之内的扇区组成扇面）。如果要读写数据，必须找到数据对应的扇区，这个过程就叫寻址。</p><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/6.png"></p><p>​    如果我们所需要的数据是随机分散在磁盘上不同页的不同扇区中，那么找到相应的数据需要等到磁臂旋转到指定的页，然后盘片寻找到对应的扇区，才能找到我们能所需要的一块数据，一次进行此过程知道找完所有数据。这个就是随机IO，读取数据速度较慢。</p><p>​    假设我们已经找到了第一块数据，并且其他所需的数据就在这块数据后边，那么就不需要重新寻址，可以依次拿到我们所需的数据，这个就叫顺序IO。 刷盘是随机IO，而记录日志是顺序IO，顺序IO效率更高，本质上是数据集中存储和分散存储的区别。因此先把修改写入日志文件，在保证了内存数据的安全性的情况下，可以延迟刷盘时机，进而提高系统吞吐。</p><p>​    Redo log位于/var/lib/mysql目录下的ib_logfile0和ib_logfile1，默认2个文件，每个48M。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_log%&#x27;</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>innodb_log_file_size</td><td>指定每个文件的大小，默认48M</td></tr><tr><td>innodb_log_files_in_group</td><td>指定文件的数量，默认为2</td></tr><tr><td>innodb_log_group_home_dir</td><td>指定文件所在路径，相对或绝对。如果不指定，则为datadir路径</td></tr></tbody></table><p> redo log特点？</p><ol><li><p>redo log是Innodb存储引擎实现的，并不是所有存储引擎都有。支持奔溃恢复是Innodb的一个特性。</p></li><li><p>redo log不是记录数据页更新之后的状态，而是记录的是“在某个数据也上做了什么修改”。属于物理日志。</p></li><li><p>redo log的大小是固定的，前面的内容会被覆盖，一旦写满，就会触发buffer pool到磁盘的同步，以便腾出空间记录后面的修改。</p></li></ol><p>除了redo log之外，还有一个跟修改有关的日志，叫做undo log，这两个日志和事务密切相关，统称为事务日志。</p><h3 id="2-3-Undo-Log"><a href="#2-3-Undo-Log" class="headerlink" title="2.3 Undo Log"></a>2.3 Undo Log</h3><p>​    Undo log（撤销日志或回滚日志）记录了事务发生之前的数据状态，分为insert undo log和update undo log。如果修改数据时出现异常，可以用undo log来实现回滚操作（保持原子性）。可以理解为undo log记录的是反向操作，比如insert会记录delete，update会记录update原来的值，跟redo log记录在哪个物理页做了什么操作不同，所以叫逻辑格式的日志。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>innodb_undo_directory</td><td>undo文件的路径</td></tr><tr><td>innodb_undo_log_truncate</td><td>设置为1，即开启在线回收(收缩)undo log日志文件</td></tr><tr><td>innodb_max_undo_log_size</td><td>如果innodb_undo_log_truncate设置为1，超过这个大小的时候会触发truncate回收的动作，如果page大小是16KB，truncate后空间缩小到10M，默认1073741824字节=1G</td></tr><tr><td>innodb_undo_logs</td><td>回滚段的数量，默认128，这个参数已经过时</td></tr><tr><td>innodb_undo_tablespaces</td><td>设置undo独立表空间个数，范围为0-95，默认为0，0表示不开启独立undo表空间，且undo日志存储在ibdata文件中，这个参数已经过时</td></tr></tbody></table><h3 id="2-4-更新过程"><a href="#2-4-更新过程" class="headerlink" title="2.4 更新过程"></a>2.4 更新过程</h3><p>有了这些日志之后，总结一下更新操作的流程。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;penyuyan&#x27;</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>1、 事务开始，从内存（buffer pool）或磁盘（data file）取到包含这条数据的数据页，返回给server的执行器</p><p>2、 Server的执行器修改数据页的这一行数据的值为penyuyan</p><p>3、 记录name=qingshan到undo log</p><p>4、 记录name=penyuyan到redo log</p><p>5、 调用存储引擎接口，记录数据页到buffer pool（修改name=penyuyan）</p><p>6、 事务提交</p><h3 id="2-5-Bin-log"><a href="#2-5-Bin-log" class="headerlink" title="2.5 Bin log"></a>2.5 Bin log</h3><p>​    Binlog以事件的形式记录了所有的ddl和dml语句（因为它记录的是操作而不是数据值，属于逻辑日志），可以用来做主从复制和数据恢复。跟redo log不同，它的文件内容是可以追加的，没有固定大小限制。在开启了binlog功能的情况下，我们可以把binlog导出成sql语句。把所有的操作重放一遍，来实现数据的恢复。Binlog的另一个功能就是用来实现主从复制，它的原理就是从服务器读取主服务器的binlog，然后再执行一遍。配置方式和主从复制的实现原理再Mycat第二节课中有讲述。有了这两个日志之后，一条更新语句是怎么执行的（redo不能一次写入了）</p><p><img src="/image/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/7.png"></p><p>例如一条语句：update teacher set name = ‘penyuyan’ where id = 1;</p><p>​    1.先查询到这条语句，如果有缓存，也会用到缓存</p><p>​    2.把name改成pengyuyan，然后调用引擎的API接口，写入这一行数据到内存，同时记录redo log。 这时redo log进入prepare状态，然后告诉执行器，执行完成了，可以随时提交</p><p>​    3.执行器收到通知后记录binlog，然后条用存储引擎接口，设置redo log为commit状态。</p><p>​    4.更新完成。</p><p>这张图片的重点：</p><p>​    1.先记录到内存，再写日志文件。</p><p>​    2.记录redo log分为两个阶段</p><p>​    3.存储引擎和Server记录不同的日志</p><p>​    4.先记录redo，再记录binlog</p><p>为什么需要两阶段提交：</p><p>举例：如果我们执行的是把name改成penyuyan，如果写完redo log，还没有写binlog的时候，MySQL重启了。因为redo log可以在重启时用于数据恢复，所以写入磁盘的是pengyuyan。但是binlog中没有记录这个逻辑日志，所以这时候用binlog去恢复数据或者同步到从库，就会出现数据不一致的情况。所以在写两个日志的情况下，binlog就充当了一个事务的协调者。通知InnoDB来执行prepare或者commit或者rollback。如果写入binlog失败，就不会提交。简单地说，这里有两个写日志的操作，类似于分布式事务，不同两阶段提交，就不能保证都成功或者都失败。</p><p>在奔溃恢复时，判断事务是否需要提交：</p><p>1.binlog无记录，redolog无记录：在redolog写之前crash，恢复操作，回滚事务。</p><p>2.binlog无记录，redolog状态prepare：在binlog写完之前crash，恢复操作，回滚事务。</p><p>3.binlog有记录，redolog状态prepare：在binlog写完提交事务之前crash，恢复操作，提交事务。</p><p>4.binlog有记录，redolog状态commit：正常完成事务，不需要恢复。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL架构</title>
    <link href="/2023/02/09/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/02/09/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/MySQL%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>​    总体上，我们可以把mysql分成三层，跟客户端对接的连接层，真正执行操作的服务层，和硬件打交道的存储引擎层。</p><p><img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%871.png"></p><h2 id="1-连接层"><a href="#1-连接层" class="headerlink" title="1.连接层"></a>1.连接层</h2><p>​    客户端要连接到mysql服务器的3306端口，必须要跟服务器端建立连接，那么管理所有的连接，验证客户端的身份和权限，这些功能就在连接层完成。</p><h2 id="2-服务层"><a href="#2-服务层" class="headerlink" title="2.服务层"></a>2.服务层</h2><p>​    连接层会把SQL语句交给服务层，这里面又包含一系列流程：比如查询缓存的判断，根据SQL调用相应的接口，对我们的SQL语句进行次发和语法的解析，比如关键字怎么识别，语法有没有错误等等。</p><p>​    然后就是优化器，MySQL底层回根据一定的规则对我们的SQL语句进行优化，最后再交给执行器去执行。</p><h2 id="3-存储引擎"><a href="#3-存储引擎" class="headerlink" title="3.存储引擎"></a>3.存储引擎</h2><p>​    存储引擎就是我们的数据真正存放的地方，在MySQL里面支持不同的存储引擎。</p><p>​    再往下就是内存或者磁盘，具体请查看查询sql执行流程。</p><h2 id="4-InnoDB总体架构"><a href="#4-InnoDB总体架构" class="headerlink" title="4.InnoDB总体架构"></a>4.InnoDB总体架构</h2><p><img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%872.png"></p><h3 id="4-1-内存结构"><a href="#4-1-内存结构" class="headerlink" title="4.1 内存结构"></a>4.1 内存结构</h3><p>​    主要分为三个部分：Buffer Pool，Change Buffer，Adaptive Hash Index，（redo）log buffer。</p><h4 id="4-1-1-Buffer-pool"><a href="#4-1-1-Buffer-pool" class="headerlink" title="4.1.1 Buffer pool"></a>4.1.1 Buffer pool</h4><p>​    Buffer pool缓存的是页面信息，包括数据页，索引页。默认大小是128M（134217728字节），可以调整。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_buffer_pool<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>​    InnoDB用LRU算法来管理缓存池（链表实现，不是传统的LRU，分成了young和old），经过淘汰的数据就是热点数据。</p><h4 id="4-1-2-LRU算法"><a href="#4-1-2-LRU算法" class="headerlink" title="4.1.2 LRU算法"></a>4.1.2 LRU算法</h4><p>​    传统的LRU可以用Map+链表实现，value存的是在链表中的地址。</p><p><img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%873.png"></p><p>​    innodb中确实使用了一个双向链表，LRU list，但是这个list放的不是data page，而是指向缓存页的指针。如果写buffer pool的时候发现没有空闲页了，就要从buffer pool中淘汰数据页了，要根据LRU链表的数据来操作。</p><p>​    首先，innodb的数据页并不都是在访问的时候才缓存到buffer pool的，innodb由一个预读机制（read ahead），也就是说，设计者认为访问某个page数据的时候，相邻的一些page可能会很快被访问到，所以先把这些page放到buffer pool中缓存起来，能提高I/O性能。这种预读的机制分为两种：</p><p>​    <strong>1.线性预读（异步的）。</strong>为了方便管理，innodb中把64个相邻的page叫做一个extent（区）。如果顺序的访问了一个extent的56个page，这时innodb就会把下一个extent缓存到buffer pool中。顺序访问多少个page才缓存下一个extent，由一个参数控制：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_read_ahead_threshold<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>​     <strong>2.随机预读。</strong>如果buffer pool已经缓存了同一个extent的数据页的个数超过13个时，就会把这个extent剩余的所有page全部缓存到buffer pool，但是随机预读的功能默认是不启用的，由一个参数控制：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_random_read_ahead<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>​    但是预读肯定也会带来一些副作用，就是导致占用的内存空间更多，剩余的空闲页更少，如果说buffer pool的size不是很大，而预读的数据很多，很有可能那些真正的需要被缓存的热点数据被预读数据挤出buffer pool，淘汰掉了，下次访问时又要去磁盘。所以为了避免这种情况，对buffer pool进行冷热分离。靠近head的叫做new sublist，用来放热数据（热区），靠近tail的叫做old sublist，用来放冷数据（冷区）。</p><p><img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%874.png"><img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%875.png"></p><p>​    所有新数据加入到buffer pool时一律先放到冷区的head。如果有些预读的数据没有被用到，会在冷区直接被淘汰。放到冷区后如果再次被访问，都会把它移动到热区的head。如果热区的数据长时间没有被访问，会被先移动到冷区的head部，最后慢慢在tail淘汰。默认情况下，热区占了5/8的大小，冷区占了3/8，这个值由innodb_old_blocks_pct控制，它代表的是old区的大小，默认是37%也就是3/8. Innodb_old_blocks_pct的值可以调整，在5%到95%之间，这个值越大，new区越小，这个LRU算法越接近传统的LRU。如果这个值太小，old区没有被访问的速度淘汰会更快。</p><p>​    还有一个问题：假设一次加载然后被立即访问的冷区数据量非常大，导致它们全部被移到了热区的head，它会导致很多热点数据被移动到冷区甚至淘汰，造成了缓冲池的污染。这个问题的解决方法是设置一个时间窗口，只有超过这个时间之后被访问，才认为是有效访问。Innodb中通过innodb_old_blocks_time这个参数来控制，默认为1秒钟，也就是说1秒钟内被访问的不算数，继续呆在冷区。只有1秒钟之后被访问的才被移到热区。这样就可以从很大程度上避免全表扫描或者预读的数据污染真正的热数据。</p><p>​    进一步的优化，为了避免并发的问题，对于LRU链表的操作是要加锁的，也就是说每一次链表的移动，都会带来资源的竞争与等待，从这个角度来说，如果进一步提升InnoDB LRU的效率，就要尽量得减少LRU链表得移动。比如把热区一个非常靠近head得page移动到head。有没有这个必要呢？所以InnoDB对热区还有一个特殊得优化：如果一个缓存页处于热数据区域，且在热数据区域得前1/4区域（注意是热区得1/4，而不是这个链表得1/4），那么当访问这个缓存页得时候，就不用把它移动到热数据区域得头部；如果缓存页处于热区得后3/4区域，那么就得移动到热区得头部。</p><h4 id="4-1-3-Change-Buffer-写缓存"><a href="#4-1-3-Change-Buffer-写缓存" class="headerlink" title="4.1.3 Change Buffer-写缓存"></a>4.1.3 Change Buffer-写缓存</h4><p>​    Change Buffer是Buffer Pool的一部分。如果这个数据页不是唯一索引，不存在数据重复的情况，也就不需要从磁盘加载索引页判断数据是不是重复（唯一性检查）。这种情况下可以先把修改记录在内存的缓存池中，从而提升更新语句（Insert， Delete，Update）的执行速度。</p><p>​    这一块区域就是Change Buffer。5.5之前叫Insert Buffer插入缓冲，现在也支持delete和update。</p><p>​    最后把Change Buffer记录到数据页的操作叫做merge。发生merge的几种情况如下：在访问这个数据页的时候，或者通过后台线程，或者通过数据库shut down，redo log写满时触发。</p><p>​    如果数据库发部分索引都是非唯一索引，并且业务是写多读少，不会在写数据后立刻读取，就可以用Change Buffer（写缓存）</p><p>​    可以通过调大这个值来扩大Change的大小，以支持写多读少的业务场景。（代表Change Buffer占Buffer pool的比例，默认为25%）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_change_buffer_max_size<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><h4 id="4-1-4-Adaptive-Hash-Index"><a href="#4-1-4-Adaptive-Hash-Index" class="headerlink" title="4.1.4 Adaptive Hash Index"></a>4.1.4 Adaptive Hash Index</h4><p>​    查看索引模块</p><h4 id="4-1-5-Redo-Log-Buffer"><a href="#4-1-5-Redo-Log-Buffer" class="headerlink" title="4.1.5 Redo Log Buffer"></a>4.1.5 Redo Log Buffer</h4><p>​    Redo Log也不是每一次都直接写入磁盘，在Buffer Pool中有一块内存区域（Log Buffer）专门用来保存即将写入日志文件的数据，默认为16M，它同样可以节省磁盘IO。</p><p>​    <img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%876.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_log_buffer_size<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>注意：redo log的内容主要用于奔溃恢复。磁盘的数据文件，数据来自buffer pool。Redo log写入磁盘，不是写入数据文件。</p><p>​    在我们写入数据到磁盘的时候，操作系统本身是有缓冲的，flush就是把操作系统缓冲区写入到磁盘。Log buffer写入磁盘的时机由一个参数控制，默认是1。刷盘越快越安全，但是也会越消耗性能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_flush_log_at_trx_commit<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>​    <img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%877.png"></p><h3 id="4-2-磁盘结构"><a href="#4-2-磁盘结构" class="headerlink" title="4.2 磁盘结构"></a>4.2 磁盘结构</h3><p>​    表空间可以看作是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。InnoDB的表空间分为5大类。</p><h4 id="4-2-1-系统表空间-system-tablespace"><a href="#4-2-1-系统表空间-system-tablespace" class="headerlink" title="4.2.1 系统表空间-(system tablespace)"></a>4.2.1 系统表空间-(system tablespace)</h4><p>​    在默认情况下InnoDB存储引擎有一个共享表空间（/var/lib/mysql/ibdata1），也叫系统表空间。</p><p>​    InnoDB系统表空间包含InnoDB数据字典和双写缓冲区，Change Buffer和undo logs，如果没有指定file-per-table，也包含用户创建的表和索引数据。</p><p>​    1.undo log后面介绍</p><p>​    2.数据字典：由内部系统表组成，存储表和索引的元数据（定义信息）</p><p>​    3.双写缓冲（InnoDB的一个特性）</p><p>​    InnoDB的页和操作系统的页大小不一致，InnoDB页大小一般为16k，操作系统页大小为4k，InnoDB页写入磁盘中时，一个页需要分4次写。</p><p>​    <img src="/image/mysql/mysql%E6%9E%B6%E6%9E%84/%E5%9B%BE%E7%89%878.png"></p><p>​    如果存储引擎正在写入页的数据到磁盘时发生了宕机，可能出现页只写了一部分的数据，比如只写了4k，就宕机了。这种情况叫做部分写失效（partial page write），可能会导致数据丢失。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_doublewrite<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>​    如果这个页本身已经损坏了，用它来做奔溃恢复是没有意义的。所以在对于应用redo log之前，需要一个页的副本，如果出现了写入失效，就用这个页的副本来还原这个页，然后再应用redo log。这个页的副本就是double write，InnoDB的双写技术，通过它实现了数据页的可靠性。跟redo log一样，double write由两部分组成，一部分是内存的double write，一部分是磁盘上的double write。因为double write是顺序写入的，不会带来很大的开销。在默认情况下，所有的表共享一个系统表空间这个文件会越来越大，而且它的空间不会收缩。</p><h4 id="4-2-2-独占表空间-file-per-table-tablespaces"><a href="#4-2-2-独占表空间-file-per-table-tablespaces" class="headerlink" title="4.2.2 独占表空间-(file-per-table tablespaces)"></a>4.2.2 独占表空间-(file-per-table tablespaces)</h4><p>​    我们可以让每张表独占一个表空间。这个开关通过innodb_file_per_table设置，默认开启。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>innodb_file_per_table<span class="hljs-operator">%</span>’；<br></code></pre></td></tr></table></figure><p>​    开启后，则每张表会开启一个表空间，这个文件就是数据目录下的ibd文件，存放表的索引和数据。但是其他类的数据，如回滚（undo）信息，插入缓冲索引页，系统事务信息，二次写缓冲（double write buffer）等还是存放在原来的共享表空间内。</p><h4 id="4-2-3-通用表空间-general-tablespaces"><a href="#4-2-3-通用表空间-general-tablespaces" class="headerlink" title="4.2.3 通用表空间-(general tablespaces)"></a>4.2.3 通用表空间-(general tablespaces)</h4><p>​    通用表空间也是一个共享的表空间，跟ibddata1类似。 可以创建一个通用表空间，用来存储不同数据库的表，数据路径和文件可以自定义，语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span>spaces ts <span class="hljs-keyword">add</span> datafile <span class="hljs-string">&#x27;/var/lib/mysql/ts.ibd&#x27;</span> file_block_size<span class="hljs-operator">=</span><span class="hljs-number">16</span>K engine<span class="hljs-operator">=</span>innodb;<br></code></pre></td></tr></table></figure><p>​    在创建表的时候可以指定表空间吗，用alert修改表空间可以转移表空间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t(id <span class="hljs-type">integer</span>) tablespace ts;<br></code></pre></td></tr></table></figure><p>​    不同的表空间的数据是可以移动的。删除表空间需要先删除里面的所有表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> t;<br><span class="hljs-keyword">drop</span> tablespace ts;<br></code></pre></td></tr></table></figure><h4 id="4-2-4-临时表空间-temporary-tablespaces"><a href="#4-2-4-临时表空间-temporary-tablespaces" class="headerlink" title="4.2.4 临时表空间-(temporary tablespaces)"></a>4.2.4 临时表空间-(temporary tablespaces)</h4><p>​    存储临时表的数据，包括用户创建的临时表，和磁盘的内部临时表。对应数据目录下的ibtmp1文件。当数据服务器正常关闭时，该表空间被删除，下次重启产生。</p><h4 id="4-2-5-Redo-Log"><a href="#4-2-5-Redo-Log" class="headerlink" title="4.2.5 Redo Log"></a>4.2.5 Redo Log</h4><p>​    在更新sql执行流程中讲述</p><h4 id="4-2-6-Undo-log-tablespaces"><a href="#4-2-6-Undo-log-tablespaces" class="headerlink" title="4.2.6 Undo log tablespaces"></a>4.2.6 Undo log tablespaces</h4><p>​    Undo log的数据默认在系统表空间ibdata1文件中，因为共享表空间不会自动收缩，页可以单独创建一个undo表空间。</p><h3 id="4-3-后台线程"><a href="#4-3-后台线程" class="headerlink" title="4.3 后台线程"></a>4.3 后台线程</h3><p>​    后台线程的主要作用是负责刷新内存池中的数据和把修改的数据页刷新到磁盘。后台线程分为：master thread，IO thread，ourge thread，page cleaner thread。</p><p>​    1.Master thread：负责刷新缓存数据到磁盘并协调调度其他后台线程。</p><p>​    2.IO thread：分为innodb buffer，log，read，write进程。分别用来处理insert buffer，重做日志，读写请求的IO回调。</p><p>​    3.Purge threadL用来回收undo页。</p><p>​    4.Page cleaner thread：用来刷新脏页。</p><p>​    除了InnoDB架构中的日志文件，MySQL的Server层也有一个日志文件，叫做binlog，它可以被所有的存储引擎使用。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
